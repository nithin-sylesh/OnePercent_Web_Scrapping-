Links,Main Heading,Chapter Headings,Description,Contents,Unordered Lists,Ordered Lists,Table Data
https://www.programiz.com/python-programming,Learn Python Programming,About Python Programming$$$Why Learn Python?$$$How to learn Python?$$$Python Resources,"Python is a powerful general-purpose programming language. It is used in web development, data science, creating software prototypes, and so on. Fortunately for beginners, Python has simple easy-to-use syntax. This makes Python an excellent language to learn to program for beginners. Our Python tutorial will guide you to learn Python one step at a time. If you prefer videos, watch our Python for beginners playlist on Youtube.",,"Free and open-source - You can freely use and distribute Python, even for commercial use.$$$Easy to learn - Python has a very simple and elegant syntax. It's much easier to read and write Python programs compared to other languages like C++, Java, C#.$$$Portable - You can move Python programs from one platform to another, and run it without any changes.$$$Python is easy to learn. Its syntax is easy and code is very readable.$$$Python has a lot of applications. It's used for developing web applications, data science, rapid application development, and so on.$$$Python allows you to write programs in fewer lines of code than most of the programming languages.$$$The popularity of Python is growing rapidly. Now it's one of the most popular programming languages.$$$Python tutorial from Programiz - We provide step by step Python tutorials, examples, and references. Get started with Python.$$$Official Python tutorial - Might be hard to follow and understand for beginners. Visit the official Python tutorial.$$$Get Learn Python App - The beginner-friendly app contains byte-size lessons and an integrated Python interpreter. To learn more, visit: Learn Python app$$$Write a lot of Python code- The only way you can learn programming is by writing a lot of code.$$$Python Examples$$$Python References$$$Python Online Compiler$$$Python Guide$$$Python Tutorial Videos",,
https://www.programiz.com/python-programming/first-program,How to Get Started With Python?,Video: Introduction to Python$$$The Easiest Way to Run Python$$$Install Python Separately$$$Your first Python Program$$$1. Run Python in Immediate mode$$$2. Run Python in the Integrated Development Environment (IDE)$$$Table of Contents,,"In this tutorial, you will learn to install and run Python on your computer. Once we do that, we will also write our first Python program.|||Python is a cross-platform programming language, which means that it can run on multiple platforms like Windows, macOS, Linux, and has even been ported to the Java and .NET virtual machines. It is free and open-source.|||Even though most of today's Linux and Mac have Python pre-installed in it, the version might be out-of-date. So, it is always a good idea to install the most current version.|||The easiest way to run Python is by using Thonny IDE.|||The Thonny IDE comes with the latest version of Python bundled in it. So you don't have to install Python separately.|||Follow the following steps to run Python on your computer.|||If you don't want to use Thonny, here's how you can install and run Python on your computer.|||Once you finish the installation process, you can run Python.||||||Once Python is installed, typing python in the command line will invoke the interpreter in immediate mode. We can directly type in Python code, and press Enter to get the output.|||Try typing in 1 + 1 and press enter. We get 2 as the output. This prompt can be used as a calculator. To exit this mode, type quit() and press enter.|||We can use any text editing software to write a Python script file.|||We just need to save it with the .py extension. But using an IDE can make our life a lot easier. IDE is a piece of software that provides useful features like code hinting, syntax highlighting and checking, file explorers, etc. to the programmer for application development.|||By the way, when you install Python, an IDE named IDLE is also installed. You can use it to run Python on your computer. It's a decent IDE for beginners.|||When you open IDLE, an interactive Python Shell is opened.|||Now you can create a new file and save it with .py extension. For example, hello.py|||Write Python code in the file and save it. To run the file, go to Run > Run Module or simply click F5.|||Now that we have Python up and running, we can write our first Python program.|||Let's create a very simple program called Hello World. A ""Hello, World!"" is a simple program that outputs Hello, World! on the screen. Since it's a very simple program, it's often used to introduce a new programming language to beginners.|||Type the following code in any text editor or an IDE and save it as hello_world.py|||Then, run the file. You will get the following output.|||Congratulations! You just wrote your first program in Python.|||As you can see, this was a pretty easy task. This is the beauty of the Python programming language.",Run Python using Thonny IDE$$$Install Python Separately$$$Run Python in Immediate mode$$$Run Python in the IDLE$$$Your first Python Program,"Download Thonny IDE.$$$Run the installer to install Thonny on your computer.$$$Go to: File > New. Then save the file with .py extension. For example, hello.py, example.py, etc.You can give any name to the file. However, the file name should end with .py$$$Write Python code in the file and save it.Running Python using Thonny IDE$$$Then Go to Run > Run current script or simply click F5 to run it.$$$Download the latest version of Python.$$$Run the installer file and follow the steps to install PythonDuring the install process, check Add Python to environment variables. This will add Python to environment variables, and you can run Python from any part of the computer.Also, you can choose the path where Python is installed.Installing Python on the computer",
https://www.programiz.com/python-programming/keywords-identifier,Python Keywords and Identifiers (Variable names),Python Keywords$$$Python Identifiers$$$Rules for writing identifiers$$$Things to Remember$$$Table of Contents,,"In this tutorial, you will learn about keywords (reserved words in Python) and identifiers (names given to variables, functions, etc.).|||Keywords are the reserved words in Python.|||We cannot use a keyword as a variable name, function name or any other identifier. They are used to define the syntax and structure of the Python language.|||In Python, keywords are case sensitive.|||There are 33 keywords in Python 3.7. This number can vary slightly over the course of time.|||All the keywords except True, False and None are in lowercase and they must be written as they are. The list of all the keywords is given below.||||||Looking at all the keywords at once and trying to figure out what they mean might be overwhelming.|||If you want to have an overview, here is the complete list of all the keywords with examples.|||An identifier is a name given to entities like class, functions, variables, etc. It helps to differentiate one entity from another.|||Python is a case-sensitive language. This means, Variable and variable are not the same.|||Always give the identifiers a name that makes sense. While c = 10 is a valid name, writing count = 10 would make more sense, and it would be easier to figure out what it represents when you look at your code after a long gap.|||Multiple words can be separated using an underscore, like this_is_a_long_variable.",Python Keywords$$$Python IdentifiersRules for writing identifiersThings to Remember$$$Rules for writing identifiers$$$Things to Remember,"Identifiers can be a combination of letters in lowercase (a to z) or uppercase (A to Z) or digits (0 to 9) or an underscore _. Names like myClass, var_1 and print_this_to_screen, all are valid example.$$$An identifier cannot start with a digit. 1variable is invalid, but variable1 is a valid name.$$$Keywords cannot be used as identifiers.global = 1Output  File ""<interactive input>"", line 1    global = 1           ^SyntaxError: invalid syntax$$$We cannot use special symbols like !, @, #, $, % etc. in our identifier.a@ = 0Output  File ""<interactive input>"", line 1    a@ = 0     ^SyntaxError: invalid syntax$$$An identifier can be of any length.",False|||await|||else|||import|||pass$$$None|||break|||except|||in|||raise$$$True|||class|||finally|||is|||return$$$and|||continue|||for|||lambda|||try$$$as|||def|||from|||nonlocal|||while$$$assert|||del|||global|||not|||with$$$async|||elif|||if|||or|||yield
https://www.programiz.com/python-programming/statement-indentation-comments,"Python Statement, Indentation and Comments",Python Statement$$$Python Indentation$$$Python Comments$$$Multi-line statement$$$Multi-line comments$$$Docstrings in Python$$$Table of Contents,,"In this tutorial, you will learn about Python statements, why indentation is important and use of comments in programming.|||Instructions that a Python interpreter can execute are called statements. For example, a = 1 is an assignment statement. if statement, for statement, while statement, etc. are other kinds of statements which will be discussed later.|||In Python, the end of a statement is marked by a newline character. But we can make a statement extend over multiple lines with the line continuation character (\). For example:|||This is an explicit line continuation. In Python, line continuation is implied inside parentheses ( ), brackets [ ], and braces { }. For instance, we can implement the above multi-line statement as:|||Here, the surrounding parentheses ( ) do the line continuation implicitly. Same is the case with [ ] and { }. For example:|||We can also put multiple statements in a single line using semicolons, as follows:|||Most of the programming languages like C, C++, and Java use braces { } to define a block of code. Python, however, uses indentation.|||A code block (body of a function, loop, etc.) starts with indentation and ends with the first unindented line. The amount of indentation is up to you, but it must be consistent throughout that block.|||Generally, four whitespaces are used for indentation and are preferred over tabs. Here is an example.|||The enforcement of indentation in Python makes the code look neat and clean. This results in Python programs that look similar and consistent.|||Indentation can be ignored in line continuation, but it's always a good idea to indent. It makes the code more readable. For example:|||and|||both are valid and do the same thing, but the former style is clearer.||||||Incorrect indentation will result in IndentationError.|||Comments are very important while writing a program. They describe what is going on inside a program, so that a person looking at the source code does not have a hard time figuring it out.|||You might forget the key details of the program you just wrote in a month's time. So taking the time to explain these concepts in the form of comments is always fruitful.|||In Python, we use the hash (#) symbol to start writing a comment.|||It extends up to the newline character. Comments are for programmers to better understand a program. Python Interpreter ignores comments.|||We can have comments that extend up to multiple lines. One way is to use the hash(#) symbol at the beginning of each line. For example:|||Another way of doing this is to use triple quotes, either ''' or """""".|||These triple quotes are generally used for multi-line strings. But they can be used as a multi-line comment as well. Unless they are not docstrings, they do not generate any extra code.|||To learn more about comments, visit Python Comments.|||A docstring is short for documentation string.|||Python docstrings (documentation strings) are the string literals that appear right after the definition of a function, method, class, or module.|||Triple quotes are used while writing docstrings. For example:|||Docstrings appear right after the definition of a function, class, or a module. This separates docstrings from multiline comments using triple quotes.|||The docstrings are associated with the object as their __doc__ attribute.|||So, we can access the docstrings of the above function with the following lines of code:|||Output|||To learn more about docstrings in Python, visit Python Docstrings.",Python StatementMulti-line statement$$$Python Indentation$$$Python CommentsMulti-line CommentsDocstring in Python$$$Multi-line statement$$$Multi-line Comments$$$Docstring in Python,,
https://www.programiz.com/python-programming/variables-constants-literals,"Python Variables, Constants and Literals",Video: Python Variables and print()$$$Python Variables$$$Assigning values to Variables in Python$$$Constants$$$Assigning value to constant in Python$$$Rules and Naming Convention for Variables and constants$$$Literals$$$Numeric Literals$$$String literals$$$Boolean literals$$$Special literals$$$Literal Collections$$$Example 1: Declaring and assigning value to a variable$$$Example 2: Changing the value of a variable$$$Example 3: Assigning multiple values to multiple variables$$$Example 3: Declaring and assigning value to a constant$$$Example 4: How to use Numeric literals in Python?$$$Example 7: How to use string literals in Python?$$$Example 8: How to use boolean literals in Python?$$$Example 9: How to use special literals in Python?$$$Example 10: How to use literals collections in Python?$$$Table of Contents,,"In this tutorial, you will learn about Python variables, constants, literals and their use cases.|||A variable is a named location used to store data in the memory. It is helpful to think of variables as a container that holds data that can be changed later in the program. For example,|||Here, we have created a variable named number. We have assigned the value 10 to the variable.|||You can think of variables as a bag to store books in it and that book can be replaced at any time.|||Initially, the value of number was 10. Later, it was changed to 1.1.|||Note: In Python, we don't actually assign values to the variables. Instead, Python gives the reference of the object(value) to the variable.|||As you can see from the above example, you can use the assignment operator = to assign a value to a variable.|||Output|||In the above program, we assigned a value apple.com to the variable website. Then, we printed out the value assigned to website i.e. apple.com|||Note: Python is a type-inferred language, so you don't have to explicitly define the variable type. It automatically knows that apple.com is a string and declares the website variable as a string.|||Output|||In the above program, we have assigned apple.com to the website variable initially. Then, the value is changed to programiz.com.|||If we want to assign the same value to multiple variables at once, we can do this as:|||The second program assigns the same string to all the three variables x, y and z.|||A constant is a type of variable whose value cannot be changed. It is helpful to think of constants as containers that hold information which cannot be changed later.|||You can think of constants as a bag to store some books which cannot be replaced once placed inside the bag.|||In Python, constants are usually declared and assigned in a module. Here, the module is a new file containing variables, functions, etc which is imported to the main file. Inside the module, constants are written in all capital letters and underscores separating the words.|||Create a constant.py:|||Create a main.py:|||Output|||In the above program, we create a constant.py module file. Then, we assign the constant value to PI and GRAVITY. After that, we create a main.py file and import the constant module. Finally, we print the constant value.|||Note: In reality, we don't use constants in Python. Naming them in all capital letters is a convention to separate them from variables, however, it does not actually prevent reassignment.|||Literal is a raw data given in a variable or constant. In Python, there are various types of literals they are as follows:|||Numeric Literals are immutable (unchangeable). Numeric literals can belong to 3 different numerical types: Integer, Float, and Complex.||||||Output|||In the above program,|||To learn more about Numeric Literals, refer to Python Numbers.|||A string literal is a sequence of characters surrounded by quotes. We can use both single, double, or triple quotes for a string. And, a character literal is a single character surrounded by single or double quotes.|||Output|||In the above program, This is Python is a string literal and C is a character literal.|||The value in triple-quotes """""" assigned to the multiline_str is a multi-line string literal.|||The string u""\u00dcnic\u00f6de"" is a Unicode literal which supports characters other than English. In this case, \u00dc represents Ü and \u00f6 represents ö.|||r""raw \n string"" is a raw string literal.|||A Boolean literal can have any of the two values: True or False.|||Output|||In the above program, we use boolean literal True and False. In Python, True represents the value as 1 and False as 0. The value of x is True because 1 is equal to True. And, the value of y is False because 1 is not equal to False.|||Similarly, we can use the True and False in numeric expressions as the value. The value of a is 5 because we add True which has a value of 1 with 4. Similarly, b is 10 because we add the False having value of 0 with 10.|||Python contains one special literal i.e. None. We use it to specify that the field has not been created.|||Output|||In the above program, we define a menu function. Inside menu, when we set the argument as drink then, it displays Available. And, when the argument is food, it displays None.|||There are four different literal collections List literals, Tuple literals, Dict literals, and Set literals.|||Output|||In the above program, we created a list of fruits, a tuple of numbers, a dictionary dict having values with keys designated to each value and a set of vowels.|||To learn more about literal collections, refer to Python Data Types.","We assigned integer literals into different variables. Here, a is binary literal, b is a decimal literal, c is an octal literal and d is a hexadecimal literal.$$$When we print the variables, all the literals are converted into decimal values.$$$10.5 and 1.5e2 are floating-point literals. 1.5e2 is expressed with exponential and is equivalent to 1.5 * 102.$$$We assigned a complex literal i.e 3.14j in variable x. Then we use imaginary literal (x.imag) and real literal (x.real) to create imaginary and real parts of complex numbers.$$$Python Variables$$$Assigning values to Variables in Python$$$Constants$$$Assigning value to constant in Python$$$Naming Convention for Variables and constants$$$Literals$$$Numeric Literals$$$String literals$$$Boolean literals$$$Special literals$$$Literal Collections","Constant and variable names should have a combination of letters in lowercase (a to z) or uppercase (A to Z) or digits (0 to 9) or an underscore (_). For example:snake_caseMACRO_CASEcamelCaseCapWords$$$Create a name that makes sense. For example, vowel makes more sense than v.$$$If you want to create a variable name having two words, use underscore to separate them. For example:my_namecurrent_salary$$$Use capital letters possible to declare a constant. For example:PIGMASSSPEED_OF_LIGHTTEMP$$$Never use special symbols like !, @, #, $, %, etc.$$$Don't start a variable name with a digit.",
https://www.programiz.com/python-programming/variables-datatypes,Python Data Types,Data types in Python$$$Python Numbers$$$Python List$$$Python Tuple$$$Python Strings$$$Python Set$$$Python Dictionary$$$Conversion between data types$$$Table of Contents,,"In this tutorial, you will learn about different data types you can use in Python.|||Every value in Python has a datatype. Since everything is an object in Python programming, data types are actually classes and variables are instance (object) of these classes.|||There are various data types in Python. Some of the important types are listed below.|||Integers, floating point numbers and complex numbers fall under Python numbers category. They are defined as int, float and complex classes in Python.|||We can use the type() function to know which class a variable or a value belongs to. Similarly, the isinstance() function is used to check if an object belongs to a particular class.|||Output|||Integers can be of any length, it is only limited by the memory available.|||A floating-point number is accurate up to 15 decimal places. Integer and floating points are separated by decimal points. 1 is an integer, 1.0 is a floating-point number.|||Complex numbers are written in the form, x + yj, where x is the real part and y is the imaginary part. Here are some examples.|||Notice that the float variable b got truncated.|||List is an ordered sequence of items. It is one of the most used datatype in Python and is very flexible. All the items in a list do not need to be of the same type.|||Declaring a list is pretty straight forward. Items separated by commas are enclosed within brackets [ ].|||We can use the slicing operator [ ] to extract an item or a range of items from a list. The index starts from 0 in Python.|||Output|||Lists are mutable, meaning, the value of elements of a list can be altered.||||||Output|||Tuple is an ordered sequence of items same as a list. The only difference is that tuples are immutable. Tuples once created cannot be modified.|||Tuples are used to write-protect data and are usually faster than lists as they cannot change dynamically.|||It is defined within parentheses () where items are separated by commas.|||We can use the slicing operator [] to extract items but we cannot change its value.|||Output|||String is sequence of Unicode characters. We can use single quotes or double quotes to represent strings. Multi-line strings can be denoted using triple quotes, ''' or """""".|||Output|||Just like a list and tuple, the slicing operator [ ] can be used with strings. Strings, however, are immutable.|||Output|||Set is an unordered collection of unique items. Set is defined by values separated by comma inside braces { }. Items in a set are not ordered.|||Output|||We can perform set operations like union, intersection on two sets. Sets have unique values. They eliminate duplicates.|||Output|||Since, set are unordered collection, indexing has no meaning. Hence, the slicing operator [] does not work.|||Dictionary is an unordered collection of key-value pairs.|||It is generally used when we have a huge amount of data. Dictionaries are optimized for retrieving data. We must know the key to retrieve the value.|||In Python, dictionaries are defined within braces {} with each item being a pair in the form key:value. Key and value can be of any type.|||We use key to retrieve the respective value. But not the other way around.|||Output|||We can convert between different data types by using different type conversion functions like int(), float(), str(), etc.|||Conversion from float to int will truncate the value (make it closer to zero).|||Conversion to and from string must contain compatible values.|||We can even convert one sequence to another.|||To convert to dictionary, each element must be a pair:",Data types in Python$$$Python Numbers$$$Python List$$$Python Tuple$$$Python Strings$$$Python Set$$$Python Dictionary$$$Conversion between data types,,
https://www.programiz.com/python-programming/type-conversion-and-casting,Python Type Conversion and Type Casting (With Examples),Type Conversion$$$Implicit Type Conversion$$$Explicit Type Conversion$$$Key Points to Remember$$$Example 1: Converting integer to float$$$Example 2: Addition of string(higher) data type and integer(lower) datatype$$$Example 3: Addition of string and integer using explicit conversion$$$Table of Contents,,"In this article, you will learn about the Type conversion and uses of type conversion.|||Before learning Type Conversion in Python, you should have knowledge about Python Data Types.|||The process of converting the value of one data type (integer, string, float, etc.) to another data type is called type conversion. Python has two types of type conversion.|||In Implicit type conversion, Python automatically converts one data type to another data type. This process doesn't need any user involvement.|||Let's see an example where Python promotes the conversion of the lower data type (integer) to the higher data type (float) to avoid data loss.|||When we run the above program, the output will be:|||In the above program,|||Now, let's try adding a string and an integer, and see how Python deals with it.|||When we run the above program, the output will be:||||||In the above program,|||In Explicit Type Conversion, users convert the data type of an object to required data type. We use the predefined functions like int(), float(), str(), etc to perform explicit type conversion.|||This type of conversion is also called typecasting because the user casts (changes) the data type of the objects.|||Syntax :|||Typecasting can be done by assigning the required data type function to the expression.|||When we run the above program, the output will be:|||In the above program,","We add two variables num_int and num_flo, storing the value in num_new.$$$We will look at the data type of all three objects respectively.$$$In the output, we can see the data type of num_int is an integer while the data type of num_flo is a float.$$$Also, we can see the num_new has a float data type because Python always converts smaller data types to larger data types to avoid the loss of data.$$$We add two variables num_int and num_str.$$$As we can see from the output, we got TypeError. Python is not able to use Implicit Conversion in such conditions.$$$However, Python has a solution for these types of situations which is known as Explicit Conversion.$$$We add num_str and num_int variable.$$$We converted num_str from string(higher) to integer(lower) type using int() function to perform the addition.$$$After converting num_str to an integer value, Python is able to add these two variables.$$$We got the num_sum value and data type to be an integer.$$$Type Conversion$$$Implicit Type Conversion$$$Explicit Type Conversion$$$Key Points to Remember","Implicit Type Conversion$$$Explicit Type Conversion$$$Type Conversion is the conversion of object from one data type to another data type.$$$Implicit Type Conversion is automatically performed by the Python interpreter.$$$Python avoids the loss of data in Implicit Type Conversion.$$$Explicit Type Conversion is also called Type Casting, the data types of objects are converted using predefined functions by the user.$$$In Type Casting, loss of data may occur as we enforce the object to a specific data type.",
https://www.programiz.com/python-programming/input-output-import,Python Input Output (I/O) Using input() and print() Function,Video: Python Take User Input$$$Python Output Using print() function$$$Output formatting$$$Python Input$$$Python Import$$$Table of Contents,,"This tutorial focuses on two built-in functions print() and input() to perform I/O task in Python. Also, you will learn to import modules and use them in your program.|||Python provides numerous built-in functions that are readily available to us at the Python prompt.|||Some of the functions like input() and print() are widely used for standard input and output operations respectively. Let us see the output section first.|||We use the print() function to output data to the standard output device (screen). We can also output data to a file, but this will be discussed later.|||An example of its use is given below.|||Output|||Another example is given below:|||Output|||In the second print() statement, we can notice that space was added between the string and the value of variable a. This is by default, but we can change it.|||The actual syntax of the print() function is:|||Here, objects is the value(s) to be printed.|||The sep separator is used between the values. It defaults into a space character.|||After all values are printed, end is printed. It defaults into a new line.|||The file is the object where the values are printed and its default value is sys.stdout (screen). Here is an example to illustrate this.|||Output|||Sometimes we would like to format our output to make it look attractive. This can be done by using the str.format() method. This method is visible to any string object.|||Here, the curly braces {} are used as placeholders. We can specify the order in which they are printed by using numbers (tuple index).||||||Output|||We can even use keyword arguments to format the string.|||We can also format strings like the old sprintf() style used in C programming language. We use the % operator to accomplish this.|||Up until now, our programs were static. The value of variables was defined or hard coded into the source code.|||To allow flexibility, we might want to take the input from the user. In Python, we have the input() function to allow this. The syntax for input() is:|||where prompt is the string we wish to display on the screen. It is optional.|||Here, we can see that the entered value 10 is a string, not a number. To convert this into a number we can use int() or float() functions.|||This same operation can be performed using the eval() function. But eval takes it further. It can evaluate even expressions, provided the input is a string|||When our program grows bigger, it is a good idea to break it into different modules.|||A module is a file containing Python definitions and statements. Python modules have a filename and end with the extension .py.|||Definitions inside a module can be imported to another module or the interactive interpreter in Python. We use the import keyword to do this.|||For example, we can import the math module by typing the following line:|||We can use the module in the following ways:|||Output|||Now all the definitions inside math module are available in our scope. We can also import some specific attributes and functions only, using the from keyword. For example:|||While importing a module, Python looks at several places defined in sys.path. It is a list of directory locations.|||We can also add our own location to this list.",Python Output Using print() functionOutput formatting$$$Python Input$$$Python Import$$$Output formatting,,
https://www.programiz.com/python-programming/operators,"Python Operators: Arithmetic, Comparison, Logical and more.",Video: Operators in Python$$$What are operators in python?$$$Arithmetic operators$$$Comparison operators$$$Logical operators$$$Bitwise operators$$$Assignment operators$$$Special operators$$$Example 1: Arithmetic operators in Python$$$Example 2: Comparison operators in Python$$$Example 3: Logical Operators in Python$$$Identity operators$$$Example 4: Identity operators in Python$$$Membership operators$$$Example #5: Membership operators in Python$$$Table of Contents,,"In this tutorial, you'll learn everything about different types of operators in Python, their syntax and how to use them with examples.|||Operators are special symbols in Python that carry out arithmetic or logical computation. The value that the operator operates on is called the operand.|||For example:|||Here, + is the operator that performs addition. 2 and 3 are the operands and 5 is the output of the operation.|||Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication, etc.|||Output|||Comparison operators are used to compare values. It returns either True or False according to the condition.|||Output||||||Logical operators are the and, or, not operators.|||Output|||Here is the truth table for these operators.|||Bitwise operators act on operands as if they were strings of binary digits. They operate bit by bit, hence the name.|||For example, 2 is 10 in binary and 7 is 111.|||In the table below: Let x = 10 (0000 1010 in binary) and y = 4 (0000 0100 in binary)|||Assignment operators are used in Python to assign values to variables.|||a = 5 is a simple assignment operator that assigns the value 5 on the right to the variable a on the left.|||There are various compound operators in Python like a += 5 that adds to the variable and later assigns the same. It is equivalent to a = a + 5.|||Python language offers some special types of operators like the identity operator or the membership operator. They are described below with examples.|||is and is not are the identity operators in Python. They are used to check if two values (or variables) are located on the same part of the memory. Two variables that are equal does not imply that they are identical.|||Output|||Here, we see that x1 and y1 are integers of the same values, so they are equal as well as identical. Same is the case with x2 and y2 (strings).|||But x3 and y3 are lists. They are equal but not identical. It is because the interpreter locates them separately in memory although they are equal.|||in and not in are the membership operators in Python. They are used to test whether a value or variable is found in a sequence (string, list, tuple, set and dictionary).|||In a dictionary we can only test for presence of key, not the value.|||Output|||Here, 'H' is in x but 'hello' is not present in x (remember, Python is case sensitive). Similarly, 1 is key and 'a' is the value in dictionary y. Hence, 'a' in y returns False.",What are operators in Python?$$$Arithmetic Operators$$$Comparison (Relational) Operators$$$Logical (Boolean) Operators$$$Bitwise Operators$$$Assignment Operators$$$Special OperatorsIndentity OperatorMembership Operator$$$Indentity Operator$$$Membership Operator,,Operator|||Meaning|||Example$$$+|||Add two operands or unary plus|||x + y+ 2$$$-|||Subtract right operand from the left or unary minus|||x - y- 2$$$*|||Multiply two operands|||x * y$$$/|||Divide left operand by the right one (always results into float)|||x / y$$$%|||Modulus - remainder of the division of left operand by the right|||x % y (remainder of x/y)$$$//|||Floor division - division that results into whole number adjusted to the left in the number line|||x // y$$$**|||Exponent - left operand raised to the power of right|||x**y (x to the power y)$$$Operator|||Meaning|||Example$$$>|||Greater than - True if left operand is greater than the right|||x > y$$$<|||Less than - True if left operand is less than the right|||x < y$$$==|||Equal to - True if both operands are equal|||x == y$$$!=|||Not equal to - True if operands are not equal|||x != y$$$>=|||Greater than or equal to - True if left operand is greater than or equal to the right|||x >= y$$$<=|||Less than or equal to - True if left operand is less than or equal to the right|||x <= y$$$Operator|||Meaning|||Example$$$and|||True if both the operands are true|||x and y$$$or|||True if either of the operands is true|||x or y$$$not|||True if operand is false (complements the operand)|||not x$$$Operator|||Meaning|||Example$$$&|||Bitwise AND|||x & y = 0 (0000 0000)$$$||||Bitwise OR|||x | y = 14 (0000 1110)$$$~|||Bitwise NOT|||~x = -11 (1111 0101)$$$^|||Bitwise XOR|||x ^ y = 14 (0000 1110)$$$>>|||Bitwise right shift|||x >> 2 = 2 (0000 0010)$$$<<|||Bitwise left shift|||x << 2 = 40 (0010 1000)$$$Operator|||Example|||Equivalent to$$$=|||x = 5|||x = 5$$$+=|||x += 5|||x = x + 5$$$-=|||x -= 5|||x = x - 5$$$*=|||x *= 5|||x = x * 5$$$/=|||x /= 5|||x = x / 5$$$%=|||x %= 5|||x = x % 5$$$//=|||x //= 5|||x = x // 5$$$**=|||x **= 5|||x = x ** 5$$$&=|||x &= 5|||x = x & 5$$$|=|||x |= 5|||x = x | 5$$$^=|||x ^= 5|||x = x ^ 5$$$>>=|||x >>= 5|||x = x >> 5$$$<<=|||x <<= 5|||x = x << 5$$$Operator|||Meaning|||Example$$$is|||True if the operands are identical (refer to the same object)|||x is True$$$is not|||True if the operands are not identical (do not refer to the same object)|||x is not True$$$Operator|||Meaning|||Example$$$in|||True if value/variable is found in the sequence|||5 in x$$$not in|||True if value/variable is not found in the sequence|||5 not in x
https://www.programiz.com/python-programming/namespace,Python Namespace and Scope of a Variable,What is Name in Python?$$$What is a Namespace in Python?$$$Python Variable Scope$$$Example of Scope and Namespace in Python$$$Table of Contents,,"In this tutorial, you will learn about namespace, mapping from names to objects, and scope of a variable. |||If you have ever read 'The Zen of Python' (type import this in the Python interpreter), the last line states, Namespaces are one honking great idea -- let's do more of those! So what are these mysterious namespaces? Let us first look at what name is.|||Name (also called identifier) is simply a name given to objects. Everything in Python is an object. Name is a way to access the underlying object.|||For example, when we do the assignment a = 2, 2 is an object stored in memory and a is the name we associate it with. We can get the address (in RAM) of some object through the built-in function id(). Let's look at how to use it.|||Output|||Here, both refer to the same object 2, so they have the same id(). Let's make things a little more interesting.|||Output|||What is happening in the above sequence of steps? Let's use a diagram to explain this:|||Initially, an object 2 is created and the name a is associated with it, when we do a = a+1, a new object 3 is created and now a is associated with this object.|||Note that id(a) and id(3) have the same values.|||Furthermore, when b = 2 is executed, the new name b gets associated with the previous object 2.|||This is efficient as Python does not have to create a new duplicate object. This dynamic nature of name binding makes Python powerful; a name could refer to any type of object.||||||All these are valid and a will refer to three different types of objects in different instances. Functions are objects too, so a name can refer to them as well.|||Output|||The same name a can refer to a function and we can call the function using this name.|||Now that we understand what names are, we can move on to the concept of namespaces.|||To simply put it, a namespace is a collection of names.|||In Python, you can imagine a namespace as a mapping of every name you have defined to corresponding objects.|||Different namespaces can co-exist at a given time but are completely isolated.|||A namespace containing all the built-in names is created when we start the Python interpreter and exists as long as the interpreter runs.|||This is the reason that built-in functions like id(), print() etc. are always available to us from any part of the program. Each module creates its own global namespace.|||These different namespaces are isolated. Hence, the same name that may exist in different modules does not collide.|||Modules can have various functions and classes. A local namespace is created when a function is called, which has all the names defined in it. Similar is the case with class. The following diagram may help to clarify this concept.|||Although there are various unique namespaces defined, we may not be able to access all of them from every part of the program. The concept of scope comes into play.|||A scope is the portion of a program from where a namespace can be accessed directly without any prefix.|||At any given moment, there are at least three nested scopes.|||When a reference is made inside a function, the name is searched in the local namespace, then in the global namespace and finally in the built-in namespace.|||If there is a function inside another function, a new scope is nested inside the local scope.|||Here, the variable a is in the global namespace. Variable b is in the local namespace of outer_function() and c is in the nested local namespace of inner_function().|||When we are in inner_function(), c is local to us, b is nonlocal and a is global. We can read as well as assign new values to c but can only read b and a from inner_function().|||If we try to assign as a value to b, a new variable b is created in the local namespace which is different than the nonlocal b. The same thing happens when we assign a value to a.|||However, if we declare a as global, all the reference and assignment go to the global a. Similarly, if we want to rebind the variable b, it must be declared as nonlocal. The following example will further clarify this.|||As you can see, the output of this program is|||In this program, three different variables a are defined in separate namespaces and accessed accordingly. While in the following program,|||The output of the program is.|||Here, all references and assignments are to the global a due to the use of keyword global.",What is Name in Python?$$$What is a Namespace$$$Python Variable Scope$$$Example of Scope and Namespace,Scope of the current function which has local names$$$Scope of the module which has global names$$$Outermost scope which has built-in names,
https://www.programiz.com/python-programming/if-elif-else,"Python if, if...else, if...elif...else and Nested if Statement",Video: Python if...else Statement$$$What is if...else statement in Python?$$$Python if...else Statement$$$Python if...elif...else Statement$$$Python Nested if statements$$$Python if Statement Syntax$$$Python if Statement Flowchart$$$Example: Python if Statement$$$Syntax of if...else$$$Python if..else Flowchart$$$Example of if...else$$$Syntax of if...elif...else$$$Flowchart of if...elif...else$$$Example of if...elif...else$$$Python Nested if Example$$$Table of Contents,,"In this article, you will learn to create decisions in a Python program using different forms of if..else statement.|||Decision making is required when we want to execute a code only if a certain condition is satisfied.|||The if…elif…else statement is used in Python for decision making.|||Here, the program evaluates the test expression and will execute statement(s) only if the test expression is True.|||If the test expression is False, the statement(s) is not executed.|||In Python, the body of the if statement is indicated by the indentation. The body starts with an indentation and the first unindented line marks the end.|||Python interprets non-zero values as True. None and 0 are interpreted as False.|||When you run the program, the output will be:||||||In the above example, num > 0 is the test expression.|||The body of if is executed only if this evaluates to True.|||When the variable num is equal to 3, test expression is true and statements inside the body of if are executed.|||If the variable num is equal to -1, test expression is false and statements inside the body of if are skipped.|||The print() statement falls outside of the if block (unindented). Hence, it is executed regardless of the test expression.|||The if..else statement evaluates test expression and will execute the body of if only when the test condition is True.|||If the condition is False, the body of else is executed. Indentation is used to separate the blocks.|||Output|||In the above example, when num is equal to 3, the test expression is true and the body of if is executed and the body of else is skipped.|||If num is equal to -5, the test expression is false and the body of else is executed and the body of if is skipped.|||If num is equal to 0, the test expression is true and body of if is executed and body of else is skipped.|||The elif is short for else if. It allows us to check for multiple expressions.|||If the condition for if is False, it checks the condition of the next elif block and so on.|||If all the conditions are False, the body of else is executed.|||Only one block among the several if...elif...else blocks is executed according to the condition.|||The if block can have only one else block. But it can have multiple elif blocks.|||When variable num is positive, Positive number is printed.|||If num is equal to 0, Zero is printed.|||If num is negative, Negative number is printed.|||We can have a if...elif...else statement inside another if...elif...else statement. This is called nesting in computer programming.|||Any number of these statements can be nested inside one another. Indentation is the only way to figure out the level of nesting. They can get confusing, so they must be avoided unless necessary.|||Output 1|||Output 2|||Output 3",What are if...else statement in Python?Python if Statement SyntaxPython if Statement FlowchartExample: Python if Statement$$$Python if...else StatementSyntax of if...elsePython if..else FlowchartExample of if...else$$$Python if...elif...else StatementSyntax of if...elif...elseFlowchart of if...elif...elseExample of if...elif...else$$$Python Nested if statements$$$Python if Statement Syntax$$$Python if Statement Flowchart$$$Example: Python if Statement$$$Syntax of if...else$$$Python if..else Flowchart$$$Example of if...else$$$Syntax of if...elif...else$$$Flowchart of if...elif...else$$$Example of if...elif...else,,
https://www.programiz.com/python-programming/for-loop,Python for Loop,Video: Python for Loop$$$What is for loop in Python?$$$The range() function$$$for loop with else$$$Syntax of for Loop$$$Flowchart of for Loop$$$Example: Python for Loop$$$Table of Contents,,"In this article, you'll learn to iterate over a sequence of elements using the different variations of for loop.|||The for loop in Python is used to iterate over a sequence (list, tuple, string) or other iterable objects. Iterating over a sequence is called traversal.|||Here, val is the variable that takes the value of the item inside the sequence on each iteration.|||Loop continues until we reach the last item in the sequence. The body of for loop is separated from the rest of the code using indentation.|||When you run the program, the output will be:|||We can generate a sequence of numbers using range() function. range(10) will generate numbers from 0 to 9 (10 numbers).|||We can also define the start, stop and step size as range(start, stop,step_size). step_size defaults to 1 if not provided.|||The range object is ""lazy"" in a sense because it doesn't generate every number that it ""contains"" when we create it. However, it is not an iterator since it supports in, len and __getitem__ operations.|||This function does not store all the values in memory; it would be inefficient. So it remembers the start, stop, step size and generates the next number on the go.|||To force this function to output all the items, we can use the function list().|||The following example will clarify this.|||Output|||We can use the range() function in for loops to iterate through a sequence of numbers. It can be combined with the len() function to iterate through a sequence using indexing. Here is an example.||||||Output|||A for loop can have an optional else block as well. The else part is executed if the items in the sequence used in for loop exhausts.|||The break keyword can be used to stop a for loop. In such cases, the else part is ignored.|||Hence, a for loop's else part runs if no break occurs.|||Here is an example to illustrate this.|||When you run the program, the output will be:|||Here, the for loop prints items of the list until the loop exhausts. When the for loop exhausts, it executes the block of code in the else and prints No items left.|||This for...else statement can be used with the break keyword to run the else block only when the break keyword was not executed. Let's take an example:|||Output",What is for loop in Python?Syntax of for LoopFlowchart of for loopExample: Python for Loop$$$The range() function$$$for loop with else$$$Syntax of for Loop$$$Flowchart of for loop$$$Example: Python for Loop,,
https://www.programiz.com/python-programming/while-loop,Python while Loop,Video: Python while Loop$$$What is while loop in Python?$$$While loop with else$$$Syntax of while Loop in Python$$$Flowchart of while Loop$$$Example: Python while Loop$$$Table of Contents,,"Loops are used in programming to repeat a specific block of code. In this article, you will learn to create a while loop in Python.|||The while loop in Python is used to iterate over a block of code as long as the test expression (condition) is true.|||We generally use this loop when we don't know the number of times to iterate beforehand.|||In the while loop, test expression is checked first. The body of the loop is entered only if the test_expression evaluates to True. After one iteration, the test expression is checked again. This process continues until the test_expression evaluates to False.|||In Python, the body of the while loop is determined through indentation.|||The body starts with indentation and the first unindented line marks the end.|||Python interprets any non-zero value as True. None and 0 are interpreted as False.|||When you run the program, the output will be:||||||In the above program, the test expression will be True as long as our counter variable i is less than or equal to n (10 in our program).|||We need to increase the value of the counter variable in the body of the loop. This is very important (and mostly forgotten). Failing to do so will result in an infinite loop (never-ending loop).|||Finally, the result is displayed.|||Same as with for loops, while loops can also have an optional else block.|||The else part is executed if the condition in the while loop evaluates to False.|||The while loop can be terminated with a break statement. In such cases, the else part is ignored. Hence, a while loop's else part runs if no break occurs and the condition is false.|||Here is an example to illustrate this.|||Output|||Here, we use a counter variable to print the string Inside loop three times.|||On the fourth iteration, the condition in while becomes False. Hence, the else part is executed.",What is while loop in Python?Syntax of while Loop in PythonFlowchart of while loopExample: Python while Loop$$$While loop with else$$$Syntax of while Loop in Python$$$Flowchart of while loop$$$Example: Python while Loop,,
https://www.programiz.com/python-programming/break-continue,Python break and continue,Video: Python break and continue Statement$$$What is the use of break and continue in Python?$$$Python break statement$$$Python continue statement$$$Syntax of break$$$Flowchart of break$$$Example: Python break$$$Syntax of Continue$$$Flowchart of continue $$$Example: Python continue$$$Table of Contents,,"In this article, you will learn to use break and continue statements to alter the flow of a loop.|||In Python, break and continue statements can alter the flow of a normal loop.|||Loops iterate over a block of code until the test expression is false, but sometimes we wish to terminate the current iteration or even the whole loop without checking test expression.|||The break and continue statements are used in these cases.|||The break statement terminates the loop containing it. Control of the program flows to the statement immediately after the body of the loop.|||If the break statement is inside a nested loop (loop inside another loop), the break statement will terminate the innermost loop.|||The working of break statement in for loop and while loop is shown below.|||Output||||||In this program, we iterate through the ""string"" sequence. We check if the letter is i, upon which we break from the loop. Hence, we see in our output that all the letters up till i gets printed. After that, the loop terminates.|||The continue statement is used to skip the rest of the code inside a loop for the current iteration only. Loop does not terminate but continues on with the next iteration.|||The working of the continue statement in for and while loop is shown below.|||Output|||This program is same as the above example except the break statement has been replaced with continue.|||We continue with the loop, if the string is i, not executing the rest of the block. Hence, we see in our output that all the letters except i gets printed.",What is the use of break and continue in Python?$$$Python break statementSyntax of breakFlowchart of breakExample of break$$$Python continue statementSyntax of ContinueFlowchart of continueExample: Python continue$$$Syntax of break$$$Flowchart of break$$$Example of break$$$Syntax of Continue$$$Flowchart of continue$$$Example: Python continue,,
https://www.programiz.com/python-programming/pass-statement,Python pass statement,Video: Python pass Statement$$$What is pass statement in Python?$$$Syntax of pass$$$Example: pass Statement$$$Table of Contents,,"In this article, you'll learn about pass statement. It is used as a placeholder for future implementation of functions, loops, etc.|||In Python programming, the pass statement is a null statement. The difference between a comment and a pass statement in Python is that while the interpreter ignores a comment entirely, pass is not ignored.|||However, nothing happens when the pass is executed. It results in no operation (NOP).|||We generally use it as a placeholder.||||||Suppose we have a loop or a function that is not implemented yet, but we want to implement it in the future. They cannot have an empty body. The interpreter would give an error. So, we use the pass statement to construct a body that does nothing.|||We can do the same thing in an empty function or class as well.",What is pass statement in Python?Syntax of passExample: pass Statement$$$Syntax of pass$$$Example: pass Statement,,
https://www.programiz.com/python-programming/function,Python Functions (def): Definition with Examples,Video: Introduction to Python Functions$$$What is a function in Python?$$$Docstrings$$$The return statement$$$How Function works in Python?$$$Scope and Lifetime of variables$$$Types of Functions$$$Syntax of Function$$$Example of a function$$$How to call a function in python?$$$Syntax of return$$$Example of return$$$Table of Contents,,"In this article, you'll learn about functions, what a function is, the syntax, components, and types of functions. Also, you'll learn to create a function in Python.|||In Python, a function is a group of related statements that performs a specific task.|||Functions help break our program into smaller and modular chunks. As our program grows larger and larger, functions make it more organized and manageable.|||Furthermore, it avoids repetition and makes the code reusable.|||Above shown is a function definition that consists of the following components.|||Once we have defined a function, we can call it from another function, program, or even the Python prompt. To call a function we simply type the function name with appropriate parameters.|||Try running the above code in the Python program with the function definition to see the output.|||Note: In python, the function definition should always be present before the function call. Otherwise, we will get an error. For example,||||||The first string after the function header is called the docstring and is short for documentation string. It is briefly used to explain what a function does.|||Although optional, documentation is a good programming practice. Unless you can remember what you had for dinner last week, always document your code.|||In the above example, we have a docstring immediately below the function header. We generally use triple quotes so that docstring can extend up to multiple lines. This string is available to us as the __doc__ attribute of the function.|||For example:|||Try running the following into the Python shell to see the output.||| |||To learn more about docstrings in Python, visit Python Docstrings.|||The return statement is used to exit a function and go back to the place from where it was called.|||This statement can contain an expression that gets evaluated and the value is returned. If there is no expression in the statement or the return statement itself is not present inside a function, then the function will return the None object.|||For example:|||Here, None is the returned value since greet() directly prints the name and no return statement is used.|||Output|||Scope of a variable is the portion of a program where the variable is recognized. Parameters and variables defined inside a function are not visible from outside the function. Hence, they have a local scope.|||The lifetime of a variable is the period throughout which the variable exists in the memory. The lifetime of variables inside a function is as long as the function executes.|||They are destroyed once we return from the function. Hence, a function does not remember the value of a variable from its previous calls.|||Here is an example to illustrate the scope of a variable inside a function.|||Output|||Here, we can see that the value of x is 20 initially. Even though the function my_func() changed the value of x to 10, it did not affect the value outside the function.|||This is because the variable x inside the function is different (local to the function) from the one outside. Although they have the same names, they are two different variables with different scopes.|||On the other hand, variables outside of the function are visible from inside. They have a global scope.|||We can read these values from inside the function but cannot change (write) them. In order to modify the value of variables outside the function, they must be declared as global variables using the keyword global.|||Basically, we can divide functions into the following two types:",What is a function in Python?$$$Syntax of Function$$$Example of a function$$$How to call functions?$$$Docstrings$$$The return statement$$$Syntax of return$$$Example of return$$$How Function works in Python?$$$Scope and Lifetime of variables$$$Types of Functions,Keyword def that marks the start of the function header.$$$A function name to uniquely identify the function. Function naming follows the same rules of writing identifiers in Python.$$$Parameters (arguments) through which we pass values to a function. They are optional.$$$A colon (:) to mark the end of the function header.$$$Optional documentation string (docstring) to describe what the function does.$$$One or more valid python statements that make up the function body. Statements must have the same indentation level (usually 4 spaces).$$$An optional return statement to return a value from the function.$$$Built-in functions - Functions that are built into Python.$$$User-defined functions - Functions defined by the users themselves.,
https://www.programiz.com/python-programming/function-argument,"Python Function Arguments (Default, Keyword and Arbitrary)","Video: Python Function Arguments: Positional, Keywords and Default$$$Arguments$$$Variable Function Arguments$$$Python Default Arguments$$$Python Keyword Arguments$$$Python Arbitrary Arguments$$$Table of Contents",,"In Python, you can define a function that takes variable number of arguments. In this article, you will learn to define such functions using default, keyword and arbitrary arguments.|||In the user-defined function topic, we learned about defining a function and calling it. Otherwise, the function call will result in an error. Here is an example.|||Output|||Here, the function greet() has two parameters.|||Since we have called this function with two arguments, it runs smoothly and we do not get any error.|||If we call it with a different number of arguments, the interpreter will show an error message. Below is a call to this function with one and no arguments along with their respective error messages.|||Up until now, functions had a fixed number of arguments. In Python, there are other ways to define a function that can take variable number of arguments.|||Three different forms of this type are described below.|||Function arguments can have default values in Python.|||We can provide a default value to an argument by using the assignment operator (=). Here is an example.|||Output||||||In this function, the parameter name does not have a default value and is required (mandatory) during a call.|||On the other hand, the parameter msg has a default value of ""Good morning!"". So, it is optional during a call. If a value is provided, it will overwrite the default value.|||Any number of arguments in a function can have a default value. But once we have a default argument, all the arguments to its right must also have default values.|||This means to say, non-default arguments cannot follow default arguments. For example, if we had defined the function header above as:|||We would get an error as:|||When we call a function with some values, these values get assigned to the arguments according to their position.|||For example, in the above function greet(), when we called it as greet(""Bruce"", ""How do you do?""), the value ""Bruce"" gets assigned to the argument name and similarly ""How do you do?"" to msg.|||Python allows functions to be called using keyword arguments. When we call functions in this way, the order (position) of the arguments can be changed. Following calls to the above function are all valid and produce the same result.|||As we can see, we can mix positional arguments with keyword arguments during a function call. But we must keep in mind that keyword arguments must follow positional arguments.|||Having a positional argument after keyword arguments will result in errors. For example, the function call as follows:|||Will result in an error:|||Sometimes, we do not know in advance the number of arguments that will be passed into a function. Python allows us to handle this kind of situation through function calls with an arbitrary number of arguments.|||In the function definition, we use an asterisk (*) before the parameter name to denote this kind of argument. Here is an example.|||Output|||Here, we have called the function with multiple arguments. These arguments get wrapped up into a tuple before being passed into the function. Inside the function, we use a for loop to retrieve all the arguments back.",Arguments$$$Variable Function ArgumentsPython Default ArgumentsPython Keyword ArgumentsPython Arbitrary Arguments$$$Python Default Arguments$$$Python Keyword Arguments$$$Python Arbitrary Arguments,,
https://www.programiz.com/python-programming/recursion,Python Recursion (Recursive Function),What is recursion?$$$Python Recursive Function$$$Advantages of Recursion$$$Disadvantages of Recursion$$$Example of a recursive function$$$Table of Contents,," In this tutorial, you will learn to create a recursive function (a function that calls itself).|||Recursion is the process of defining something in terms of itself.|||A physical world example would be to place two parallel mirrors facing each other. Any object in between them would be reflected recursively.|||In Python, we know that a function can call other functions. It is even possible for the function to call itself. These types of construct are termed as recursive functions.|||The following image shows the working of a recursive function called recurse.|||Following is an example of a recursive function to find the factorial of an integer.|||Factorial of a number is the product of all the integers from 1 to that number. For example, the factorial of 6 (denoted as 6!) is 1*2*3*4*5*6 = 720.|||Output|||In the above example, factorial() is a recursive function as it calls itself.||||||When we call this function with a positive integer, it will recursively call itself by decreasing the number.|||Each function multiplies the number with the factorial of the number below it until it is equal to one. This recursive call can be explained in the following steps.|||Let's look at an image that shows a step-by-step process of what is going on:|||Our recursion ends when the number reduces to 1. This is called the base condition.|||Every recursive function must have a base condition that stops the recursion or else the function calls itself infinitely.|||The Python interpreter limits the depths of recursion to help avoid infinite recursions, resulting in stack overflows.|||By default, the maximum depth of recursion is 1000. If the limit is crossed, it results in RecursionError. Let's look at one such condition.|||Output",What is recursion?$$$Python Recursive Function$$$Advantages of Recursion$$$Disadvantages of Recursion,Recursive functions make the code look clean and elegant.$$$A complex task can be broken down into simpler sub-problems using recursion.$$$Sequence generation is easier with recursion than using some nested iteration.$$$Sometimes the logic behind recursion is hard to follow through.$$$Recursive calls are expensive (inefficient) as they take up a lot of memory and time.$$$Recursive functions are hard to debug.,
https://www.programiz.com/python-programming/anonymous-function,Python Lambda (Anonymous) Function,Video: Python Lambda$$$What are lambda functions in Python?$$$How to use lambda Functions in Python?$$$Use of Lambda Function in python$$$Syntax of Lambda Function in python$$$Example of Lambda Function in python$$$Example use with filter()$$$Example use with map()$$$Table of Contents,,"In this article, you'll learn about the anonymous function, also known as lambda functions. You'll learn what they are, their syntax and how to use them (with examples).|||In Python, an anonymous function is a function that is defined without a name.|||While normal functions are defined using the def keyword in Python, anonymous functions are defined using the lambda keyword.|||Hence, anonymous functions are also called lambda functions.|||A lambda function in python has the following syntax.|||Lambda functions can have any number of arguments but only one expression. The expression is evaluated and returned. Lambda functions can be used wherever function objects are required.|||Here is an example of lambda function that doubles the input value.|||Output||||||In the above program, lambda x: x * 2 is the lambda function. Here x is the argument and x * 2 is the expression that gets evaluated and returned.|||This function has no name. It returns a function object which is assigned to the identifier double. We can now call it as a normal function. The statement|||is nearly the same as:|||We use lambda functions when we require a nameless function for a short period of time.|||In Python, we generally use it as an argument to a higher-order function (a function that takes in other functions as arguments). Lambda functions are used along with built-in functions like filter(), map() etc.|||The filter() function in Python takes in a function and a list as arguments.|||The function is called with all the items in the list and a new list is returned which contains items for which the function evaluates to True.|||Here is an example use of filter() function to filter out only even numbers from a list.|||Output|||The map() function in Python takes in a function and a list.|||The function is called with all the items in the list and a new list is returned which contains items returned by that function for each item.|||Here is an example use of map() function to double all the items in a list.|||Output",What are lambda functions in Python?$$$How to use lambda Functions in Python?Syntax of Lambda Function in pythonExample of Lambda Function in pythonUse of Lambda Function in python$$$Syntax of Lambda Function in python$$$Example of Lambda Function in python$$$Use of Lambda Function in python,,
https://www.programiz.com/python-programming/global-local-nonlocal-variables,"Python Global, Local and Nonlocal variables (With Examples)",Video: Python Local and Global Variables$$$Global Variables$$$Local Variables$$$Global and local variables$$$Nonlocal Variables$$$Example 1: Create a Global Variable$$$Example 2: Accessing local variable outside the scope$$$Example 3: Create a Local Variable$$$Example 4: Using Global and Local variables in the same code$$$Example 5: Global variable and Local variable with same name$$$Example 6: Create a nonlocal variable$$$Table of Contents,,"In this tutorial, you’ll learn about Python Global variables, Local variables, Nonlocal variables and where to use them.|||In Python, a variable declared outside of the function or in global scope is known as a global variable. This means that a global variable can be accessed inside or outside of the function.|||Let's see an example of how a global variable is created in Python.|||Output|||In the above code, we created x as a global variable and defined a foo() to print the global variable x. Finally, we call the foo() which will print the value of x.|||What if you want to change the value of x inside a function?|||Output|||The output shows an error because Python treats x as a local variable and x is also not defined inside foo().|||To make this work, we use the global keyword. Visit Python Global Keyword to learn more.|||A variable declared inside the function's body or in the local scope is known as a local variable.|||Output|||The output shows an error because we are trying to access a local variable y in a global scope whereas the local variable only works inside foo() or local scope.|||Let's see an example on how a local variable is created in Python.|||Normally, we declare a variable inside the function to create a local variable.|||Output|||Let's take a look at the earlier problem where x was a global variable and we wanted to modify x inside foo().||||||Here, we will show how to use global variables and local variables in the same code.|||Output|||In the above code, we declare x as a global and y as a local variable in the foo(). Then, we use multiplication operator * to modify the global variable x and we print both x and y.|||After calling the foo(), the value of x becomes global global because we used the x * 2 to print two times global. After that, we print the value of local variable y i.e local.|||Output|||In the above code, we used the same name x for both global variable and local variable. We get a different result when we print the same variable because the variable is declared in both scopes, i.e. the local scope inside foo() and global scope outside foo().|||When we print the variable inside foo() it outputs local x: 10. This is called the local scope of the variable.|||Similarly, when we print the variable outside the foo(), it outputs global x: 5. This is called the global scope of the variable.|||Nonlocal variables are used in nested functions whose local scope is not defined. This means that the variable can be neither in the local nor the global scope.|||Let's see an example of how a nonlocal variable is used in Python.|||We use nonlocal keywords to create nonlocal variables.|||Output|||In the above code, there is a nested inner() function. We use nonlocal keywords to create a nonlocal variable. The inner() function is defined in the scope of another function outer().|||Note : If we change the value of a nonlocal variable, the changes appear in the local variable.",Global Variables in Python$$$Local Variables in Python$$$Global and Local Variables Together$$$Nonlocal Variables in Python,,
https://www.programiz.com/python-programming/global-keyword,Python Global Keyword (With Examples),What is the global keyword$$$Rules of global Keyword$$$Use of global Keyword$$$Global Variables Across Python Modules$$$Global in Nested Functions$$$Table of Contents,,"In this article, you’ll learn about the global keyword, global variable and when to use global keywords.|||Before reading this article, make sure you have got some basics of Python Global, Local and Nonlocal Variables.|||In Python, global keyword allows you to modify the variable outside of the current scope. It is used to create a global variable and make changes to the variable in a local context.|||The basic rules for global keyword in Python are:|||Let's take an example.|||When we run the above program, the output will be:|||However, we may have some scenarios where we need to modify the global variable from inside a function.|||When we run the above program, the output shows an error:|||This is because we can only access the global variable but cannot modify it from inside the function.|||The solution for this is to use the global keyword.|||When we run the above program, the output will be:|||In the above program, we define c as a global keyword inside the add() function.|||Then, we increment the variable c by 2, i.e c = c + 2. After that, we call the add() function. Finally, we print the global variable c.|||As we can see, change also occurred on the global variable outside the function, c = 2.||||||In Python, we create a single module config.py to hold global variables and share information across Python modules within the same program.|||Here is how we can share global variables across the python modules.|||Create a config.py file, to store global variables|||Create a update.py file, to change global variables|||Create a main.py file, to test changes in value|||When we run the main.py file, the output will be|||In the above, we have created three files: config.py, update.py, and main.py.|||The module config.py stores global variables of a and b. In the update.py file, we import the config.py module and modify the values of a and b. Similarly, in the main.py file, we import both config.py and update.py module. Finally, we print and test the values of global variables whether they are changed or not.|||Here is how you can use a global variable in nested function.|||The output is :|||In the above program, we declared a global variable inside the nested function bar(). Inside foo() function, x has no effect of the global keyword.|||Before and after calling bar(), the variable x takes the value of local variable i.e x = 20. Outside of the foo() function, the variable x will take value defined in the bar() function i.e x = 25. This is because we have used global keyword in x to create global variable inside the bar() function (local scope).|||If we make any changes inside the bar() function, the changes appear outside the local scope, i.e. foo().","When we create a variable inside a function, it is local by default.$$$When we define a variable outside of a function, it is global by default. You don't have to use global keyword.$$$We use global keyword to read and write a global variable inside a function.$$$Use of global keyword outside a function has no effect.$$$What is the global keyword$$$Rules of global Keyword$$$Use of global Keyword$$$Global Variables Across Python Modules$$$Global in Nested Functions",,
https://www.programiz.com/python-programming/modules,Python Modules: Learn to Create and Import Custom and Built-in Modules,Video: Python Modules$$$What are modules in Python?$$$How to import modules in Python?$$$Python Module Search Path$$$Reloading a module$$$The dir() built-in function$$$Python import statement$$$Import with renaming$$$Python from...import statement$$$Import all names$$$Table of Contents,,"In this article, you will learn to create and import custom modules in Python. Also, you will find different techniques to import and use custom and built-in modules in Python.|||Modules refer to a file containing Python statements and definitions.|||A file containing Python code, for example: example.py, is called a module, and its module name would be example.|||We use modules to break down large programs into small manageable and organized files. Furthermore, modules provide reusability of code.|||We can define our most used functions in a module and import it, instead of copying their definitions into different programs.|||Let us create a module. Type the following and save it as example.py.|||Here, we have defined a function add() inside a module named example. The function takes in two numbers and returns their sum.|||We can import the definitions inside a module to another module or the interactive interpreter in Python.|||We use the import keyword to do this. To import our previously defined module example, we type the following in the Python prompt.|||This does not import the names of the functions defined in example directly in the current symbol table. It only imports the module name example there.|||Using the module name we can access the function using the dot . operator. For example:|||Python has tons of standard modules. You can check out the full list of Python standard modules and their use cases. These files are in the Lib directory inside the location where you installed Python.|||Standard modules can be imported the same way as we import our user-defined modules.|||There are various ways to import modules. They are listed below..|||We can import a module using the import statement and access the definitions inside it using the dot operator as described above. Here is an example.|||When you run the program, the output will be:||||||We can import a module by renaming it as follows:|||We have renamed the math module as m. This can save us typing time in some cases.|||Note that the name math is not recognized in our scope. Hence, math.pi is invalid, and m.pi is the correct implementation.|||We can import specific names from a module without importing the module as a whole. Here is an example.|||Here, we imported only the pi attribute from the math module.|||In such cases, we don't use the dot operator. We can also import multiple attributes as follows:|||We can import all names(definitions) from a module using the following construct:|||Here, we have imported all the definitions from the math module. This includes all names visible in our scope except those beginning with an underscore(private definitions).|||Importing everything with the asterisk (*) symbol is not a good programming practice. This can lead to duplicate definitions for an identifier. It also hampers the readability of our code.|||While importing a module, Python looks at several places. Interpreter first looks for a built-in module. Then(if built-in module not found), Python looks into a list of directories defined in sys.path. The search is in this order.|||We can add and modify this list to add our own path.|||The Python interpreter imports a module only once during a session. This makes things more efficient. Here is an example to show how this works.|||Suppose we have the following code in a module named my_module.|||Now we see the effect of multiple imports.|||We can see that our code got executed only once. This goes to say that our module was imported only once.|||Now if our module changed during the course of the program, we would have to reload it.One way to do this is to restart the interpreter. But this does not help much.|||Python provides a more efficient way of doing this. We can use the reload() function inside the imp module to reload a module. We can do it in the following ways:|||We can use the dir() function to find out names that are defined inside a module.|||For example, we have defined a function add() in the module example that we had in the beginning.|||We can use dir in example module in the following way:|||Here, we can see a sorted list of names (along with add). All other names that begin with an underscore are default Python attributes associated with the module (not user-defined).|||For example, the __name__ attribute contains the name of the module.|||All the names defined in our current namespace can be found out using the dir() function without any arguments.",The current directory.$$$PYTHONPATH (an environment variable with a list of directories).$$$The installation-dependent default directory.$$$What are modules in Python?$$$How to import modules in Python?Python import statementImport with renamingPython from...import statementImport all names$$$Python Module Search Path$$$Reloading a module$$$The dir() built-in function$$$Python import statement$$$Import with renaming$$$Python from...import statement$$$Import all names,,
https://www.programiz.com/python-programming/package,Python packages: How to create and import them?,Video: Python Packages: Organize Your Code$$$What are packages?$$$Importing module from a package$$$Table of Contents,,"In this article, you'll learn to divide your code base into clean, efficient modules using Python packages. Also, you'll learn to import and use your own or third party packages in a Python program.|||We don't usually store all of our files on our computer in the same location. We use a well-organized hierarchy of directories for easier access.|||Similar files are kept in the same directory, for example, we may keep all the songs in the ""music"" directory. Analogous to this, Python has packages for directories and modules for files.|||As our application program grows larger in size with a lot of modules, we place similar modules in one package and different modules in different packages. This makes a project (program) easy to manage and conceptually clear.|||Similarly, as a directory can contain subdirectories and files, a Python package can have sub-packages and modules.|||A directory must contain a file named __init__.py in order for Python to consider it as a package. This file can be left empty but we generally place the initialization code for that package in this file.|||Here is an example. Suppose we are developing a game. One possible organization of packages and modules could be as shown in the figure below.|||We can import modules from packages using the dot (.) operator.|||For example, if we want to import the start module in the above example, it can be done as follows:|||Now, if this module contains a function named select_difficulty(), we must use the full name to reference it.||||||If this construct seems lengthy, we can import the module without the package prefix as follows:|||We can now call the function simply as follows:|||Another way of importing just the required function (or class or variable) from a module within a package would be as follows:|||Now we can directly call this function.|||Although easier, this method is not recommended. Using the full namespace avoids confusion and prevents two same identifier names from colliding.|||While importing packages, Python looks in the list of directories defined in sys.path, similar as for module search path.",What are packages?$$$Importing module from a package,,
https://www.programiz.com/python-programming/numbers,"Python Numbers, Type Conversion and Mathematics",Number Data Type in Python$$$Type Conversion$$$Python Decimal$$$Python Fractions$$$Python Mathematics$$$When to use Decimal instead of float?$$$Table of Contents,,"In this article, you'll learn about the different numbers used in Python, how to convert from one data type to the other, and the mathematical operations supported in Python.|||Python supports integers, floating-point numbers and complex numbers. They are defined as int, float, and complex classes in Python.|||Integers and floating points are separated by the presence or absence of a decimal point. For instance, 5 is an integer whereas 5.0 is a floating-point number.|||Complex numbers are written in the form, x + yj, where x is the real part and y is the imaginary part.|||We can use the type() function to know which class a variable or a value belongs to and isinstance() function to check if it belongs to a particular class.|||Let's look at an example:|||When we run the above program, we get the following output:|||While integers can be of any length, a floating-point number is accurate only up to 15 decimal places (the 16th place is inaccurate).|||The numbers we deal with every day are of the decimal (base 10) number system. But computer programmers (generally embedded programmers) need to work with binary (base 2), hexadecimal (base 16) and octal (base 8) number systems.|||In Python, we can represent these numbers by appropriately placing a prefix before that number. The following table lists these prefixes.|||Here are some examples|||When you run the program, the output will be:|||We can convert one type of number into another. This is also known as coercion.|||Operations like addition, subtraction coerce integer to float implicitly (automatically), if one of the operands is float.|||We can see above that 1 (integer) is coerced into 1.0 (float) for addition and the result is also a floating point number.||||||We can also use built-in functions like int(), float() and complex() to convert between types explicitly. These functions can even convert from strings.|||When converting from float to integer, the number gets truncated (decimal parts are removed).|||Python built-in class float performs some calculations that might amaze us. We all know that the sum of 1.1 and 2.2 is 3.3, but Python seems to disagree.|||What is going on?|||It turns out that floating-point numbers are implemented in computer hardware as binary fractions as the computer only understands binary (0 and 1). Due to this reason, most of the decimal fractions we know, cannot be accurately stored in our computer.|||Let's take an example. We cannot represent the fraction 1/3 as a decimal number. This will give 0.33333333... which is infinitely long, and we can only approximate it.|||It turns out that the decimal fraction 0.1 will result in an infinitely long binary fraction of 0.000110011001100110011... and our computer only stores a finite number of it.|||This will only approximate 0.1 but never be equal. Hence, it is the limitation of our computer hardware and not an error in Python.|||To overcome this issue, we can use the decimal module that comes with Python. While floating-point numbers have precision up to 15 decimal places, the decimal module has user-settable precision.|||Let's see the difference:|||Output|||This module is used when we want to carry out decimal calculations as we learned in school.|||It also preserves significance. We know 25.50 kg is more accurate than 25.5 kg as it has two significant decimal places compared to one.|||Output|||Notice the trailing zeroes in the above example.|||We might ask, why not implement Decimal every time, instead of float? The main reason is efficiency. Floating point operations are carried out much faster than Decimal operations.|||We generally use Decimal in the following cases.|||Python provides operations involving fractional numbers through its fractions module.|||A fraction has a numerator and a denominator, both of which are integers. This module has support for rational number arithmetic.|||We can create Fraction objects in various ways. Let's have a look at them.|||Output|||While creating Fraction from float, we might get some unusual results. This is due to the imperfect binary floating point number representation as discussed in the previous section.|||Fortunately, Fraction allows us to instantiate with string as well. This is the preferred option when using decimal numbers.|||Output|||This data type supports all basic operations. Here are a few examples.|||Output|||Python offers modules like math and random to carry out different mathematics like trigonometry, logarithms, probability and statistics, etc.|||Output|||Here is the full list of functions and attributes available in the Python math module.|||When we run the above program we get the output as follows.(Values may be different due to the random behavior)|||Here is the full list of functions and attributes available in the Python random module.",When we are making financial applications that need exact decimal representation.$$$When we want to control the level of precision required.$$$When we want to implement the notion of significant decimal places.$$$Number Data Type in Python$$$Type Conversion$$$Python DecimalWhen to use Decimal instead of float?$$$Python Fractions$$$Python Mathematics$$$When to use Decimal instead of float?,,Number System|||Prefix$$$Binary|||'0b' or '0B'$$$Octal|||'0o' or '0O'$$$Hexadecimal|||'0x' or '0X'
https://www.programiz.com/python-programming/list,Python List (With Examples),Video: Python Lists and Tuples$$$Create Python Lists$$$Access List Elements$$$List Slicing in Python$$$Add/Change List Elements$$$Delete List Elements$$$Python List Methods$$$List Comprehension: Elegant way to create Lists$$$Other List Operations in Python$$$List Index$$$Negative indexing$$$List Membership Test$$$Iterating Through a List$$$Table of Contents,,"In this tutorial, we'll learn everything about Python lists: creating lists, changing list elements, removing elements, and other list operations with the help of examples.|||Python lists are one of the most versatile data types that allow us to work with multiple elements at once. For example,|||In Python, a list is created by placing  elements inside square brackets [], separated by commas.|||A list can have any number of items and they may be of different types (integer, float, string, etc.).|||A list can also have another list as an item. This is called a nested list.|||There are various ways in which we can access the elements of a list.|||We can use the index operator [] to access an item in a list. In Python, indices start at 0. So, a list having 5 elements will have an index from 0 to 4.|||Trying to access indexes other than these will raise an IndexError. The index must be an integer. We can't use float or other types, this will result in TypeError.|||Nested lists are accessed using nested indexing.|||Output|||Python allows negative indexing for its sequences. The index of -1 refers to the last item, -2 to the second last item and so on.|||Output|||We can access a range of items in a list by using the slicing operator :.|||Output|||Note: When we slice lists, the start index is inclusive but the end index is exclusive. For example, my_list[2: 5] returns a list with elements at index 2, 3 and 4, but not 5.|||Lists are mutable, meaning their elements can be changed unlike string or tuple.|||We can use the assignment operator = to change an item or a range of items.||||||Output|||We can add one item to a list using the append() method or add several items using the extend() method.|||Output|||We can also use + operator to combine two lists. This is also called concatenation.|||The * operator repeats a list for the given number of times.|||Output|||Furthermore, we can insert one item at a desired location by using the method insert() or insert multiple items by squeezing it into an empty slice of a list.|||Output|||We can delete one or more items from a list using the Python del statement. It can even delete the list entirely.|||Output|||We can use  remove() to remove the given item or pop() to remove an item at the given index.|||The pop() method removes and returns the last item if the index is not provided. This helps us implement lists as stacks (first in, last out data structure).|||And, if we have to empty the whole list, we can use the clear() method.|||Output|||Finally, we can also delete items in a list by assigning an empty list to a slice of elements.|||Python has many useful list methods that makes it really easy to work with lists. Here are some of the commonly used list methods.|||List comprehension is an elegant and concise way to create a new list from an existing list in Python.|||A list comprehension consists of an expression followed by for statement inside square brackets.|||Here is an example to make a list with each item being increasing power of 2.|||Output|||This code is equivalent to:|||A list comprehension can optionally contain more for or if statements. An optional if statement can filter out items for the new list. Here are some examples.|||Visit Python list comprehension to learn more.|||We can test if an item exists in a list or not, using the keyword in.|||Output|||Using a for loop we can iterate through each item in a list.|||Output",Create Python lists$$$Access List Elements$$$Slicing of Lists$$$Add and Change List Elements$$$Remove Elements from a List?$$$Python List Methods$$$Python List Comprehension$$$Other List Operations in Python,,Methods|||Descriptions$$$append()|||adds an element to the end of the list$$$extend()|||adds all elements of a list to another list$$$insert()|||inserts an item at the defined index$$$remove()|||removes an item from the list$$$pop()|||returns and removes an element at the given index$$$clear()|||removes all items from the list$$$index()|||returns the index of the first matched item$$$count()|||returns the count of the number of items passed as an argument$$$sort()|||sort items in a list in ascending order$$$reverse()|||reverse the order of items in the list$$$copy() |||returns a shallow copy of the list
https://www.programiz.com/python-programming/tuple,Python Tuple (With Examples),Video: Python Lists and Tuples$$$Creating a Tuple$$$Access Tuple Elements$$$Changing a Tuple$$$Deleting a Tuple$$$Tuple Methods$$$Other Tuple Operations$$$1. Indexing$$$2. Negative Indexing$$$3. Slicing$$$1. Tuple Membership Test$$$2. Iterating Through a Tuple$$$Advantages of Tuple over List$$$Table of Contents,,"In this article, you'll learn everything about Python tuples. More specifically, what are tuples, how to create them, when to use them and various methods you should be familiar with.|||A tuple in Python is similar to a list. The difference between the two is that we cannot change the elements of a tuple once it is assigned whereas we can change the elements of a list.|||A tuple is created by placing all the items (elements) inside parentheses (), separated by commas. The parentheses are optional, however, it is a good practice to use them.|||A tuple can have any number of items and they may be of different types (integer, float, list, string, etc.).|||Output|||A tuple can also be created without using parentheses. This is known as tuple packing.|||Output|||Creating a tuple with one element is a bit tricky.|||Having one element within parentheses is not enough. We will need a trailing comma to indicate that it is, in fact, a tuple.|||Output|||There are various ways in which we can access the elements of a tuple.|||We can use the index operator [] to access an item in a tuple, where the index starts from 0.|||So, a tuple having 6 elements will have indices from 0 to 5. Trying to access an index outside of the tuple index range(6,7,... in this example) will raise an IndexError.|||The index must be an integer, so we cannot use float or other types. This will result in TypeError.|||Likewise, nested tuples are accessed using nested indexing, as shown in the example below.|||Output|||Python allows negative indexing for its sequences.|||The index of -1 refers to the last item, -2 to the second last item and so on.||||||Output|||We can access a range of items in a tuple by using the slicing operator colon :.|||Output|||Slicing can be best visualized by considering the index to be between the elements as shown below. So if we want to access a range, we need the index that will slice the portion from the tuple.|||Unlike lists, tuples are immutable.|||This means that elements of a tuple cannot be changed once they have been assigned. But, if the element is itself a mutable data type like a list, its nested items can be changed.|||We can also assign a tuple to different values (reassignment).|||Output|||We can use + operator to combine two tuples. This is called concatenation.|||We can also repeat the elements in a tuple for a given number of times using the * operator.|||Both + and * operations result in a new tuple.|||Output|||As discussed above, we cannot change the elements in a tuple. It means that we cannot delete or remove items from a tuple.|||Deleting a tuple entirely, however, is possible using the keyword del.|||Output|||Methods that add items or remove items are not available with tuple. Only the following two methods are available.|||Some examples of Python tuple methods:|||Output|||We can test if an item exists in a tuple or not, using the keyword in.|||Output|||We can use a for loop to iterate through each item in a tuple.|||Output|||Since tuples are quite similar to lists, both of them are used in similar situations. However, there are certain advantages of implementing a tuple over a list. Below listed are some of the main advantages:","We generally use tuples for heterogeneous (different) data types and lists for homogeneous (similar) data types.$$$Since tuples are immutable, iterating through a tuple is faster than with list. So there is a slight performance boost.$$$Tuples that contain immutable elements can be used as a key for a dictionary. With lists, this is not possible.$$$If you have data that doesn't change, implementing it as tuple will guarantee that it remains write-protected.$$$Tuple (Introduction)$$$Creating a tuple$$$Access Tuple Items$$$Changing a tuple$$$Deleting a Tuple$$$Tuple Methods$$$Other Tuple Operations$$$Advantages of Tuple over List",,
https://www.programiz.com/python-programming/string,Python Strings (With Examples),Video: Python Strings$$$What is String in Python?$$$How to create a string in Python?$$$How to access characters in a string?$$$How to change or delete a string?$$$Python String Operations$$$Python String Formatting$$$Common Python String Methods$$$Concatenation of Two or More Strings$$$Iterating Through a string$$$String Membership Test$$$Built-in functions to Work with Python$$$Escape Sequence$$$Raw String to ignore escape sequence$$$The format() Method for Formatting Strings$$$Old style formatting$$$Table of Contents,,"In this tutorial you will learn to create, format, modify and delete strings in Python. Also, you will be introduced to various string operations and functions.|||A string is a sequence of characters.|||A character is simply a symbol. For example, the English language has 26 characters.|||Computers do not deal with characters, they deal with numbers (binary). Even though you may see characters on your screen, internally it is stored and manipulated as a combination of 0s and 1s.|||This conversion of character to a number is called encoding, and the reverse process is decoding. ASCII and Unicode are some of the popular encodings used.|||In Python, a string is a sequence of Unicode characters. Unicode was introduced to include every character in all languages and bring uniformity in encoding. You can learn about Unicode from Python Unicode.|||Strings can be created by enclosing characters inside a single quote or double-quotes. Even triple quotes can be used in Python but generally used to represent multiline strings and docstrings.|||When you run the program, the output will be:|||We can access individual characters using indexing and a range of characters using slicing. Index starts from 0. Trying to access a character out of index range will raise an IndexError. The index must be an integer. We can't use floats or other types, this will result into TypeError.|||Python allows negative indexing for its sequences.|||The index of -1 refers to the last item, -2 to the second last item and so on. We can access a range of items in a string by using the slicing operator :(colon).|||When we run the above program, we get the following output:|||If we try to access an index out of the range or use numbers other than an integer, we will get errors.|||Slicing can be best visualized by considering the index to be between the elements as shown below.|||If we want to access a range, we need the index that will slice the portion from the string.||||||Strings are immutable. This means that elements of a string cannot be changed once they have been assigned. We can simply reassign different strings to the same name.|||We cannot delete or remove characters from a string. But deleting the string entirely is possible using the del keyword.|||There are many operations that can be performed with strings which makes it one of the most used data types in Python.|||To learn more about the data types available in Python visit: Python Data Types|||Joining of two or more strings into a single one is called concatenation.|||The + operator does this in Python. Simply writing two string literals together also concatenates them.|||The * operator can be used to repeat the string for a given number of times.|||When we run the above program, we get the following output:|||Writing two string literals together also concatenates them like + operator.|||If we want to concatenate strings in different lines, we can use parentheses.|||We can iterate through a string using a for loop. Here is an example to count the number of 'l's in a string.|||When we run the above program, we get the following output:|||We can test if a substring exists within a string or not, using the keyword in.|||Various built-in functions that work with sequence work with strings as well.|||Some of the commonly used ones are enumerate() and len(). The enumerate() function returns an enumerate object. It contains the index and value of all the items in the string as pairs. This can be useful for iteration.|||Similarly, len() returns the length (number of characters) of the string.|||When we run the above program, we get the following output:|||If we want to print a text like He said, ""What's there?"", we can neither use single quotes nor double quotes. This will result in a SyntaxError as the text itself contains both single and double quotes.|||One way to get around this problem is to use triple quotes. Alternatively, we can use escape sequences.|||An escape sequence starts with a backslash and is interpreted differently. If we use a single quote to represent a string, all the single quotes inside the string must be escaped. Similar is the case with double quotes. Here is how it can be done to represent the above text.|||When we run the above program, we get the following output:|||Here is a list of all the escape sequences supported by Python.|||Here are some examples|||Sometimes we may wish to ignore the escape sequences inside a string. To do this we can place r or R in front of the string. This will imply that it is a raw string and any escape sequence inside it will be ignored.|||The format() method that is available with the string object is very versatile and powerful in formatting strings. Format strings contain curly braces {} as placeholders or replacement fields which get replaced.|||We can use positional arguments or keyword arguments to specify the order.|||When we run the above program, we get the following output:|||The format() method can have optional format specifications. They are separated from the field name using colon. For example, we can left-justify <, right-justify > or center ^ a string in the given space.|||We can also format integers as binary, hexadecimal, etc. and floats can be rounded or displayed in the exponent format. There are tons of formatting you can use. Visit here for all the string formatting available with the format() method.|||We can even format strings like the old sprintf() style used in C programming language. We use the % operator to accomplish this.|||There are numerous methods available with the string object. The format() method that we mentioned above is one of them. Some of the commonly used methods are lower(), upper(), join(), split(), find(), replace() etc. Here is a complete list of all the built-in methods to work with strings in Python.",What is String in Python?$$$How to create a string in Python?$$$How to access characters in a string?$$$How to change or delete a string?$$$Python String OperationsConcatenation of Two or More StringsIterating Through StringString Membership TestBuilt-in functions to Work with Python$$$Python String FormattingEscape SequenceRaw String to ignore escape sequenceThe format() Method for Formatting StringsOld style formatting$$$Common Python String Methods$$$Concatenation of Two or More Strings$$$Iterating Through String$$$String Membership Test$$$Built-in functions to Work with Python$$$Escape Sequence$$$Raw String to ignore escape sequence$$$The format() Method for Formatting Strings$$$Old style formatting,,"Escape Sequence|||Description$$$\newline|||Backslash and newline ignored$$$\\|||Backslash$$$\'|||Single quote$$$\""|||Double quote$$$\a|||ASCII Bell$$$\b|||ASCII Backspace$$$\f|||ASCII Formfeed$$$\n|||ASCII Linefeed$$$\r|||ASCII Carriage Return$$$\t|||ASCII Horizontal Tab$$$\v|||ASCII Vertical Tab$$$\ooo|||Character with octal value ooo$$$\xHH|||Character with hexadecimal value HH"
https://www.programiz.com/python-programming/set,Python Set (With Examples),Video: Sets in Python$$$Creating Python Sets$$$Modifying a set in Python$$$Removing elements from a set$$$Python Set Operations$$$Other Python Set Methods$$$Other Set Operations$$$Python Frozenset$$$Set Union$$$Set Intersection$$$Set Difference$$$Set Symmetric Difference$$$Set Membership Test$$$Iterating Through a Set$$$Built-in Functions with Set$$$Table of Contents,,"In this tutorial, you'll learn everything about Python sets; how they are created, adding or removing elements from them, and all operations performed on sets in Python.|||A set is an unordered collection of items. Every set element is unique (no duplicates) and must be immutable (cannot be changed).|||However, a set itself is mutable. We can add or remove items from it.|||Sets can also be used to perform mathematical set operations like union, intersection, symmetric difference, etc.|||A set is created by placing all the items (elements) inside curly braces {}, separated by comma, or by using the built-in set() function.|||It can have any number of items and they may be of different types (integer, float, tuple, string etc.). But a set cannot have mutable elements like lists, sets or dictionaries as its elements.|||Output|||Try the following examples as well.|||Output|||Creating an empty set is a bit tricky.|||Empty curly braces {} will make an empty dictionary in Python. To make a set without any elements, we use the set() function without any argument.|||Output|||Sets are mutable. However, since they are unordered, indexing has no meaning.|||We cannot access or change an element of a set using indexing or slicing. Set data type does not support it.|||We can add a single element using the add() method, and multiple elements using the update() method. The update() method can take tuples, lists, strings or other sets as its argument. In all cases, duplicates are avoided.|||Output||||||A particular item can be removed from a set using the methods discard() and remove().|||The only difference between the two is that the discard() function leaves a set unchanged if the element is not present in the set. On the other hand, the remove() function will raise an error in such a condition (if element is not present in the set).|||The following example will illustrate this.|||Output|||Similarly, we can remove and return an item using the pop() method.|||Since set is an unordered data type, there is no way of determining which item will be popped. It is completely arbitrary.|||We can also remove all the items from a set using the clear() method.|||Output|||Sets can be used to carry out mathematical set operations like union, intersection, difference and symmetric difference. We can do this with operators or methods.|||Let us consider the following two sets for the following operations.|||Union of A and B is a set of all elements from both sets.|||Union is performed using | operator. Same can be accomplished using the union() method.|||Output|||Try the following examples on Python shell.|||Intersection of A and B is a set of elements that are common in both the sets.|||Intersection is performed using & operator. Same can be accomplished using the intersection() method.|||Output|||Try the following examples on Python shell.|||Difference of the set B from set A(A - B) is a set of elements that are only in A but not in B. Similarly, B - A is a set of elements in B but not in A.|||Difference is performed using - operator. Same can be accomplished using the difference() method.|||Output|||Try the following examples on Python shell.|||Symmetric Difference of A and B is a set of elements in A and B but not in both (excluding the intersection).|||Symmetric difference is performed using ^ operator. Same can be accomplished using the method symmetric_difference().|||Output|||Try the following examples on Python shell.|||There are many set methods, some of which we have already used above. Here is a list of all the methods that are available with the set objects:|||We can test if an item exists in a set or not, using the in keyword.|||Output|||We can iterate through each item in a set using a for loop.|||Built-in functions like all(), any(), enumerate(), len(), max(), min(), sorted(), sum() etc. are commonly used with sets to perform different tasks.|||Frozenset is a new class that has the characteristics of a set, but its elements cannot be changed once assigned. While tuples are immutable lists, frozensets are immutable sets.|||Sets being mutable are unhashable, so they can't be used as dictionary keys. On the other hand, frozensets are hashable and can be used as keys to a dictionary.|||Frozensets can be created using the frozenset() function.|||This data type supports methods like copy(), difference(), intersection(), isdisjoint(), issubset(), issuperset(), symmetric_difference() and union(). Being immutable, it does not have methods that add or remove elements.|||Try these examples on Python shell.",Introduction$$$Creating Python Sets$$$Modifying Python Sets$$$Removing elements Sets$$$Python Set Operations$$$Set Union$$$Set Intersection$$$Set Difference$$$Set Symmetric Difference$$$Other Python Set Methods$$$Set Membership Test$$$Iterating Through a Set$$$Built-in Functions with Set$$$Python Frozenset,,"Method|||Description$$$add()|||Adds an element to the set$$$clear()|||Removes all elements from the set$$$copy()|||Returns a copy of the set$$$difference()|||Returns the difference of two or more sets as a new set$$$difference_update()|||Removes all elements of another set from this set$$$discard()|||Removes an element from the set if it is a member. (Do nothing if the element is not in set)$$$intersection()|||Returns the intersection of two sets as a new set$$$intersection_update()|||Updates the set with the intersection of itself and another$$$isdisjoint()|||Returns True if two sets have a null intersection$$$issubset()|||Returns True if another set contains this set$$$issuperset()|||Returns True if this set contains another set$$$pop()|||Removes and returns an arbitrary set element. Raises KeyError if the set is empty$$$remove()|||Removes an element from the set. If the element is not a member, raises a KeyError$$$symmetric_difference()|||Returns the symmetric difference of two sets as a new set$$$symmetric_difference_update()|||Updates a set with the symmetric difference of itself and another$$$union()|||Returns the union of sets in a new set$$$update()|||Updates the set with the union of itself and others$$$Function|||Description$$$all()|||Returns True if all elements of the set are true (or if the set is empty).$$$any()|||Returns True if any element of the set is true. If the set is empty, returns False.$$$enumerate()|||Returns an enumerate object. It contains the index and value for all the items of the set as a pair.$$$len()|||Returns the length (the number of items) in the set.$$$max()|||Returns the largest item in the set.$$$min()|||Returns the smallest item in the set.$$$sorted()|||Returns a new sorted list from elements in the set(does not sort the set itself).$$$sum()|||Returns the sum of all elements in the set."
https://www.programiz.com/python-programming/dictionary,Python Dictionary (With Examples),Video: Python Dictionaries to Store key/value Pairs$$$Creating Python Dictionary$$$Accessing Elements from Dictionary$$$Changing and Adding Dictionary elements$$$Removing elements from Dictionary$$$Python Dictionary Methods$$$Python Dictionary Comprehension$$$Other Dictionary Operations$$$Dictionary Membership Test$$$Iterating Through a Dictionary$$$Dictionary Built-in Functions$$$Table of Contents,,"In this tutorial, you'll learn everything about Python dictionaries; how they are created, accessing, adding, removing elements from them and various built-in methods.|||Python dictionary is an unordered collection of items. Each item of a dictionary has a key/value pair.|||Dictionaries are optimized to retrieve values when the key is known.|||Creating a dictionary is as simple as placing items inside curly braces {} separated by commas.|||An item has a key and a corresponding value that is expressed as a pair (key: value).|||While the values can be of any data type and can repeat, keys must be of immutable type (string, number or tuple with immutable elements) and must be unique.|||As you can see from above, we can also create a dictionary using the built-in dict() function.|||While indexing is used with other data types to access values, a dictionary uses keys. Keys can be used either inside square brackets [] or with the get() method.|||If we use the square brackets [], KeyError is raised in case a key is not found in the dictionary. On the other hand, the get() method returns None if the key is not found.|||Output|||Dictionaries are mutable. We can add new items or change the value of existing items using an assignment operator.|||If the key is already present, then the existing value gets updated. In case the key is not present, a new (key: value) pair is added to the dictionary.|||Output|||We can remove a particular item in a dictionary by using the pop() method. This method removes an item with the provided key and returns the value.|||The popitem() method can be used to remove and return an arbitrary (key, value) item pair from the dictionary. All the items can be removed at once, using the clear() method.|||We can also use the del keyword to remove individual items or the entire dictionary itself.||||||Output|||Methods that are available with a dictionary are tabulated below. Some of them have already been used in the above examples.|||Here are a few example use cases of these methods.|||Output|||Dictionary comprehension is an elegant and concise way to create a new dictionary from an iterable in Python.|||Dictionary comprehension consists of an expression pair (key: value) followed by a for statement inside curly braces {}.|||Here is an example to make a dictionary with each item being a pair of a number and its square.|||Output|||This code is equivalent to|||Output|||A dictionary comprehension can optionally contain more for or if statements.|||An optional if statement can filter out items to form the new dictionary.|||Here are some examples to make a dictionary with only odd items.|||Output|||To learn more dictionary comprehensions, visit Python Dictionary Comprehension.|||We can test if a key is in a dictionary or not using the keyword in. Notice that the membership test is only for the keys and not for the values.|||Output|||We can iterate through each key in a dictionary using a for loop.|||Output|||Built-in functions like all(), any(), len(), cmp(), sorted(), etc. are commonly used with dictionaries to perform different tasks.|||Here are some examples that use built-in functions to work with a dictionary.|||Output",Introduction$$$Creating Python Dictionary$$$Accessing Elements from Dictionary$$$Changing Dictionary Values$$$Removing Dictionary Items$$$Python Dictionary Methods$$$Python Dictionary Comprehension$$$Other Dictionary Operations$$$Dictionary Membership Test$$$Iterating Through Dictionary$$$Dictionary Built-in Functions,,"Method|||Description$$$clear()|||Removes all items from the dictionary.$$$copy()|||Returns a shallow copy of the dictionary.$$$fromkeys(seq[, v])|||Returns a new dictionary with keys from seq and value equal to v (defaults to None).$$$get(key[,d])|||Returns the value of the key. If the key does not exist, returns d (defaults to None).$$$items()|||Return a new object of the dictionary's items in (key, value) format.$$$keys()|||Returns a new object of the dictionary's keys.$$$pop(key[,d])|||Removes the item with the key and returns its value or d if key is not found. If d is not provided and the key is not found, it raises KeyError.$$$popitem()|||Removes and returns an arbitrary item (key, value). Raises KeyError if the dictionary is empty.$$$setdefault(key[,d])|||Returns the corresponding value if the key is in the dictionary. If not, inserts the key with a value of d and returns d (defaults to None).$$$update([other])|||Updates the dictionary with the key/value pairs from other, overwriting existing keys.$$$values()|||Returns a new object of the dictionary's values$$$Function|||Description$$$all()|||Return True if all keys of the dictionary are True (or if the dictionary is empty).$$$any()|||Return True if any key of the dictionary is true. If the dictionary is empty, return False.$$$len()|||Return the length (the number of items) in the dictionary.$$$cmp()|||Compares items of two dictionaries. (Not available in Python 3)$$$sorted()|||Return a new sorted list of keys in the dictionary."
https://www.programiz.com/python-programming/file-operation,Python File I/O: Read and Write Files in Python,Video: Reading and Writing Files in Python$$$Files$$$Opening Files in Python$$$Closing Files in Python$$$Writing to Files in Python$$$Reading Files in Python$$$Python File Methods$$$Table of Contents,,"In this tutorial, you'll learn about Python file operations. More specifically, opening a file, reading from it, writing into it, closing it, and various file methods that you should be aware of.|||Files are named locations on disk to store related information. They are used to permanently store data in a non-volatile memory (e.g. hard disk).|||Since Random Access Memory (RAM) is volatile (which loses its data when the computer is turned off), we use files for future use of the data by permanently storing them.|||When we want to read from or write to a file, we need to open it first. When we are done, it needs to be closed so that the resources that are tied with the file are freed.|||Hence, in Python, a file operation takes place in the following order:|||Python has a built-in open() function to open a file. This function returns a file object, also called a handle, as it is used to read or modify the file accordingly.|||We can specify the mode while opening a file. In mode, we specify whether we want to read r, write w or append a to the file. We can also specify if we want to open the file in text mode or binary mode.|||The default is reading in text mode. In this mode, we get strings when reading from the file.|||On the other hand, binary mode returns bytes and this is the mode to be used when dealing with non-text files like images or executable files.|||Unlike other languages, the character a does not imply the number 97 until it is encoded using ASCII (or other equivalent encodings).|||Moreover, the default encoding is platform dependent. In windows, it is cp1252 but utf-8 in Linux.|||So, we must not also rely on the default encoding or else our code will behave differently in different platforms.|||Hence, when working with files in text mode, it is highly recommended to specify the encoding type.|||When we are done with performing operations on the file, we need to properly close the file.|||Closing a file will free up the resources that were tied with the file. It is done using the close() method available in Python.|||Python has a garbage collector to clean up unreferenced objects but we must not rely on it to close the file.||||||This method is not entirely safe. If an exception occurs when we are performing some operation with the file, the code exits without closing the file.|||A safer way is to use a try...finally block.|||This way, we are guaranteeing that the file is properly closed even if an exception is raised that causes program flow to stop.|||The best way to close a file is by using the with statement. This ensures that the file is closed when the block inside the with statement is exited.|||We don't need to explicitly call the close() method. It is done internally.|||In order to write into a file in Python, we need to open it in write w, append a or exclusive creation x mode.|||We need to be careful with the w mode, as it will overwrite into the file if it already exists. Due to this, all the previous data are erased.|||Writing a string or sequence of bytes (for binary files) is done using the write() method. This method returns the number of characters written to the file.|||This program will create a new file named test.txt in the current directory if it does not exist. If it does exist, it is overwritten.|||We must include the newline characters ourselves to distinguish the different lines.|||To read a file in Python, we must open the file in reading r mode.|||There are various methods available for this purpose. We can use the read(size) method to read in the size number of data. If the size parameter is not specified, it reads and returns up to the end of the file.|||We can read the text.txt file we wrote in the above section in the following way:|||We can see that the read() method returns a newline as '\n'. Once the end of the file is reached, we get an empty string on further reading.|||We can change our current file cursor (position) using the seek() method. Similarly, the tell() method returns our current position (in number of bytes).|||We can read a file line-by-line using a for loop. This is both efficient and fast.|||In this program, the lines in the file itself include a newline character \n. So, we use the end parameter of the print() function to avoid two newlines when printing.|||Alternatively, we can use the readline() method to read individual lines of a file. This method reads a file till the newline, including the newline character.|||Lastly, the readlines() method returns a list of remaining lines of the entire file. All these reading methods return empty values when the end of file (EOF) is reached.|||There are various methods available with the file object. Some of them have been used in the above examples.|||Here is the complete list of methods in text mode with a brief description:",Files$$$Opening Files in Python$$$Closing Files in Python$$$Writing to Files in Python$$$Reading Files in Python$$$Python File Methods,Open a file$$$Read or write (perform operation)$$$Close the file,"Mode|||Description$$$r|||Opens a file for reading. (default)$$$w|||Opens a file for writing. Creates a new file if it does not exist or truncates the file if it exists.$$$x|||Opens a file for exclusive creation. If the file already exists, the operation fails.$$$a|||Opens a file for appending at the end of the file without truncating it. Creates a new file if it does not exist.$$$t|||Opens in text mode. (default)$$$b|||Opens in binary mode.$$$+|||Opens a file for updating (reading and writing)$$$Method|||Description$$$close()|||Closes an opened file. It has no effect if the file is already closed.$$$detach()|||Separates the underlying binary buffer from the TextIOBase and returns it.$$$fileno()|||Returns an integer number (file descriptor) of the file.$$$flush()|||Flushes the write buffer of the file stream.$$$isatty()|||Returns True if the file stream is interactive.$$$read(n)|||Reads at most n characters from the file. Reads till end of file if it is negative or None.$$$readable()|||Returns True if the file stream can be read from.$$$readline(n=-1)|||Reads and returns one line from the file. Reads in at most n bytes if specified.$$$readlines(n=-1)|||Reads and returns a list of lines from the file. Reads in at most n bytes/characters if specified.$$$seek(offset,from=SEEK_SET)|||Changes the file position to offset bytes, in reference to from (start, current, end).$$$seekable()|||Returns True if the file stream supports random access.$$$tell()|||Returns an integer that represents the current position of the file's object.$$$truncate(size=None)|||Resizes the file stream to size bytes. If size is not specified, resizes to current location.$$$writable()|||Returns True if the file stream can be written to.$$$write(s)|||Writes the string s to the file and returns the number of characters written.$$$writelines(lines)|||Writes a list of lines to the file."
https://www.programiz.com/python-programming/directory,Python Directory and Files Management,Video: Python os Module$$$Python Directory$$$Get Current Directory$$$Changing Directory$$$List Directories and Files$$$Making a New Directory$$$Renaming a Directory or a File$$$Removing Directory or File$$$Table of Contents,,"In this tutorial, you'll learn about file and directory management in Python, i.e. creating a directory, renaming it, listing all directories, and working with them.|||If there are a large number of files to handle in our Python program, we can arrange our code within different directories to make things more manageable.|||A directory or folder is a collection of files and subdirectories. Python has the os module that provides us with many useful methods to work with directories (and files as well).|||We can get the present working directory using the getcwd() method of the os module.|||This method returns the current working directory in the form of a string. We can also use the getcwdb() method to get it as bytes object.|||The extra backslash implies an escape sequence. The print() function will render this properly.|||We can change the current working directory by using the chdir() method.|||The new path that we want to change into must be supplied as a string to this method. We can use both the forward-slash / or the backward-slash \ to separate the path elements.|||It is safer to use an escape sequence when using the backward slash.|||All files and sub-directories inside a directory can be retrieved using the listdir() method.||||||This method takes in a path and returns a list of subdirectories and files in that path. If no path is specified, it returns the list of subdirectories and files from the current working directory.|||We can make a new directory using the mkdir() method.|||This method takes in the path of the new directory. If the full path is not specified, the new directory is created in the current working directory.|||The rename() method can rename a directory or a file.|||For renaming any directory or file, the rename() method takes in two basic arguments: the old name as the first argument and the new name as the second argument.|||A file can be removed (deleted) using the remove() method.|||Similarly, the rmdir() method removes an empty directory.|||Note: The rmdir() method can only remove empty directories.|||In order to remove a non-empty directory, we can use the rmtree() method inside the shutil module.",Python Directory$$$Get Current Directory$$$Changing Directory$$$List Directories and Files$$$Making a New Directory$$$Renaming a Directory or a File$$$Removing Directory or File,,
https://www.programiz.com/python-programming/exceptions,Python Errors and Built-in Exceptions,Video: Python Exception Handling$$$Python Syntax Errors$$$Python Logical Errors (Exceptions)$$$Python Built-in Exceptions$$$Table of Contents,,"In this tutorial, you will learn about different types of errors and exceptions that are built-in to Python. They are raised whenever the Python interpreter encounters errors.|||We can make certain mistakes while writing a program that lead to errors when we try to run it. A python program terminates as soon as it encounters an unhandled error. These errors can be broadly classified into two classes:|||Error caused by not following the proper structure (syntax) of the language is called syntax error or parsing error.|||Let's look at one example:|||As shown in the example, an arrow indicates where the parser ran into the syntax error.|||We can notice here that a colon : is missing in the if statement.|||Errors that occur at runtime (after passing the syntax test) are called exceptions or logical errors.|||For instance, they occur when we try to open a file(for reading) that does not exist (FileNotFoundError), try to divide a number by zero (ZeroDivisionError), or try to import a module that does not exist (ImportError).|||Whenever these types of runtime errors occur, Python creates an exception object. If not handled properly, it prints a traceback to that error along with some details about why that error occurred.|||Let's look at how Python treats these errors:||||||Illegal operations can raise exceptions. There are plenty of built-in exceptions in Python that are raised when corresponding errors occur. We can view all the built-in exceptions using the built-in local() function as follows:|||locals()['__builtins__'] will return a module of built-in exceptions, functions, and attributes. dir allows us to list these attributes as strings.|||Some of the common built-in exceptions in Python programming along with the error that cause them are listed below:|||If required, we can also define our own exceptions in Python. To learn more about them, visit Python User-defined Exceptions.|||We can handle these built-in and user-defined exceptions in Python using try, except and finally statements. To learn more about them, visit Python try, except and finally statements.",Introduction$$$Python Syntax Errors$$$Python Exceptions$$$Python Built-in Exceptions,Syntax errors$$$Logical errors (Exceptions),"Exception|||Cause of Error$$$AssertionError|||Raised when an assert statement fails.$$$AttributeError|||Raised when attribute assignment or reference fails.$$$EOFError|||Raised when the input() function hits end-of-file condition.$$$FloatingPointError|||Raised when a floating point operation fails.$$$GeneratorExit|||Raise when a generator's close() method is called.$$$ImportError|||Raised when the imported module is not found.$$$IndexError|||Raised when the index of a sequence is out of range.$$$KeyError|||Raised when a key is not found in a dictionary.$$$KeyboardInterrupt|||Raised when the user hits the interrupt key (Ctrl+C or Delete).$$$MemoryError|||Raised when an operation runs out of memory.$$$NameError|||Raised when a variable is not found in local or global scope.$$$NotImplementedError|||Raised by abstract methods.$$$OSError|||Raised when system operation causes system related error.$$$OverflowError|||Raised when the result of an arithmetic operation is too large to be represented.$$$ReferenceError|||Raised when a weak reference proxy is used to access a garbage collected referent.$$$RuntimeError|||Raised when an error does not fall under any other category.$$$StopIteration|||Raised by next() function to indicate that there is no further item to be returned by iterator.$$$SyntaxError|||Raised by parser when syntax error is encountered.$$$IndentationError|||Raised when there is incorrect indentation.$$$TabError|||Raised when indentation consists of inconsistent tabs and spaces.$$$SystemError|||Raised when interpreter detects internal error.$$$SystemExit|||Raised by sys.exit() function.$$$TypeError|||Raised when a function or operation is applied to an object of incorrect type.$$$UnboundLocalError|||Raised when a reference is made to a local variable in a function or method, but no value has been bound to that variable.$$$UnicodeError|||Raised when a Unicode-related encoding or decoding error occurs.$$$UnicodeEncodeError|||Raised when a Unicode-related error occurs during encoding.$$$UnicodeDecodeError|||Raised when a Unicode-related error occurs during decoding.$$$UnicodeTranslateError|||Raised when a Unicode-related error occurs during translating.$$$ValueError|||Raised when a function gets an argument of correct type but improper value.$$$ZeroDivisionError|||Raised when the second operand of division or modulo operation is zero."
https://www.programiz.com/python-programming/exception-handling,"Python Exception Handling Using try, except and finally statement",Video: Python Exception Handling (try..except..finally)$$$Exceptions in Python$$$Catching Exceptions in Python$$$Catching Specific Exceptions in Python$$$Raising Exceptions in Python$$$Python try with else clause$$$Python try...finally$$$Table of Contents,,"In this tutorial, you'll learn how to handle exceptions in your Python program using try, except and finally statements with the help of examples.|||Python has many built-in exceptions that are raised when your program encounters an error (something in the program goes wrong).|||When these exceptions occur, the Python interpreter stops the current process and passes it to the calling process until it is handled. If not handled, the program will crash.|||For example, let us consider a program where we have a function A that calls function B, which in turn calls function C. If an exception occurs in function C but is not handled in C, the exception passes to B and then to A.|||If never handled, an error message is displayed and our program comes to a sudden unexpected halt.|||In Python, exceptions can be handled using a try statement.|||The critical operation which can raise an exception is placed inside the try clause. The code that handles the exceptions is written in the except clause.|||We can thus choose what operations to perform once we have caught the exception. Here is a simple example.|||Output|||In this program, we loop through the values of the randomList list. As previously mentioned, the portion that can cause an exception is placed inside the try block.|||If no exception occurs, the except block is skipped and normal flow continues(for last value). But if any exception occurs, it is caught by the except block (first and second values).|||Here, we print the name of the exception using the exc_info() function inside sys module. We can see that a causes ValueError and 0 causes ZeroDivisionError.||||||Since every exception in Python inherits from the base Exception class, we can also perform the above task in the following way:|||This program has the same output as the above program.|||In the above example, we did not mention any specific exception in the except clause.|||This is not a good programming practice as it will catch all exceptions and handle every case in the same way. We can specify which exceptions an except clause should catch.|||A try clause can have any number of except clauses to handle different exceptions, however, only one will be executed in case an exception occurs.|||We can use a tuple of values to specify multiple exceptions in an except clause. Here is an example pseudo code.|||In Python programming, exceptions are raised when errors occur at runtime. We can also manually raise exceptions using the raise keyword.|||We can optionally pass values to the exception to clarify why that exception was raised.|||In some situations, you might want to run a certain block of code if the code block inside try ran without any errors. For these cases, you can use the optional else keyword with the try statement.|||Note: Exceptions in the else clause are not handled by the preceding except clauses.|||Let's look at an example:|||Output|||If we pass an odd number:|||If we pass an even number, the reciprocal is computed and displayed.|||However, if we pass 0, we get ZeroDivisionError as the code block inside else is not handled by preceding except.|||The try statement in Python can have an optional finally clause. This clause is executed no matter what, and is generally used to release external resources.|||For example, we may be connected to a remote data center through the network or working with a file or a Graphical User Interface (GUI).|||In all these circumstances, we must clean up the resource before the program comes to a halt whether it successfully ran or not. These actions (closing a file, GUI or disconnecting from network) are performed in the finally clause to guarantee the execution.|||Here is an example of file operations to illustrate this.|||This type of construct makes sure that the file is closed even if an exception occurs during the program execution.",Exceptions in Python$$$Catching Exceptions in Python$$$Catching Specific Exceptions in Python$$$Raising Exceptions in Python$$$Python try with else clause$$$Python try...finally,,
https://www.programiz.com/python-programming/user-defined-exception,How to Define Custom Exceptions in Python? (With Examples),Creating Custom Exceptions$$$Example: User-Defined Exception in Python$$$Customizing Exception Classes$$$Table of Contents,,"In this tutorial, you will learn how to define custom exceptions depending upon your requirements with the help of examples.|||Python has numerous built-in exceptions that force your program to output an error when something in the program goes wrong.|||However, sometimes you may need to create your own custom exceptions that serve your purpose.|||In Python, users can define custom exceptions by creating a new class. This exception class has to be derived, either directly or indirectly, from the built-in Exception class. Most of the built-in exceptions are also derived from this class.|||Here, we have created a user-defined exception called CustomError which inherits from the Exception class. This new exception, like other exceptions, can be raised using the raise statement with an optional error message.|||When we are developing a large Python program, it is a good practice to place all the user-defined exceptions that our program raises in a separate file. Many standard modules do this. They define their exceptions separately as exceptions.py or errors.py (generally but not always).|||User-defined exception class can implement everything a normal class can do, but we generally make them simple and concise. Most implementations declare a custom base class and derive others exception classes from this base class. This concept is made clearer in the following example.|||In this example, we will illustrate how user-defined exceptions can be used in a program to raise and catch errors.|||This program will ask the user to enter a number until they guess a stored number correctly. To help them figure it out, a hint is provided whether their guess is greater than or less than the stored number.|||Here is a sample run of this program.|||We have defined a base class called Error.|||The other two exceptions (ValueTooSmallError and ValueTooLargeError) that are actually raised by our program are derived from this class. This is the standard way to define user-defined exceptions in Python programming, but you are not limited to this way only.|||We can further customize this class to accept other arguments as per our needs.|||To learn about customizing the Exception classes, you need to have the basic knowledge of Object-Oriented programming.|||Visit Python Object Oriented Programming to start learning about Object-Oriented programming in Python.||||||Let's look at one example:|||Output|||Here, we have overridden the constructor of the Exception class to accept our own custom arguments salary and message. Then, the constructor of the parent Exception class is called manually with the self.message argument using super().|||The custom self.salary attribute is defined to be used later.|||The inherited __str__ method of the Exception class is then used to display the corresponding message when SalaryNotInRangeError is raised.|||We can also customize the __str__ method itself by overriding it.|||Output|||To learn more about how you can handle exceptions in Python, visit Python Exception Handling.",Introduction$$$Creating Custom Exceptions$$$Customizing Exception Classes,,
https://www.programiz.com/python-programming/object-oriented-programming,Python Object Oriented Programming,Video: Object-oriented Programming in Python$$$Object Oriented Programming$$$Class$$$Object$$$Methods$$$Inheritance$$$Encapsulation$$$Polymorphism$$$Key Points to Remember:$$$Example 1: Creating Class and Object in Python$$$Example 2 : Creating Methods in Python$$$Example 3: Use of Inheritance in Python$$$Example 4: Data Encapsulation in Python$$$Example 5: Using Polymorphism in Python$$$Table of Contents,,"In this tutorial, you’ll learn about Object-Oriented Programming (OOP) in Python and its fundamental concept with the help of examples.|||Python is a multi-paradigm programming language. It supports different programming approaches.|||One of the popular approaches to solve a programming problem is by creating objects. This is known as Object-Oriented Programming (OOP).|||An object has two characteristics:|||Let's take an example:|||A parrot is an object, as it has the following properties:|||The concept of OOP in Python focuses on creating reusable code. This concept is also known as DRY (Don't Repeat Yourself).|||In Python, the concept of OOP follows some basic principles:|||A class is a blueprint for the object.|||We can think of class as a sketch of a parrot with labels. It contains all the details about the name, colors, size etc. Based on these descriptions, we can study about the parrot. Here, a parrot is an object.|||The example for class of parrot can be :|||Here, we use the class keyword to define an empty class Parrot. From class, we construct instances. An instance is a specific object created from a particular class.|||An object (instance) is an instantiation of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.|||The example for object of parrot class can be:|||Here, obj is an object of class Parrot.|||Suppose we have details of parrots. Now, we are going to show how to build the class and objects of parrots.|||Output|||In the above program, we created a class with the name Parrot. Then, we define attributes. The attributes are a characteristic of an object.|||These attributes are defined inside the __init__ method of the class. It is the initializer method that is first run as soon as the object is created.|||Then, we create instances of the Parrot class. Here, blu and woo are references (value) to our new objects.|||We can access the class attribute using __class__.species. Class attributes are the same for all instances of a class. Similarly, we access the instance attributes using blu.name and blu.age. However, instance attributes are different for every instance of a class.||||||To learn more about classes and objects, go to Python Classes and Objects|||Methods are functions defined inside the body of a class. They are used to define the behaviors of an object.|||Output|||In the above program, we define two methods i.e sing() and dance(). These are called instance methods because they are called on an instance object i.e blu.|||Inheritance is a way of creating a new class for using details of an existing class without modifying it. The newly formed class is a derived class (or child class). Similarly, the existing class is a base class (or parent class).|||Output|||In the above program, we created two classes i.e. Bird (parent class) and Penguin (child class). The child class inherits the functions of parent class. We can see this from the swim() method.|||Again, the child class modified the behavior of the parent class. We can see this from the whoisThis() method. Furthermore, we extend the functions of the parent class, by creating a new run() method.|||Additionally, we use the super() function inside the __init__() method. This allows us to run the __init__() method of the parent class inside the child class.|||Using OOP in Python, we can restrict access to methods and variables. This prevents data from direct modification which is called encapsulation. In Python, we denote private attributes using underscore as the prefix i.e single _ or double __.|||Output|||In the above program, we defined a Computer class.|||We used __init__() method to store the maximum selling price of Computer. Here, notice the code|||Here, we have tried to modify the value of __maxprice outside of the class. However, since __maxprice is a private variable, this modification is not seen on the output.|||As shown, to change the value, we have to use a setter function i.e setMaxPrice() which takes price as a parameter.|||Polymorphism is an ability (in OOP) to use a common interface for multiple forms (data types).|||Suppose, we need to color a shape, there are multiple shape options (rectangle, square, circle). However we could use the same method to color any shape. This concept is called Polymorphism.|||Output|||In the above program, we defined two classes Parrot and Penguin. Each of them have a common fly() method. However, their functions are different.|||To use polymorphism, we created a common interface i.e flying_test() function that takes any object and calls the object's fly() method. Thus, when we passed the blu and peggy objects in the flying_test() function, it ran effectively.","attributes$$$behavior$$$name, age, color as attributes$$$singing, dancing as behavior$$$Object-Oriented Programming makes the program easy to understand as well as efficient.$$$Since the class is sharable, the code can be reused.$$$Data is safe and secure with data abstraction.$$$Polymorphism allows the same interface for different objects, so programmers can write efficient code.$$$Introduction to OOP in Python$$$Class$$$Object$$$Methods$$$Inheritance$$$Encapsulation$$$Polymorphism$$$Key Points to Remember",,
https://www.programiz.com/python-programming/class,Python Classes and Objects [With Examples],Video: Python Classes and Objects$$$Python Objects and Classes$$$Defining a Class in Python$$$Creating an Object in Python$$$Constructors in Python$$$Deleting Attributes and Objects$$$Table of Contents,,"In this tutorial, you will learn about the core functionality of Python objects and classes. You'll learn what a class is, how to create it and use it in your program.|||Python is an object-oriented programming language. Unlike procedure-oriented programming, where the main emphasis is on functions, object-oriented programming stresses on objects.|||An object is simply a collection of data (variables) and methods (functions) that act on those data. Similarly, a class is a blueprint for that object.|||We can think of a class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object.|||As many houses can be made from a house's blueprint, we can create many objects from a class. An object is also called an instance of a class and the process of creating this object is called instantiation.|||Like function definitions begin with the def keyword in Python, class definitions begin with a class keyword.|||The first string inside the class is called docstring and has a brief description of the class. Although not mandatory, this is highly recommended.|||Here is a simple class definition.|||A class creates a new local namespace where all its attributes are defined. Attributes may be data or functions.|||There are also special attributes in it that begins with double underscores __. For example, __doc__ gives us the docstring of that class.|||As soon as we define a class, a new class object is created with the same name. This class object allows us to access the different attributes as well as to instantiate new objects of that class.|||Output|||We saw that the class object could be used to access different attributes.|||It can also be used to create new object instances (instantiation) of that class. The procedure to create an object is similar to a function call.|||This will create a new object instance named harry. We can access the attributes of objects using the object name prefix.|||Attributes may be data or method. Methods of an object are corresponding functions of that class.|||This means to say, since Person.greet is a function object (attribute of class), Person.greet will be a method object.|||Output||||||You may have noticed the self parameter in function definition inside the class but we called the method simply as harry.greet() without any arguments. It still worked.|||This is because, whenever an object calls its method, the object itself is passed as the first argument. So, harry.greet() translates into Person.greet(harry).|||In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method's object before the first argument.|||For these reasons, the first argument of the function in class must be the object itself. This is conventionally called self. It can be named otherwise but we highly recommend to follow the convention.|||Now you must be familiar with class object, instance object, function object, method object and their differences.|||Class functions that begin with double underscore __ are called special functions as they have special meaning.|||Of one particular interest is the __init__() function. This special function gets called whenever a new object of that class is instantiated.|||This type of function is also called constructors in Object Oriented Programming (OOP). We normally use it to initialize all the variables.|||Output|||In the above example, we defined a new class to represent complex numbers. It has two functions, __init__() to initialize the variables (defaults to zero) and get_data() to display the number properly.|||An interesting thing to note in the above step is that attributes of an object can be created on the fly. We created a new attribute attr for object num2 and read it as well. But this does not create that attribute for object num1.|||Any attribute of an object can be deleted anytime, using the del statement. Try the following on the Python shell to see the output.|||We can even delete the object itself, using the del statement.|||Actually, it is more complicated than that. When we do c1 = ComplexNumber(1,3), a new instance object is created in memory and the name c1 binds with it.|||On the command del c1, this binding is removed and the name c1 is deleted from the corresponding namespace. The object however continues to exist in memory and if no other name is bound to it, it is later automatically destroyed.|||This automatic destruction of unreferenced objects in Python is also called garbage collection.",Python Objects and Classes$$$Defining a Class in Python$$$Creating an Object in Python$$$Constructors in Python$$$Deleting Attributes and Objects,,
https://www.programiz.com/python-programming/inheritance,Python Inheritance (With Examples),Video: Python Inheritance$$$Inheritance in Python$$$Method Overriding in Python$$$Python Inheritance Syntax$$$Example of Inheritance in Python$$$Table of Contents,,"Inheritance enables us to define a class that takes all the functionality from a parent class and allows us to add more. In this tutorial, you will learn to use inheritance in Python.|||Inheritance is a powerful feature in object oriented programming.|||It refers to defining a new class with little or no modification to an existing class. The new class is called derived (or child) class and the one from which it inherits is called the base (or parent) class.|||Derived class inherits features from the base class where new features can be added to it. This results in re-usability of code.|||To demonstrate the use of inheritance, let us take an example.|||A polygon is a closed figure with 3 or more sides. Say, we have a class called Polygon defined as follows.|||This class has data attributes to store the number of sides n and magnitude of each side as a list called sides.||||||The inputSides() method takes in the magnitude of each side and dispSides() displays these side lengths.|||A triangle is a polygon with 3 sides. So, we can create a class called Triangle which inherits from Polygon. This makes all the attributes of Polygon class available to the Triangle class.|||We don't need to define them again (code reusability). Triangle can be defined as follows.|||However, class Triangle has a new method findArea() to find and print the area of the triangle. Here is a sample run.|||We can see that even though we did not define methods like inputSides() or dispSides() for class Triangle separately, we were able to use them.|||If an attribute is not found in the class itself, the search continues to the base class. This repeats recursively, if the base class is itself derived from other classes.|||In the above example, notice that __init__() method was defined in both classes, Triangle as well Polygon. When this happens, the method in the derived class overrides that in the base class. This is to say, __init__() in Triangle gets preference over the __init__ in Polygon.|||Generally when overriding a base method, we tend to extend the definition rather than simply replace it. The same is being done by calling the method in base class from the one in derived class (calling Polygon.__init__() from __init__() in Triangle).|||A better option would be to use the built-in function super(). So, super().__init__(3) is equivalent to Polygon.__init__(self,3) and is preferred. To learn more about the super() function in Python, visit Python super() function.|||Two built-in functions isinstance() and issubclass() are used to check inheritances.|||The function isinstance() returns True if the object is an instance of the class or other classes derived from it. Each and every class in Python inherits from the base class object.|||Similarly, issubclass() is used to check for class inheritance.",Inheritance in PythonPython Inheritance SyntaxExample of Inheritance in Python$$$Method Overriding in Python$$$Python Inheritance Syntax$$$Example of Inheritance in Python,,
https://www.programiz.com/python-programming/multiple-inheritance,Python Multiple Inheritance: What is it and How to use it?,Python Multiple Inheritance$$$Python Multilevel Inheritance$$$Method Resolution Order in Python$$$Example$$$Table of Contents,,"In this tutorial, you'll learn about multiple inheritance in Python and how to use it in your program. You'll also learn about multi-level inheritance and the method resolution order.|||A class can be derived from more than one base class in Python, similar to C++. This is called multiple inheritance.|||In multiple inheritance, the features of all the base classes are inherited into the derived class. The syntax for multiple inheritance is similar to single inheritance.|||Here, the MultiDerived class is derived from Base1 and Base2 classes.|||The MultiDerived class inherits from both Base1 and Base2 classes.|||We can also inherit from a derived class. This is called multilevel inheritance. It can be of any depth in Python.|||In multilevel inheritance, features of the base class and the derived class are inherited into the new derived class.|||An example with corresponding visualization is given below.|||Here, the Derived1 class is derived from the Base class, and the Derived2 class is derived from the Derived1 class.||||||Every class in Python is derived from the object class. It is the most base type in Python.|||So technically, all other classes, either built-in or user-defined, are derived classes and all objects are instances of the object class.|||In the multiple inheritance scenario, any specified attribute is searched first in the current class. If not found, the search continues into parent classes in depth-first, left-right fashion without searching the same class twice.|||So, in the above example of MultiDerived class the search order is [MultiDerived, Base1, Base2, object]. This order is also called linearization of MultiDerived class and the set of rules used to find this order is called Method Resolution Order (MRO).|||MRO must prevent local precedence ordering and also provide monotonicity. It ensures that a class always appears before its parents. In case of multiple parents, the order is the same as tuples of base classes.|||MRO of a class can be viewed as the __mro__ attribute or the mro() method. The former returns a tuple while the latter returns a list.|||Here is a little more complex multiple inheritance example and its visualization along with the MRO.|||Output|||To know the actual algorithm on how MRO is calculated, visit Discussion on MRO.",Python Multiple Inheritance$$$Python Multilevel Inheritance$$$Method Resolution Order in Python,,
https://www.programiz.com/python-programming/operator-overloading,Python Operator Overloading,Python Operator Overloading$$$Python Special Functions$$$Overloading the + Operator$$$Overloading Comparison Operators$$$Table of Contents,,"You can change the meaning of an operator in Python depending upon the operands used. In this tutorial, you will learn how to use operator overloading in Python Object Oriented Programming.|||Python operators work for built-in classes. But the same operator behaves differently with different types. For example, the + operator will perform arithmetic addition on two numbers, merge two lists, or concatenate two strings.|||This feature in Python that allows the same operator to have different meaning according to the context is called operator overloading.|||So what happens when we use them with objects of a user-defined class? Let us consider the following class, which tries to simulate a point in 2-D coordinate system.|||Output|||Here, we can see that a TypeError was raised, since Python didn't know how to add two Point objects together.|||However, we can achieve this task in Python through operator overloading. But first, let's get a notion about special functions.|||Class functions that begin with double underscore __ are called special functions in Python.|||These functions are not the typical functions that we define for a class. The __init__() function we defined above is one of them. It gets called every time we create a new object of that class.|||There are numerous other special functions in Python. Visit Python Special Functions to learn more about them.|||Using special functions, we can make our class compatible with built-in functions.|||Suppose we want the print() function to print the coordinates of the Point object instead of what we got. We can define a __str__() method in our class that controls how the object gets printed. Let's look at how we can achieve this:||||||Now let's try the print() function again.|||Output|||That's better. Turns out, that this same method is invoked when we use the built-in function str() or format().|||So, when you use str(p1) or format(p1), Python internally calls the p1.__str__() method. Hence the name, special functions.|||Now let's go back to operator overloading.|||To overload the + operator, we will need to implement __add__() function in the class. With great power comes great responsibility. We can do whatever we like, inside this function. But it is more sensible to return a Point object of the coordinate sum.|||Now let's try the addition operation again:|||Output|||What actually happens is that, when you use p1 + p2, Python calls p1.__add__(p2) which in turn is Point.__add__(p1,p2). After this, the addition operation is carried out the way we specified.|||Similarly, we can overload other operators as well. The special function that we need to implement is tabulated below.|||Python does not limit operator overloading to arithmetic operators only. We can overload comparison operators as well.|||Suppose we wanted to implement the less than symbol < symbol in our Point class.|||Let us compare the magnitude of these points from the origin and return the result for this purpose. It can be implemented as follows.|||Output|||Similarly, the special functions that we need to implement, to overload other comparison operators are tabulated below.",Python Operator Overloading$$$Python Special Functions$$$Overloading the + Operator$$$Overloading Comparison Operators,,Operator|||Expression|||Internally$$$Addition|||p1 + p2|||p1.__add__(p2)$$$Subtraction|||p1 - p2|||p1.__sub__(p2)$$$Multiplication|||p1 * p2|||p1.__mul__(p2)$$$Power|||p1 ** p2|||p1.__pow__(p2)$$$Division|||p1 / p2|||p1.__truediv__(p2)$$$Floor Division|||p1 // p2|||p1.__floordiv__(p2)$$$Remainder (modulo)|||p1 % p2|||p1.__mod__(p2)$$$Bitwise Left Shift|||p1 << p2|||p1.__lshift__(p2)$$$Bitwise Right Shift|||p1 >> p2|||p1.__rshift__(p2)$$$Bitwise AND|||p1 & p2|||p1.__and__(p2)$$$Bitwise OR|||p1 | p2|||p1.__or__(p2)$$$Bitwise XOR|||p1 ^ p2|||p1.__xor__(p2)$$$Bitwise NOT|||~p1|||p1.__invert__()$$$Operator|||Expression|||Internally$$$Less than|||p1 < p2|||p1.__lt__(p2)$$$Less than or equal to|||p1 <= p2|||p1.__le__(p2)$$$Equal to|||p1 == p2|||p1.__eq__(p2)$$$Not equal to|||p1 != p2|||p1.__ne__(p2)$$$Greater than|||p1 > p2|||p1.__gt__(p2)$$$Greater than or equal to|||p1 >= p2|||p1.__ge__(p2)
https://www.programiz.com/python-programming/iterator,Python Iterators (__iter__ and __next__): How to Use it and Why?,Video: Python Iterators$$$Iterators in Python$$$Iterating Through an Iterator$$$Working of for loop for Iterators$$$Building Custom Iterators$$$Python Infinite Iterators$$$Table of Contents,,"Iterators are objects that can be iterated upon. In this tutorial, you will learn how iterator works and how you can build your own iterator using __iter__ and __next__ methods.|||Iterators are everywhere in Python. They are elegantly implemented within for loops, comprehensions, generators etc. but are hidden in plain sight.|||Iterator in Python is simply an object that can be iterated upon. An object which will return data, one element at a time.|||Technically speaking, a Python iterator object must implement two special methods, __iter__() and __next__(), collectively called the iterator protocol.|||An object is called iterable if we can get an iterator from it. Most built-in containers in Python like: list, tuple, string etc. are iterables.|||The iter() function (which in turn calls the __iter__() method) returns an iterator from them.|||We use the next() function to manually iterate through all the items of an iterator. When we reach the end and there is no more data to be returned, it will raise the StopIteration Exception. Following is an example.|||Output||||||A more elegant way of automatically iterating is by using the for loop. Using this, we can iterate over any object that can return an iterator, for example list, string, file etc.|||As we see in the above example, the for loop was able to iterate automatically through the list.|||In fact the for loop can iterate over any iterable. Let's take a closer look at how the for loop is actually implemented in Python.|||Is actually implemented as.|||So internally, the for loop creates an iterator object, iter_obj by calling iter() on the iterable.|||Ironically, this for loop is actually an infinite while loop.|||Inside the loop, it calls next() to get the next element and executes the body of the for loop with this value. After all the items exhaust, StopIteration is raised which is internally caught and the loop ends. Note that any other kind of exception will pass through.|||Building an iterator from scratch is easy in Python. We just have to implement the __iter__() and the __next__() methods.|||The __iter__() method returns the iterator object itself. If required, some initialization can be performed.|||The __next__() method must return the next item in the sequence. On reaching the end, and in subsequent calls, it must raise StopIteration.|||Here, we show an example that will give us the next power of 2 in each iteration. Power exponent starts from zero up to a user set number.|||If you do not have any idea about object-oriented programming, visit Python Object-Oriented Programming.|||Output|||We can also use a for loop to iterate over our iterator class.|||It is not necessary that the item in an iterator object has to be exhausted. There can be infinite iterators (which never ends). We must be careful when handling such iterators.|||Here is a simple example to demonstrate infinite iterators.|||The built-in function iter() can be called with two arguments where the first argument must be a callable object (function) and second is the sentinel. The iterator calls this function until the returned value is equal to the sentinel.|||We can see that the int() function always returns 0. So passing it as iter(int,1) will return an iterator that calls int() until the returned value equals 1. This never happens and we get an infinite iterator.|||We can also build our own infinite iterators. The following iterator will, theoretically, return all the odd numbers.|||A sample run would be as follows.|||And so on...|||Be careful to include a terminating condition, when iterating over these types of infinite iterators.|||The advantage of using iterators is that they save resources. Like shown above, we could get all the odd numbers without storing the entire number system in memory. We can have infinite items (theoretically) in finite memory.|||There's an easier way to create iterators in Python. To learn more visit: Python generators using yield.",Iterators in Python$$$Iterating Through an Iterator$$$Working of for loop for Iterators$$$Building Custom Iterators$$$Python Infinite Iterators,,
https://www.programiz.com/python-programming/generator,"Python yield, Generators and Generator Expressions",Video: Python Generators$$$Generators in Python$$$Create Generators in Python$$$Differences between Generator function and Normal function$$$Python Generators with a Loop$$$Python Generator Expression$$$Use of Python Generators$$$1. Easy to Implement$$$2. Memory Efficient$$$3. Represent Infinite Stream$$$4. Pipelining Generators$$$Table of Contents,,"In this tutorial, you'll learn how to create iterations easily using Python generators, how it is different from iterators and normal functions, and why you should use it.|||There is a lot of work in building an iterator in Python. We have to implement a class with __iter__() and __next__() method, keep track of internal states, and raise StopIteration when there are no values to be returned.|||This is both lengthy and counterintuitive. Generator comes to the rescue in such situations.|||Python generators are a simple way of creating iterators. All the work we mentioned above are automatically handled by generators in Python.|||Simply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time).|||It is fairly simple to create a generator in Python. It is as easy as defining a normal function, but with a yield statement instead of a return statement.|||If a function contains at least one yield statement (it may contain other yield or return statements), it becomes a generator function. Both yield and return will return some value from a function.|||The difference is that while a return statement terminates a function entirely, yield statement pauses the function saving all its states and later continues from there on successive calls.|||Here is how a generator function differs from a normal function.|||Here is an example to illustrate all of the points stated above. We have a generator function named my_gen() with several yield statements.|||An interactive run in the interpreter is given below. Run these in the Python shell to see the output.|||One interesting thing to note in the above example is that the value of variable n is remembered between each call.|||Unlike normal functions, the local variables are not destroyed when the function yields. Furthermore, the generator object can be iterated only once.|||To restart the process we need to create another generator object using something like a = my_gen().|||One final thing to note is that we can use generators with for loops directly.|||This is because a for loop takes an iterator and iterates over it using next() function. It automatically ends when StopIteration is raised. Check here to know how a for loop is actually implemented in Python.|||When you run the program, the output will be:|||The above example is of less use and we studied it just to get an idea of what was happening in the background.||||||Normally, generator functions are implemented with a loop having a suitable terminating condition.|||Let's take an example of a generator that reverses a string.|||Output|||In this example, we have used the range() function to get the index in reverse order using the for loop.|||Note: This generator function not only works with strings, but also with other kinds of iterables like list, tuple, etc.|||Simple generators can be easily created on the fly using generator expressions. It makes building generators easy.|||Similar to the lambda functions which create anonymous functions, generator expressions create anonymous generator functions.|||The syntax for generator expression is similar to that of a list comprehension in Python. But the square brackets are replaced with round parentheses.|||The major difference between a list comprehension and a generator expression is that a list comprehension produces the entire list while the generator expression produces one item at a time.|||They have lazy execution ( producing items only when asked for ). For this reason, a generator expression is much more memory efficient than an equivalent list comprehension.|||Output|||We can see above that the generator expression did not produce the required result immediately. Instead, it returned a generator object, which produces items only on demand.|||Here is how we can start getting items from the generator:|||When we run the above program, we get the following output:|||Generator expressions can be used as function arguments. When used in such a way, the round parentheses can be dropped.|||There are several reasons that make generators a powerful implementation.|||Generators can be implemented in a clear and concise way as compared to their iterator class counterpart. Following is an example to implement a sequence of power of 2 using an iterator class.|||The above program was lengthy and confusing. Now, let's do the same using a generator function.|||Since generators keep track of details automatically, the implementation was concise and much cleaner.|||A normal function to return a sequence will create the entire sequence in memory before returning the result. This is an overkill, if the number of items in the sequence is very large.|||Generator implementation of such sequences is memory friendly and is preferred since it only produces one item at a time.|||Generators are excellent mediums to represent an infinite stream of data. Infinite streams cannot be stored in memory, and since generators produce only one item at a time, they can represent an infinite stream of data.|||The following generator function can generate all the even numbers (at least in theory).|||Multiple generators can be used to pipeline a series of operations. This is best illustrated using an example.|||Suppose we have a generator that produces the numbers in the Fibonacci series. And we have another generator for squaring numbers.|||If we want to find out the sum of squares of numbers in the Fibonacci series, we can do it in the following way by pipelining the output of generator functions together.|||Output|||This pipelining is efficient and easy to read (and yes, a lot cooler!).","Generator function contains one or more yield statements.$$$When called, it returns an object (iterator) but does not start execution immediately.$$$Methods like __iter__() and __next__() are implemented automatically. So we can iterate through the items using next().$$$Once the function yields, the function is paused and the control is transferred to the caller.$$$Local variables and their states are remembered between successive calls.$$$Finally, when the function terminates, StopIteration is raised automatically on further calls.$$$Generators in Python$$$Create Generators in Python$$$Generator function vs Normal function$$$Python Generators with a Loop$$$Python Generator Expression$$$Use of Python Generators",,
https://www.programiz.com/python-programming/closure,Python Closures: How to use it and Why?,Nonlocal variable in a nested function$$$Defining a Closure Function$$$When do we have closures?$$$When to use closures?$$$Table of Contents,,"In this tutorial, you'll learn about Python closure, how to define a closure, and the reasons you should use it.|||Before getting into what a closure is, we have to first understand what a nested function and nonlocal variable is.|||A function defined inside another function is called a nested function. Nested functions can access variables of the enclosing scope.|||In Python, these non-local variables are read-only by default and we must declare them explicitly as non-local (using nonlocal keyword) in order to modify them.|||Following is an example of a nested function accessing a non-local variable.|||Output|||We can see that the nested printer() function was able to access the non-local msg variable of the enclosing function.|||In the example above, what would happen if the last line of the function print_msg() returned the printer() function instead of calling it? This means the function was defined as follows:|||Output|||That's unusual.||||||The print_msg() function was called with the string ""Hello"" and the returned function was bound to the name another. On calling another(), the message was still remembered although we had already finished executing the print_msg() function.|||This technique by which some data (""Hello in this case) gets attached to the code is called closure in Python.|||This value in the enclosing scope is remembered even when the variable goes out of scope or the function itself is removed from the current namespace.|||Try running the following in the Python shell to see the output.|||Here, the returned function still works even when the original function was deleted.|||As seen from the above example, we have a closure in Python when a nested function references a value in its enclosing scope.|||The criteria that must be met to create closure in Python are summarized in the following points.|||So what are closures good for?|||Closures can avoid the use of global values and provides some form of data hiding. It can also provide an object oriented solution to the problem.|||When there are few methods (one method in most cases) to be implemented in a class, closures can provide an alternate and more elegant solution. But when the number of attributes and methods get larger, it's better to implement a class.|||Here is a simple example where a closure might be more preferable than defining a class and making objects. But the preference is all yours.|||Output|||Python Decorators make an extensive use of closures as well.|||On a concluding note, it is good to point out that the values that get enclosed in the closure function can be found out.|||All function objects have a __closure__ attribute that returns a tuple of cell objects if it is a closure function. Referring to the example above, we know times3 and times5 are closure functions.|||The cell object has the attribute cell_contents which stores the closed value.",We must have a nested function (function inside a function).$$$The nested function must refer to a value defined in the enclosing function.$$$The enclosing function must return the nested function.$$$Nonlocal variable in a nested function$$$Defining a Closure Function$$$When do we have closures?$$$When to use closures?,,
https://www.programiz.com/python-programming/decorator,Python Decorators: How to Use it and Why?,Video: @Decorators in Python$$$Decorators in Python$$$Prerequisites for learning decorators$$$Getting back to Decorators$$$Decorating Functions with Parameters$$$Chaining Decorators in Python$$$Table of Contents,,"A decorator takes in a function, adds some functionality and returns it. In this tutorial, you will learn how you can create a decorator and why you should use it.|||Python has an interesting feature called decorators to add functionality to an existing code.|||This is also called metaprogramming because a part of the program tries to modify another part of the program at compile time.|||In order to understand about decorators, we must first know a few basic things in Python.|||We must be comfortable with the fact that everything in Python (Yes! Even classes), are objects. Names that we define are simply identifiers bound to these objects. Functions are no exceptions, they are objects too (with attributes). Various different names can be bound to the same function object.|||Here is an example.|||Output|||When you run the code, both functions first and second give the same output. Here, the names first and second refer to the same function object.|||Now things start getting weirder.|||Functions can be passed as arguments to another function.|||If you have used functions like map, filter and reduce in Python, then you already know about this.|||Such functions that take other functions as arguments are also called higher order functions. Here is an example of such a function.|||We invoke the function as follows.|||Furthermore, a function can return another function.||||||Output|||Here, is_returned() is a nested function which is defined and returned each time we call is_called().|||Finally, we must know about Closures in Python.|||Functions and methods are called callable as they can be called.|||In fact, any object which implements the special __call__() method is termed callable. So, in the most basic sense, a decorator is a callable that returns a callable.|||Basically, a decorator takes in a function, adds some functionality and returns it.|||When you run the following codes in shell,|||In the example shown above, make_pretty() is a decorator. In the assignment step:|||The function ordinary() got decorated and the returned function was given the name pretty.|||We can see that the decorator function added some new functionality to the original function. This is similar to packing a gift. The decorator acts as a wrapper. The nature of the object that got decorated (actual gift inside) does not alter. But now, it looks pretty (since it got decorated).|||Generally, we decorate a function and reassign it as,|||This is a common construct and for this reason, Python has a syntax to simplify this.|||We can use the @ symbol along with the name of the decorator function and place it above the definition of the function to be decorated. For example,|||is equivalent to|||This is just a syntactic sugar to implement decorators.|||The above decorator was simple and it only worked with functions that did not have any parameters. What if we had functions that took in parameters like:|||This function has two parameters, a and b. We know it will give an error if we pass in b as 0.|||Now let's make a decorator to check for this case that will cause the error.|||This new implementation will return None if the error condition arises.|||In this manner, we can decorate functions that take parameters.|||A keen observer will notice that parameters of the nested inner() function inside the decorator is the same as the parameters of functions it decorates. Taking this into account, now we can make general decorators that work with any number of parameters.|||In Python, this magic is done as function(*args, **kwargs). In this way, args will be the tuple of positional arguments and kwargs will be the dictionary of keyword arguments. An example of such a decorator will be:|||Multiple decorators can be chained in Python.|||This is to say, a function can be decorated multiple times with different (or same) decorators. We simply place the decorators above the desired function.|||Output|||The above syntax of,|||is equivalent to|||The order in which we chain decorators matter. If we had reversed the order as,|||The output would be:",Decorators in Python$$$Prerequisites for learning decorators$$$Getting back to Decorators$$$Decorating Functions with Parameters$$$Chaining Decorators in Python,,
https://www.programiz.com/python-programming/property,Python @property: How to Use it and Why? - Programiz,Class Without Getters and Setters$$$Using Getters and Setters$$$The property Class$$$The @property Decorator$$$Table of Contents,,"In this tutorial, you will learn about Python @property decorator; a pythonic way to use getters and setters in object-oriented programming.|||Python programming provides us with a built-in @property decorator which makes usage of getter and setters much easier in Object-Oriented Programming.|||Before going into details on what @property decorator is, let us first build an intuition on why it would be needed in the first place.|||Let us assume that we decide to make a class that stores the temperature in degrees Celsius. It would also implement a method to convert the temperature into degrees Fahrenheit. One way of doing this is as follows:|||We can make objects out of this class and manipulate the temperature attribute as we wish:|||Output|||The extra decimal places when converting into Fahrenheit is due to the floating point arithmetic error. To learn more, visit Python Floating Point Arithmetic Error.|||Whenever we assign or retrieve any object attribute like temperature as shown above, Python searches it in the object's built-in __dict__ dictionary attribute.|||Therefore, man.temperature internally becomes man.__dict__['temperature'].|||Suppose we want to extend the usability of the Celsius class defined above. We know that the temperature of any object cannot reach below -273.15 degrees Celsius (Absolute Zero in Thermodynamics)|||Let's update our code to implement this value constraint.|||An obvious solution to the above restriction will be to hide the attribute temperature (make it private) and define new getter and setter methods to manipulate it. This can be done as follows:|||As we can see, the above method introduces two new get_temperature() and set_temperature() methods.|||Furthermore, temperature was replaced with _temperature. An underscore _ at the beginning is used to denote private variables in Python.|||Now, let's use this implementation:||||||Output|||This update successfully implemented the new restriction. We are no longer allowed to set the temperature below -273.15 degrees Celsius.|||Note: The private variables don't actually exist in Python. There are simply norms to be followed. The language itself doesn't apply any restrictions.|||However, the bigger problem with the above update is that all the programs that implemented our previous class have to modify their code from obj.temperature to obj.get_temperature() and all expressions like obj.temperature = val to obj.set_temperature(val).|||This refactoring can cause problems while dealing with hundreds of thousands of lines of codes.|||All in all, our new update was not backwards compatible. This is where @property comes to rescue.|||A pythonic way to deal with the above problem is to use the property class. Here is how we can update our code:|||We added a print() function inside get_temperature() and set_temperature() to clearly observe that they are being executed.|||The last line of the code makes a property object temperature. Simply put, property attaches some code (get_temperature and set_temperature) to the member attribute accesses (temperature).|||Let's use this update code:|||Output|||As we can see, any code that retrieves the value of temperature will automatically call get_temperature() instead of a dictionary (__dict__) look-up. Similarly, any code that assigns a value to temperature will automatically call set_temperature().|||We can even see above that set_temperature() was called even when we created an object.|||Can you guess why?|||The reason is that when an object is created, the __init__() method gets called. This method has the line self.temperature = temperature. This expression automatically calls set_temperature().|||Similarly, any access like c.temperature automatically calls get_temperature(). This is what property does. Here are a few more examples.|||By using property, we can see that no modification is required in the implementation of the value constraint. Thus, our implementation is backward compatible.|||Note: The actual temperature value is stored in the private _temperature variable. The temperature attribute is a property object which provides an interface to this private variable.|||In Python, property() is a built-in function that creates and returns a property object. The syntax of this function is:|||where,|||As seen from the implementation, these function arguments are optional. So, a property object can simply be created as follows.|||A property object has three methods, getter(), setter(), and deleter() to specify fget, fset and fdel at a later point. This means, the line:|||can be broken down as:|||These two pieces of codes are equivalent.|||Programmers familiar with Python Decorators can recognize that the above construct can be implemented as decorators.|||We can even not define the names get_temperature and set_temperature as they are unnecessary and pollute the class namespace.|||For this, we reuse the temperature name while defining our getter and setter functions. Let's look at how to implement this as a decorator:|||Output|||The above implementation is simple and efficient. It is the recommended way to use property.",fget is function to get value of the attribute$$$fset is function to set value of the attribute$$$fdel is function to delete the attribute$$$doc is a string (like a comment)$$$Introduction$$$Class Without Getters and Setters$$$Using Getters and Setters$$$The property Class$$$The @property Decorator,,
https://www.programiz.com/python-programming/regex,Python RegEx (With Examples),"Specify Pattern Using RegEx$$$Python RegEx$$$re.findall()$$$re.split()$$$re.sub()$$$re.subn()$$$re.search()$$$Match object$$$MetaCharacters$$$Example 1: re.findall()$$$Example 2: re.split()$$$Example 3: re.sub()$$$Example 4: re.subn()$$$Example 5: re.search()$$$match.group()$$$Example 6: Match object$$$match.start(), match.end() and match.span()$$$match.re and match.string$$$Using r prefix before RegEx$$$Example 7: Raw string using r prefix$$$Table of Contents",,"In this tutorial, you will learn about regular expressions (RegEx), and use Python's re module to work with RegEx (with the help of examples).|||A Regular Expression (RegEx) is a sequence of characters that defines a search pattern. For example,|||The above code defines a RegEx pattern. The pattern is: any five letter string starting with a and ending with s.|||A pattern defined using RegEx can be used to match against a string.|||Python has a module named re to work with RegEx. Here's an example:|||Here, we used re.match() function to search pattern within the test_string. The method returns a match object if the search is successful. If not, it returns None.|||There are other several functions defined in the re module to work with RegEx. Before we explore that, let's learn about regular expressions themselves.|||If you already know the basics of RegEx, jump to Python RegEx.|||To specify regular expressions, metacharacters are used. In the above example, ^ and $ are metacharacters.|||Metacharacters are characters that are interpreted in a special way by a RegEx engine. Here's a list of metacharacters:|||[] . ^ $ * + ? {} () \ ||||[] - Square brackets|||Square brackets specifies a set of characters you wish to match.|||Here, [abc] will match if the string you are trying to match contains any of the a, b or c.|||You can also specify a range of characters using - inside square brackets.|||You can complement (invert) the character set by using caret ^ symbol at the start of a square-bracket.|||. - Period|||A period matches any single character (except newline '\n').|||^ - Caret|||The caret symbol ^ is used to check if a string starts with a certain character.|||$ - Dollar|||The dollar symbol $ is used to check if a string ends with a certain character.|||* - Star|||The star symbol * matches zero or more occurrences of the pattern left to it.|||+ - Plus|||The plus symbol + matches one or more occurrences of the pattern left to it.|||? - Question Mark|||The question mark symbol ? matches zero or one occurrence of the pattern left to it.|||{} - Braces|||Consider this code: {n,m}. This means at least n, and at most m repetitions of the pattern left to it.|||Let's try one more example. This RegEx [0-9]{2, 4} matches at least 2 digits but not more than 4 digits|||| - Alternation|||Vertical bar | is used for alternation (or operator).|||Here, a|b match any string that contains either a or b|||() - Group|||Parentheses () is used to group sub-patterns. For example, (a|b|c)xz match any string that matches either a or b or c followed by xz|||\ - Backslash|||Backlash \ is used to escape various characters including all metacharacters. For example,|||\$a match if a string contains $ followed by a. Here, $ is not interpreted by a RegEx engine in a special way.|||If you are unsure if a character has special meaning or not, you can put \ in front of it. This makes sure the character is not treated in a special way.|||Special Sequences|||Special sequences make commonly used patterns easier to write. Here's a list of special sequences:||||||\A - Matches if the specified characters are at the start of a string.|||\b - Matches if the specified characters are at the beginning or end of a word.|||\B - Opposite of \b. Matches if the specified characters are not at the beginning or end of a word.|||\d - Matches any decimal digit. Equivalent to [0-9]|||\D - Matches any non-decimal digit. Equivalent to [^0-9]|||\s - Matches where a string contains any whitespace character. Equivalent to [ \t\n\r\f\v].|||\S - Matches where a string contains any non-whitespace character. Equivalent to [^ \t\n\r\f\v].|||\w - Matches any alphanumeric character (digits and alphabets). Equivalent to [a-zA-Z0-9_]. By the way, underscore _ is also considered an alphanumeric character.|||\W - Matches any non-alphanumeric character. Equivalent to [^a-zA-Z0-9_]|||\Z - Matches if the specified characters are at the end of a string.|||Tip: To build and test regular expressions, you can use RegEx tester tools such as regex101. This tool not only helps you in creating regular expressions, but it also helps you learn it.|||Now you understand the basics of RegEx, let's discuss how to use RegEx in your Python code.|||Python has a module named re to work with regular expressions. To use it, we need to import the module.|||The module defines several functions and constants to work with RegEx.|||The re.findall() method returns a list of strings containing all matches.|||If the pattern is not found, re.findall() returns an empty list.|||The re.split method splits the string where there is a match and returns a list of strings where the splits have occurred.|||If the pattern is not found, re.split() returns a list containing the original string.|||You can pass maxsplit argument to the re.split() method. It's the maximum number of splits that will occur.|||By the way, the default value of maxsplit is 0; meaning all possible splits.|||The syntax of re.sub() is:|||The method returns a string where matched occurrences are replaced with the content of replace variable.|||If the pattern is not found, re.sub() returns the original string.|||You can pass count as a fourth parameter to the re.sub() method. If omited, it results to 0. This will replace all occurrences.|||The re.subn() is similar to re.sub() except it returns a tuple of 2 items containing the new string and the number of substitutions made.|||The re.search() method takes two arguments: a pattern and a string. The method looks for the first location where the RegEx pattern produces a match with the string.|||If the search is successful, re.search() returns a match object; if not, it returns None.|||Here, match contains a match object.|||You can get methods and attributes of a match object using dir() function.|||Some of the commonly used methods and attributes of match objects are:|||The group() method returns the part of the string where there is a match.|||Here, match variable contains a match object.|||Our pattern (\d{3}) (\d{2}) has two subgroups (\d{3}) and (\d{2}). You can get the part of the string of these parenthesized subgroups. Here's how:|||The start() function returns the index of the start of the matched substring. Similarly, end() returns the end index of the matched substring.|||The span() function returns a tuple containing start and end index of the matched part.|||The re attribute of a matched object returns a regular expression object. Similarly, string attribute returns the passed string.|||We have covered all commonly used methods defined in the re module. If you want to learn more, visit Python 3 re module.|||When r or R prefix is used before a regular expression, it means raw string. For example, '\n' is a new line whereas r'\n' means two characters: a backslash \ followed by n.|||Backlash \ is used to escape various characters including all metacharacters. However, using r prefix makes \ treat as a normal character.",[a-e] is the same as [abcde].$$$[1-4] is the same as [1234].$$$[0-39] is the same as [01239].$$$[^abc] means any character except a or b or c.$$$[^0-9] means any non-digit character.$$$RegEx Introduction$$$Create patterns using metacharacters$$$Python RegExre.findall()re.split()re.sub()re.search()Match objectr Prefix before RegEx$$$re.findall()$$$re.split()$$$re.sub()$$$re.search()$$$Match object$$$r Prefix before RegEx,,"Expression|||String|||Matched?$$$^a...s$|||abs|||No match$$$alias|||Match$$$abyss|||Match$$$Alias|||No match$$$An abacus|||No match$$$Expression|||String|||Matched?$$$[abc]|||a|||1 match$$$ac|||2 matches$$$Hey Jude|||No match$$$abc de ca|||5 matches$$$Expression|||String|||Matched?$$$..|||a|||No match$$$ac|||1 match$$$acd|||1 match$$$acde|||2 matches (contains 4 characters)$$$Expression|||String|||Matched?$$$^a|||a|||1 match$$$abc|||1 match$$$bac|||No match$$$^ab|||abc|||1 match$$$acb|||No match (starts with a but not followed by b)$$$Expression|||String|||Matched?$$$a$|||a|||1 match$$$formula|||1 match$$$cab|||No match$$$Expression|||String|||Matched?$$$ma*n|||mn|||1 match$$$man|||1 match$$$maaan|||1 match$$$main|||No match (a is not followed by n)$$$woman|||1 match$$$Expression|||String|||Matched?$$$ma+n|||mn|||No match (no a character)$$$man|||1 match$$$maaan|||1 match$$$main|||No match (a is not followed by n)$$$woman|||1 match$$$Expression|||String|||Matched?$$$ma?n|||mn|||1 match$$$man|||1 match$$$maaan|||No match (more than one a character)$$$main|||No match (a is not followed by n)$$$woman|||1 match$$$Expression|||String|||Matched?$$$a{2,3}|||abc dat|||No match$$$abc daat|||1 match (at daat)$$$aabc daaat|||2 matches (at aabc and daaat)$$$aabc daaaat|||2 matches (at aabc and daaaat)$$$Expression|||String|||Matched?$$$[0-9]{2,4}|||ab123csde|||1 match (match at ab123csde)$$$12 and 345673|||3 matches (12, 3456, 73)$$$1 and 2|||No match$$$Expression|||String|||Matched?$$$a|b|||cde|||No match$$$ade|||1 match (match at ade)$$$acdbea|||3 matches (at acdbea)$$$Expression|||String|||Matched?$$$(a|b|c)xz|||ab xz|||No match$$$abxz|||1 match (match at abxz)$$$axz cabxz|||2 matches (at axzbc cabxz)$$$Expression|||String|||Matched?$$$\Athe|||the sun|||Match$$$In the sun|||No match$$$Expression|||String|||Matched?$$$\bfoo|||football|||Match$$$a football|||Match$$$afootball|||No match$$$foo\b|||the foo|||Match$$$the afoo test|||Match$$$the afootest|||No match$$$Expression|||String|||Matched?$$$\Bfoo|||football|||No match$$$a football|||No match$$$afootball|||Match$$$foo\B|||the foo|||No match$$$the afoo test|||No match$$$the afootest|||Match$$$Expression|||String|||Matched?$$$\d|||12abc3|||3 matches (at 12abc3)$$$Python|||No match$$$Expression|||String|||Matched?$$$\D|||1ab34""50|||3 matches (at 1ab34""50)$$$1345|||No match$$$Expression|||String|||Matched?$$$\s|||Python RegEx|||1 match$$$PythonRegEx|||No match$$$Expression|||String|||Matched?$$$\S|||a b|||2 matches (at  a b)$$$   |||No match$$$Expression|||String|||Matched?$$$\w|||12&"": ;c |||3 matches (at 12&"": ;c)$$$%""> !|||No match$$$Expression|||String|||Matched?$$$\W|||1a2%c|||1 match (at 1a2%c)$$$Python|||No match$$$Expression|||String|||Matched?$$$Python\Z|||I like Python|||1 match$$$I like Python Programming|||No match$$$Python is fun.|||No match"
https://www.programiz.com/python-programming/examples,Python Examples | Programiz,,The best way to learn Python is by practicing examples. This page             contains examples on basic concepts of Python. We encourage you to try these examples on your own before looking at the solution. All the programs on this page are tested and should work on all platforms.,,,"Python Program to Print Hello world!$$$Python Program to Add Two Numbers$$$Python Program to Find the Square Root$$$Python Program to Calculate the Area of a Triangle$$$Python Program to Solve Quadratic Equation$$$Python Program to Swap Two Variables$$$Python Program to Generate a Random Number$$$Python Program to Convert Kilometers to Miles$$$Python Program to Convert Celsius To Fahrenheit$$$Python Program to Check if a Number is Positive, Negative or 0$$$Python Program to Check if a Number is Odd or Even$$$Python Program to Check Leap Year$$$Python Program to Find the Largest Among Three Numbers$$$Python Program to Check Prime Number$$$Python Program to Print all Prime Numbers in an Interval$$$Python Program to Find the Factorial of a Number$$$Python Program to Display the multiplication Table$$$Python Program to Print the Fibonacci sequence$$$Python Program to Check Armstrong Number$$$Python Program to Find Armstrong Number in an Interval$$$Python Program to Find the Sum of Natural Numbers$$$Python Program to Display Powers of 2 Using Anonymous Function$$$Python Program to Find Numbers Divisible by Another Number$$$Python Program to Convert Decimal to Binary, Octal and Hexadecimal$$$Python Program to Find ASCII Value of Character$$$Python Program to Find HCF or GCD$$$Python Program to Find LCM$$$Python Program to Find the Factors of a Number$$$Python Program to Make a Simple Calculator$$$Python Program to Shuffle Deck of Cards$$$Python Program to Display Calendar$$$Python Program to Display Fibonacci Sequence Using Recursion$$$Python Program to Find Sum of Natural Numbers Using Recursion$$$Python Program to Find Factorial of Number Using Recursion$$$Python Program to Convert Decimal to Binary Using Recursion$$$Python Program to Add Two Matrices$$$Python Program to Transpose a Matrix$$$Python Program to Multiply Two Matrices$$$Python Program to Check Whether a String is Palindrome or Not$$$Python Program to Remove Punctuations From a String$$$Python Program to Sort Words in Alphabetic Order$$$Python Program to Illustrate Different Set Operations$$$Python Program to Count the Number of Each Vowel$$$Python Program to Merge Mails$$$Python Program to Find the Size (Resolution) of a Image$$$Python Program to Find Hash of File$$$Python Program to Create Pyramid Patterns$$$Python Program to Merge Two Dictionaries$$$Python Program to Safely Create a Nested Directory$$$Python Program to Access Index of a List Using for Loop$$$Python Program to Flatten a Nested List$$$Python Program to Slice Lists$$$Python Program to Iterate Over Dictionaries Using for Loop$$$Python Program to Sort a Dictionary by Value$$$Python Program to Check If a List is Empty$$$Python Program to Catch Multiple Exceptions in One Line$$$Python Program to Copy a File$$$Python Program to Concatenate Two Lists $$$Python Program to Check if a Key is Already Present in a Dictionary$$$Python Program to Split a List Into Evenly Sized Chunks$$$Python Program to Parse a String to a Float or Int$$$Python Program to Print Colored Text to the Terminal$$$ Python Program to Convert String to Datetime$$$Python Program to Get the Last Element of the List$$$Python Program to Get a Substring of a String$$$Python Program to Print Output Without a Newline$$$Python Program Read a File Line by Line Into a List$$$Python Program to Randomly Select an Element From the List$$$Python Program to Check If a String Is a Number (Float)$$$Python Program to Count the Occurrence of an Item in a List$$$Python Program to Append to a File$$$Python Program to Delete an Element From a Dictionary$$$Python Program to Create a Long Multiline String$$$Python Program to Extract Extension From the File Name$$$Python Program to Measure the Elapsed Time in Python$$$Python Program to Get the Class Name of an Instance$$$Python Program to Convert Two Lists Into a Dictionary$$$Python Program to Differentiate Between type() and isinstance()$$$Python Program to Trim Whitespace From a String$$$Python Program to Get the File Name From the File Path$$$Python Program to Represent enum$$$Python Program to Return Multiple Values From a Function$$$Python Program to Get Line Count of a File$$$Python Program to Find All File with .txt Extension Present Inside a Directory$$$Python Program to Get File Creation and Modification Date$$$Python Program to Get the Full Path of the Current Working Directory$$$Python Program to Iterate Through Two Lists in Parallel$$$Python Program to Check the File Size$$$Python Program to Reverse a Number$$$Python Program to Compute the Power of a Number$$$Python Program to Count the Number of Digits Present In a Number$$$Python Program to Check If Two Strings are Anagram$$$Python Program to Capitalize the First Character of a String$$$Python Program to Compute all the Permutation of the String$$$Python Program to Create a Countdown Timer$$$Python Program to Count the Number of Occurrence of a Character in String$$$Python Program to Remove Duplicate Element From a List$$$Python Program to Convert Bytes to a String",
https://www.programiz.com/python-programming/datetime,Python datetime (With Examples),"Video: Python datetime - Work with Dates and Times$$$datetime.date Class$$$datetime.time$$$datetime.datetime$$$datetime.timedelta$$$Python format datetime$$$Handling timezone in Python$$$Example 1: Get Current Date and Time$$$Example 2: Get Current Date$$$Example 3: Date object to represent a date$$$Example 4: Get current date$$$Example 5: Get date from a timestamp$$$Example 6: Print today's year, month and day$$$Example 7: Time object to represent time$$$Example 8: Print hour, minute, second and microsecond$$$Example 9: Python datetime object$$$Example 10: Print year, month, hour, minute and timestamp$$$Example 11: Difference between two dates and times$$$Example 12: Difference between two timedelta objects$$$Example 13: Printing negative timedelta object$$$Example 14: Time duration in seconds$$$Python strftime() - datetime object to string$$$Example 15: Format date using strftime()$$$Python strptime() - string to datetime$$$Example 16: strptime()$$$Table of Contents",,"In this article, you will learn to manipulate date and time in Python with the help of examples. |||Python has a module named datetime to work with dates and times. Let's create a few simple programs related to date and time before we dig deeper.|||When you run the program, the output will be something like:|||Here, we have imported datetime module using import datetime statement.|||One of the classes defined in the datetime module is datetime class. We then used now() method to create a datetime object containing the current local date and time.|||When you run the program, the output will be something like:|||In this program, we have used today() method defined in the date class to get a date object containing the current local date.|||What's inside datetime?|||We can use dir() function to get a list containing all attributes of a module.|||When you run the program, the output will be:|||Commonly used classes in the datetime module are:|||You can instantiate date objects from the date class. A date object represents a date (year, month and day).|||When you run the program, the output will be:|||If you are wondering, date() in the above example is a constructor of the date class. The constructor takes three arguments: year, month and day.|||The variable a is a date object.|||We can only import date class from the datetime module. Here's how:|||You can create a date object containing the current date by using a classmethod named today(). Here's how:|||We can also create date objects from a timestamp. A Unix timestamp is the number of seconds between a particular date and January 1, 1970 at UTC. You can convert a timestamp to date using fromtimestamp() method.|||When you run the program, the output will be:|||We can get year, month, day, day of the week etc. from the date object easily. Here's how:|||A time object instantiated from the time class represents the local time.|||When you run the program, the output will be:|||Once you create a time object, you can easily print its attributes such as hour, minute etc.|||When you run the example, the output will be:|||Notice that we haven't passed microsecond argument. Hence, its default value 0 is printed.|||The datetime module has a class named dateclass that can contain information from both date and time objects.|||When you run the program, the output will be:||||||The first three arguments year, month and day in the datetime() constructor are mandatory.|||When you run the program, the output will be:|||A timedelta object represents the difference between two dates or times.|||When you run the program, the output will be:|||Notice, both t3 and t6 are of <class 'datetime.timedelta'> type.|||When you run the program, the output will be:|||Here, we have created two timedelta objects t1 and t2, and their difference is printed on the screen.|||When you run the program, the output will be:|||You can get the total number of seconds in a timedelta object using total_seconds() method.|||When you run the program, the output will be:|||You can also find sum of two dates and times using + operator. Also, you can multiply and divide a timedelta object by integers and floats.|||The way date and time is represented may be different in different places, organizations etc. It's more common to use mm/dd/yyyy in the US, whereas dd/mm/yyyy is more common in the UK.|||Python has strftime() and strptime() methods to handle this.|||The strftime() method is defined under classes date, datetime and time. The method creates a formatted string from a given date, datetime or time object.|||When you run the program, the output will be something like:|||Here, %Y, %m, %d, %H etc. are format codes. The strftime() method takes one or more format codes and returns a formatted string based on it.|||In the above program, t, s1 and s2 are strings.|||To learn more about strftime() and format codes, visit: Python strftime().|||The strptime() method creates a datetime object from a given string (representing date and time).|||When you run the program, the output will be:|||The strptime() method takes two arguments:|||By the way, %d, %B and %Y format codes are used for day, month(full name) and year respectively.|||Visit Python strptime() to learn more.|||Suppose, you are working on a project and need to display date and time based on their timezone. Rather than trying to handle timezone yourself, we suggest you to use a third-party pytZ module.|||When you run the program, the output will be something like:|||Here, datetime_NY and datetime_London are datetime objects containing the current date and time of their respective timezone.","date Class$$$time Class$$$datetime Class$$$timedelta Class$$$%Y - year [0001,..., 2018, 2019,..., 9999]$$$%m - month [01, 02, ..., 11, 12]$$$%d - day [01, 02, ..., 30, 31]$$$%H - hour [00, 01, ..., 22, 23$$$%M - minute [00, 01, ..., 58, 59]$$$%S - second [00, 01, ..., 58, 59]$$$Python datetime (Introduction)$$$Example: Get current date and time$$$datetime.date$$$datetime.time$$$datetime.datetime$$$datetime.timedelta$$$Python format datetime$$$Handling timezone in Python",a string representing date and time$$$format code equivalent to the first argument,
https://www.programiz.com/python-programming/datetime/strftime,Python strftime() - datetime to string,Video: Dates and Times in Python$$$Example 1: datetime to string using strftime()$$$How strftime() works?$$$Example 2: Creating string from a timestamp$$$Format Code List$$$Example 3: Locale's appropriate date and time$$$Table of Contents,,"In this article, you will learn to convert date, time and datetime objects to its equivalent string (with the help of examples)|||The strftime() method returns a string representing date and time using date, time or datetime object.|||The program below converts a datetime object containing current date and time to different string formats.|||When you run the program, the output will something like be:|||Here, year, day, time and date_time are strings, whereas now is a datetime object.|||In the above program, %Y, %m, %d etc. are format codes. The strftime() method takes one or more format codes as an argument and returns a formatted string based on it.||||||When you run the program, the output will be:|||The table below shows all the codes that you can pass to the strftime() method.|||When you run the program, the output will be:|||Format codes %c, %x and %X are used for locale's appropriate date and time representation.|||We also recommend you to check Python strptime(). The strptime() method creates a datetime object from a string.",Python strftime()$$$Example: datetime object to string$$$How strftime() works?$$$Example: string from a timestamp$$$Format code list$$$Example: Locale's appropriate date and time,We imported datetime class from the datetime module. It's because the object of datetime class can access strftime() method.$$$The datetime object containing current date and time is stored in now variable.$$$The strftime() method can be used to create formatted strings.$$$The string you pass to the strftime() method may contain more than one format codes.,"Directive|||Meaning|||Example$$$%a|||Abbreviated weekday name.|||Sun, Mon, ...$$$%A|||Full weekday name.|||Sunday, Monday, ...$$$%w|||Weekday as a decimal number.|||0, 1, ..., 6$$$%d|||Day of the month as a zero-padded decimal.|||01, 02, ..., 31$$$%-d|||Day of the month as a decimal number.|||1, 2, ..., 30$$$%b|||Abbreviated month name.|||Jan, Feb, ..., Dec$$$%B|||Full month name.|||January, February, ...$$$%m|||Month as a zero-padded decimal number.|||01, 02, ..., 12$$$%-m|||Month as a decimal number.|||1, 2, ..., 12$$$%y|||Year without century as a zero-padded decimal number.|||00, 01, ..., 99$$$%-y|||Year without century as a decimal number.|||0, 1, ..., 99$$$%Y|||Year with century as a decimal number.|||2013, 2019 etc.$$$%H|||Hour (24-hour clock) as a zero-padded decimal number.|||00, 01, ..., 23$$$%-H|||Hour (24-hour clock) as a decimal number.|||0, 1, ..., 23$$$%I|||Hour (12-hour clock) as a zero-padded decimal number.|||01, 02, ..., 12$$$%-I|||Hour (12-hour clock) as a decimal number.|||1, 2, ... 12$$$%p|||Locale’s AM or PM.|||AM, PM$$$%M|||Minute as a zero-padded decimal number.|||00, 01, ..., 59$$$%-M|||Minute as a decimal number.|||0, 1, ..., 59$$$%S|||Second as a zero-padded decimal number.|||00, 01, ..., 59$$$%-S|||Second as a decimal number.|||0, 1, ..., 59$$$%f|||Microsecond as a decimal number, zero-padded on the left.|||000000 - 999999$$$%z|||UTC offset in the form +HHMM or -HHMM.||| $$$%Z|||Time zone name.||| $$$%j|||Day of the year as a zero-padded decimal number.|||001, 002, ..., 366$$$%-j|||Day of the year as a decimal number.|||1, 2, ..., 366$$$%U|||Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0.|||00, 01, ..., 53$$$%W|||Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0.|||00, 01, ..., 53$$$%c|||Locale’s appropriate date and time representation.|||Mon Sep 30 07:06:05 2013$$$%x|||Locale’s appropriate date representation.|||09/30/13$$$%X|||Locale’s appropriate time representation.|||07:06:05$$$%%|||A literal '%' character.|||%"
https://www.programiz.com/python-programming/datetime/strptime,Python strptime() - string to datetime object,Video: Dates and Times in Python$$$Example 1: string to datetime object$$$Example 2: string to datetime object$$$Format Code List$$$How strptime() works?$$$ValueError in strptime()$$$Table of Contents,,"In this article, you will learn to create a datetime object from a string (with the help of examples).|||The strptime() method creates a datetime object from the given string.|||Note: You cannot create datetime object from every string. The string needs to be in a certain format.|||When you run the program, the output will be:|||The strptime() class method takes two arguments:|||Based on the string and format code used, the method returns its equivalent datetime object.|||In the above example:|||||||||Here,|||When you run the program, the output will be:|||The table below shows all the format codes that you can use.|||If the string (first argument) and the format code (second argument) passed to the strptime() doesn't match, you will get ValueError. For example:|||If you run this program, you will get an error.|||Recommended Readings: Python strftime()","string (that be converted to datetime)$$$format code$$$%d - Represents the day of the month. Example: 01, 02, ..., 31$$$%B - Month's name in full. Example: January, February etc.$$$%Y - Year in four digits. Example: 2018, 2019 etc.$$$Python strptime()$$$Example 1: string to datetime$$$How strptime() works?$$$Example 2: string to datetime$$$Format code list$$$ValueError() in strptime()",,"Directive|||Meaning|||Example$$$%a|||Abbreviated weekday name.|||Sun, Mon, ...$$$%A|||Full weekday name.|||Sunday, Monday, ...$$$%w|||Weekday as a decimal number.|||0, 1, ..., 6$$$%d|||Day of the month as a zero-padded decimal.|||01, 02, ..., 31$$$%-d|||Day of the month as a decimal number.|||1, 2, ..., 30$$$%b|||Abbreviated month name.|||Jan, Feb, ..., Dec$$$%B|||Full month name.|||January, February, ...$$$%m|||Month as a zero-padded decimal number.|||01, 02, ..., 12$$$%-m|||Month as a decimal number.|||1, 2, ..., 12$$$%y|||Year without century as a zero-padded decimal number.|||00, 01, ..., 99$$$%-y|||Year without century as a decimal number.|||0, 1, ..., 99$$$%Y|||Year with century as a decimal number.|||2013, 2019 etc.$$$%H|||Hour (24-hour clock) as a zero-padded decimal number.|||00, 01, ..., 23$$$%-H|||Hour (24-hour clock) as a decimal number.|||0, 1, ..., 23$$$%I|||Hour (12-hour clock) as a zero-padded decimal number.|||01, 02, ..., 12$$$%-I|||Hour (12-hour clock) as a decimal number.|||1, 2, ... 12$$$%p|||Locale’s AM or PM.|||AM, PM$$$%M|||Minute as a zero-padded decimal number.|||00, 01, ..., 59$$$%-M|||Minute as a decimal number.|||0, 1, ..., 59$$$%S|||Second as a zero-padded decimal number.|||00, 01, ..., 59$$$%-S|||Second as a decimal number.|||0, 1, ..., 59$$$%f|||Microsecond as a decimal number, zero-padded on the left.|||000000 - 999999$$$%z|||UTC offset in the form +HHMM or -HHMM.||| $$$%Z|||Time zone name.||| $$$%j|||Day of the year as a zero-padded decimal number.|||001, 002, ..., 366$$$%-j|||Day of the year as a decimal number.|||1, 2, ..., 366$$$%U|||Week number of the year (Sunday as the first day of the week). All days in a new year preceding the first Sunday are considered to be in week 0.|||00, 01, ..., 53$$$%W|||Week number of the year (Monday as the first day of the week). All days in a new year preceding the first Monday are considered to be in week 0.|||00, 01, ..., 53$$$%c|||Locale’s appropriate date and time representation.|||Mon Sep 30 07:06:05 2013$$$%x|||Locale’s appropriate date representation.|||09/30/13$$$%X|||Locale’s appropriate time representation.|||07:06:05$$$%%|||A literal '%' character.|||%"
https://www.programiz.com/python-programming/datetime/current-datetime,How to get current date and time in Python?,Video: Dates and Times in Python$$$Example 1: Python get today's date$$$Example 2: Current date in different formats$$$Example 3: Get the current date and time$$$Table of Contents,,"In this article, you will learn to get today's date and current date and time in Python. We will also format the date and time in different formats using strftime() method.|||There are a number of ways you can take to get the current date. We will use the date class of the datetime module to accomplish this task.|||Here, we imported the date class from the datetime module. Then, we used the date.today() method to get the current local date.|||By the way, date.today() returns a date object, which is assigned to the today variable in the above program. Now, you can use the strftime() method to create a string representing date in different formats.|||When you run the program, the output will be something like:||||||If you need to get the current date and time, you can use datetime class of the datetime module.|||You will gate output like below.|||Here, we have used datetime.now() to get the current date and time. Then, we used strftime() to create a string representing date and time in another format.",Example: today's date$$$Example: Current date in different formats$$$Example: Current date and time,,
https://www.programiz.com/python-programming/datetime/current-time,Python Get Current time,Example 1: Current time using datetime object$$$Example 2: Current time using time module$$$Example 3: Current time of a timezone$$$Table of Contents,,"In this article, you will learn to get current time of your locale as well as different time zones in Python.|||There are a number of ways you can take to get current time in Python.|||Output|||In the above example, we have imported datetime class from the datetime module. Then, we used now() method to get a datetime object containing current date and time.|||Using datetime.strftime() method, we then created a string representing current time.|||If you need to create a time object containing current time, you can do something like this.||||||Output|||You can also get the current time using time module.|||Output|||If you need to find current time of a certain timezone, you can use pytZ module.|||Output",Example: Current time using datetime object$$$Example: Current time using time module$$$Example: Current time of a timezone,,
https://www.programiz.com/python-programming/datetime/timestamp-datetime,Python timestamp to datetime and vice-versa,Example 1: Python timestamp to datetime$$$Example 2: Python datetime to timestamp,,"In this article, you will learn to convert timestamp to datetime object and datetime object to timestamp (with the help of examples).|||It's pretty common to store date and time as a timestamp in a database. A Unix timestamp is the number of seconds between a particular date and January 1, 1970 at UTC.|||When you run the program, the output will be:|||Here, we have imported datetime class from the datetime module. Then, we used datetime.fromtimestamp() classmethod which returns the local date and time (datetime object). This object is stored in dt_object variable.||||||Note: You can easily create a string representing date and time from a datetime object using strftime() method.|||You can get timestamp from a datetime object using datetime.timestamp() method.",,,
https://www.programiz.com/python-programming/time,Python time Module (with Examples),time.struct_time Class$$$Python time.time()$$$Python time.ctime()$$$Python time.sleep()$$$Python time.localtime()$$$Python time.gmtime()$$$Python time.mktime()$$$Python time.asctime()$$$Python time.strftime()$$$Python time.strptime()$$$Table of Contents,,"In this article, we will explore time module in detail. We will learn to use different time-related functions defined in the time module with the help of examples.|||Python has a module named time to handle time-related tasks. To use functions defined in the module, we need to import the module first. Here's how:|||Here are commonly used time-related functions.|||The time() function returns the number of seconds passed since epoch.|||For Unix system, January 1, 1970, 00:00:00 at UTC is epoch (the point where time begins).|||The time.ctime() function takes seconds passed since epoch as an argument and returns a string representing local time.|||If you run the program, the output will be something like:|||The sleep() function suspends (delays) execution of the current thread for the given number of seconds.|||To learn more, visit: Python sleep().|||Before we talk about other time-related functions, let's explore time.struct_time class in brief.|||Several functions in the time module such as gmtime(), asctime() etc. either take time.struct_time object as an argument or return it.|||Here's an example of time.struct_time object.|||The values (elements) of the time.struct_time object are accessible using both indices and attributes.|||The localtime() function takes the number of seconds passed since epoch as an argument and returns struct_time in local time.|||When you run the program, the output will be something like:|||If no argument or None is passed to localtime(), the value returned by time() is used.||||||The gmtime() function takes the number of seconds passed since epoch as an argument and returns struct_time in UTC.|||When you run the program, the output will be:|||If no argument or None is passed to gmtime(), the value returned by time() is used.|||The mktime() function takes struct_time (or a tuple containing 9 elements corresponding to struct_time) as an argument and returns the seconds passed since epoch in local time. Basically, it's the inverse function of localtime().|||The example below shows how mktime() and localtime() are related.|||When you run the program, the output will be something like:|||The asctime() function takes struct_time (or a tuple containing 9 elements corresponding to struct_time) as an argument and returns a string representing it. Here's an example:|||When you run the program, the output will be:|||The strftime() function takes struct_time (or tuple corresponding to it) as an argument and returns a string representing it based on the format code used. For example,|||When you run the program, the output will be something like:|||Here, %Y, %m, %d, %H etc. are format codes.|||To learn more, visit: time.strftime().|||The strptime() function parses a string representing time and returns struct_time.|||When you run the program, the output will be:","%Y - year [0001,..., 2018, 2019,..., 9999]$$$%m - month [01, 02, ..., 11, 12]$$$%d - day [01, 02, ..., 30, 31]$$$%H - hour [00, 01, ..., 22, 23$$$%M - minutes [00, 01, ..., 58, 59]$$$%S - second [00, 01, ..., 58, 61]$$$Python time$$$time.time()$$$time.ctime()$$$time.sleep()$$$time.struct_time Class$$$time.localtime()$$$time.gmtime()$$$time.mktime()$$$time.asctime()$$$time.strftime()$$$time.strptime()",,"Index|||Attribute|||Values$$$0|||tm_year|||0000, ...., 2018, ..., 9999$$$1|||tm_mon|||1, 2, ..., 12$$$2|||tm_mday|||1, 2, ..., 31$$$3|||tm_hour|||0, 1, ..., 23$$$4|||tm_min|||0, 1, ..., 59$$$5|||tm_sec|||0, 1, ..., 61$$$6|||tm_wday|||0, 1, ..., 6; Monday is 0$$$7|||tm_yday|||1, 2, ..., 366$$$8|||tm_isdst|||0, 1 or -1"
https://www.programiz.com/python-programming/time/sleep,Python sleep() Function (With Examples),Example 1: Python sleep()$$$Example 2: Python create a digital clock$$$Multithreading in Python$$$time.sleep() in multithreaded programs$$$Example 3: Python multithreading$$$Example 4: sleep() in a multithreaded program$$$Table of Contents,,"The sleep() function suspends (waits) execution of the current thread for a given number of seconds. |||Python has a module named time which provides several useful functions to handle time-related tasks. One of the popular functions among them is sleep().|||The sleep() function suspends execution of the current thread for a given number of seconds.|||Here's how this program works:|||As you can see from the above example, sleep() takes a floating-point number as an argument.|||Before Python 3.5, the actual suspension time may be less than the argument specified to the time() function.|||Since Python 3.5, the suspension time will be at least the seconds specified.|||In the above program, we computed and printed the current local time inside the infinite while loop. Then, the program waits for 1 second. Again, the current local time is computed and printed. This process goes on.|||When you run the program, the output will be something like:|||Here is a slightly modified better version of the above program.|||To learn more, visit digital clock in Python shell.|||Before talking about sleep() in multithreaded programs, let's talk about processes and threads.||||||A computer program is a collection of instructions. A process is the execution of those instructions.|||A thread is a subset of the process. A process can have one or more threads.|||All the programs above in this article are single-threaded programs. Here's an example of a multithreaded Python program.|||When you run the program, the output will be something like:|||The above program has two threads t1 and t2. These threads are run using t1.start() and t2.start() statements.|||Note that, t1 and t2 run concurrently and you might get different output.|||Visit this page to learn more about Multithreading in Python.|||The sleep() function suspends execution of the current thread for a given number of seconds.|||In case of single-threaded programs, sleep() suspends execution of the thread and process. However, the function suspends a thread rather than the whole process in multithreaded programs.|||The above program has two threads. We have used time.sleep(0.5) and time.sleep(0.75) to suspend execution of these two threads for 0.5 seconds and 0.7 seconds respectively.|||Recommended Reading: Python time.sleep() sleeps thread","""Printed immediately"" is printed$$$Suspends (Delays) execution for 2.4 seconds.$$$""Printed after 2.4 seconds"" is printed.$$$Python sleep() Introduction$$$Example: Python sleep()$$$Example: Digital clock in Python$$$Multithreading in Python$$$sleep() in a multithreaded program$$$Example: sleep() in a multithreaded program",,
https://www.programiz.com/python-programming/methods,Python Standard Library Functions | Programiz, Python Built-in Functions$$$Python abs()$$$Python any()$$$Python all()$$$Python ascii()$$$Python bin()$$$Python bool()$$$Python bytearray()$$$Python callable()$$$Python bytes()$$$Python chr()$$$Python compile()$$$Python classmethod()$$$Python complex()$$$Python delattr()$$$Python dict()$$$Python dir()$$$Python divmod()$$$Python enumerate()$$$Python staticmethod()$$$Python filter()$$$Python eval()$$$Python float()$$$Python format()$$$Python frozenset()$$$Python getattr()$$$Python globals()$$$Python exec()$$$Python hasattr()$$$Python help()$$$Python hex()$$$Python hash()$$$Python input()$$$Python id()$$$Python isinstance()$$$Python int()$$$Python issubclass()$$$Python iter()$$$Python list()$$$Python locals()$$$Python len()$$$Python max()$$$Python min()$$$Python map()$$$Python next()$$$Python memoryview()$$$Python object()$$$Python oct()$$$Python ord()$$$Python open()$$$Python pow()$$$Python print()$$$Python property()$$$Python range()$$$Python repr()$$$Python reversed()$$$Python round()$$$Python set()$$$Python setattr()$$$Python slice()$$$Python sorted()$$$Python str()$$$Python sum()$$$Python tuple()$$$Python type()$$$Python vars()$$$Python zip()$$$Python __import__()$$$Python super(),,,,,
https://www.programiz.com/python-programming/guide,Python Programming,What is Python Programming Language?$$$Features of Python Programming$$$Reasons to Choose Python as First Language$$$How you can learn to code in Python?$$$Final Words$$$Simple and easy to learn$$$Free and open-source$$$Portability$$$Extensible and Embeddable$$$High-Level Interpreted Language$$$Rich library and large community$$$1. Simple Elegant Syntax$$$2. Not overly strict$$$3. The expressiveness of the language$$$4. Great Community and Support$$$Learn Python from Programiz$$$Learn Python from Mobile App$$$Table of Contents,,"Python is a powerful multipurpose programming language created by Guido van Rossum.|||It has a simple and easy-to-use syntax, making it a popular first-choice programming language for beginners.|||This is a comprehensive guide that explores the reasons you should consider learning Python and the ways you can get started with Python.|||If you directly want to get started with Python, visit our Python Tutorial page.|||Python is an interpreted, object-oriented, high-level programming language. As it is general-purpose, it has a wide range of applications from web development, building desktop GUI to scientific and mathematical computing.|||Python is popular for its simple and relatively straightforward syntax. Its syntax readability increases productivity as it allows us to focus more on the problem rather than structuring the code.|||Python has a very simple and elegant syntax. It is much easier to read and write programs in Python compared to other languages like C, C++, or Java.|||Due to this reason, many beginners are introduced to programming with Python as their first programming language.|||You can freely use and distribute Python programs even for commercial use. As it is open-source, you can even change Python's source code to fit your use case.|||A single Python program can run on different platforms without any change in source code. It runs on almost all platforms including Windows, Mac OS X, and Linux.|||You can combine Python code with other programming languages like C or Java to increase efficiency. This allows high performance and scripting capabilities that other languages do not provide out of the box.|||Python itself handles tasks like memory management and garbage collection. So unlike C or C++, you don't have to worry about system architecture or any other lower-level operations.|||Python has numerous reliable built-in libraries. Python programmers have developed tons of free and open-source libraries, so you don't have to code everything by yourself.|||The Python community is very large and ever-growing. If you encounter errors while programming in Python, it's like that it has already been asked and solved by someone in this community.|||Programming in Python is fun. It's easier to understand and write Python code. The syntax feels natural. Let's take the following example where we add two numbers:||||||Even if you have never programmed before, you can easily guess that this program adds two numbers and displays the result.|||You don't need to define the type of a variable in Python. Also, it's not necessary to add a semicolon at the end of the statement.|||Python enforces you to follow good practices (like proper indentation). These small things can make learning much easier for beginners.|||Python allows you to write programs having greater functionality with fewer lines of code. Let's look at code to swap the values of two variables. It can be done in Python with the following lines of code:|||Here, we can see that the code is very less and more readable.|||If instead, we were to use Java, the same program would have to be written in the following way:|||This is just an example. There are many more such cases where Python increases efficiency by reducing the amount of code required to program something.|||Python has a large supporting community. There are numerous active online forums that can come in handy if you are stuck anywhere in the learning process. Some of them are:|||Programiz offers dozens of tutorials and examples to help you learn Python programming from scratch. Each tutorial is written in-depth with examples and detailed explanations.|||Programiz provides a beginner-friendly mobile app. It contains byte-size lessons and an integrated Python interpreter. To learn more, visit Learn Python app.|||We at Programiz think Python is a terrific language to learn.|||If you are getting started in programming, Python is an awesome choice. You will be amazed by how much you can do in Python once you know the basics.|||It is easy to overlook the fact that Python is a powerful language. Not only is Python good for learning programming, but it is also a good language to have in your arsenal.|||Python can help you to get started in everything, whether it is changing your idea into a prototype, creating a game, or getting into Machine Learning and Artificial Intelligence.",Learn Python subreddit$$$Google Forum for Python$$$Python Questions - Stack Overflow$$$Introduction$$$What is Python Programming?$$$Features$$$Why choose Python?$$$How to learn Python?$$$Final Words,,
