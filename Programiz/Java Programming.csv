Links,Main Heading,Chapter Headings,Description,Contents,Unordered Lists,Ordered Lists,Table Data
https://www.programiz.com/java-programming,Learn Java Programming,About Java Programming$$$Why Learn Java?$$$How to learn Java?$$$Java Resources,"Java is a powerful general-purpose programming language. It is used to develop desktop and mobile applications, big data processing, embedded systems, and so on. According to Oracle, the company that owns Java, Java runs on 3 billion devices worldwide, which makes Java one of the most popular programming languages. Our Java tutorial will guide you to learn Java one step at a time.",,"Platform independent - We can write Java code in one platform (operating system) and run on another platform without any modification.$$$Object-oriented - Java is an object-oriented language. This helps to make our Java code more flexible and reusable.$$$Speed - Well optimized Java code is nearly as fast as lower-level languages like C++ and much faster than Python, PHP, etc.$$$Java is a platform-independent language. We can write Java code in one platform and run it in another platform$$$Java is a general-purpose language with a wide range of applications. It's used for developing mobile and desktop applications, big data processing, embedded systems, and so on.$$$Java is an object-oriented programming language. It helps in code reusability.$$$Java tutorial from Programiz - We provide step-by-step Java tutorials and examples. Get started with Java.$$$Official Java tutorial - Java documentation is one of the best programming language documentation. Visit the official Java tutorial.$$$Write a lot of Java code- The only way you can learn programming is by writing a lot of code.$$$What is Java?$$$Java Online Compiler$$$Java Examples$$$Java Library Functions",,
https://www.programiz.com/java-programming/hello-world,Java Hello World - Your First Java Program,"Java ""Hello, World!"" Program$$$How Java ""Hello, World!"" Program Works?$$$Things to take away$$$Table of Contents",,"In this tutorial, you will learn to write ""Hello World"" program in Java.|||A ""Hello, World!"" is a simple program that outputs Hello, World! on the screen. Since it's a very simple program, it's often used to introduce a new programming language to a newbie.|||Let's explore how Java ""Hello, World!"" program works.|||Note: You can use our online Java compiler to run Java programs.|||Output|||The code above is a print statement. It prints the text Hello, World! to standard output (your screen). The text inside the quotation marks is called String in Java.||||||Notice the print statement is inside the main function, which is inside the class definition.|||This is a valid Java program that does nothing.|||Don't worry if you don't understand the meaning of class, static, methods, and so on for now. We will discuss it in detail in later chapters.","Every valid Java Application must have a class definition that matches the filename (class name and file name should be same).$$$The main method must be inside the class definition.$$$The compiler executes the codes starting from the main function.$$$What is ""Hello World"" program?$$$Java ""Hello, World!"" Program$$$How Java ""Hello, World!"" Program Works?$$$Things to take away","// Your First ProgramIn Java, any line starting with // is a comment. Comments are intended for users reading the code to understand the intent and functionality of the program. It is completely ignored by the Java compiler (an application that translates Java program to Java bytecode that computer can execute). To learn more, visit Java comments.$$$class HelloWorld { ... }In Java, every application begins with a class definition. In the program, HelloWorld is the name of the class, and the class definition is:class HelloWorld {... .. ...}For now, just remember that every Java application has a class definition, and the name of the class should match the filename in Java.$$$public static void main(String[] args) { ... }This is the main method. Every application in Java must contain the main method. The Java compiler starts executing the code from the main method.How does it work? Good question. However, we will not discuss it in this article. After all, it's a basic program to introduce Java programming language to a newbie. We will learn the meaning of public, static, void, and how methods work? in later chapters.For now, just remember that the main function is the entry point of your Java application, and it's mandatory in a Java program. The signature of the main method in Java is:public static void main(String[] args) {... .. ...}$$$System.out.println(""Hello, World!""); The code above is a print statement. It prints the text Hello, World! to standard output (your screen). The text inside the quotation marks is called String in Java.Notice the print statement is inside the main function, which is inside the class definition.",
https://www.programiz.com/java-programming/jvm-jre-jdk,"Java JDK, JRE and JVM","What is JVM?$$$What is JRE?$$$What is JDK?$$$Relationship between JVM, JRE, and JDK.$$$Table of Contents",,"In this tutorial, you will learn about JDK, JRE, and JVM. You will also learn the key differences between them.|||JVM (Java Virtual Machine) is an abstract machine that enables your computer to run a Java program.|||When you run the Java program, Java compiler first compiles your Java code to bytecode. Then, the JVM translates bytecode into native machine code (set of instructions that a computer's CPU executes directly).|||Java is a platform-independent language. It's because when you write Java code, it's ultimately written for JVM but not your physical machine (computer). Since JVM ​executes the Java bytecode which is platform-independent, Java is platform-independent.|||If you are interested in learning about JVM Architecture, visit The JVM Architecture Explained.|||JRE (Java Runtime Environment) is a software package that provides Java class libraries, Java Virtual Machine (JVM), and other components that are required to run Java applications.||||||JRE is the superset of JVM.|||If you need to run Java programs, but not develop them, JRE is what you need. You can download JRE from Java SE Runtime Environment 8 Downloads page.|||JDK (Java Development Kit) is a software development kit required to develop applications in Java. When you download JDK, JRE is also downloaded with it.|||In addition to JRE, JDK also contains a number of development tools (compilers, JavaDoc, Java Debugger, etc).|||If you want to develop Java applications, download JDK.",What is JVM?$$$What is JRE?$$$What is JDK?,,
https://www.programiz.com/java-programming/variables-literals,Java Variables and Literals (With Examples),Java Variables$$$Rules for Naming Variables in Java$$$Java literals$$$Create Variables in Java$$$Change values of variables$$$1. Boolean Literals$$$2. Integer Literals$$$3. Floating-point Literals$$$4. Character Literals$$$5. String literals$$$Table of Contents,,"In this tutorial, we will learn about Java variables and literals with the help of examples.|||A variable is a location in memory (storage area) to hold data.|||To indicate the storage area, each variable should be given a unique name (identifier). Learn more about Java identifiers.|||Here's how we create a variable in Java,|||Here, speedLimit is a variable of int data type and we have assigned value 80 to it.|||The int data type suggests that the variable can only hold integers. To learn more, visit Java data types.|||In the example, we have assigned value to the variable during declaration. However, it's not mandatory.|||You can declare variables and assign variables separately. For example,|||Note: Java is a statically-typed language. It means that all variables must be declared before they can be used.|||The value of a variable can be changed in the program, hence the name variable. For example,|||Here, initially, the value of speedLimit is 80. Later, we changed it to 90.|||However, we cannot change the data type of a variable in Java within the same scope.|||What is the variable scope?|||Don't worry about it for now. Just remember that we can't do something like this:|||To learn more, visit: Can I change declaration type for a variable in Java?|||Java programming language has its own set of rules and conventions for naming variables. Here's what you need to know:|||There are 4 types of variables in Java programming language:||||||If you are interested to learn more about it now, visit Java Variable Types.|||Literals are data used for representing fixed values. They can be used directly in the code. For example,|||Here, 1, 2.5, and 'F' are literals.|||Here are different types of literals in Java.|||In Java, boolean literals are used to initialize boolean data types. They can store two values: true and false. For example,|||Here, false and true are two boolean literals.|||An integer literal is a numeric value(associated with numbers) without any fractional or exponential part. There are 4 types of integer literals in Java:|||For example:|||In Java, binary starts with 0b, octal starts with 0, and hexadecimal starts with 0x.|||Note: Integer literals are used to initialize variables of integer types like byte, short, int, and long.|||A floating-point literal is a numeric literal that has either a fractional form or an exponential form. For example,|||Note: The floating-point literals are used to initialize float and double type variables.|||Character literals are unicode character enclosed inside single quotes. For example,|||Here, a is the character literal.|||We can also use escape sequences as character literals. For example, \b (backspace), \t (tab), \n (new line), etc.|||A string literal is a sequence of characters enclosed inside double-quotes. For example,|||Here, Java Programming and Programiz are two string literals.","Java is case sensitive. Hence, age and AGE are two different variables. For example, int age = 24;int AGE = 25;System.out.println(age);  // prints 24System.out.println(AGE);  // prints 25$$$Variables must start with either a letter or an underscore, _ or a dollar, $ sign. For example, int age;  // valid name and good practiceint _age;  // valid but bad practiceint $age;  // valid but bad practice$$$Variable names cannot start with numbers. For example, int 1age;  // invalid variables$$$Variable names can't use whitespace. For example, int my age;  // invalid variablesHere, is we need to use variable names having more than one word, use all lowercase letters for the first word and capitalize the first letter of each subsequent word. For example, myAge.$$$When creating variables, choose a name that makes sense. For example, score, number, level makes more sense than variable names such as s, n, and l.$$$If you choose one-word variable names, use all lowercase letters. For example, it's better to use speed rather than SPEED, or sPEED.$$$Instance Variables (Non-Static Fields)$$$Class Variables (Static Fields)$$$Local Variables$$$Parameters$$$Java Variables$$$Create Variables in Java$$$Rules for Naming Variables in Java$$$Java literals$$$Boolean Literals$$$Integer Literals$$$Floating-point Literals$$$Character Literals$$$String literals",binary (base 2)$$$decimal (base 10)$$$octal (base 8)$$$hexadecimal (base 16),
https://www.programiz.com/java-programming/variables-primitive-data-types,Java Data Types (Primitive Types),Java Data Types$$$8 Primitive Data Types$$$1. boolean type$$$Example 1: Java boolean data type$$$2. byte type$$$Example 2: Java byte data type$$$3. short type$$$Example 3: Java short data type$$$4. int type$$$Example 4: Java int data type$$$5. long type$$$Example 5: Java long data type$$$6. double type$$$Example 6: Java double data type$$$7. float type$$$Example 7: Java float data type$$$8. char type$$$Example 8: Java char data type$$$String type$$$Table of Contents,,"In this tutorial, we will learn about all 8 primitive data types in Java with the help of examples.|||As the name suggests, data types specify the type of data that can be stored inside variables in Java.|||Java is a statically-typed language. This means that all variables must be declared before they can be used.|||Here, speed is a variable, and the data type of the variable is int.|||The int data type determines that the speed variable can only contain integers.|||There are 8 data types predefined in Java, known as primitive data types.|||Note: In addition to primitive data types, there are also referenced types (object type).|||Notice, the use of L at the end of -42332200000. This represents that it's an integer of the long type.||||||Notice that we have used -42.3f instead of -42.3in the above program. It's because -42.3 is a double literal.|||To tell the compiler to treat -42.3 as float rather than double, you need to use f or F.|||If you want to know about single-precision and double-precision, visit Java single-precision and double-precision floating-point.|||Here, the Unicode value of Q is \u0051. Hence, we get Q as the output.|||Here is another example:|||Here, we have assigned 9 as a character (specified by single quotes) to the letter1 variable. However, the letter2 variable is assigned 65 as an integer number (no single quotes).|||Hence, A is printed to the output. It is because Java treats characters as an integer and the ASCII value of A is 65. To learn more about ASCII, visit What is ASCII Code?.|||Java also provides support for character strings via java.lang.String class. Strings in Java are not primitive types. Instead, they are objects. For example,|||Here, myString is an object of the String class. To learn more, visit Java Strings.","The boolean data type has two possible values, either true or false.$$$Default value: false.$$$They are usually used for true/false conditions.$$$The byte data type can have values from -128 to 127 (8-bit signed two's complement integer).$$$If it's certain that the value of a variable will be within -128 to 127, then it is used instead of int to save memory.$$$Default value: 0$$$The short data type in Java can have values from -32768 to 32767 (16-bit signed two's complement integer).$$$If it's certain that the value of a variable will be within -32768 and 32767, then it is used instead of other integer data types (int, long).$$$Default value: 0$$$The int data type can have values from -231 to 231-1 (32-bit signed two's complement integer).$$$If you are using Java 8 or later, you can use an unsigned 32-bit integer. This will have a minimum value of 0 and a maximum value of 232-1. To learn more, visit How to use the unsigned integer in java 8?$$$Default value: 0$$$The long data type can have values from -263 to 263-1 (64-bit signed two's complement integer).$$$If you are using Java 8 or later, you can use an unsigned 64-bit integer with a minimum value of 0 and a maximum value of 264-1.$$$Default value: 0$$$The double data type is a double-precision 64-bit floating-point.$$$It should never be used for precise values such as currency.$$$Default value: 0.0 (0.0d)$$$The float data type is a single-precision 32-bit floating-point. Learn more about single-precision and double-precision floating-point if you are interested.$$$It should never be used for precise values such as currency.$$$Default value: 0.0 (0.0f)$$$It's a 16-bit Unicode character.$$$The minimum value of the char data type is '\u0000' (0) and the maximum value of the is '\uffff'.$$$Default value: '\u0000'$$$Java Data Types$$$boolean type$$$byte type$$$short type$$$int type$$$long type$$$double type$$$float type$$$char type",,
https://www.programiz.com/java-programming/operators,"Java Operators: Arithmetic, Relational, Logical and more",1. Java Arithmetic Operators$$$2. Java Assignment Operators$$$3. Java Relational Operators$$$4. Java Logical Operators$$$5. Java Unary Operators$$$Increment and Decrement Operators$$$6. Java Bitwise Operators$$$Other operators$$$Example 1: Arithmetic Operators$$$Example 2: Assignment Operators$$$Example 3: Relational Operators$$$Example 4: Logical Operators$$$Example 5: Increment and Decrement Operators$$$Java instanceof Operator$$$Java Ternary Operator$$$Table of Contents,,"In this tutorial, you'll learn about different types of operators in Java, their syntax and how to use them with the help of examples.|||Operators are symbols that perform operations on variables and values. For example, + is an operator used for addition, while * is also an operator used for multiplication.|||Operators in Java can be classified into 5 types:|||Arithmetic operators are used to perform arithmetic operations on variables and data. For example,|||Here, the + operator is used to add two variables a and b. Similarly, there are various other arithmetic operators in Java.|||Output|||In the above example, we have used +, -, and * operators to compute addition, subtraction, and multiplication operations.|||/ Division Operator|||Note the operation, a / b in our program. The / operator is the division operator.|||If we use the division operator with two integers, then the resulting quotient will also be an integer. And, if one of the operands is a floating-point number, we will get the result will also be in floating-point.|||% Modulo Operator|||The modulo operator % computes the remainder. When a = 7 is divided by b = 4, the remainder is 3.|||Note: The % operator is mainly used with integers.|||Assignment operators are used in Java to assign values to variables. For example,|||Here, = is the assignment operator. It assigns the value on its right to the variable on its left. That is, 5 is assigned to the variable age.|||Let's see some more assignment operators available in Java.|||Output|||Relational operators are used to check the relationship between two operands. For example,|||Here, < operator is the relational operator. It checks if a is less than b or not.|||It returns either true or false.|||Note: Relational operators are used in decision making and loops.|||Logical operators are used to check whether an expression is true or false. They are used in decision making.||||||Working of Program|||Unary operators are used with only one operand. For example, ++ is a unary operator that increases the value of a variable by 1. That is, ++5 will return 6.|||Different types of unary operators are:|||Java also provides increment and decrement operators: ++ and -- respectively. ++ increases the value of the operand by 1, while -- decrease it by 1. For example,|||Here, the value of num gets increased to 6 from its initial value of 5.|||Output|||In the above program, we have used the ++ and -- operator as prefixes (++a, --b). We can also use these operators as postfix (a++, b++).|||There is a slight difference when these operators are used as prefix versus when they are used as a postfix.|||To learn more about these operators, visit increment and decrement operators.|||Bitwise operators in Java are used to perform operations on individual bits. For example,|||Here, ~ is a bitwise operator. It inverts the value of each bit (0 to 1 and 1 to 0).|||The various bitwise operators present in Java are:|||These operators are not generally used in Java. To learn more, visit Java Bitwise and Bit Shift Operators.|||Besides these operators, there are other additional operators in Java.|||The instanceof operator checks whether an object is an instanceof a particular class. For example,|||Output|||Here, str is an instance of the String class. Hence, the instanceof operator returns true. To learn more, visit Java instanceof.|||The ternary operator (conditional operator) is shorthand for the if-then-else statement. For example,|||Here's how it works.|||Let's see an example of a ternary operator.|||Output|||In the above example, we have used the ternary operator to check if the year is a leap year or not. To learn more, visit the Java ternary operator.|||Now that you know about Java operators, it's time to know about the order in which operators are evaluated. To learn more, visit Java Operator Precedence.","(5 > 3) && (8 > 5) returns true because both (5 > 3) and (8 > 5) are true.$$$(5 > 3) && (8 < 5) returns false because the expression (8 < 5) is false.$$$(5 < 3) || (8 > 5) returns true because the expression (8 > 5) is true.$$$(5 > 3) && (8 > 5) returns true because the expression (5 > 3) is true.$$$(5 > 3) && (8 > 5) returns false because both (5 < 3) and (8 < 5) are false.$$$!(5 == 3) returns true because 5 == 3 is false.$$$!(5 > 3) returns false because 5 > 3 is true.$$$If the Expression is true, expression1 is assigned to the variable.$$$If the Expression is false, expression2 is assigned to the variable.$$$Introduction$$$Java Arithmetic Operators$$$Java Assignment Operators$$$Java Relational Operators$$$Java Logical Operators$$$Java Unary Operators$$$Increment and Decrement Operators$$$Java Bitwise Operators$$$Java instanceof Operator$$$Java Ternary Operator",Arithmetic Operators$$$Assignment Operators$$$Relational Operators$$$Logical Operators$$$Unary Operators$$$Bitwise Operators,Operator|||Operation$$$+|||Addition$$$-|||Subtraction$$$*|||Multiplication$$$/|||Division$$$%|||Modulo Operation (Remainder after division)$$$Operator|||Example|||Equivalent to$$$=|||a = b;|||a = b;$$$+=|||a += b;|||a = a + b;$$$-=|||a -= b;|||a = a - b;$$$*=|||a *= b;|||a = a * b;$$$/=|||a /= b;|||a = a / b;$$$%=|||a %= b;|||a = a % b;$$$Operator|||Description|||Example$$$==|||Is Equal To|||3 == 5 returns false$$$!=|||Not Equal To|||3 != 5 returns true$$$>|||Greater Than|||3 > 5 returns false$$$<|||Less Than|||3 < 5 returns true$$$>=|||Greater Than or Equal To|||3 >= 5 returns false$$$<=|||Less Than or Equal To|||3 <= 5 returns true$$$Operator|||Example|||Meaning$$$&& (Logical AND)|||expression1 && expression2|||true only if both expression1 and expression2 are true$$$|| (Logical OR)|||expression1 || expression2|||true if either expression1 or expression2 is true$$$! (Logical NOT)|||!expression|||true if expression is false and vice versa$$$Operator|||Meaning$$$+|||Unary plus: not necessary to use since numbers are positive without using it$$$-|||Unary minus: inverts the sign of an expression$$$++|||Increment operator: increments value by 1$$$--|||Decrement operator: decrements value by 1$$$!|||Logical complement operator: inverts the value of a boolean$$$Operator|||Description$$$~|||Bitwise Complement$$$<<|||Left Shift$$$>>|||Right Shift$$$>>>|||Unsigned Right Shift$$$&|||Bitwise AND$$$^|||Bitwise exclusive OR
https://www.programiz.com/java-programming/basic-input-output,Java Basic Input and Output,"Java Output$$$Java Input$$$Difference between println(), print() and printf()$$$Example: print() and println()$$$Example: Printing Variables and Literals$$$Example: Print Concatenated Strings$$$Example: Get Integer Input From the User$$$Example: Get float, double and String Input$$$Table of Contents",,"In this tutorial, you will learn simple ways to display output to users and take input from users in Java.|||In Java, you can simply use|||to send output to standard output (screen).|||Here,|||Don't worry if you don't understand it. We will discuss class, public, and static in later chapters.|||Let's take an example to output a line.|||Output:|||Here, we have used the println() method to display the string.|||Output:|||In the above example, we have shown the working of the print() and println() methods. To learn about the printf() method, visit Java printf().|||When you run the program, the output will be:|||Here, you can see that we have not used the quotation marks. It is because to display integers, variables and so on, we don't use quotation marks.|||Output:|||In the above example, notice the line,||||||Here, we have used the + operator to concatenate (join) the two strings: ""I am "" and ""awesome."".|||And also, the line,|||Here, first the value of variable number is evaluated. Then, the value is concatenated to the string: ""Number = "".|||Java provides different ways to get input from the user. However, in this tutorial, you will learn to get input from user using the object of Scanner class.|||In order to use the object of Scanner, we need to import java.util.Scanner package.|||To learn more about importing packages in Java, visit Java Import Packages.|||Then, we need to create an object of the Scanner class. We can use the object to take input from the user.|||Output:|||In the above example, we have created an object named input of the Scanner class. We then call the nextInt() method of the Scanner class to get an integer input from the user.|||Similarly, we can use nextLong(), nextFloat(), nextDouble(), and next() methods to get long, float, double, and string input respectively from the user.|||Note: We have used the close() method to close the object. It is recommended to close the scanner object once the input is taken.|||Output:|||As mentioned, there are other several ways to get input from the user. To learn more about Scanner, visit Java Scanner.","System is a class$$$out is a public static field: it accepts output data.$$$print() - It prints string inside the quotes.$$$println() - It prints string inside the quotes similar like print() method. Then the cursor moves to the beginning of the next line.$$$printf() - It provides string formatting (similar to printf in C/C++ programming).$$$Java Output$$$Difference between println(), print() and printf()$$$Printing Variables and Literals$$$Print Concatenated Strings$$$Java Input$$$Get Integer Input From the User$$$Get float, double and String Input",,
https://www.programiz.com/java-programming/expressions-statements-blocks,"Java Expressions, Statements and Blocks",Java Expressions$$$Java Statements$$$Java Blocks$$$Expression statements$$$Declaration Statements$$$Table of Contents,,"In this tutorial, you will learn about Java expressions, Java statements, difference between expression and statement, and Java blocks with the help of examples.|||In previous chapters, we have used expressions, statements, and blocks without much explaining about them. Now that you know about variables, operators, and literals, it will be easier to understand these concepts.|||A Java expression consists of variables, operators, literals, and method calls. To know more about method calls, visit Java methods. For example,|||Here, score = 90 is an expression that returns an int. Consider another example,|||Here, a + b - 3.4 is an expression.|||Here, number1 == number2 is an expression that returns a boolean value. Similarly, ""Number 1 is larger than number 2"" is a string expression.|||In Java, each statement is a complete unit of execution. For example,|||Here, we have a statement. The complete execution of this statement involves multiplying integers 9 and 5 and then assigning the result to the variable score.|||In the above statement, we have an expression 9 * 5. In Java, expressions are part of statements.|||We can convert an expression into a statement by terminating the expression with a ;. These are known as expression statements. For example,|||In the above example, we have an expression number = 10. Here, by adding a semicolon (;), we have converted the expression into a statement (number = 10;).|||Consider another example,||||||Similarly, ++number is an expression whereas ++number; is a statement.|||In Java, declaration statements are used for declaring variables. For example,|||The statement above declares a variable tax which is initialized to 9.5.|||Note: There are control flow statements that are used in decision making and looping in Java. You will learn about control flow statements in later chapters.|||A block is a group of statements (zero or more) that is enclosed in curly braces { }. For example,|||Output:|||In the above example, we have a block if {....}.|||Here, inside the block we have two statements:|||However, a block may not have any statements. Consider the following examples,|||This is a valid Java program. Here, we have a block if {...}. However, there is no any statement inside this block.|||Here, we have block public static void main() {...}. However, similar to the above example, this block does not have any statement.","System.out.print(""Hey "");$$$System.out.print(""Jude!"");$$$Java Expressions$$$Java Statements$$$Expression statements$$$Declaration Statements$$$Java Blocks",,
https://www.programiz.com/java-programming/comments,Java Comments: Why and How to Use them?,Types of Comments in Java$$$Use Comments the Right Way$$$Single-line Comment$$$Multi-line Comment$$$Table of Contents,,"In this tutorial, you will learn about Java comments, why we use them, and how to use comments in right way.|||In computer programming, comments are a portion of the program that are completely ignored by Java compilers. They are mainly used to help programmers to understand the code. For example,|||Here, we have used the following comments,|||In Java, there are two types of comments:|||A single-line comment starts and ends in the same line. To write a single-line comment, we can use the // symbol. For example,|||Output:|||Here, we have used two single-line comments:|||The Java compiler ignores everything from // to the end of line. Hence, it is also known as End of Line comment.||||||When we want to write comments in multiple lines, we can use the multi-line comment. To write multi-line comments, we can use the /*....*/ symbol. For example,|||Output:|||Here, we have used the multi-line comment:|||This type of comment is also known as Traditional Comment. In this type of comment, the Java compiler ignores everything from /* to */.|||One thing you should always consider that comments shouldn't be the substitute for a way to explain poorly written code in English. You should always write well structured and self explaining code. And, then use comments.|||Some believe that code should be self-describing and comments should be rarely used. However, in my personal opinion, there is nothing wrong with using comments. We can use comments to explain complex algorithms, regex or scenarios where we have to choose one technique among different technique to solve problems.|||Note: In most cases, always use comments to explain 'why' rather than 'how' and you are good to go.","declare and initialize two variables$$$print the output$$$single-line comment$$$multi-line comment$$$""Hello, World!"" program example$$$prints ""Hello World!""$$$What is Comment?$$$Single-line Comment$$$Multi-line Comment$$$Use Comments the Right Way",,
https://www.programiz.com/java-programming/if-else-statement,Java if...else (With Examples),1. Java if (if-then) Statement$$$2. Java if...else (if-then-else) Statement$$$3. Java if...else...if Statement$$$4. Java Nested if..else Statement$$$Working of if Statement$$$Example 1: Java if Statement$$$Example 2: Java if with String$$$How the if...else statement works?$$$Example 3: Java if...else Statement$$$How the if...else...if ladder works?$$$Example 4: Java if...else...if Statement$$$Example 5: Nested if...else Statement$$$Table of Contents,,"In this tutorial, you will learn about control flow statements using Java if and if...else statements with the help of examples.|||In programming, we use the if..else statement to run a block of code among more than one alternatives.|||For example, assigning grades (A, B, C) based on the percentage obtained by a student.|||The syntax of an if-then statement is:|||Here, condition is a boolean expression such as age >= 18.|||Output|||In the program, number < 0 is false. Hence, the code inside the parenthesis is skipped.|||Note: If you want to learn more about about test conditions, visit Java Relational Operators and Java Logical Operators.|||We can also use Java Strings as the test condition.|||Output|||In the above example, we are comparing two strings in the if block.|||The if statement executes a certain section of code if the test expression is evaluated to true. However, if the test expression is evaluated to false, it does nothing.|||In this case, we can use an optional else block. Statements inside the body of else block are executed if the test expression is evaluated to false. This is known as the if-...else statement in Java.|||The syntax of the if...else statement is:|||Here, the program will do one task (codes inside if block) if the condition is true and another task (codes inside else block) if the condition is false.|||Output|||In the above example, we have a variable named number. Here, the test expression number > 0 checks if number is greater than 0.|||Since the value of the number is 10, the test expression evaluates to true. Hence code inside the body of if is executed.||||||Now, change the value of the number to a negative integer. Let's say -5.|||If we run the program with the new value of number, the output will be:|||Here, the value of number is -5. So the test expression evaluates to false. Hence code inside the body of else is executed.|||In Java, we have an if...else...if ladder, that can be used to execute one block of code among multiple other blocks.|||Here, if statements are executed from the top towards the bottom. When the test condition is true, codes inside the body of that if block is executed. And, program control jumps outside the if...else...if ladder.|||If all test expressions are false, codes inside the body of else are executed.|||Output|||In the above example, we are checking whether number is positive, negative, or zero. Here, we have two condition expressions:|||Here, the value of number is 0. So both the conditions evaluate to false. Hence the statement inside the body of else is executed.|||Note: Java provides a special operator called ternary operator, which is a kind of shorthand notation of if...else...if statement. To learn about the ternary operator, visit Java Ternary Operator.|||In Java, it is also possible to use if..else statements inside an if...else statement. It's called the nested if...else statement.|||Here's a program to find the largest of 3 numbers using the nested if...else statement.|||Output:|||In the above programs, we have assigned the value of variables ourselves to make this easier.|||However, in real-world applications, these values may come from user input data, log files, form submission, etc.","if the percentage is above 90, assign grade A$$$if the percentage is above 75, assign grade B$$$if the percentage is above 65, assign grade C$$$if condition evaluates to true, statements are executed$$$if condition evaluates to false, statements are skipped$$$number > 0 - checks if number is greater than 0$$$number < 0 - checks if number is less than 0$$$Introduction$$$Java if (if-then) Statement$$$Example: Java if Statement$$$Java if...else (if-then-else) Statement$$$Example: Java if else Statement$$$Java if..else..if Statement$$$Example: Java if..else..if Statement$$$Java Nested if..else Statement",,
https://www.programiz.com/java-programming/switch-statement,Java switch Statement (With Examples),Example: Java switch Statement$$$Flowchart of switch Statement$$$break statement in Java switch...case$$$default case in Java switch-case$$$Table of Contents,,"In this tutorial, you will learn to use the switch statement in Java to control the flow of your program’s execution with the help of examples.|||The switch statement allows us to execute a block of code among many alternatives.|||The syntax of the switch statement in Java is:|||How does the switch-case statement work?|||The expression is evaluated once and compared with the values of each case.|||Note: The working of the switch-case statement is similar to the Java if...else...if ladder. However, the syntax of the switch statement is cleaner and much easier to read and write.|||Output:|||In the above example, we have used the switch statement to find the size. Here, we have a variable number. The variable is compared with the value of each case statement.|||Since the value matches with 44, the code of case 44 is executed.|||Here, the size variable is assigned with the value Large.|||Recommended Reading: Create a Simple Calculator Using the Java switch Statement|||Notice that we have been using break in each case block.|||The break statement is used to terminate the switch-case statement. If break is not used, all the cases after the matching case are also executed. For example,||||||Output|||In the above example, expression matches with case 2. Here, we haven't used the break statement after each case.|||Hence, all the cases after case 2 are also executed.|||This is why the break statement is needed to terminate the switch-case statement after the matching case. To learn more, visit Java break Statement.|||The switch statement also includes an optional default case. It is executed when the expression doesn't match any of the cases. For example,|||Output|||In the above example, we have created a switch-case statement. Here, the value of expression doesn't match with any of the cases.|||Hence, the code inside the default case is executed.|||Note: The Java switch statement only works with:","If expression matches with value1, the code of case value1 are executed. Similarly, the code of case value2 is executed if expression matches with value2.$$$If there is no match, the code of the default case is executed.$$$Primitive data types: byte, short, char, and int$$$Enumerated types$$$String Class$$$Wrapper Classes: Character, Byte, Short, and Integer.$$$Java Switch Statement$$$Example: switch statement$$$Flowchart of switch...case$$$break statement$$$default case",,
https://www.programiz.com/java-programming/for-loop,Java for Loop (With Examples),Java for Loop$$$Java for-each Loop$$$Example 1: Display a Text Five Times$$$Example 2: Display numbers from 1 to 5$$$Example 3: Display Sum of n Natural Numbers$$$Java Infinite for Loop$$$Table of Contents,,"In this tutorial, we will learn how to use for loop in Java with the help of examples and we will also learn about the working of Loop in computer programming.|||In computer programming, loops are used to repeat a block of code. For example, if you want to show a message 100 times, then rather than typing the same code 100 times, you can use a loop.|||In Java, there are three types of loops.|||This tutorial focuses on the for loop. You will learn about the other type of loops in the upcoming tutorials.|||Java for loop is used to run a block of code for a certain number of times. The syntax of for loop is:|||Here,|||To learn more about the conditions, visit Java relational and logical operators.|||Output|||Here is how this program works.||||||Output|||Here is how the program works.|||Output:|||Here, the value of sum is 0 initially. Then, the for loop is iterated from i = 1 to 1000. In each iteration, i is added to sum and its value is increased by 1.|||When i becomes 1001, the test condition is false and sum will be equal to 0 + 1 + 2 + .... + 1000.|||The above program to add the sum of natural numbers can also be written as|||The output of this program is the same as the Example 3.|||The Java for loop has an alternative syntax that makes it easy to iterate through arrays and collections. For example,|||Output|||Here, we have used the for-each loop to print each element of the numbers array one by one.|||In the first iteration of the loop, number will be 3, number will be 7 in second iteration and so on.|||To learn more, visit Java for-each Loop.|||If we set the test expression in such a way that it never evaluates to false, the for loop will run forever. This is called infinite for loop. For example,|||Here, the test expression ,i <= 10, is never false and Hello is printed repeatedly until the memory runs out.",for loop$$$while loop$$$do...while loop$$$Introduction$$$Java for Loop$$$for Loop Flowchart$$$Example: Print Text 5 Times$$$Example: Sum of Natural Numbers$$$infinite for Loop,"The initialExpression initializes and/or declares variables and executes only once.$$$The condition is evaluated. If the condition is true, the body of the for loop is executed.$$$The updateExpression updates the value of initialExpression.$$$The condition is evaluated again. The process continues until the condition is false.",Iteration|||Variable|||Condition: i <= n|||Action$$$1st|||i = 1n = 5|||true|||Java is fun is printed.i is increased to 2.$$$2nd|||i = 2n = 5|||true|||Java is fun is printed.i is increased to 3.$$$3rd|||i = 3n = 5|||true|||Java is fun is printed.i is increased to 4.$$$4th|||i = 4n = 5|||true|||Java is fun is printed.i is increased to 5.$$$5th|||i = 5n = 5|||true|||Java is fun is printed.i is increased to 6.$$$6th|||i = 6n = 5|||false|||The loop is terminated.$$$Iteration|||Variable|||Condition: i <= n|||Action$$$1st|||i = 1n = 5|||true|||1 is printed.i is increased to 2.$$$2nd|||i = 2n = 5|||true|||2 is printed.i is increased to 3.$$$3rd|||i = 3n = 5|||true|||3 is printed.i is increased to 4.$$$4th|||i = 4n = 5|||true|||4 is printed.i is increased to 5.$$$5th|||i = 5n = 5|||true|||5 is printed.i is increased to 6.$$$6th|||i = 6n = 5|||false|||The loop is terminated.
https://www.programiz.com/java-programming/enhanced-for-loop,Java for-each Loop (With Examples),for-each Loop Sytnax$$$Example 1: Print Array Elements$$$Example 2: Sum of Array Elements$$$for loop Vs for-each loop$$$1. Using for loop$$$2. Using for-each Loop$$$Table of Contents,,"In this tutorial, we will learn about the Java for-each loop and its difference with for loop with the help of examples.|||In Java, the for-each loop is used to iterate through elements of arrays and collections (like ArrayList). It is also known as the enhanced for loop.|||The syntax of the Java for-each loop is:|||Here,|||Output|||Here, we have used the for-each loop to print each element of the numbers array one by one.|||Output:||||||In the above program, the execution of the for each loop looks as:|||As we can see, we have added each element of the numbers array to the sum variable in each iteration of the loop.|||Let's see how a for-each loop is different from a regular Java for loop.|||Output:|||Output:|||Here, the output of both programs is the same. However, the for-each loop is easier to write and understand.|||This is why the for-each loop is preferred over the for loop when working with arrays and collections.","array - an array or a collection$$$item - each item of array/collection is assigned to this variable$$$dataType - the data type of the array/collection$$$In the first iteration, item will be 3.$$$In the second iteration, item will be 9.$$$In the third iteration, item will be 5.$$$In the fourth iteration, item will be -5.$$$Introduction$$$Working of for each Loop$$$Example: for-each loop$$$for loop Vs for-each loop$$$Disadvantages of for-each Loop",,Iteration|||Variables$$$1|||number = 3sum = 0 + 3 = 3$$$2|||number = 4sum = 3 + 4 = 7$$$3|||number = 5sum = 7 + 5 = 12$$$4|||number = -5sum = 12 + (-5) = 7$$$5|||number = 0sum = 7 + 0 = 7$$$6|||number = 12sum = 7 + 12 = 19
https://www.programiz.com/java-programming/do-while-loop,Java while and do...while Loop,Java while loop$$$Flowchart of while loop$$$Java do...while loop$$$for and while loops$$$Example 1: Display Numbers from 1 to 5$$$Example 2: Sum of Positive Numbers Only$$$Flowchart of do...while loop$$$Example 3: Display Numbers from 1 to 5$$$Example 4: Sum of Positive Numbers$$$Infinite while loop$$$Table of Contents,,"In this tutorial, we will learn how to use while and do while loop in Java with the help of examples.|||In computer programming, loops are used to repeat a block of code. For example, if you want to show a message 100 times, then you can use a loop. It's just a simple example; you can achieve much more with loops.|||In the previous tutorial, you learned about Java for loop. Here, you are going to learn about while and do...while loops.|||Java while loop is used to run a specific code until a certain condition is met. The syntax of the while loop is:|||Here,|||To learn more about the conditions, visit Java relational and logical operators.|||Output|||Here is how this program works.|||Output|||In the above program, we have used the Scanner class to take input from the user. Here, nextInt() takes integer input from the user.|||The while loop continues until the user enters a negative number. During each iteration, the number entered by the user is added to the sum variable.|||When the user enters a negative number, the loop terminates. Finally, the total sum is displayed.|||The do...while loop is similar to while loop. However, the body of do...while loop is executed once before the test expression is checked. For example,|||Here,||||||Let's see the working of do...while loop.|||Output|||Here is how this program works.|||Output 1|||Here, the user enters a positive number, that number is added to the sum variable. And this process continues until the number is negative. When the number is negative, the loop terminates and displays the sum without adding the negative number.|||Output 2|||Here, the user enters a negative number. The test condition will be false but the code inside of the loop executes once.|||If the condition of a loop is always true, the loop runs for infinite times (until the memory is full). For example,|||Here is an example of an infinite do...while loop.|||In the above programs, the textExpression is always true. Hence, the loop body will run for infinite times.|||The for loop is used when the number of iterations is known. For example,|||And while and do...while loops are generally used when the number of iterations is unknown. For example,",Introduction$$$Java while Loop$$$Flowchart of while Loop$$$Example: while Loop$$$Java do...while Loop$$$Flowchart of do...while Loop$$$Example: do...while Loop$$$Infinite while Loop$$$Java for vs while loop,"A while loop evaluates the textExpression inside the parenthesis ().$$$If the textExpression evaluates to true, the code inside the while loop is executed.$$$The textExpression is evaluated again.$$$This process continues until the textExpression is false.$$$When the textExpression evaluates to false, the loop stops.$$$The body of the loop is executed at first. Then the textExpression is evaluated.$$$If the textExpression evaluates to true, the body of the loop inside the do statement is executed again.$$$The textExpression is evaluated once again.$$$If the textExpression evaluates to true, the body of the loop inside the do statement is executed again.$$$This process continues until the textExpression evaluates to false. Then the loop stops.",Iteration|||Variable|||Condition: i <= n|||Action$$$1st|||i = 1n = 5|||true|||1 is printed.i is increased to 2.$$$2nd|||i = 2n = 5|||true|||2 is printed.i is increased to 3.$$$3rd|||i = 3n = 5|||true|||3 is printed.i is increased to 4.$$$4th|||i = 4n = 5|||true|||4 is printed.i is increased to 5.$$$5th|||i = 5n = 5|||true|||5 is printed.i is increased to 6.$$$6th|||i = 6n = 5|||false|||The loop is terminated$$$Iteration|||Variable|||Condition: i <= n|||Action$$$ |||i = 1n = 5|||not checked|||1 is printed.i is increased to 2.$$$1st|||i = 2n = 5|||true|||2 is printed.i is increased to 3.$$$2nd|||i = 3n = 5|||true|||3 is printed.i is increased to 4.$$$3rd|||i = 4n = 5|||true|||4 is printed.i is increased to 5.$$$4th|||i = 5n = 5|||true|||6 is printed.i is increased to 6.$$$5th|||i = 6n = 5|||false|||The loop is terminated
https://www.programiz.com/java-programming/break-statement,Java break Statement (With Examples),How break statement works?$$$Java break and Nested Loop$$$Labeled break Statement$$$Example 1: Java break statement$$$Example 2: Java break statement$$$Example 3: labeled break Statement$$$Table of Contents,,"In this tutorial, you will learn about the break statement, labeled break statement in Java with the help of examples.|||While working with loops, it is sometimes desirable to skip some statements inside the loop or terminate the loop immediately without checking the test expression.|||In such cases, break and continue statements are used. You will learn about the Java continue statement in the next tutorial.|||The break statement in Java terminates the loop immediately, and the control of the program moves to the next statement following the loop.|||It is almost always used with decision-making statements (Java if...else Statement).|||Here is the syntax of the break statement in Java:|||Output:|||In the above program, we are using the for loop to print the value of i in each iteration. To know how for loop works, visit the Java for loop. Here, notice the statement,|||This means when the value of i is equal to 5, the loop terminates. Hence we get the output with values less than 5 only.|||The program below calculates the sum of numbers entered by the user until user enters a negative number.|||To take input from the user, we have used the Scanner object. To learn more about Scanner, visit Java Scanner.|||Output:|||In the above program, the test expression of the while loop is always true. Here, notice the line,|||This means when the user input negative numbers, the while loop is terminated.||||||In the case of nested loops, the break statement terminates the innermost loop.|||Here, the break statement terminates the innermost while loop, and control jumps to the outer loop.|||Till now, we have used the unlabeled break statement. It terminates the innermost loop and switch statement. However, there is another form of break statement in Java known as the labeled break.|||We can use the labeled break statement to terminate the outermost loop as well.|||As you can see in the above image, we have used the label identifier to specify the outer loop. Now, notice how the break statement is used (break label;).|||Here, the break statement is terminating the labeled statement (i.e. outer loop). Then, the control of the program jumps to the statement after the labeled statement.|||Here's another example:|||In the above example, when the statement break second; is executed, the while loop labeled as second is terminated. And, the control of the program moves to the statement after the second while loop.|||Output:|||In the above example, the labeled break statement is used to terminate the loop labeled as first. That is,|||Here, if we change the statement break first; to break second; the program will behave differently. In this case, for loop labeled as second will be terminated. For example,|||Output:|||Note: The break statement is also used to terminate cases inside the switch statement. To learn more, visit the Java switch statement.",Introduction$$$How break statement works?$$$Example: Java break statement$$$Java break and Nested Loop$$$Labeled break Statement$$$Example: labeled break Statement,,
https://www.programiz.com/java-programming/continue-statement,Java continue Statement (With Examples),Java continue$$$Working of Java continue statement$$$Java continue with Nested Loop$$$Labeled continue Statement$$$Example 1: Java continue statement$$$Example 2: Compute the sum of 5 positive numbers$$$Example 3: continue with Nested Loop$$$Example 4: labeled continue Statement$$$Table of Contents,,"In this tutorial, you will learn about the continue statement and labeled continue statement in Java with the help of examples.|||While working with loops, sometimes you might want to skip some statements or terminate the loop. In such cases, break and continue statements are used.|||To learn about the break statement, visit Java break. Here, we will learn about the continue statement.|||The continue statement skips the current iteration of a loop (for, while, do...while, etc).|||After the continue statement, the program moves to the end of the loop. And, test expression is evaluated (update statement is evaluated in case of the for loop).|||Here's the syntax of the continue statement.|||Note: The continue statement is almost always used in decision-making statements (if...else Statement).|||Output:|||In the above program, we are using the for loop to print the value of i in each iteration. To know how for loop works, visit Java for loop. Notice the statement,|||Here, the continue statement is executed when the value of i becomes more than 4 and less than 9.|||It then skips the print statement for those values. Hence, the output skips the values 5, 6, 7, and 8.|||Output:|||In the above example, we have used the for loop to print the sum of 5 positive numbers. Notice the line,|||Here, when the user enters a negative number, the continue statement is executed. This skips the current iteration of the loop and takes the program control to the update expression of the loop.|||Note: To take input from the user, we have used the Scanner object. To learn more, visit Java Scanner.|||In the case of nested loops in Java, the continue statement skips the current iteration of the innermost loop.||||||Output|||In the above example, we have used the nested while loop. Note that we have used the continue statement inside the inner loop.|||Here, when the value of j is 2, the value of j is increased and the continue statement is executed.|||This skips the iteration of the inner loop. Hence, the text Inner Loop: 2 is skipped from the output.|||Till now, we have used the unlabeled continue statement. However, there is another form of continue statement in Java known as labeled continue.|||It includes the label of the loop along with the continue keyword. For example,|||Here, the continue statement skips the current iteration of the loop specified by label.|||We can see that the label identifier specifies the outer loop. Notice the use of the continue inside the inner loop.|||Here, the continue statement is skipping the current iteration of the labeled statement (i.e. outer loop). Then, the program control goes to the next iteration of the labeled statement.|||Output:|||In the above example, the labeled continue statement is used to skip the current iteration of the loop labeled as first.|||Here, we can see the outermost for loop is labeled as first,|||Hence, the iteration of the outer for loop is skipped if the value of i is 3 or the value of j is 2.|||Note: The use of labeled continue is often discouraged as it makes your code hard to understand. If you are in a situation where you have to use labeled continue, refactor your code and try to solve it in a different way to make it more readable.",Java continue$$$Working of Java continue statement$$$Example: Java continue statement$$$Java continue with Nested Loop$$$Example: continue with Nested Loop$$$Labeled continue Statement$$$Example: labeled continue Statement,,
https://www.programiz.com/java-programming/arrays,Java Array (With Examples),How to declare an array in Java?$$$How to Initialize Arrays in Java?$$$How to Access Elements of an Array in Java?$$$Looping Through Array Elements$$$Example: Compute Sum and Average of Array Elements$$$Example: Access Array Elements$$$Example: Using For Loop$$$Example: Using the for-each Loop$$$Multidimensional Arrays$$$Recommended Readings$$$Table of Contents,,"In this tutorial, we will learn to work with arrays in Java. We will learn to declare, initialize, and access array elements with the help of examples.|||An array is a collection of similar types of data.|||For example, if we want to store the names of 100 people then we can create an array of the string type that can store 100 names.|||Here, the above array cannot store more than 100 names. The number of values in a Java array is always fixed.|||In Java, here is how we can declare an array.|||For example,|||Here, data is an array that can hold values of type double.|||But, how many elements can array this hold?|||Good question! To define the number of elements that an array can hold, we have to allocate memory for the array in Java. For example,|||Here, the array can store 10 elements. We can also say that the size or length of the array is 10.|||In Java, we can declare and allocate the memory of an array in one single statement. For example,|||In Java, we can initialize arrays during declaration. For example,|||Here, we have created an array named age and initialized it with the values inside the curly brackets.|||Note that we have not provided the size of the array. In this case, the Java compiler automatically specifies the size by counting the number of elements in the array (i.e. 5).|||In the Java array, each memory location is associated with a number. The number is known as an array index. We can also initialize arrays in Java, using the index number. For example,|||Note:|||We can access the element of an array using the index number. Here is the syntax for accessing elements of an array,|||Let's see an example of accessing array elements using index numbers.|||Output||||||In the above example, notice that we are using the index number to access each element of the array.|||We can use loops to access all the elements of the array at once.|||In Java, we can also loop through each element of the array. For example,|||Output|||In the above example, we are using the for Loop in Java to iterate through each element of the array. Notice the expression inside the loop,|||Here, we are using the length property of the array to get the size of the array.|||We can also use the for-each loop to iterate through the elements of an array. For example,|||Output|||Output:|||In the above example, we have created an array of named numbers. We have used the for...each loop to access each element of the array.|||Inside the loop, we are calculating the sum of each element. Notice the line,|||Here, we are using the length attribute of the array to calculate the size of the array. We then calculate the average using:|||As you can see, we are converting the int value into double. This is called type casting in Java. To learn more about typecasting, visit Java Type Casting.|||Arrays we have mentioned till now are called one-dimensional arrays. However, we can declare multidimensional arrays in Java.|||A multidimensional array is an array of arrays. That is, each element of a multidimensional array is an array itself. For example,|||Here, we have created a multidimensional array named matrix. It is a 2-dimensional array. To learn more, visit the Java multidimensional array.","dataType - it can be primitive data types like int, char, double, byte, etc. or Java objects$$$arrayName - it is an identifier$$$Array indices always start from 0. That is, the first element of an array is at index 0.$$$If the size of an array is n, then the last element of the array will be at index n-1.$$$Java Copy Array$$$Java Program to Print an Array$$$Java Program to Concatenate two Arrays$$$Java ArrayList to Array and Array to ArrayList$$$Java Dynamic Array$$$Introduction$$$How to declare an array in Java?$$$How to Initialize Arrays in Java?$$$How to Access Elements of an Array in Java?$$$Looping Through Array Elements$$$Example: Compute Sum and Average of Array Elements$$$Multidimensional Arrays",,
https://www.programiz.com/java-programming/multidimensional-array,Java Multidimensional Array (2d and 3d Array),How to initialize a 2d array in Java?$$$How to initialize a 3d array in Java?$$$Example: 2-dimensional Array$$$Example: Print all elements of 2d array Using Loop$$$Example: 3-dimensional Array$$$Table of Contents,,"In this tutorial, we will learn about the Java multidimensional array using 2-dimensional arrays and 3-dimensional arrays with the help of examples.|||Before we learn about the multidimensional array, make sure you know about Java array.|||A multidimensional array is an array of arrays. Each element of a multidimensional array is an array itself. For example,|||Here, we have created a multidimensional array named a. It is a 2-dimensional array, that can hold a maximum of 12 elements,|||Remember, Java uses zero-based indexing, that is, indexing of arrays in Java starts with 0 and not 1.|||Let's take another example of the multidimensional array. This time we will be creating a 3-dimensional array. For example,|||Here, data is a 3d array that can hold a maximum of 24 (3*4*2) elements of type String.|||Here is how we can initialize a 2-dimensional array in Java.|||As we can see, each element of the multidimensional array is an array itself. And also, unlike C/C++, each row of the multidimensional array in Java can be of different lengths.|||Output:|||In the above example, we are creating a multidimensional array named a. Since each component of a multidimensional array is also an array (a[0], a[1] and a[2] are also arrays).||||||Here, we are using the length attribute to calculate the length of each row.|||Output:|||We can also use the for...each loop to access elements of the multidimensional array. For example,|||Output:|||In the above example, we are have created a 2d array named a. We then used for loop and for...each loop to access each element of the array.|||Let's see how we can use a 3d array in Java. We can initialize a 3d array similar to the 2d array. For example,|||Basically, a 3d array is an array of 2d arrays. The rows of a 3d array can also vary in length just like in a 2d array.|||Output:",Java Multidimensional Array$$$2-dimensional array in Java$$$Example: 2d Array$$$3-dimensional array in Java$$$Example: 3d Array,,
https://www.programiz.com/java-programming/copy-arrays,"Java Copy Arrays (Using System arraycopy(), Looping construct and so on)",1. Copying Arrays Using Assignment Operator$$$2. Using Looping Construct to Copy Arrays$$$3. Copying Arrays Using arraycopy() method$$$4. Copying Arrays Using copyOfRange() method$$$5. Copying 2d Arrays Using Loop$$$Copying 2d Arrays using arraycopy()$$$Table of Contents,,"In this tutorial, you will learn about different ways you can use to copy arrays (both one dimensional and two-dimensional) in Java with the help of examples.|||In Java, we can copy one array into another. There are several techniques you can use to copy arrays in Java.|||Let's take an example,|||Output:|||In the above example, we have used the assignment operator (=) to copy an array named numbers to another array named positiveNumbers.|||This technique is the easiest one and it works as well. However, there is a problem with this technique. If we change elements of one array, corresponding elements of the other arrays also change. For example,|||Output:|||Here, we can see that we have changed one value of the numbers array. When we print the positiveNumbers array, we can see that the same value is also changed.|||It's because both arrays refer to the same array object. This is because of the shallow copy. To learn more about shallow copy, visit shallow copy.|||Now, to make new array objects while copying the arrays, we need deep copy rather than a shallow copy.|||Let's take an example:|||Output:|||In the above example, we have used the for loop to iterate through each element of the source array. In each iteration, we are copying elements from the source array to the destination array.|||Here, the source and destination array refer to different objects (deep copy). Hence, if elements of one array are changed, corresponding elements of another array is unchanged.|||Notice the statement,|||Here, the toString() method is used to convert an array into a string. To learn more, visit the toString() method (official Java documentation).|||In Java, the System class contains a method named arraycopy() to copy arrays. This method is a better approach to copy arrays than the above two.|||The arraycopy() method allows you to copy a specified portion of the source array to the destination array. For example,||||||Here,|||Let's take an example:|||Output:|||In the above example, we have used the arraycopy() method,|||As you can see, the default initial value of elements of an int type array is 0.|||We can also use the copyOfRange() method defined in Java Arrays class to copy arrays. For example,|||Output|||In the above example, notice the line,|||Here, we can see that we are creating the destination1 array and copying the source array to it at the same time. We are not creating the destination1 array before calling the copyOfRange() method. To learn more about the method, visit Java copyOfRange.|||Similar to the single-dimensional array, we can also copy the 2-dimensional array using the for loop. For example,|||Output:|||In the above program, notice the line,|||Here, the deepToString() method is used to provide a better representation of the 2-dimensional array. To learn more, visit Java deepToString().|||To make the above code more simpler, we can replace the inner loop with System.arraycopy() as in the case of a single-dimensional array. For example,|||Output:|||Here, we can see that we get the same output by replacing the inner for loop with the arraycopy() method.","src - source array you want to copy$$$srcPos - starting position (index) in the source array$$$dest - destination array where elements will be copied from the source$$$destPos - starting position (index) in the destination array$$$length - number of elements to copy$$$System.arraycopy(n1, 0, n2, 0, n1.length) - entire elements from the n1 array are copied to n2 array$$$System.arraycopy(n1, 2, n3, 1, 2) - 2 elements of the n1 array starting from index 2 are copied to the index starting from 1 of the n3 array$$$Copying Arrays Using Assignment Operator$$$Using Looping Construct$$$Using the arraycopy() Method$$$Using the copyOfRange() Method$$$Copying 2d Arrays Using Loop$$$Using arraycopy()",,
https://www.programiz.com/java-programming/class-objects,Java Class and Objects (With Example),Java Class$$$Create a class in Java$$$Java Objects$$$Access Members of a Class$$$Example: Java Class and Objects$$$Example: Create objects inside the same class$$$Creating an Object in Java$$$Table of Contents,,"In this tutorial, you will learn about the concept of classes and objects in Java with the help of examples.|||Java is an object-oriented programming language. The core concept of the object-oriented approach is to break complex problems into smaller objects.|||An object is any entity that has a state and behavior. For example, a bicycle is an object. It has|||Before we learn about objects, let's first know about classes in Java.|||A class is a blueprint for the object. Before we create an object, we first need to define the class.|||We can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object.|||Since many houses can be made from the same description, we can create many objects from a class.|||We can create a class in Java using the class keyword. For example,|||Here, fields (variables) and methods represent the state and behavior of the object respectively.|||For our bicycle object, we can create the class as|||In the above example, we have created a class named Bicycle. It contains a field named gear and a method named braking().|||Here, Bicycle is a prototype. Now, we can create any number of bicycles using the prototype. And, all the bicycles will share the fields and methods of the prototype.|||Note: We have used keywords private and public. These are known as access modifiers. To learn more, visit Java access modifiers.|||An object is called an instance of a class. For example, suppose Bicycle is a class then MountainBicycle, SportsBicycle, TouringBicycle, etc can be considered as objects of the class.|||Here is how we can create an object of a class.|||We have used the new keyword along with the constructor of the class to create an object. Constructors are similar to methods and have the same name as the class. For example, Bicycle() is the constructor of the Bicycle class. To learn more, visit Java Constructors.||||||Here, sportsBicycle and touringBicycle are the names of objects. We can use them to access fields and methods of the class.|||As you can see, we have created two objects of the class. We can create multiple objects of a single class in Java.|||Note: Fields and methods of a class are also called members of the class.|||We can use the name of objects along with the . operator to access members of a class. For example,|||In the above example, we have created a class named Bicycle. It includes a field named gear and a method named braking(). Notice the statement,|||Here, we have created an object of Bicycle named sportsBicycle. We then use the object to access the field and method of the class.|||We have mentioned the word method quite a few times. You will learn about Java methods in detail in the next chapter.|||Now that we understand what is class and object. Let's see a fully working example.|||Output:|||In the above program, we have created a class named Lamp. It contains a variable: isOn and two methods: turnOn() and turnOff().|||Inside the Main class, we have created two objects: led and halogen of the Lamp class. We then used the objects to call the methods of the class.|||The variable isOn defined inside the class is also called an instance variable. It is because when we create an object of the class, it is called an instance of the class. And, each instance will have its own copy of the variable.|||That is, led and halogen objects will have their own copy of the isOn variable.|||Note that in the previous example, we have created objects inside another class and accessed the members from that class.|||However, we can also create objects inside the same class.|||Output|||Here, we are creating the object inside the main() method of the same class.","States: idle, first gear, etc$$$Behaviors: braking, accelerating, etc.$$$fields are used to store data$$$methods are used to perform some operations$$$sportsBicycle.gear - access the field gear$$$sportsBicycle.braking() - access the method braking()$$$led.turnOn() - It sets the isOn variable to true and prints the output.$$$halogen.turnOff() - It sets the isOn variable to false and prints the output.$$$Introduction$$$Java Class$$$Create a class in Java$$$Java Objects$$$Access Members of a Class$$$Example: Java Class and Objects$$$Example: Create objects inside a class",,
https://www.programiz.com/java-programming/methods,Java Methods (With Examples),Java Methods$$$Declaring a Java Method$$$Calling a Method in Java$$$Example 1: Java Methods$$$Java Method Return Type$$$Method Parameters in Java$$$Standard Library Methods$$$What are the advantages of using methods?$$$Example 2: Method Return Type$$$Example 3: Method Parameters$$$Example 4: Java Standard Library Method$$$Example 5: Java Method for Code Reusability$$$Table of Contents,,"In this tutorial, we will learn about Java methods, how to define methods, and how to use methods in Java programs with the help of examples.|||A method is a block of code that performs a specific task.|||Suppose you need to create a program to create a circle and color it. You can create two methods to solve this problem:|||Dividing a complex problem into smaller chunks makes your program easy to understand and reusable.|||In Java, there are two types of methods:|||Let's first learn about user-defined methods.|||The syntax to declare a method is:|||Here,|||For example,|||In the above example, the name of the method is adddNumbers(). And, the return type is int. We will learn more about return types later in this tutorial.|||This is the simple syntax of declaring a method. However, the complete syntax of declaring a method is|||Here,|||In the above example, we have declared a method named addNumbers(). Now, to use the method, we need to call it.|||Here's is how we can call the addNumbers() method.|||Output|||In the above example, we have created a method named addNumbers(). The method takes two parameters a and b. Notice the line,|||Here, we have called the method by passing two arguments num1 and num2. Since the method is returning some value, we have stored the value in the result variable.|||Note: The method is not static. Hence, we are calling the method using the object of the class.|||A Java method may or may not return a value to the function call. We use the return statement to return any value. For example,|||Here, we are returning the variable sum. Since the return type of the function is int. The sum variable should be of int type. Otherwise, it will generate an error.|||Output:||||||In the above program, we have created a method named square(). The method takes a number as its parameter and returns the square of the number.|||Here, we have mentioned the return type of the method as int. Hence, the method should always return an integer value.|||Note: If the method does not return any value, we use the void keyword as the return type of the method. For example,|||A method parameter is a value accepted by the method. As mentioned earlier, a method can also have any number of parameters. For example,|||If a method is created with parameters, we need to pass the corresponding values while calling the method. For example,|||Output|||Here, the parameter of the method is int. Hence, if we pass any other data type instead of int, the compiler will throw an error. It is because Java is a strongly typed language.|||Note: The argument 24 passed to the display2() method during the method call is called the actual argument.|||The parameter num accepted by the method definition is known as a formal argument. We need to specify the type of formal arguments. And, the type of actual arguments and formal arguments should always match.|||The standard library methods are built-in methods in Java that are readily available for use. These standard libraries come along with the Java Class Library (JCL) in a Java archive (*.jar) file with JVM and JRE.|||For example,|||Here's a working example:|||Output:|||To learn more about standard library methods, visit Java Library Methods.|||1. The main advantage is code reusability. We can write a method once, and use it multiple times. We do not have to rewrite the entire code each time. Think of it as, ""write once, reuse multiple times"".|||Output:|||In the above program, we have created the method named getSquare() to calculate the square of a number. Here, the method is used to calculate the square of numbers less than 6.|||Hence, the same method is used again and again.|||2. Methods make code more readable and easier to debug. Here, the getSquare() method keeps the code to compute the square in a block. Hence, makes it more readable.","a method to draw the circle$$$a method to color the circle$$$User-defined Methods: We can create our own method based on our requirements.$$$Standard Library Methods: These are built-in methods in Java that are available to use.$$$returnType - It specifies what type of value a method returns For example if a method has an int return type then it returns an integer value.If the method does not return a value, its return type is void.$$$methodName - It is an identifier that is used to refer to the particular method in a program.$$$method body - It includes the programming statements that are used to perform some tasks. The method body is enclosed inside the curly braces { }.$$$modifier - It defines access types whether the method is public, private, and so on. To learn more, visit Java Access Specifier.$$$static - If we use the static keyword, it can be accessed without creating objects.For example, the sqrt() method of standard Math class is static. Hence, we can directly call Math.sqrt() without creating an instance of Math class.$$$parameter1/parameter2 - These are values passed to a method. We can pass any number of arguments to a method.$$$print() is a method of java.io.PrintSteam. The print(""..."") method prints the string inside quotation marks.$$$sqrt() is a method of Math class. It returns the square root of a number.$$$Java Methods$$$Declaring a Java Method$$$Calling a Java Method$$$Java Method Return Type$$$Method Parameters$$$Standard Library Methods$$$Advantages of Java Methods",,
https://www.programiz.com/java-programming/constructors,Java Constructors (With Examples),What is a Constructor?$$$Example 1: Java Constructor$$$1. Java No-Arg Constructors$$$2. Java Parameterized Constructor$$$3. Java Default Constructor$$$Important Notes on Java Constructors$$$Constructors Overloading in Java$$$Types of Constructor$$$Example 2: Java private no-arg constructor$$$Example 3: Java public no-arg constructors$$$Example 4: Parameterized constructor$$$Example 5: Default Constructor$$$Example 6: Java Constructor Overloading$$$Table of Contents,,"In this tutorial, we will learn about Java constructors, their types, and how to use them with the help of examples.|||A constructor in Java is similar to a method that is invoked when an object of the class is created.|||Unlike Java methods, a constructor has the same name as that of the class and does not have any return type. For example,|||Here, Test() is a constructor. It has the same name as that of the class and doesn't have a return type.|||Recommended Reading: Why do constructors not return values|||Output:|||In the above example, we have created a constructor named Main(). Inside the constructor, we are initializing the value of the name variable.|||Notice the statement of creating an object of the Main class.|||Here, when the object is created, the Main() constructor is called. And, the value of the name variable is initialized.|||Hence, the program prints the value of the name variables as Programiz.|||In Java, constructors can be divided into 3 types:|||Similar to methods, a Java constructor may or may not have any parameters (arguments).|||If a constructor does not accept any parameters, it is known as a no-argument constructor. For example,|||Output:|||In the above example, we have created a constructor Main(). Here, the constructor does not accept any parameters. Hence, it is known as a no-arg constructor.|||Notice that we have declared the constructor as private.|||Once a constructor is declared private, it cannot be accessed from outside the class. So, creating objects from outside the class is prohibited using the private constructor.|||Here, we are creating the object inside the same class. Hence, the program is able to access the constructor. To learn more, visit Java Implement Private Constructor.|||However, if we want to create objects outside the class, then we need to declare the constructor as public.||||||Output:|||Recommended Reading: Java Access Modifier|||A Java constructor can also accept one or more parameters. Such constructors are known as parameterized constructors (constructor with parameters).|||Output:|||In the above example, we have created a constructor named Main(). Here, the constructor takes a single parameter. Notice the expression,|||Here, we are passing the single value to the constructor. Based on the argument passed, the language variable is initialized inside the constructor.|||If we do not create any constructor, the Java compiler automatically create a no-arg constructor during the execution of the program. This constructor is called default constructor.|||Output:|||Here, we haven't created any constructors. Hence, the Java compiler automatically creates the default constructor.|||The default constructor initializes any uninitialized instance variables with default values.|||In the above program, the variables a and b are initialized with default value 0 and false respectively.|||The above program is equivalent to:|||The output of the program is the same as Example 5.|||Similar to Java method overloading, we can also create two or more constructors with different parameters. This is called constructors overloading.|||Output:|||In the above example, we have two constructors: Main() and Main(String language). Here, both the constructor initialize the value of the variable language with different values.|||Based on the parameter passed during object creation, different constructors are called and different values are assigned.|||It is also possible to call one constructor from another constructor. To learn more, visit Java Call One Constructor from Another.|||Note: We have used this keyword to specify the variable of the class. To know more about this keyword, visit Java this keyword.","Constructors are invoked implicitly when you instantiate objects.$$$The two rules for creating a constructor are:The name of the constructor should be the same as the class.A Java constructor must not have a return type.$$$If a class doesn't have a constructor, the Java compiler automatically creates a default constructor during run-time. The default constructor initializes instance variables with default values. For example, the int variable will be initialized to 0$$$Constructor types:No-Arg Constructor - a constructor that does not accept any argumentsParameterized constructor - a constructor that accepts argumentsDefault Constructor - a constructor that is automatically created by the Java compiler if it is not explicitly defined.$$$A constructor cannot be abstract or static or final.$$$A constructor can be overloaded but can not be overridden.$$$What is a Constructor?$$$Example: Java Constructor$$$Java No-Arg Constructors$$$Java Parameterized Constructor$$$Java Default Constructor$$$Important Notes on Java Constructors$$$Constructors Overloading in Java",No-Arg Constructor$$$Parameterized Constructor$$$Default Constructor,Type|||Default Value$$$boolean|||false$$$byte|||0$$$short|||0$$$int|||0$$$long|||0L$$$char|||\u0000$$$float|||0.0f$$$double|||0.0d$$$object|||Reference null
https://www.programiz.com/java-programming/string,Java String (With Examples),Java String Operations$$$Escape character in Java Strings$$$Java Strings are Immutable$$$Creating strings using the new keyword$$$Methods of Java String$$$Example: Create a String in Java$$$1. Get length of a String$$$2. Join Two Java Strings$$$3. Compare two Strings$$$Example: Create Java Strings using the new keyword$$$Create String using literals vs new keyword$$$Table of Contents,,"In this tutorial, we will learn about Java strings, how to create them, and various methods of the String class with the help of examples.|||In Java, a string is a sequence of characters. For example, ""hello"" is a string containing a sequence of characters 'h', 'e', 'l', 'l', and 'o'.|||We use double quotes to represent a string in Java. For example,|||Here, we have created a string variable named type. The variable is initialized with the string Java Programming.|||In the above example, we have created three strings named first, second, and third. Here, we are directly creating strings like primitive types.|||However, there is another way of creating Java strings (using the new keyword). We will learn about that later in this tutorial.|||Note: Strings in Java are not primitive types (like int, char, etc). Instead, all strings are objects of a predefined class named String.|||And, all string variables are instances of the String class.|||Java String provides various methods to perform different operations on strings. We will look into some of the commonly used string operations.|||To find the length of a string, we use the length() method of the String. For example,|||Output|||In the above example, the length() method calculates the total number of characters in the string and returns it. To learn more, visit Java String length().|||We can join two strings in Java using the concat() method. For example,|||Output|||In the above example, we have created two strings named first and second. Notice the statement,|||Here, the concat() method joins the second string to the first string and assigns it to the joinedString variable.|||We can also join two strings using the + operator in Java. To learn more, visit Java String concat().|||In Java, we can make comparisons between two strings using the equals() method. For example,|||Output|||In the above example, we have created 3 strings named first, second, and third. Here, we are using the equal() method to check if one string is equal to another.|||The equals() method checks the content of strings while comparing them. To learn more, visit Java String equals().|||Note: We can also compare two strings using the == operator in Java. However, this approach is different than the equals() method. To learn more, visit Java String == vs equals().|||The escape character is used to escape some of the characters present inside a string.|||Suppose we need to include double quotes inside a string.|||Since strings are represented by double quotes, the compiler will treat ""This is the "" as the string. Hence, the above code will cause an error.|||To solve this issue, we use the escape character \ in Java. For example,||||||Now escape characters tell the compiler to escape double quotes and read the whole text.|||In Java, strings are immutable. This means, once we create a string, we cannot change that string.|||To understand it more deeply, consider an example:|||Here, we have created a string variable named example. The variable holds the string ""Hello! "".|||Now suppose we want to change the string.|||Here, we are using the concat() method to add another string World to the previous string.|||It looks like we are able to change the value of the previous string. However, this is not true.|||Let's see what has happened here,|||So far we have created strings like primitive types in Java.|||Since strings in Java are objects, we can create strings using the new keyword as well. For example,|||In the above example, we have created a string name using the new keyword.|||Here, when we create a string object, the String() constructor is invoked. To learn more about constructor, visit Java Constructor.|||Note: The String class provides various other constructors to create strings. To learn more, visit Java String (official Java documentation).|||Now that we know how strings are created using string literals and the new keyword, let's see what is the major difference between them.|||In Java, the JVM maintains a string pool to store all of its strings inside the memory. The string pool helps in reusing the strings.|||1. While creating strings using string literals,|||Here, we are directly providing the value of the string (Java). Hence, the compiler first checks the string pool to see if the string already exists.|||2. While creating strings using the new keyword,|||Here, the value of the string is not directly provided. Hence, a new ""Java"" string is created even though ""Java"" is already present inside the memory pool.|||Besides those mentioned above, there are various string methods present in Java. Here are some of those methods:","If the string already exists, the new string is not created. Instead, the new reference, example points to the already existed string (Java).$$$If the string doesn't exist, the new string (Java is created.$$$Java String$$$Create a String in Java$$$Get Length of a String$$$Join two Strings$$$Compare two Strings$$$Escape character in Strings$$$Immutable Strings$$$Creating strings using the new keyword$$$String literals vs new keyword $$$Methods of Java String","JVM takes the first string ""Hello! ""$$$creates a new string by adding ""World"" to the first string$$$assign the new string ""Hello! World"" to the example variable$$$the first string ""Hello! "" remains unchanged",Methods|||Description$$$contains()|||checks whether the string contains a substring$$$substring()|||returns the substring of the string$$$join()|||join the given strings using the delimiter$$$replace()|||replaces the specified old character with the specified new character$$$replaceAll()|||replaces all substrings matching the regex pattern$$$replaceFirst()|||replace the first matching substring$$$charAt()|||returns the character present in the specified location$$$getBytes()|||converts the string to an array of bytes$$$indexOf()|||returns the position of the specified character in the string$$$compareTo()|||compares two strings in the dictionary order$$$compareToIgnoreCase()|||compares two strings ignoring case differences$$$trim()|||removes any leading and trailing whitespaces$$$format()|||returns a formatted string$$$split()|||breaks the string into an array of strings$$$toLowerCase()|||converts the string to lowercase$$$toUpperCase()|||converts the string to uppercase$$$valueOf()|||returns the string representation of the specified argument$$$toCharArray()|||converts the string to a char array$$$matches()|||checks whether the string matches the given regex$$$startsWith()|||checks if the string begins with the given string$$$endsWith()|||checks if the string ends with the given string$$$isEmpty()|||checks whether a string is empty of not$$$intern() |||returns the canonical representation of the string$$$contentEquals()|||checks whether the string is equal to charSequence$$$hashCode()|||returns a hash code for the string$$$subSequence()|||returns a subsequence from the string
https://www.programiz.com/java-programming/access-modifiers,Java Access Modifiers (With Examples),What are Access Modifiers?$$$Types of Access Modifier$$$Default Access Modifier$$$Private Access Modifier$$$Access Modifiers Summarized in one figure$$$Protected Access Modifier$$$Public Access Modifier$$$Table of Contents,,"In this tutorial, we will learn about the Java Access Modifier, its types, and how to use them with the help of examples.|||In Java, access modifiers are used to set the accessibility (visibility) of classes, interfaces, variables, methods, constructors, data members, and the setter methods. For example,|||In the above example, we have declared 2 methods: method1() and method2(). Here,|||Note the keyword public and private. These are access modifiers in Java. They are also known as visibility modifiers.|||Note: You cannot set the access modifier of getters methods.|||Before you learn about types of access modifiers, make sure you know about Java Packages.|||There are four access modifiers keywords in Java and they are:|||If we do not explicitly specify any access modifier for classes, methods, variables, etc, then by default the default access modifier is considered. For example,|||Here, the Logger class has the default access modifier. And the class is visible to all the classes that belong to the defaultPackage package. However, if we try to use the Logger class in another class outside of defaultPackage, we will get a compilation error.|||When variables and methods are declared private, they cannot be accessed outside of the class. For example,|||In the above example, we have declared a private variable named name. When we run the program, we will get the following error:|||The error is generated because we are trying to access the private variable of the Data class from the Main class.|||You might be wondering what if we need to access those private variables. In this case, we can use the getters and setters method. For example,|||Output:||||||In the above example, we have a private variable named name. In order to access the variable from the outer class, we have used methods: getName() and setName(). These methods are called getter and setter in Java.|||Here, we have used the setter method (setName()) to assign value to the variable and the getter method (getName()) to access the variable.|||We have used this keyword inside the setName() to refer to the variable of the class. To learn more on this keyword, visit Java this Keyword.|||Note: We cannot declare classes and interfaces private in Java. However, the nested classes can be declared private. To learn more, visit Java Nested and Inner Class.|||When methods and data members are declared protected, we can access them within the same package as well as from subclasses. For example,|||Output:|||In the above example, we have a protected method named display() inside the Animal class. The Animal class is inherited by the Dog class. To learn more about inheritance, visit Java Inheritance.|||We then created an object dog of the Dog class. Using the object we tried to access the protected method of the parent class.|||Since protected methods can be accessed from the child classes, we are able to access the method of Animal class from the Dog class.|||Note: We cannot declare classes or interfaces protected in Java.|||When methods, variables, classes, and so on are declared public, then we can access them from anywhere. The public access modifier has no scope restriction. For example,|||Output:|||Here,|||Access modifiers are mainly used for encapsulation. It can help us to control what part of a program can access the members of a class. So that misuse of data can be prevented. To learn more about encapsulation, visit Java Encapsulation.",method1 is public - This means it can be accessed by other classes.$$$method2 is private - This means it can not be accessed by other classes.$$$The public class Animal is accessed from the Main class.$$$The public variable legCount is accessed from the Main class.$$$The public method display() is accessed from the Main class.$$$What are Access Modifiers?$$$Default Access Modifier$$$Private Access Modifier$$$Protected Access Modifier$$$Public Access Modifier$$$Access Modifiers Summarized,,Modifier|||Description$$$Default|||declarations are visible only within the package (package private)$$$Private|||declarations are visible within the class only$$$Protected|||declarations are visible within the package or all subclasses$$$Public|||declarations are visible everywhere
https://www.programiz.com/java-programming/this-keyword,Java this: Where and How to use it?,this Keyword$$$Use of this Keyword$$$Using this for Ambiguity Variable Names$$$Using this in Constructor Overloading$$$this with Getters and Setters$$$Passing this as an Argument$$$Table of Contents,,"In this article, we will learn about this keyword in Java, how and where to use them with the help of examples.|||In Java, this keyword is used to refer to the current object inside a method or a constructor. For example,|||Output:|||In the above example, we created an object named obj of the class Main. We then print the reference to the object obj and this keyword of the class.|||Here, we can see that the reference of both obj and this is the same. It means this is nothing but the reference to the current object.|||There are various situations where this keyword is commonly used.|||In Java, it is not allowed to declare two or more variables having the same name inside a scope (class scope or method scope). However, instance variables and parameters may have the same name. For example,|||In the above program, the instance variable and the parameter have the same name: age. Here, the Java compiler is confused due to name ambiguity.|||In such a situation, we use this keyword. For example,|||First, let's see an example without using this keyword:|||Output:|||In the above example, we have passed 8 as a value to the constructor. However, we are getting 0 as an output. This is because the Java compiler gets confused because of the ambiguity in names between instance the variable and the parameter.|||Now, let's rewrite the above code using this keyword.|||Output:|||Now, we are getting the expected output. It is because when the constructor is called, this inside the constructor is replaced by the object obj that has called the constructor. Hence the age variable is assigned value 8.|||Also, if the name of the parameter and instance variable is different, the compiler automatically appends this keyword. For example, the code:|||is equivalent to:||||||Another common use of this keyword is in setters and getters methods of a class. For example:|||Output:|||Here, we have used this keyword:|||While working with constructor overloading, we might have to invoke one constructor from another constructor. In such a case, we cannot call the constructor explicitly. Instead, we have to use this keyword.|||Here, we use a different form of this keyword. That is, this(). Let's take an example,|||Output:|||In the above example, we have used this keyword,|||Notice the line,|||Here, when we print the object c1, the object is converted into a string. In this process, the toString() is called. Since we override the toString() method inside our class, we get the output according to that method.|||One of the huge advantages of this() is to reduce the amount of duplicate code. However, we should be always careful while using this().|||This is because calling constructor from another constructor adds overhead and it is a slow process. Another huge advantage of using this() is to reduce the amount of duplicate code.|||Note: Invoking one constructor from another constructor is called explicit constructor invocation.|||We can use this keyword to pass the current object as an argument to a method. For example,|||Output:|||In the above example, inside the constructor ThisExample(), notice the line,|||Here, we are calling the add() method by passing this as an argument. Since this keyword contains the reference to the object obj of the class, we can change the value of x and y inside the add() method.","to assign value inside the setter method$$$to access value inside the getter method$$$to call the constructor Complex(int i, int j) from the constructor Complex(int i)$$$to call the constructor Complex(int i) from the constructor Complex()$$$this Keyword$$$Using this for Ambiguity Variable Names$$$this with Getters and Setters$$$Using this in Constructor Overloading$$$Passing this as an Argument",,
https://www.programiz.com/java-programming/final-keyword,Java final keyword (With examples),1. Java final Variable$$$2. Java final Method$$$3. Java final Class$$$Table of Contents,,"In this tutorial, we will learn about Java final variables, methods and classes with examples.|||In Java, the final keyword is used to denote constants. It can be used with variables, methods, and classes.|||Once any entity (variable, method or class) is declared final, it can be assigned only once. That is,|||In Java, we cannot change the value of a final variable. For example,|||In the above program, we have created a final variable named age. And we have tried to change the value of the final variable.|||When we run the program, we will get a compilation error with the following message.|||Note: It is recommended to use uppercase to declare final variables in Java.|||Before you learn about final methods and final classes, make sure you know about the Java Inheritance.|||In Java, the final method cannot be overridden by the child class. For example,||||||In the above example, we have created a final method named display() inside the FinalDemo class. Here, the Main class inherits the FinalDemo class.|||We have tried to override the final method in the Main class. When we run the program, we will get a compilation error with the following message.|||In Java, the final class cannot be inherited by another class. For example,|||In the above example, we have created a final class named FinalClass. Here, we have tried to inherit the final class by the Main class.|||When we run the program, we will get a compilation error with the following message.",the final variable cannot be reinitialized with another value$$$the final method cannot be overridden$$$the final class cannot be extended$$$Introduction$$$Java final Variable$$$Java final Method$$$Java final Class,,
https://www.programiz.com/java-programming/recursion,Java Recursion: Recursive Methods (With Examples),Example: Factorial of a Number Using Recursion$$$Working of Factorial Program$$$Advantages and Disadvantages of Recursion$$$How Recursion works?$$$Table of Contents,,"In this tutorial, you will learn about Java recursive function, its advantages and disadvantages.|||In Java, a method that calls itself is known as a recursive method. And, this process is known as recursion.|||A physical world example would be to place two parallel mirrors facing each other. Any object in between them would be reflected recursively.|||In the above example, we have called the recurse() method from inside the main method. (normal method call). And, inside the recurse() method, we are again calling the same recurse method. This is a recursive call.|||In order to stop the recursive call, we need to provide some conditions inside the method. Otherwise, the method will be called infinitely.|||Hence, we use the if...else statement (or similar approach) to terminate the recursive call inside the method.|||Output:|||In the above example, we have a method named factorial(). The factorial() is called from the main() method. with the number variable passed as an argument.|||Here, notice the statement,||||||The factorial() method is calling itself. Initially, the value of n is 4 inside factorial(). During the next recursive call, 3 is passed to the factorial() method. This process continues until n is equal to 0.|||When n is equal to 0, the if statement returns false hence 1 is returned. Finally, the accumulated result is passed to the main() method.|||The image below will give you a better idea of how the factorial program is executed using recursion.|||When a recursive call is made, new storage locations for variables are allocated on the stack. As, each recursive call returns, the old variables and parameters are removed from the stack. Hence, recursion generally uses more memory and is generally slow.|||On the other hand, a recursive solution is much simpler and takes less time to write, debug and maintain.|||Recommended Reading: What are the advantages and disadvantages of recursion?",Introduction$$$How recursion works?$$$Example: Factorial of a Number Using Recursion$$$Working of Factorial Program$$$Advantages and Disadvantages of Recursion,,
https://www.programiz.com/java-programming/instanceof,Java instanceof (With Examples),Java instanceof during Inheritance$$$Java instanceof in Interface$$$Example: Java instanceof$$$Table of Contents,,"In this tutorial, you will learn about Java instanceof operator in detail with the help of examples.|||The instanceof operator in Java is used to check whether an object is an instance of a particular class or not.|||Its syntax is|||Here, if objectName is an instance of className, the operator returns true. Otherwise, it returns false.|||Output|||In the above example, we have created a variable name of the String type and an object obj of the Main class.|||Here, we have used the instanceof operator to check whether name and obj are instances of the String and Main class respectively. And, the operator returns true in both cases.|||Note: In Java, String is a class rather than a primitive data type. To learn more, visit Java String.|||We can use the instanceof operator to check if objects of the subclass is also an instance of the superclass. For example,|||In the above example, we have created a subclass Dog that inherits from the superclass Animal. We have created an object d1 of the Dog class.|||Inside the print statement, notice the expression,||||||Here, we are using the instanceof operator to check whether d1 is also an instance of the superclass Animal.|||The instanceof operator is also used to check whether an object of a class is also an instance of the interface implemented by the class. For example,|||In the above example, the Dog class implements the Animal interface. Inside the print statement, notice the expression,|||Here, d1 is an instance of Dog class. The instanceof operator checks if d1 is also an instance of the interface Animal.|||Note: In Java, all the classes are inherited from the Object class. So, instances of all the classes are also an instance of the Object class.|||In the previous example, if we check,|||The result will be true.",Java instanceof$$$Example: instanceof$$$Java instanceof during Inheritance$$$Java instanceof in Interface,,
https://www.programiz.com/java-programming/inheritance,Java Inheritance (With Examples),is-a relationship$$$Method Overriding in Java Inheritance$$$super Keyword in Java Inheritance$$$protected Members in Inheritance$$$Why use inheritance?$$$Types of inheritance$$$Example 1: Java Inheritance$$$Example 2: Method overriding in Java Inheritance$$$Example 3: super Keyword in Inheritance$$$Example 4: protected Members in Inheritance$$$1. Single Inheritance$$$2. Multilevel Inheritance$$$3. Hierarchical Inheritance$$$4. Multiple Inheritance$$$5. Hybrid Inheritance$$$Table of Contents,,"In this tutorial, we will learn about Java inheritance and its types with the help of example.|||Inheritance is one of the key features of OOP that allows us to create a new class from an existing class.|||The new class that is created is known as subclass (child or derived class) and the existing class from where the child class is derived is known as superclass (parent or base class).|||The extends keyword is used to perform inheritance in Java. For example,|||In the above example, the Dog class is created by inheriting the methods and fields from the Animal class.|||Here, Dog is the subclass and Animal is the superclass.|||Output|||In the above example, we have derived a subclass Dog from superclass Animal. Notice the statements,|||Here, labrador is an object of Dog. However, name and eat() are the members of the Animal class.|||Since Dog inherits the field and method from Animal, we are able to access the field and method using the object of the Dog.|||In Java, inheritance is an is-a relationship. That is, we use inheritance only if there exists an is-a relationship between two classes. For example,|||Here, Car can inherit from Vehicle, Orange can inherit from Fruit, and so on.|||In Example 1, we see the object of the subclass can access the method of the superclass.|||However, if the same method is present in both the superclass and subclass, what will happen?|||In this case, the method in the subclass overrides the method in the superclass. This concept is known as method overriding in Java.|||Output||||||In the above example, the eat() method is present in both the superclass Animal and the subclass Dog.|||Here, we have created an object labrador of Dog.|||Now when we call eat() using the object labrador, the method inside Dog is called. This is because the method inside the derived class overrides the method inside the base class.|||This is called method overriding. To learn more, visit Java Method Overriding.|||Note: We have used the @Override annotation to tell the compiler that we are overriding a method. However, the annotation is not mandatory. To learn more, visit Java Annotations.|||Previously we saw that the same method in the subclass overrides the method in superclass.|||In such a situation, the super keyword is used to call the method of the parent class from the method of the child class.|||Output|||In the above example, the eat() method is present in both the base class Animal and the derived class Dog. Notice the statement,|||Here, the super keyword is used to call the eat() method present in the superclass.|||We can also use the super keyword to call the constructor of the superclass from the constructor of the subclass. To learn more, visit Java super keyword.|||In Java, if a class includes protected fields and methods, then these fields and methods are accessible from the subclass of the class.|||Output|||In the above example, we have created a class named Animal. The class includes a protected field: name and a method: display().|||We have inherited the Dog class inherits Animal. Notice the statement,|||Here, we are able to access the protected field and method of the superclass using the labrador object of the subclass.|||There are five types of inheritance.|||In single inheritance, a single subclass extends from a single superclass. For example,|||In multilevel inheritance, a subclass extends from a superclass and then the same subclass acts as a superclass for another class. For example,|||In hierarchical inheritance, multiple subclasses extend from a single superclass. For example,|||In multiple inheritance, a single subclass extends from multiple superclasses. For example,|||Note: Java doesn't support multiple inheritance. However, we can achieve multiple inheritance using interfaces. To learn more, visit Java implements multiple inheritance.|||Hybrid inheritance is a combination of two or more types of inheritance. For example,|||Here, we have combined hierarchical and multiple inheritance to form a hybrid inheritance.","Car is a Vehicle$$$Orange is a Fruit$$$Surgeon is a Doctor$$$Dog is an Animal$$$The most important use of inheritance in Java is code reusability. The code that is present in the parent class can be directly used by the child class.$$$Method overriding is also known as runtime polymorphism. Hence, we can achieve Polymorphism in Java with the help of inheritance.$$$Introduction$$$Example: Java Inheritance$$$is-a relationship$$$Method Overriding Inheritance$$$super Keyword Inheritance$$$protected Members and Inheritance$$$Why use inheritance?$$$Types of inheritance",,
https://www.programiz.com/java-programming/method-overriding,Java Method Overriding,Java Overriding Rules$$$super Keyword in Java Overriding$$$Access Specifiers in Method Overriding$$$Overriding Abstract Methods$$$Example 1: Method Overriding$$$Example 2: Use of super Keyword$$$Example 3: Access Specifier in Overriding$$$Table of Contents,,"In this tutorial, we will learn about method overriding in Java with the help of examples.|||In the last tutorial, we learned about inheritance. Inheritance is an OOP property that allows us to derive a new class (subclass) from an existing class (superclass). The subclass inherits the attributes and methods of the superclass.|||Now, if the same method is defined in both the superclass and the subclass, then the method of the subclass class overrides the method of the superclass. This is known as method overriding.|||Output:|||In the above program, the displayInfo() method is present in both the Animal superclass and the Dog subclass.|||When we call displayInfo() using the d1 object (object of the subclass), the method inside the subclass Dog is called. The displayInfo() method of the subclass overrides the same method of the superclass.||||||Notice the use of the @Override annotation in our example. In Java, annotations are the metadata that we used to provide information to the compiler. Here, the @Override annotation specifies the compiler that the method after this annotation overrides the method of the superclass.|||It is not mandatory to use @Override. However, when we use this, the method should follow all the rules of overriding. Otherwise, the compiler will generate an error.|||A common question that arises while performing overriding in Java is:|||Can we access the method of the superclass after overriding? |||Well, the answer is Yes. To access the method of the superclass from the subclass, we use the super keyword.|||Output:|||In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal.|||When we call the method displayInfo() using the d1 object of the Dog subclass, the method inside the Dog subclass is called; the method inside the superclass is not called.||||||Inside displayInfo() of the Dog subclass, we have used super.displayInfo() to call displayInfo() of the superclass.|||It is important to note that constructors in Java are not inherited. Hence, there is no such thing as constructor overriding in Java.|||However, we can call the constructor of the superclass from its subclasses. For that, we use super(). To learn more, visit Java super keyword.|||The same method declared in the superclass and its subclasses can have different access specifiers. However, there is a restriction.|||We can only use those access specifiers in subclasses that provide larger access than the access specifier of the superclass. For example,|||Suppose, a method myClass() in the superclass is declared protected. Then, the same method myClass() in the subclass can be either public or protected, but not private.|||Output:|||In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal.|||Whenever we call displayInfo() using the d1 (object of the subclass), the method inside the subclass is called.|||Notice that, the displayInfo() is declared protected in the Animal superclass. The same method has the public access specifier in the Dog subclass. This is possible because the public provides larger access than the protected.|||In Java, abstract classes are created to be the superclass of other classes. And, if a class contains an abstract method, it is mandatory to override it.|||We will learn more about abstract classes and overriding of abstract methods in later tutorials.","Both the superclass and the subclass must have the same method name, the same return type and the same parameter list.$$$We cannot override the method declared as final and static.$$$We should always override abstract methods of the superclass (will be discussed in later tutorials).$$$Method Overriding (Introduction)$$$Example: Method Overriding$$$Java Method Overriding Rules$$$Java super Keyword$$$Access Specifiers in Method Overriding",,
https://www.programiz.com/java-programming/super-keyword,Java super Keyword (With Examples),Uses of super keyword$$$1. Access Overridden Methods of the superclass$$$2. Access Attributes of the Superclass$$$3. Use of super() to access superclass constructor$$$Example 1: Method overriding$$$Example 2: super to Call Superclass Method$$$Example 3: Access superclass attribute$$$Example 4: Use of super()$$$Example 5: Call Parameterized Constructor Using super()$$$Table of Contents,,"In this tutorial, we will learn about the super keyword in Java with the help of examples.|||The super keyword in Java is used in subclasses to access superclass members (attributes, constructors and methods).|||Before we learn about the super keyword, make sure to know about Java inheritance.|||Let’s understand each of these uses.|||If methods with the same name are defined in both superclass and subclass, the method in the subclass overrides the method in the superclass. This is called method overriding.|||Output|||In this example, by making an object dog1 of Dog class, we can call its method printMessage() which then executes the display() statement.|||Since display() is defined in both the classes, the method of subclass Dog overrides the method of superclass Animal. Hence, the display() of the subclass is called.||||||What if the overridden method of the superclass has to be called? |||We use super.display() if the overridden method display() of superclass Animal needs to be called.|||Output|||Here, how the above program works.||||||The superclass and subclass can have attributes with the same name. We use the super keyword to access the attribute of the superclass.|||Output:|||In this example, we have defined the same instance field type in both the superclass Animal and the subclass Dog.|||We then created an object dog1 of the Dog class. Then, the printType() method is called using this object.|||Inside the printType() function,||||||Hence, System.out.println(""I am a "" + type); prints I am a mammal. And, System.out.println(""I am an "" + super.type); prints I am an animal.|||As we know, when an object of a class is created, its default constructor is automatically called.|||To explicitly call the superclass constructor from the subclass constructor, we use super(). It's a special form of the super keyword.|||super() can be used only inside the subclass constructor and must be the first statement.|||Output |||Here, when an object dog1 of Dog class is created, it automatically calls the default or no-arg constructor of that class.|||Inside the subclass constructor, the super() statement calls the constructor of the superclass and executes the statements inside it. Hence, we get the output I am an animal.||||||The flow of the program then returns back to the subclass constructor and executes the remaining statements. Thus, I am a dog will be printed.|||However, using super() is not compulsory. Even if super() is not used in the subclass constructor, the compiler implicitly calls the default constructor of the superclass.|||So, why use redundant code if the compiler automatically invokes super()? |||It is required if the parameterized constructor (a constructor that takes arguments) of the superclass has to be called from the subclass constructor.|||The parameterized super() must always be the first statement in the body of the constructor of the subclass, otherwise, we get a compilation error.|||Output|||The compiler can automatically call the no-arg constructor. However, it cannot call parameterized constructors.|||If a parameterized constructor has to be called, we need to explicitly define it in the subclass constructor.||||||Note that in the above example, we explicitly called the parameterized constructor super(""Animal""). The compiler does not call the default constructor of the superclass in this case.",type refers to the attribute of the subclass Dog.$$$super.type refers to the attribute of the superclass Animal.$$$Use of super Keyword$$$Access overridden methods of the superclass$$$Access attributes of the superclass$$$Access superclass constructor Using super(),To call methods of the superclass that is overridden in the subclass.$$$To access attributes (fields) of the superclass if both superclass and subclass have attributes with the same name.$$$To explicitly call superclass no-arg (default) or parameterized constructor from the subclass constructor.,
https://www.programiz.com/java-programming/abstract-classes-methods,Java Abstract Class and Method (With Example),Java Abstract Class$$$Java Abstract Method$$$Implementing Abstract Methods$$$Java Abstraction$$$Key Points to Remember$$$Example: Java Abstract Class and Method$$$Accesses Constructor of Abstract Classes$$$Example 3: Java Abstraction$$$Table of Contents,,"In this tutorial, we will learn about Java abstract classes and methods with the help of examples. We will also learn about abstraction in Java.|||The abstract class in Java cannot be instantiated (we cannot create objects of abstract classes). We use the abstract keyword to declare an abstract class. For example,|||An abstract class can have both the regular methods and abstract methods. For example,|||To know about the non-abstract methods, visit Java methods. Here, we will learn about abstract methods.|||A method that doesn't have its body is known as an abstract method. We use the same abstract keyword to create abstract methods. For example,|||Here, display() is an abstract method. The body of display() is replaced by ;.|||If a class contains an abstract method, then the class should be declared abstract. Otherwise, it will generate an error. For example,|||Though abstract classes cannot be instantiated, we can create subclasses from it. We can then access members of the abstract class using the object of the subclass. For example,|||Output|||In the above example, we have created an abstract class named Language. The class contains a regular method display().|||We have created the Main class that inherits the abstract class. Notice the statement,|||Here, obj is the object of the child class Main. We are calling the method of the abstract class using the object obj.|||If the abstract class includes any abstract method, then all the child classes inherited from the abstract superclass must provide the implementation of the abstract method. For example,|||Output|||In the above example, we have created an abstract class Animal. The class contains an abstract method makeSound() and a non-abstract method eat().|||We have inherited a subclass Dog from the superclass Animal. Here, the subclass Dog provides the implementation for the abstract method makeSound().||||||We then used the object d1 of the Dog class to call methods makeSound() and eat().|||Note: If the Dog class doesn't provide the implementation of the abstract method makeSound(), Dog should also be declared as abstract. This is because the subclass Dog inherits makeSound() from Animal.|||An abstract class can have constructors like the regular class. And, we can access the constructor of an abstract class from the subclass using the super keyword. For example,|||Here, we have used the super() inside the constructor of Dog to access the constructor of the Animal.|||Note that the super should always be the first statement of the subclass constructor. Visit Java super keyword to learn more.|||The major use of abstract classes and methods is to achieve abstraction in Java.|||Abstraction is an important concept of object-oriented programming that allows us to hide unnecessary details and only show the needed information.|||This allows us to manage complexity by omitting or hiding details with a simpler, higher-level idea.|||A practical example of abstraction can be motorbike brakes. We know what brake does. When we apply the brake, the motorbike will stop. However, the working of the brake is kept hidden from us.|||The major advantage of hiding the working of the brake is that now the manufacturer can implement brake differently for different motorbikes, however, what brake does will be the same.|||Let's take an example that helps us to better understand Java abstraction.|||Output:|||In the above example, we have created an abstract super class MotorBike. The superclass MotorBike has an abstract method brake().|||The brake() method cannot be implemented inside MotorBike. It is because every bike has different implementation of brakes. So, all the subclasses of MotorBike would have different implementation of brake().|||So, the implementation of brake() in MotorBike is kept hidden.|||Here, MountainBike makes its own implementation of brake() and SportsBike makes its own implementation of brake().|||Note: We can also use interfaces to achieve abstraction in Java. To learn more, visit Java Interface.","We use the abstract keyword to create abstract classes and methods.$$$An abstract method doesn't have any implementation (method body).$$$A class containing abstract methods should also be abstract.$$$We cannot create objects of an abstract class.$$$To implement features of an abstract class, we inherit subclasses from it and create objects of the subclass.$$$A subclass must override all abstract methods of an abstract class. However, if the subclass is declared abstract, it's not mandatory to override abstract methods.$$$We can access the static attributes and methods of an abstract class using the reference of the abstract class. For example,Animal.staticMethod();$$$Java Abstract Class$$$Java Abstract Method$$$Example: Java Abstract Class and Method$$$Implementing Abstract Methods$$$Constructor of Abstract Classes$$$Java Abstraction$$$Key Points to Remember",,
https://www.programiz.com/java-programming/interfaces,Java Interface (With Examples),Implementing an Interface$$$Extending an Interface$$$Advantages of Interface in Java$$$default methods in Java Interfaces$$$private and static Methods in Interface$$$Example 1: Java Interface$$$Example 2: Java Interface$$$Implementing Multiple Interfaces$$$Extending Multiple Interfaces$$$Why default methods?$$$Example: Default Method in Java Interface$$$Practical Example of Interface$$$Table of Contents,,"In this tutorial, we will learn about Java interfaces. We will learn how to implement interfaces and when to use them in detail with the help of examples.|||An interface is a fully abstract class. It includes a group of abstract methods (methods without a body).|||We use the interface keyword to create an interface in Java. For example,|||Here,|||Like abstract classes, we cannot create objects of interfaces.|||To use an interface, other classes must implement it. We use the implements keyword to implement an interface.|||Output|||In the above example, we have created an interface named Polygon. The interface contains an abstract method getArea().|||Here, the Rectangle class implements Polygon. And, provides the implementation of the getArea() method.|||Output|||In the above example, we have created an interface named Language. The interface includes an abstract method getName().|||Here, the ProgrammingLanguage class implements the interface and provides the implementation for the method.|||In Java, a class can also implement multiple interfaces. For example,|||Similar to classes, interfaces can extend other interfaces. The extends keyword is used for extending interfaces. For example,|||Here, the Polygon interface extends the Line interface. Now, if any class implements Polygon, it should provide implementations for all the abstract methods of both Line and Polygon.|||An interface can extend multiple interfaces. For example,||||||Now that we know what interfaces are, let's learn about why interfaces are used in Java.|||Note: All the methods inside an interface are implicitly public and all fields are implicitly public static final. For example,|||With the release of Java 8, we can now add methods with implementation inside an interface. These methods are called default methods.|||To declare default methods inside interfaces, we use the default keyword. For example,|||Let's take a scenario to understand why default methods are introduced in Java.|||Suppose, we need to add a new method in an interface.|||We can add the method in our interface easily without implementation. However, that's not the end of the story. All our classes that implement that interface must provide an implementation for the method.|||If a large number of classes were implementing this interface, we need to track all these classes and make changes to them. This is not only tedious but error-prone as well.|||To resolve this, Java introduced default methods. Default methods are inherited like ordinary methods.|||Let's take an example to have a better understanding of default methods.|||Output|||In the above example, we have created an interface named Polygon. It has a default method getSides() and an abstract method getArea().|||Here, we have created two classes Rectangle and Square that implement Polygon.|||The Rectangle class provides the implementation of the getArea() method and overrides the getSides() method. However, the Square class only provides the implementation of the getArea() method.|||Now, while calling the getSides() method using the Rectangle object, the overridden method is called. However, in the case of the Square object, the default method is called.|||The Java 8 also added another feature to include static methods inside an interface.|||Similar to a class, we can access static methods of an interface using its references. For example,|||Note: With the release of Java 9, private methods are also supported in interfaces.|||We cannot create objects of an interface. Hence, private methods are used as helper methods that provide support to other methods in interfaces.|||Let's see a more practical example of Java Interface.|||Output|||In the above program, we have created an interface named Polygon. It includes a default method getPerimeter() and an abstract method getArea().|||We can calculate the perimeter of all polygons in the same manner so we implemented the body of getPerimeter() in Polygon.|||Now, all polygons that implement Polygon can use getPerimeter() to calculate perimeter.|||However, the rule for calculating the area is different for different polygons. Hence, getArea() is included without implementation.|||Any class that implements Polygon must provide an implementation of getArea().","Language is an interface.$$$It includes abstract methods: getType() and getVersion().$$$Similar to abstract classes, interfaces help us to achieve abstraction in Java.Here, we know getArea() calculates the area of polygons but the way area is calculated is different for different polygons. Hence, the implementation of getArea() is independent of one another.$$$Interfaces provide specifications that a class (which implements it) must follow.In our previous example, we have used getArea() as a specification inside the interface Polygon. This is like setting a rule that we should be able to get the area of every polygon.Now any class that implements the Polygon interface must provide an implementation for the getArea() method.$$$Interfaces are also used to achieve multiple inheritance in Java. For example, interface Line {…}interface Polygon {…}class Rectangle implements Line, Polygon {…}Here, the class Rectangle is implementing two different interfaces. This is how we achieve multiple inheritance in Java.$$$Java Interface$$$Implementing Interface$$$Interface Example$$$Extending Interface$$$Advantages of Interface$$$default methods$$$private and static Methods in Interface$$$Practical Example of Interface",,
https://www.programiz.com/java-programming/polymorphism,Java Polymorphism (With Examples),Example: Java Polymorphism$$$Java Method Overriding$$$2. Java Method Overloading$$$3. Java Operator Overloading$$$Polymorphic Variables$$$Why Polymorphism?$$$Example 1: Polymorphism using method overriding$$$Example 3: Polymorphism using method overloading$$$Example: Polymorphic Variables$$$Table of Contents,,"In this tutorial, we will learn about Java polymorphism and its implementation with the help of examples.|||Polymorphism is an important concept of object-oriented programming. It simply means more than one form.|||That is, the same entity (method or operator or object) can perform different operations in different scenarios.|||Output|||In the above example, we have created a superclass: Polygon and two subclasses: Square and Circle. Notice the use of the render() method.|||The main purpose of the render() method is to render the shape. However, the process of rendering a square is different than the process of rendering a circle.|||Hence, the render() method behaves differently in different classes. Or, we can say render() is polymorphic.|||Polymorphism allows us to create consistent code. In the previous example, we can also create different methods: renderSquare() and renderCircle() to render Square and Circle, respectively.|||This will work perfectly. However, for every shape, we need to create different methods. It will make our code inconsistent.|||To solve this, polymorphism in Java allows us to create a single method render() that will behave differently for different shapes.|||Note: The print() method is also an example of polymorphism. It is used to print values of different types like char, int, string, etc.|||We can achieve polymorphism in Java using the following ways:|||During inheritance in Java, if the same method is present in both the superclass and the subclass. Then, the method in the subclass overrides the same method in the superclass. This is called method overriding.|||In this case, the same method will perform one operation in the superclass and another operation in the subclass. For example,|||Output:|||In the above example, we have created a superclass named Language and a subclass named Java. Here, the method displayInfo() is present in both Language and Java.|||The use of displayInfo() is to print the information. However, it is printing different information in Language and Java.|||Based on the object used to call the method, the corresponding information is printed.|||Note: The method that is called is determined during the execution of the program. Hence, method overriding is a run-time polymorphism.|||In a Java class, we can create methods with the same name if they differ in parameters. For example,||||||This is known as method overloading in Java. Here, the same method will perform different operations based on the parameter.|||Output:|||In the above example, we have created a class named Pattern. The class contains a method named display() that is overloaded.|||Here, the main function of display() is to print the pattern. However, based on the arguments passed, the method is performing different operations:|||Note: The method that is called is determined by the compiler. Hence, it is also known as compile-time polymorphism.|||Some operators in Java behave differently with different operands. For example,|||Let's see how we can achieve polymorphism using operator overloading.|||The + operator is used to add two entities. However, in Java, the + operator performs two operations.|||1. When + is used with numbers (integers and floating-point numbers), it performs mathematical addition. For example,|||2. When we use the + operator with strings, it will perform string concatenation (join two strings). For example,|||Here, we can see that the + operator is overloaded in Java to perform two operations: addition and concatenation.|||Note: In languages like C++, we can define operators to work differently for different operands. However, Java doesn't support user-defined operator overloading.|||A variable is called polymorphic if it refers to different values under different conditions.|||Object variables (instance variables) represent the behavior of polymorphic variables in Java. It is because object variables of a class can refer to objects of its class as well as objects of its subclasses.|||Output:|||In the above example, we have created an object variable pl of the ProgrammingLanguage class. Here, pl is a polymorphic variable. This is because,|||This is an example of upcasting in Java.","prints a pattern of *, if no argument is passed or$$$prints pattern of the parameter, if a single char type argument is passed.$$$+ operator is overloaded to perform numeric addition as well as string concatenation, and$$$operators like &, |, and ! are overloaded for logical and bitwise operations.$$$In statement pl = new ProgrammingLanguage(), pl refer to the object of the ProgrammingLanguage class.$$$And, in statement pl = new Java(), pl refer to the object of the Java class.$$$Introduction$$$Example: Java Polymorphism$$$Why Polymorphism?$$$Java Method Overriding$$$Java Method Overloading$$$Java Operator Overloading$$$Polymorphic Variables",Method Overriding$$$Method Overloading$$$Operator Overloading,
https://www.programiz.com/java-programming/encapsulation,Java Encapsulation,Java Encapsulation$$$Why Encapsulation?$$$Data Hiding$$$Example 1: Java Encapsulation$$$Example 2: Data hiding using the private specifier$$$Table of Contents,,"In this tutorial, you will learn about encapsulation and data hiding in Java with the help of examples.|||Encapsulation is one of the key features of object-oriented programming. Encapsulation refers to the bundling of fields and methods inside a single class.|||It prevents outer classes from accessing and changing fields and methods of a class. This also helps to achieve data hiding.|||Output|||In the above example, we have created a class named Area. The main purpose of this class is to calculate the area.|||To calculate an area, we need two variables: length and breadth and a method: getArea(). Hence, we bundled these fields and methods inside a single class.|||Here, the fields and methods can be accessed from other classes as well. Hence, this is not data hiding.|||This is only encapsulation. We are just keeping similar codes together.|||Note: People often consider encapsulation as data hiding, but that's not entirely true.|||Encapsulation refers to the bundling of related fields and methods together. This can be used to achieve data hiding. Encapsulation in itself is not data hiding.|||Data hiding is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding.||||||We can use access modifiers to achieve data hiding. For example,|||Output|||In the above example, we have a private field age. Since it is private, it cannot be accessed from outside the class.|||In order to access age, we have used public methods: getAge() and setAge(). These methods are called getter and setter methods.|||Making age private allowed us to restrict unauthorized access from outside the class. This is data hiding.|||If we try to access the age field from the Main class, we will get an error.","In Java, encapsulation helps us to keep related fields and methods together, which makes our code cleaner and easy to read.$$$It helps to control the values of our data fields. For example,class Person {  private int age;  public void setAge(int age) {    if (age >= 0) {      this.age = age;    }  }}Here, we are making the age variable private and applying logic inside the setAge() method. Now, age cannot be negative.$$$The getter and setter methods provide read-only or write-only access to our class fields. For example,getName()  // provides read-only accesssetName() // provides write-only access$$$It helps to decouple components of a system. For example, we can encapsulate code into multiple bundles.These decoupled components (bundle) can be developed, tested, and debugged independently and concurrently. And, any changes in a particular component do not have any effect on other components.$$$We can also achieve data hiding using encapsulation. In the above example, if we change the length and breadth variable into private, then the access to these fields is restricted.And, they are kept hidden from outer classes. This is called data hiding.$$$Introduction$$$Example: Java Encapsulation$$$Why Encapsulation?$$$Data Hiding",,
https://www.programiz.com/java-programming/nested-inner-class,Java Nested and Inner Class (With Examples),Non-Static Nested Class (Inner Class)$$$Static Nested Class$$$Example 1: Inner class$$$Accessing Members of Outer Class within Inner Class$$$Example 2: Accessing Members$$$Example 3: Static Inner Class$$$Example 4: Accessing members of Outer class inside Static Inner Class$$$Key Points to Remember$$$Table of Contents,,"In this tutorial, you will learn about the nested class in Java and its types with the help of examples.|||In Java, you can define a class within another class. Such class is known as nested class. For example,|||There are two types of nested classes you can create in Java.|||Recommended reading:|||Let's first look at non-static nested classes.|||A non-static nested class is a class within another class. It has access to members of the enclosing class (outer class). It is commonly known as inner class.|||Since the inner class exists within the outer class, you must instantiate the outer class first, in order to instantiate the inner class.|||Here's an example of how you can declare inner classes in Java.|||Output:|||In the above program, there are two nested classes: Processor and RAM inside the outer class: CPU. We can declare the inner class as protected. Hence, we have declared the RAM class as protected.|||Inside the Main class,|||Note: We use the dot (.) operator to create an instance of the inner class using the outer class.|||We can access the members of the outer class by using this keyword. If you want to learn about this keyword, visit Java this keyword. |||Output:|||In the above program, we have the inner class named Engine inside the outer class Car. Here, notice the line,|||We are using this keyword to access the carType variable of the outer class. You may have noticed that instead of using this.carType we have used Car.this.carType.||||||It is because if we had not mentioned the name of the outer class Car, then this keyword will represent the member inside the inner class.|||Similarly, we are also accessing the method of the outer class from the inner class.|||It is important to note that, although the getCarName() is a private method, we are able to access it from the inner class.|||In Java, we can also define a static class inside another class. Such class is known as static nested class. Static nested classes are not called static inner classes.|||Unlike inner class, a static nested class cannot access the member variables of the outer class. It is because the static nested class doesn't require you to create an instance of the outer class.|||Here, we are creating an object of the static nested class by simply using the class name of the outer class. Hence, the outer class cannot be referenced using OuterClass.this.|||Output:|||In the above program, we have created a static class named USB inside the class MotherBoard. Notice the line,|||Here, we are creating an object of USB using the name of the outer class.|||Now, let's see what would happen if you try to access the members of the outer class:|||When we try to run the program, we will get an error:|||This is because we are not using the object of the outer class to create an object of the inner class. Hence, there is no reference to the outer class Motherboard stored in Motherboard.this.","Non-static nested class (inner class)$$$Static nested class$$$Java Access Modifiers$$$Java Static Keyword$$$we first created an instance of an outer class CPU named cpu.$$$Using the instance of the outer class, we then created objects of inner classes: CPU.Processor processor = cpu.new Processor;CPU.RAM ram = cpu.new RAM();$$$Java treats the inner class as a regular member of a class. They are just like methods and variables declared inside a class.$$$Since inner classes are members of the outer class, you can apply any access modifiers like private, protected to your inner class which is not possible in normal classes.$$$Since the nested class is a member of its enclosing outer class, you can use the dot (.) notation to access the nested class and its members.$$$Using the nested class will make your code more readable and provide better encapsulation.$$$Non-static nested classes (inner classes) have access to other members of the outer/enclosing class, even if they are declared private.$$$Introduction$$$Non-Static Nested Class$$$Accessing Members of Outer Class within Inner Class$$$Static Nested Class$$$Key Points to Remember",,
https://www.programiz.com/java-programming/static-class,Java Nested Static Class,Java Nested Static Class$$$Accessing Members of Outer Class$$$Static Top-level Class$$$Example: Static Nested Class$$$Example: Accessing Non-static members$$$Table of Contents,,"In this tutorial, you will learn about nested static class with the help of examples. You will also learn about how static classes differs from inner classes.|||As learned in previous tutorials, we can have a class inside another class in Java. Such classes are known as nested classes. In Java, nested classes are of two types:|||We have already discussed inner classes in the previous tutorial. Visit Java Nested Class if you want to learn about inner classes.|||In this tutorial, we will learn about nested static classes.|||We use the keyword static to make our nested class static.|||Note: In Java, only nested classes are allowed to be static.|||Like regular classes, static nested classes can include both static and non-static fields and methods. For example,|||Static nested classes are associated with the outer class.|||To access the static nested class, we don’t need objects of the outer class.|||Output|||In the above program, we have two nested class Mammal and Reptile inside a class Animal.|||To create an object of the non-static class Reptile, we have used|||To create an object of the static class Mammal, we have used||||||In Java, static nested classes are associated with the outer class. This is why static nested classes can only access the class members (static fields and methods) of the outer class.|||Let’s see what will happen if we try to access non-static fields and methods of the outer class.|||Output|||In the above example, we have created a non-static method eat() inside the class Animal.|||Now, if we try to access eat() using the object mammal, the compiler shows an error.|||It is because mammal is an object of a static class and we cannot access non-static methods from static classes.|||As mentioned above, only nested classes can be static. We cannot have static top-level classes.|||Let’s see what will happen if we try to make a top-level class static.|||Output|||In the above example, we have tried to create a static class Animal. Since Java doesn’t allow static top-level class, we will get an error.",Nested non-static class (Inner class)$$$Nested static class.$$$Introduction$$$Java Nested Static Class $$$Accessing Members of Outer Class $$$Static Top-level Class ,,
https://www.programiz.com/java-programming/anonymous-class,Java Anonymous Class,Advantages of Anonymous Classes$$$Example 1: Anonymous Class Extending a Class$$$Example 2: Anonymous Class Implementing an Interface$$$Table of Contents,,"In this tutorial, you will learn about anonymous classes in Java with the help of examples.|||In Java, a class can contain another class known as nested class. It's possible to create a nested class without giving any name.|||A nested class that doesn't have any name is known as an anonymous class.|||An anonymous class must be defined inside another class. Hence, it is also known as an anonymous inner class. Its syntax is:|||Anonymous classes usually extend subclasses or implement interfaces.|||Here, Type can be|||The above code creates an object, object1, of an anonymous class at runtime.|||Note: Anonymous classes are defined inside an expression. So, the semicolon is used at the end of anonymous classes to indicate the end of the expression.|||Output|||In the above example, we have created a class Polygon. It has a single method display().||||||We then created an anonymous class that extends the class Polygon and overrides the display() method.|||When we run the program, an object p1 of the anonymous class is created. The object then calls the display() method of the anonymous class.|||Output|||In the above example, we have created an anonymous class that implements the Polygon interface.|||In anonymous classes, objects are created whenever they are required. That is, objects are created to perform some specific tasks. For example,|||Here, an object of the anonymous class is created dynamically when we need to override the display() method.|||Anonymous classes also help us to make our code concise.",Introduction$$$Anonymous class extending a class$$$Anonymous class implementing an interface$$$Advantages of anonymous classes ,a superclass that an anonymous class extends$$$an interface that an anonymous class implements,
https://www.programiz.com/java-programming/singleton,Java Singleton (With Example),Use of Singleton in Java$$$Example: Java Singleton Class Syntax$$$Table of Contents,,"In this tutorial, we will learn to implement Singleton Design Pattern in Java with the help of examples.|||In Java, Singleton is a design pattern that ensures that a class can only have one object.|||To create a singleton class, a class must implement the following properties:|||In the above example,|||Singletons can be used while working with databases. They can be used to create a connection pool to access the database while reusing the same connection for all the clients. For example,||||||When we run the program, the output will be:|||In our above example,|||Singleton is a design pattern rather than a feature specific to Java. A design pattern is like our code library that includes various coding techniques shared by programmers around the world.|||It's important to note that, there are only a few scenarios (like logging) where singletons make sense. We recommend you avoid using singletons completely if you are not sure whether to use them or not. Learn more: What is so bad about Singleton?","Create a private constructor of the class to restrict object creation outside of the class.$$$Create a private attribute of the class type that refers to the single object.$$$Create a public static method that allows us to create and access the object we created. Inside the method, we will create a condition that restricts us from creating more than one object.$$$private static SingletonExample singleObject - a reference to the object of the class.$$$private SingletonExample() - a private constructor that restricts creating objects outside of the class.$$$public static SingletonExample getInstance() - this method returns the reference to the only object of the class. Since the method static, it can be accessed using the class name.$$$We have created a singleton class Database.$$$The dbObject is a class type field. This will refer to the object of the class Database.$$$The private constructor Database() prevents object creation outside of the class.$$$The static class type method getInstance() returns the instance of the class to the outside world.$$$In the Main class, we have class type variable db1. We are calling getInstance() using db1 to get the only object of the Database.$$$The method getConnection() can only be accessed using the object of the Database.$$$Since the Database can have only one object, all the clients can access the database through a single connection.$$$Java Singleton$$$Singleton Example$$$Use of Singleton Class",,
https://www.programiz.com/java-programming/enums,Java enum & enum Class (With Examples),Enum Class in Java$$$Methods of Java Enum Class$$$Why Java Enums?$$$Example 1: Java Enum$$$Example 2: Java Enum with the switch statement$$$Example 3: Java Enum Class$$$1. Java Enum ordinal()$$$2. Enum compareTo()$$$3. Enum toString()$$$4. Enum name()$$$5. Java Enum valueOf()$$$6. Enum values()$$$Table of Contents,,"In this tutorial, we will learn about enums in Java. We will learn to create and use enums and enum classes with the help of examples.|||In Java, an enum (short for enumeration) is a type that has a fixed set of constant values. We use the enum keyword to declare enums. For example,|||Here, we have created an enum named Size. It contains fixed values SMALL, MEDIUM, LARGE, and EXTRALARGE.|||These values inside the braces are called enum constants (values).|||Note: The enum constants are usually represented in uppercase.|||Output|||As we can see from the above example, we use the enum name to access the constant values.|||Also, we can create variables of enum types. For example,|||Here, pizzaSize is a variable of the Size type. It can only be assigned with 4 values.|||Output|||In the above program, we have created an enum type Size. We then declared a variable pizzaSize of the Size type.|||Here, the variable pizzaSize can only be assigned with 4 values (SMALL, MEDIUM, LARGE, EXTRALARGE).|||Notice the statement,|||It will call the Test() constructor inside the Test class. Now, the variable pizzaSize is assigned with the MEDIUM constant.|||Based on the value, one of the cases of the switch case statement is executed.|||In Java, enum types are considered to be a special type of class. It was introduced with the release of Java 5.|||An enum class can include methods and fields just like regular classes.|||When we create an enum class, the compiler will create instances (objects) of each enum constants. Also, all enum constant is always public static final by default.|||Output|||In the above example, we have created an enum class Size. It has four constants SMALL, MEDIUM, LARGE and EXTRALARGE.||||||Since Size is an enum class, the compiler automatically creates instances for each enum constants.|||Here inside the main() method, we have used the instance SMALL to call the getSize() method.|||Note: Like regular classes, an enum class also may include constructors. To learn more about it, visit Java enum constructor.|||There are some predefined methods in enum classes that are readily available for use.|||The ordinal() method returns the position of an enum constant. For example,|||The compareTo() method compares the enum constants based on their ordinal value. For example,|||The toString() method returns the string representation of the enum constants. For example,|||The name() method returns the defined name of an enum constant in string form. The returned value from the name() method is final. For example,|||The valueOf() method takes a string and returns an enum constant having the same string name. For example,|||The values() method returns an array of enum type containing all the enum constants. For example,|||In Java, enum was introduced to replace the use of int constants.|||Suppose we have used a collection of int constants.|||Here, the problem arises if we print the constants. It is because only the number is printed which might not be helpful.|||So, instead of using int constants, we can simply use enums. For example,|||This makes our code more intuitive.|||Also, enum provides compile-time type safety.|||If we declare a variable of the Size type. For example,|||Here, it is guaranteed that the variable will hold one of the four values. Now, If we try to pass values other than those four values, the compiler will generate an error.",Introduction$$$Example: Java Enum$$$Java Enum with switch statement$$$Enum Class in Java$$$Example: Java Enum Class$$$Methods of Java Enum Class$$$Why Java Enums?,,
https://www.programiz.com/java-programming/enum-constructor,Java enum Constructor,Example: enum Constructor$$$Table of Contents,,"In this Java tutorial, you can learn about enum constructors with the help of a working example.|||Before you learn about enum constructors, make sure to know about Java enums.|||In Java, an enum class may include a constructor like a regular class. These enum constructors are either|||Output|||In the above example, we have created an enum Size. It includes a private enum constructor. The constructor takes a string value as a parameter and assigns value to the variable pizzaSize.|||Since the constructor is private, we cannot access it from outside the class. However, we can use enum constants to call the constructor.|||In the Main class, we assigned SMALL to an enum variable size. The constant SMALL then calls the constructor Size with string as an argument.|||Finally, we called getSize() using size.",private - accessible within the classor$$$package-private - accessible within the package$$$Java enum Constructor (Introduction)$$$Example: enum Constructor ,,
https://www.programiz.com/java-programming/enum-string,Java enum Strings,Java enum Strings$$$Change Default String Value of enums$$$Table of Contents,,"In this tutorial, we will learn to learn about string values for enum constants. We will also learn to override default string value for enum constants with the help of examples.|||Before you learn about enum strings, make sure to know about Java enum.|||In Java, we can get the string representation of enum constants using the toString() method or the name() method. For example,|||Output |||In the above example, we have seen the default string representation of an enum constant is the name of the same constant.||||||We can change the default string representation of enum constants by overriding the toString() method. For example,|||Output |||In the above program, we have created an enum Size. And we have overridden the toString() method for enum constants SMALL and MEDIUM.|||Note: We cannot override the name() method. It is because the name() method is final.|||To learn more, visit best ways to create enum String.",Java enum Strings $$$Change Default String Representation of enums ,,
https://www.programiz.com/java-programming/reflection,Java Reflection (With Examples),"Reflection of Java Classes$$$Example: Java Class Reflection$$$Reflecting Fields, Methods, and Constructors$$$1. Reflection of Java Methods$$$2. Reflection of Java Fields$$$3. Reflection of Java Constructor$$$Table of Contents",,"In this tutorial, we will learn reflection, a feature in Java programming that allows us to inspect and modify classes, methods, etc.|||In Java, reflection allows us to inspect and manipulate classes, interfaces, constructors, methods, and fields at run time.|||There is a class in Java named Class that keeps all the information about objects and classes at runtime. The object of Class can be used to perform reflection.|||In order to reflect a Java class, we first need to create an object of Class.|||And, using the object we can call various methods to get information about methods, fields, and constructors present in a class.|||There exists three ways to create objects of Class:|||1. Using forName() method|||Here, the forName() method takes the name of the class to be reflected as its argument.|||2. Using getClass() method|||Here, we are using the object of the Dog class to create an object of Class.|||3. Using .class extension|||Now that we know how we can create objects of the Class. We can use this object to get information about the corresponding class at runtime.|||Output|||In the above example, we have created a superclass: Animal and a subclass: Dog. Here, we are trying to inspect the class Dog.|||Notice the statement,|||Here, we are creating an object obj of Class using the getClass() method. Using the object, we are calling different methods of Class.|||To learn more about Class, visit Java Class (official Java documentation).|||Note: We are using the Modifier class to convert the integer access modifier to a string.|||The package java.lang.reflect provides classes that can be used for manipulating class members. For example,|||The Method class provides various methods that can be used to get information about the methods present in a class. For example,|||Output|||In the above example, we are trying to get information about the methods present in the Dog class. As mentioned earlier, we have first created an object obj of Class using the getClass() method.|||Notice the expression,|||Here, the getDeclaredMethod() returns all the methods present inside the class.||||||Also, we have created an object m of the Method class. Here,|||The Method class also provides various other methods that can be used to inspect methods at run time. To learn more, visit the Java Method class (official Java documentation).|||Like methods, we can also inspect and modify different fields of a class using the methods of the Field class. For example,|||Output|||In the above example, we have created a class named Dog. It includes a public field named type. Notice the statement,|||Here, we are accessing the public field of the Dog class and assigning it to the object field1 of the Field class.|||We then used various methods of the Field class:|||Similarly, we can also access and modify private fields as well. However, the reflection of private field is little bit different than the public field. For example,|||Output|||In the above example, we have created a class named Dog. The class contains a private field named color. Notice the statement.|||Here, we are accessing color and assigning it to the object field1 of the Field class. We then used field1 to modify the accessibility of color and allows us to make changes to it.|||We then used field1 to perform various operations on the private field color.|||To learn more about the different methods of Field, visit Java Field Class (official Java documentation).|||We can also inspect different constructors of a class using various methods provided by the Constructor class. For example,|||Output|||In the above example, we have created a class named Dog. The class includes two constructors.|||We are using reflection to find the information about the constructors of the class. Notice the statement,|||Here, the we are accessing all the constructors present in Dog and assigning them to an array constructors of the Constructor type.|||We then used object c to get different informations about the constructor.|||To learn about more methods of the Constructor class, visit Constructor class",obj.getName() - returns the name of the class$$$obj.getModifiers() - returns the access modifier of the class$$$obj.getSuperclass() - returns the super class of the class$$$Method class - provides information about methods in a class$$$Field class - provides information about fields in a class$$$Constructor class - provides information about constructors in a class$$$m.getName() - returns the name of a method$$$m.getModifiers() - returns the access modifier of methods in integer form$$$m.getReturnType() - returns the return type of methods$$$field1.set() - sets the value of the field$$$field1.get() - returns the value of field$$$field1.getModifiers() - returns the value of the field in integer form$$$c.getName() - returns the name of the constructor$$$c.getModifiers() - returns the access modifiers of the constructor in integer form$$$c.getParameterCount() - returns the number of parameters present in each constructor$$$Java Reflection$$$Reflection of Java Classes$$$Example: Java Class Reflection$$$Reflection of Methods$$$Reflection of Fields$$$Reflection of Constructor,,
https://www.programiz.com/java-programming/exceptions,Java Exceptions,Java Exception hierarchy$$$Java Exception Types$$$Errors$$$Exceptions$$$1. RuntimeException$$$2. IOException$$$Table of Contents,,"In this tutorial, we will learn about exceptions in Java. We will cover errors, exceptions and different types of exceptions in Java.|||An exception is an unexpected event that occurs during program execution. It affects the flow of the program instructions which can cause the program to terminate abnormally.|||An exception can occur for many reasons. Some of them are:|||Here is a simplified diagram of the exception hierarchy in Java.||||||As you can see from the image above, the Throwable class is the root class in the hierarchy.|||Note that the hierarchy splits into two branches: Error and Exception.|||Errors represent irrecoverable conditions such as Java virtual machine (JVM) running out of memory, memory leaks, stack overflow errors, library incompatibility, infinite recursion, etc.|||Errors are usually beyond the control of the programmer and we should not try to handle errors.|||Exceptions can be caught and handled by the program.|||When an exception occurs within a method, it creates an object. This object is called the exception object.|||It contains information about the exception such as the name and description of the exception and state of the program when the exception occurred.||||||We will learn how to handle these exceptions in the next tutorial. In this tutorial, we will now focus on different types of exceptions in Java.|||The exception hierarchy also has two branches: RuntimeException and IOException.|||A runtime exception happens due to a programming error. They are also known as unchecked exceptions.|||These exceptions are not checked at compile-time but run-time. Some of the common runtime exceptions are:|||You can think about it in this way. “If it is a runtime exception, it is your fault”.|||The NullPointerException would not have occurred if you had checked whether the variable was initialized or not before using it.|||An ArrayIndexOutOfBoundsException would not have occurred if you tested the array index against the array bounds.|||An IOException is also known as a checked exception. They are checked by the compiler at the compile-time and the programmer is prompted to handle these exceptions.|||Some of the examples of checked exceptions are:|||Now we know about exceptions, we will learn about handling exceptions in the next tutorial.",Invalid user input$$$Device failure$$$Loss of network connection$$$Physical limitations (out of disk memory)$$$Code errors$$$Opening an unavailable file$$$Improper use of an API - IllegalArgumentException $$$Null pointer access (missing the initialization of a variable) - NullPointerException $$$Out-of-bounds array access - ArrayIndexOutOfBoundsException $$$Dividing a number by 0 - ArithmeticException $$$Trying to open a file that doesn’t exist results in FileNotFoundException $$$Trying to read past the end of a file$$$Java Exceptions (Introduction)$$$Java exception hierarchy $$$Errors $$$Exceptions $$$Java Exception Types ,,
https://www.programiz.com/java-programming/exception-handling,Java Exception Handling (With Examples),1. Java try...catch block$$$2. Java finally block$$$3. Java throw and throws keyword$$$Example: Exception handling using try...catch$$$Example: Java Exception Handling using finally block$$$Example: Exception handling using Java throw$$$Example: Java throws keyword$$$Table of Contents,,"In the tutorial, we will learn about different approaches of exception handling in Java with the help of examples.|||In the last tutorial, we learned about Java exceptions. We know that exceptions abnormally terminate the execution of a program.|||This is why it is important to handle exceptions. Here's a list of different approaches to handle exceptions in Java.|||The try-catch block is used to handle exceptions in Java. Here's the syntax of try...catch block:|||Here, we have placed the code that might generate an exception inside the try block. Every try block is followed by a catch block.|||When an exception occurs, it is caught by the catch block. The catch block cannot be used without the try block.|||Output|||In the example, we are trying to divide a number by 0. Here, this code generates an exception.|||To handle the exception, we have put the code, 5 / 0 inside the try block. Now when an exception occurs, the rest of the code inside the try block is skipped.|||The catch block catches the exception and statements inside the catch block is executed.|||If none of the statements in the try block generates an exception, the catch block is skipped.|||In Java, the finally block is always executed no matter whether there is an exception or not.|||The finally block is optional. And, for each try block, there can be only one finally block.|||The basic syntax of finally block is:|||If an exception occurs, the finally block is executed after the try...catch block. Otherwise, it is executed after the try block. For each try block, there can be only one finally block.|||Output||||||In the above example, we are dividing a number by 0 inside the try block. Here, this code generates an ArithmeticException.|||The exception is caught by the catch block. And, then the finally block is executed.|||Note: It is a good practice to use the finally block. It is because it can include important cleanup codes like,|||The Java throw keyword is used to explicitly throw a single exception.|||When we throw an exception, the flow of the program moves from the try block to the catch block.|||Output|||In the above example, we are explicitly throwing the ArithmeticException using the throw keyword.|||Similarly, the throws keyword is used to declare the type of exceptions that might occur within the method. It is used in the method declaration.|||Output|||When we run this program, if the file test.txt does not exist, FileInputStream throws a FileNotFoundException which extends the IOException class.|||The findFile() method specifies that an IOException can be thrown. The main() method calls this method and handles the exception if it is thrown.|||If a method does not handle exceptions, the type of exceptions that may occur within it must be specified in the throws clause.|||To learn more, visit Java throw and throws.","try...catch block$$$finally block$$$throw and throws keyword$$$code that might be accidentally skipped by return, continue or break$$$closing a file or connection$$$Introduction$$$Java try...catch block$$$Java finally block$$$Java throw and throws keyword",,
https://www.programiz.com/java-programming/try-catch,Java try...catch (With Examples),Java try...finally block$$$Java try...catch...finally block$$$Multiple Catch blocks$$$Example: Java try...catch block$$$Example: Java try...finally block$$$Catching Multiple Exceptions$$$Java try-with-resources statement$$$Table of Contents,,"In this tutorial, we will learn about the try catch statement in Java with the help of examples.|||The try...catch block in Java is used to handle exceptions and prevents the abnormal termination of the program.|||Here's the syntax of a try...catch block in Java.|||The try block includes the code that might generate an exception.|||The catch block includes the code that is executed when there occurs an exception inside the try block.|||Output|||In the above example, notice the line,|||Here, we are trying to divide a number by zero. In this case, an exception occurs. Hence, we have enclosed this code inside the try block.|||When the program encounters this code, ArithmeticException occurs. And, the exception is caught by the catch block and executes the code inside the catch block.|||The catch block is only executed if there exists an exception inside the try block.|||Note: In Java, we can use a try block without a catch block. However, we cannot use a catch block without a try block.|||We can also use the try block along with a finally block.|||In this case, the finally block is always executed whether there is an exception inside the try block or not.|||Output|||In the above example, we have used the try block along with the finally block. We can see that the code inside the try block is causing an exception.|||However, the code inside the finally block is executed irrespective of the exception.|||In Java, we can also use the finally block after the try...catch block. For example,|||Output|||In the above example, we have created an array named list and a file named output.txt. Here, we are trying to read data from the array and storing to the file.|||Notice the code,|||Here, the size of the array is 5 and the last element of the array is at list[4]. However, we are trying to access elements at a[5] and a[6].|||Hence, the code generates an exception that is caught by the catch block.|||Since the finally block is always executed, we have included code to close the PrintWriter inside the finally block.||||||It is a good practice to use finally block to include important cleanup code like closing a file or connection.|||Note: There are some cases when a finally block does not execute:|||For each try block, there can be zero or more catch blocks. Multiple catch blocks allow us to handle each exception differently.|||The argument type of each catch block indicates the type of exception that can be handled by it. For example,|||Output|||In this example, we have created an integer array named arr of size 10.|||Since the array index starts from 0, the last element of the array is at arr[9]. Notice the statement,|||Here, we are trying to assign a value to the index 10. Hence, IndexOutOfBoundException occurs.|||When an exception occurs in the try block,|||From Java SE 7 and later, we can now catch more than one type of exception with one catch block.|||This reduces code duplication and increases code simplicity and efficiency.|||Each exception type that can be handled by the catch block is separated using a vertical bar |.|||Its syntax is:|||To learn more, visit Java catching multiple exceptions.|||The try-with-resources statement is a try statement that has one or more resource declarations.|||Its syntax is:|||The resource is an object to be closed at the end of the program. It must be declared and initialized in the try statement.|||Let's take an example.|||The try-with-resources statement is also referred to as automatic resource management. This statement automatically closes all the resources at the end of the statement.|||To learn more, visit the java try-with-resources statement.","Use of System.exit() method$$$An exception occurs in the finally block$$$The death of a thread$$$The exception is thrown to the first catch block. The first catch block does not handle an IndexOutOfBoundsException, so it is passed to the next catch block.$$$The second catch block in the above example is the appropriate exception handler because it handles an IndexOutOfBoundsException. Hence, it is executed.$$$Java try...catch$$$Example: try...catch block$$$Java try...finally$$$Java try...catch...finally$$$Multiple Catch blocks$$$Catching Multiple Exceptions$$$Java try-with-resources statement",,
https://www.programiz.com/java-programming/throw-throws,Java throw and throws Keyword,Java throws keyword$$$Java throw keyword$$$Example 1: Java throws Keyword$$$Throwing multiple exceptions$$$throws keyword Vs. try...catch...finally$$$Example 2: Java throw keyword$$$Example 3: Throwing checked exception$$$Table of Contents,,"In this tutorial, we will learn to use throw and throws keyword for exception handling with the help of examples.|||In Java, exceptions can be categorized into two types:|||Refer to Java Exceptions to learn in detail about checked and unchecked exceptions.|||Usually, we don't need to handle unchecked exceptions. It's because unchecked exceptions occur due to programming errors. And, it is a good practice to correct them instead of handling them.|||This tutorial will now focus on how to handle checked exceptions using throw and throws.|||We use the throws keyword in the method declaration to declare the type of exceptions that might occur within it.|||Its syntax is:|||As you can see from the above syntax, we can use throws to declare multiple exceptions.|||Output|||When we run this program, if the file test.txt does not exist, FileInputStream throws a FileNotFoundException which extends the IOException class.|||If a method does not handle exceptions, the type of exceptions that may occur within it must be specified in the throws clause so that methods further up in the call stack can handle them or specify them using throws keyword themselves.|||The findFile() method specifies that an IOException can be thrown. The main() method calls this method and handles the exception if it is thrown.|||Here's how we can throw multiple exceptions using the throws keyword.|||Here, the findFile() method specifies that it can throw NullPointerException, IOException, and InvalidClassException in its throws clause.|||Note that we have not handled the NullPointerException. This is because it is an unchecked exception. It is not necessary to specify it in the throws clause and handle it.|||There might be several methods that can cause exceptions. Writing try...catch for each method will be tedious and code becomes long and less-readable.||||||throws is also useful when you have checked exception (an exception that must be handled) that you don't want to catch in your current method.|||The throw keyword is used to explicitly throw a single exception.|||When an exception is thrown, the flow of program execution transfers from the try block to the catch block. We use the throw keyword within a method.|||Its syntax is:|||A throwable object is an instance of class Throwable or subclass of the Throwable class.|||Output|||In this example, we are explicitly throwing an ArithmeticException. |||Note: ArithmeticException is an unchecked exception. It's usually not necessary to handle unchecked exceptions.|||Output|||The findFile() method throws an IOException with the message we passed to its constructor.|||Note that since it is a checked exception, we must specify it in the throws clause.|||The methods that call this findFile() method need to either handle this exception or specify it using throws keyword themselves.|||We have handled this exception in the main() method. The flow of program execution transfers from the try block to catch block when an exception is thrown. So, the rest of the code in the try block is skipped and statements in the catch block are executed.","Unchecked Exceptions: They are not checked at compile-time but at run-time.For example: ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, exceptions under Error class, etc.$$$Checked Exceptions: They are checked at compile-time. For example, IOException, InterruptedException, etc.$$$Introduction$$$throws keyword $$$Throwing multiple exceptions $$$throws keyword Vs. try...catch...finally $$$throw keyword ",,
https://www.programiz.com/java-programming/multiple-exceptions,Java catch Multiple Exceptions,Handle Multiple Exceptions in a catch Block$$$Catching base Exception$$$Example 1: Multiple catch blocks$$$Example 2: Multi-catch block$$$Example 3: Catching base exception class only$$$Example 4: Catching base and child exception classes$$$Table of Contents,,"In this tutorial, we will learn to handle multiple exceptions in Java with the help of examples.|||Before Java 7, we had to write multiple exception handling codes for different types of exceptions even if there was code redundancy.|||Let’s take an example.|||Output|||In this example, two exceptions may occur:|||We are printing out the exception message in both the catch blocks i.e. duplicate code.|||The associativity of the assignment operator = is right to left, so an ArithmeticException is thrown first with the message / by zero.|||In Java SE 7 and later, we can now catch more than one type of exception in a single catch block.|||Each exception type that can be handled by the catch block is separated using a vertical bar or pipe |.|||Its syntax is:|||Output|||Catching multiple exceptions in a single catch block reduces code duplication and increases efficiency.|||The bytecode generated while compiling this program will be smaller than the program having multiple catch blocks as there is no code redundancy.||||||Note: If a catch block handles multiple exceptions, the catch parameter is implicitly final. This means we cannot assign any values to catch parameters.|||When catching multiple exceptions in a single catch block, the rule is generalized to specialized.|||This means that if there is a hierarchy of exceptions in the catch block, we can catch the base exception only instead of catching multiple specialized exceptions.|||Let’s take an example.|||Output|||We know that all the exception classes are subclasses of the Exception class. So, instead of catching multiple specialized exceptions, we can simply catch the Exception class.|||If the base exception class has already been specified in the catch block, do not use child exception classes in the same catch block. Otherwise, we will get a compilation error.|||Let’s take an example.|||Output|||In this example, ArithmeticException and ArrayIndexOutOfBoundsException are both subclasses of the Exception class. So, we get a compilation error.",ArithmeticException because we are trying to divide a number by 0.$$$ArrayIndexOutOfBoundsException because we have declared a new integer array with array bounds 0 to 9 and we are trying to assign a value to index 10.$$$Introduction$$$Handle Multiple Exceptions in a catch Block $$$Catching base Exception ,,
https://www.programiz.com/java-programming/try-with-resources,Java try-with-resources (With Examples),Suppressed Exceptions$$$Advantages of using try-with-resources$$$Java 9 try-with-resources enhancement$$$Example 1: try-with-resources$$$Retrieving Suppressed Exceptions$$$1. finally block not required to close the resource$$$Example 2: Close resource using finally block$$$2. try-with-resources with multiple resources$$$Example 3: try with multiple resources$$$Table of Contents,,"In this tutorial, we will learn about the try-with-resources statement to close resources automatically.|||The try-with-resources statement automatically closes all the resources at the end of the statement. A resource is an object to be closed at the end of the program.|||Its syntax is:|||As seen from the above syntax, we declare the try-with-resources statement by,|||Note: The try-with-resources statement closes all the resources that implement the AutoCloseable interface.|||Let us take an example that implements the try-with-resources statement.|||Output if the test.txt file is not found.|||Output if the test.txt file is found.|||In this example, we use an instance of BufferedReader to read data from the test.txt file.|||Declaring and instantiating the BufferedReader inside the try-with-resources statement ensures that its instance is closed regardless of whether the try statement completes normally or throws an exception.|||If an exception occurs, it can be handled using the exception handling blocks or the throws keyword.|||In the above example, exceptions can be thrown from the try-with-resources statement when:|||An exception can also be thrown from the try block as a file read can fail for many reasons at any time.|||If exceptions are thrown from both the try block and the try-with-resources statement, exception from the try block is thrown and exception from the try-with-resources statement is suppressed.|||In Java 7 and later, the suppressed exceptions can be retrieved by calling the Throwable.getSuppressed() method from the exception thrown by the try block.|||This method returns an array of all suppressed exceptions. We get the suppressed exceptions in the catch block.||||||Here are the advantages of using try-with-resources:|||Before Java 7 introduced this feature, we had to use the finally block to ensure that the resource is closed to avoid resource leaks.|||Here's a program that is similar to Example 1. However, in this program, we have used finally block to close resources.|||Output|||As we can see from the above example, the use of finally block to clean up resources makes the code more complex.|||Notice the try...catch block in the finally block as well? This is because an IOException can also occur while closing the BufferedReader instance inside this finally block so it is also caught and handled.|||The try-with-resources statement does automatic resource management. We need not explicitly close the resources as JVM automatically closes them. This makes the code more readable and easier to write.|||We can declare more than one resource in the try-with-resources statement by separating them with a semicolon ;|||If this program executes without generating any exceptions, Scanner object reads a line from the testRead.txt file and writes it in a new testWrite.txt file.|||When multiple declarations are made, the try-with-resources statement closes these resources in reverse order. In this example, the PrintWriter object is closed first and then the Scanner object is closed.|||In Java 7, there is a restriction to the try-with-resources statement. The resource needs to be declared locally within its block.|||If we declared the resource outside the block in Java 7, it would have generated an error message.|||To deal with this error, Java 9 improved the try-with-resources statement so that the reference of the resource can be used even if it is not declared locally. The above code will now execute without any compilation error.",The file test.txt is not found.$$$Closing the BufferedReader object.$$$Introduction$$$Example: try-with-resources $$$Suppressed Exceptions $$$Advantages of using try-with-resources $$$Java 9 try-with-resources enhancement ,declaring and instantiating the resource within the try clause.$$$specifying and handling all exceptions that might be thrown while closing the resource.,
https://www.programiz.com/java-programming/annotations,Java Annotations (With Examples),Annotation formats$$$Annotation placement$$$Types of Annotations$$$Use of Annotations$$$Example 1: @Override Annotation Example$$$1. Marker Annotations$$$2. Single element Annotations$$$3. Multiple element Annotations$$$1. Above declarations$$$Example 2: @SuppressWarnings Annotation Example$$$2. Type annotations$$$Table of Contents,,"In this tutorial, we will learn what annotations are, different Java annotations and how to use them with the help of examples.|||Java annotations are metadata (data about data) for our program source code.|||They provide additional information about the program to the compiler but are not part of the program itself. These annotations do not affect the execution of the compiled program.|||Annotations start with @. Its syntax is:|||Let's take an example of @Override annotation.|||The @Override annotation specifies that the method that has been marked with this annotation overrides the method of the superclass with the same method name, return type, and parameter list.|||It is not mandatory to use @Override when overriding a method. However, if we use it, the compiler gives an error if something is wrong (such as wrong parameter type) while overriding the method.|||Output|||In this example, the method displayInfo() is present in both the superclass Animal and subclass Dog. When this method is called, the method of the subclass is called instead of the method in the superclass.|||Annotations may also include elements (members/attributes/parameters).|||Marker annotations do not contain members/elements. It is only used for marking a declaration.|||Its syntax is:|||Since these annotations do not contain elements, parentheses can be excluded. For example,|||A single element annotation contains only one element.|||Its syntax is:|||If there is only one element, it is a convention to name that element as value.|||In this case, the element name can be excluded as well. The element name will be value by default.|||These annotations contain multiple elements separated by commas.|||Its syntax is:|||Any declaration can be marked with annotation by placing it above that declaration. As of Java 8, annotations can also be placed before a type.|||As mentioned above, Java annotations can be placed above class, method, interface, field, and other program element declarations.||||||Output|||If the above program is compiled without using the @SuppressWarnings(""unchecked"") annotation, the compiler will still compile the program but it will give warnings like:|||We are getting the warning|||because of the following statement.|||This is because we haven't defined the generic type of the array list. We can fix this warning by specifying generics inside angle brackets <>.|||Before Java 8, annotations could be applied to declarations only. Now, type annotations can be used as well. This means that we can place annotations wherever we use a type.|||Constructor invocations|||Type definitions|||This declaration specifies non-null variable str of type String to avoid NullPointerException.|||This declaration specifies a non-null list of type String.|||This declaration specifies a list of non-null values of type String.|||Type casts |||extends and implements clause |||throws clause |||Type annotations enable Java code to be analyzed better and provide even stronger type checks.|||1. Predefined annotations|||2. Meta-annotations|||3. Custom annotations|||These annotation types are described in detail in the Java Annotation Types tutorial.","Compiler instructions - Annotations can be used for giving instructions to the compiler, detect errors or suppress warnings. The built-in annotations @Deprecated, @Override, @SuppressWarnings are used for these purposes.$$$Compile-time instructions - Compile-time instructions provided by these annotations help the software build tools to generate code, XML files and many more.$$$Runtime instructions - Some annotations can be defined to give instructions to the program at runtime. These annotations are accessed using Java Reflection.$$$Annotation formats$$$Annotation placement$$$Types of Java Annotations$$$Use of Annotations",@Deprecated$$$@Override$$$@SuppressWarnings$$$@SafeVarargs$$$@FunctionalInterface$$$@Retention$$$@Documented$$$@Target$$$@Inherited$$$@Repeatable,
https://www.programiz.com/java-programming/annotation-types,Java Annotations Types,Predefined Annotation Types$$$Custom Annotations$$$Meta Annotations$$$1. @Deprecated$$$Example 1: @Deprecated annotation example$$$2. @Override$$$Example 2: @Override annotation example$$$3. @SuppressWarnings$$$Example 3: @SuppressWarnings annotation example$$$4. @SafeVarargs$$$Example 4: @SafeVarargs annotation example$$$5. @FunctionalInterface$$$Example 5: @FunctionalInterface annotation example$$$Example 6: Custom annotation example$$$1. @Retention$$$2. @Documented$$$3. @Target$$$4. @Inherited$$$5. @Repeatable$$$Table of Contents,,"In this tutorial, we will learn about different types of Java annotation with the help of examples.|||Java annotations are metadata (data about data) for our program source code. There are several predefined annotations provided by the Java SE. Moreover, we can also create custom annotations as per our needs.|||If you do not know what annotations are, visit the Java annotations tutorial.|||These annotations can be categorized as:|||1. Predefined annotations |||2. Custom annotations|||3. Meta-annotations|||The @Deprecated annotation is a marker annotation that indicates the element (class, method, field, etc) is deprecated and has been replaced by a newer element.|||Its syntax is:|||When a program uses the element that has been declared deprecated, the compiler generates a warning.|||We use Javadoc @deprecated tag for documenting the deprecated element.|||Output|||The @Override annotation specifies that a method of a subclass overrides the method of the superclass with the same method name, return type, and parameter list.|||It is not mandatory to use @Override when overriding a method. However, if we use it, the compiler gives an error if something is wrong (such as wrong parameter type) while overriding the method.|||Output |||In this example, by making an object dog1 of Dog class, we can call its method printMessage() which then executes the display() statement.|||Since display() is defined in both the classes, the method of subclass Dog overrides the method of superclass Animal. Hence, the display() of the subclass is called.|||As the name suggests, the @SuppressWarnings annotation instructs the compiler to suppress warnings that are generated while the program executes.|||We can specify the type of warnings to be suppressed. The warnings that can be suppressed are compiler-specific but there are two categories of warnings: deprecation and unchecked.|||To suppress a particular category of warning, we use:|||For example,|||To suppress multiple categories of warnings, we use:|||For example,|||Category deprecated instructs the compiler to suppress warnings when we use a deprecated element.|||Category unchecked instructs the compiler to suppress warnings when we use raw types.|||And, undefined warnings are ignored. For example,|||Output |||Here, deprecatedMethod() has been marked as deprecated and will give compiler warnings when used. By using the @SuppressWarnings(""deprecated"") annotation, we can avoid compiler warnings.|||The @SafeVarargs annotation asserts that the annotated method or constructor does not perform unsafe operations on its varargs (variable number of arguments).|||We can only use this annotation on methods or constructors that cannot be overridden. This is because the methods that override them might perform unsafe operations.|||Before Java 9, we could use this annotation only on final or static methods because they cannot be overridden. We can now use this annotation for private methods as well.|||Warnings |||Output|||Here, List ... lists specifies a variable-length argument of type List. This means that the method displayList() can have zero or more arguments.||||||The above program compiles without errors but gives warnings when @SafeVarargs annotation isn't used.|||When we use @SafeVarargs annotation in the above example,|||We get the same output but without any warnings. Unchecked warnings are also suppressed when we use this annotation.|||Java 8 first introduced this @FunctionalInterface annotation. This annotation indicates that the type declaration on which it is used is a functional interface. A functional interface can have only one abstract method.|||If we add another abstract method, let's say|||Now, when we run the program, we will get the following warning:|||It is not mandatory to use @FunctionalInterface annotation. The compiler will consider any interface that meets the functional interface definition as a functional interface.|||We use this annotation to make sure that the functional interface has only one abstract method.|||However, it can have any number of default and static methods because they have an implementation.|||It is also possible to create our own custom annotations.|||Its syntax is:|||Here is what you need to know about custom annotation:|||Output |||Meta-annotations are annotations that are applied to other annotations.|||The @Retention annotation specifies the level up to which the annotation will be available.|||Its syntax is:|||There are 3 types of retention policies:|||For example,|||By default, custom annotations are not included in the official Java documentation. To include our annotation in the Javadoc documentation, we use the @Documented annotation.|||For example,|||We can restrict an annotation to be applied to specific targets using the @Target annotation.|||Its syntax is:|||The ElementType can have one of the following types:|||For example,|||In this example, we have restricted the use of this annotation to methods only.|||Note: If the target type is not defined, the annotation can be used for any element.|||By default, an annotation type cannot be inherited from a superclass. However, if we need to inherit an annotation from a superclass to a subclass, we use the @Inherited annotation.|||Its syntax is:|||For example,|||An annotation that has been marked by @Repeatable can be applied multiple times to the same declaration.|||The value defined in the @Repeatable annotation is the container annotation. The container annotation has a variable value of array type of the above repeatable annotation. Here, Universities are the containing annotation type.|||Now, the @University annotation can be used multiple times on the same declaration.|||If we need to retrieve the annotation data, we can use the Reflection API.|||To retrieve annotation values, we use getAnnotationsByType() or getAnnotations() method defined in the Reflection API.","@Deprecated$$$@Override$$$@SuppressWarnings$$$@SafeVarargs$$$@FunctionalInterface$$$@Retention$$$@Documented$$$@Target$$$@Inherited$$$@Repeatable$$$Annotations can be created by using @interface followed by the annotation name.$$$The annotation can have elements that look like methods but they do not have an implementation.$$$The default value is optional. The parameters cannot have a null value.$$$The return type of the method can be primitive, enum, string, class name or array of these types.$$$RetentionPolicy.SOURCE - The annotation is available only at the source level and is ignored by the compiler.$$$RetentionPolicy.CLASS - The annotation is available to the compiler at compile-time, but is ignored by the Java Virtual Machine (JVM).$$$RetentionPolicy.RUNTIME - The annotation is available to the JVM.$$$Predefined Annotation Types$$$Custom Annotations$$$Meta Annotations",,Element Type|||Target$$$ElementType.ANNOTATION_TYPE|||Annotation type$$$ElementType.CONSTRUCTOR |||Constructors$$$ElementType.FIELD |||Fields$$$ElementType.LOCAL_VARIABLE |||Local variables$$$ElementType.METHOD |||Methods$$$ElementType.PACKAGE |||Package$$$ElementType.PARAMETER |||Parameter$$$ElementType.TYPE |||Any element of class
https://www.programiz.com/java-programming/logging,Java Logging,Java Logging Components$$$LogManager$$$Advantages of Logging$$$1. Logger$$$Logging the message$$$2. Filters$$$3. Handlers(Appenders)$$$4. Formatters$$$Table of Contents,,"In this tutorial, we will learn about Java Logging and its various components with the help of examples.|||Java allows us to create and capture log messages and files through the process of logging.|||In Java, logging requires frameworks and APIs. Java has a built-in logging framework in the java.util.logging package.|||We can also use third-party frameworks like Log4j, Logback, and many more for logging purposes.|||The figure below represents the core components and the flow of control of the Java Logging API (java.util.logging).|||The Logger class provides methods for logging. We can instantiate objects from the Logger class and call its methods for logging purposes.|||Let's take an example.|||The getLogger() method of the Logger class is used to find or create a new Logger. The string argument defines the name of the logger.|||Here, this creates a new Logger object or returns an existing Logger with the same name.|||It is a convention to define a Logger after the current class using class.getName().|||Note: This method will throw NullPointerException if the passed name is null.|||Each Logger has a level that determines the importance of the log message. There are 7 basic log levels:|||Each log level has an integer value that determines their severity except for two special log levels OFF and ALL.|||By default, the top three log levels are always logged. To set a different level, we can use the following code:|||In this example, only level FINE and levels above it are set to be logged. All other log messages are dropped.|||Now to log a message, we use the log() method.|||There are shorthand methods for logging at desired levels.|||All log requests that have passed the set log level are then forwarded to the LogRecord.|||Note: If a logger's level is set to null, its level is inherited from its parent and so on up the tree.||||||A filter (if it is present) determines whether the LogRecord should be forwarded or not. As the name suggests, it filters the log messages according to specific criteria.|||A LogRecord is only passed from the logger to the log handler and from the log handler to external systems if it passes the specified criteria.|||The log handler or the appenders receive the LogRecord and exports it to various targets.|||Java SE provides 5 built-in handlers:|||A handler can pass the LogRecord to a filter to again determine whether it can be forwarded to external systems or not.|||To add a new handler, we use the following code:|||To remove a handler, we use the following code:|||A logger can have multiple handlers. To get all the handlers, we use the following code:|||A handler can also use a Formatter to format the LogRecord object into a string before exporting it to external systems.|||Java SE has two built-in Formatters:|||We can use the following code to format a handler:|||The LogManager object keeps track of the global logging information. It reads and maintains the logging configuration and the logger instances.|||The log manager is a singleton, which means that only one instance of it is instantiated.|||To obtain the log manager instance, we use the following code:|||Here are some of the advantages of logging in Java.",helps in monitoring the flow of the program$$$helps in capturing any errors that may occur$$$provides support for problem diagnosis and debugging$$$Introduction$$$Logging Components$$$Logger$$$Logging the message$$$Filters$$$Handlers (Appenders)$$$Formatters$$$LogManager$$$Advantages,,"Log Level (in descending order)|||Use$$$SEVERE|||serious failure$$$WARNING|||warning message, a potential problem$$$INFO|||general runtime information$$$CONFIG|||configuration information$$$FINE|||general developer information (tracing messages)$$$FINER|||detailed developer information (tracing messages)$$$FINEST|||highly detailed developer information(tracing messages)$$$OFF|||turn off logging for all levels (capture nothing)$$$ALL|||turn on logging for all levels (capture everything)$$$Handlers|||Use$$$StreamHandler|||writes to an OutputStream$$$ConsoleHandler|||writes to console$$$FileHandler|||writes to file$$$SocketHandler|||writes to remote TCP ports$$$MemoryHandler|||writes to memory$$$Formatters|||Use$$$SimpleFormatter|||formats LogRecord to string$$$XMLFormatter|||formats LogRecord to XML form"
https://www.programiz.com/java-programming/assertions,Java Assertions (assert Statement),Enabling Assertions$$$Another form of assertion statement$$$Enabling assertion for specific classes and packages$$$Disabling Assertions$$$Advantages of Assertion$$$When to use Assertions$$$When not to use Assertions$$$Example 1: Java assertion$$$Example 2: Java assertion with expression example$$$1. Unreachable codes$$$2. Documenting assumptions$$$1. Argument checking in public methods$$$2. To evaluate expressions that affect the program operation$$$Table of Contents,,"In this tutorial, we will learn about the Java assert statement (Java assertions) with the help of examples.|||Assertions in Java help to detect bugs by testing code we assume to be true.|||An assertion is made using the assert keyword.|||Its syntax is:|||Here, condition is a boolean expression that we assume to be true when the program executes.|||By default, assertions are disabled and ignored at runtime.|||To enable assertions, we use:|||OR|||When assertions are enabled and the condition is true, the program executes normally.|||But if the condition evaluates to false while assertions are enabled, JVM throws an AssertionError, and the program stops immediately.|||Output|||We get the above output because this program has no compilation errors and by default, assertions are disabled.|||After enabling assertions, we get the following output:|||In this form of assertion statement, an expression is passed to the constructor of the AssertionError object. This expression has a value that is displayed as the error’s detail message if the condition is false.|||The detailed message is used to capture and transmit the information of the assertion failure to help in debugging the problem.|||Output|||As we see from the above example, the expression is passed to the constructor of the AssertionError object. If our assumption is false and assertions are enabled, an exception is thrown with an appropriate message.|||This message helps in diagnosing and fixing the error that caused the assertion to fail.|||If we do not provide any arguments to the assertion command-line switches,|||This enables assertions in all classes except system classes.|||We can also enable assertion for specific classes and packages using arguments. The arguments that can be provided to these command-line switches are:|||Enable assertion in class names|||To enable assertion for all classes of our program Main,|||To enable only one class,|||This enables assertion in only the AnimalClass in the Main program.||||||Enable assertion in package names|||To enable assertions for package com.animal and its sub-packages only,|||Enable assertion in unnamed packages|||To enable assertion in unnamed packages (when we don’t use a package statement) in the current working directory.|||Enable assertion in system classes|||To enable assertion in system classes, we use a different command-line switch:|||OR|||The arguments that can be provided to these switches are the same.|||To disable assertions, we use:|||OR|||To disable assertion in system classes, we use:|||OR|||The arguments that can be passed while disabling assertions are the same as while enabling them.|||Unreachable codes are codes that do not execute when we try to run the program. Use assertions to make sure unreachable codes are actually unreachable.|||Let’s take an example.|||Let’s take another example of a switch statement without a default case.|||The above switch statement indicates that the days of the week can be only one of the above 7 values. Having no default case means that the programmer believes that one of these cases will always be executed.|||However, there might be some cases that have not yet been considered where the assumption is actually false.|||This assumption should be checked using an assertion to make sure that the default switch case is not reached.|||If dayOfWeek has a value other than the valid days, an AssertionError is thrown.|||To document their underlying assumptions, many programmers use comments. Let’s take an example.|||Use assertions instead.|||Comments can get out-of-date and out-of-sync as the program grows. However, we will be forced to update the assert statements; otherwise, they might fail for valid conditions too.|||Arguments in public methods may be provided by the user.|||So, if an assertion is used to check these arguments, the conditions may fail and result in AssertionError.|||Instead of using assertions, let it result in the appropriate runtime exceptions and handle these exceptions.|||Do not call methods or evaluate exceptions that can later affect the program operation in assertion conditions.|||Let us take an example of a list weekdays which contains the names of all the days in a week.|||Here, we are trying to remove elements Saturday and Sunday from the ArrayList weekdays.|||If the assertion is enabled, the program works fine. However, if assertions are disabled, the elements from the list are not removed. This may result in program failure.|||Instead, assign the result to a variable and then use that variable for assertion.|||In this way, we can ensure that all the weekends are removed from the weekdays regardless of the assertion being enabled or disabled. As a result, it does not affect the program operation in the future.",Enabling assertions$$$Example: Java assertion$$$Another form of assertion statement$$$Assertion for specific classes and packages$$$Disabling assertions$$$When to use assertions$$$When not to use assertions,Quick and efficient for detecting and correcting bugs.$$$Assertion checks are done only during development and testing. They are automatically removed in the production code at runtime so that it won’t slow the execution of the program.$$$It helps remove boilerplate code and make code more readable.$$$Refactors and optimizes code with increased confidence that it functions correctly.,
https://www.programiz.com/java-programming/collections,Java Collections Framework,Interfaces of Collections FrameWork$$$Java Collection Interface$$$Subinterfaces of the Collection Interface$$$Java Map Interface$$$Java Iterator Interface$$$Why the Collections Framework?$$$Example: ArrayList Class of Collections$$$Collections Framework Vs. Collection Interface$$$List Interface$$$Set Interface$$$Queue Interface$$$Table of Contents,,"In this tutorial, we will learn about different interfaces of the Java collections framework.|||The Java collections framework provides a set of interfaces and classes to implement various data structures and algorithms.|||For example, the LinkedList class of the collections framework provides the implementation of the doubly-linked list data structure.|||The Java collections framework provides various interfaces. These interfaces include several methods to perform different operations on collections.||||||We will learn about these interfaces, their subinterfaces, and implementation in various classes in detail in the later chapters. Let's learn about the commonly used interfaces in brief in this tutorial.|||The Collection interface is the root interface of the collections framework hierarchy.|||Java does not provide direct implementations of the Collection interface but provides implementations of its subinterfaces like List, Set, and Queue. To learn more, visit: Java Collection Interface|||People often get confused between the collections framework and Collection Interface.|||The Collection interface is the root interface of the collections framework. The framework includes other interfaces as well: Map and Iterator. These interfaces may also have subinterfaces.|||As mentioned earlier, the Collection interface includes subinterfaces that are implemented by Java classes.|||All the methods of the Collection interface are also present in its subinterfaces.|||Here are the subinterfaces of the Collection Interface:||||||The List interface is an ordered collection that allows us to add and remove elements like an array. To learn more, visit Java List Interface|||The Set interface allows us to store elements in different sets similar to the set in mathematics. It cannot have duplicate elements. To learn more, visit Java Set Interface|||The Queue interface is used when we want to store and access elements in First In, First Out manner. To learn more, visit Java Queue Interface|||In Java, the Map interface allows elements to be stored in key/value pairs. Keys are unique names that can be used to access a particular element in a map. And, each key has a single value associated with it. To learn more, visit Java Map Interface|||In Java, the Iterator interface provides methods that can be used to access elements of collections. To learn more, visit Java Iterator Interface|||The Java collections framework provides various data structures and algorithms that can be used directly. This has two main advantages:|||Moreover, the collections framework allows us to use a specific data structure for a particular type of data. Here are a few examples,|||Before we wrap up this tutorial, let's take an example of the ArrayList class of the collections framework.|||The ArrayList class allows us to create resizable arrays. The class implements the List interface (which is a subinterface of the Collection interface).|||Output:|||In the later tutorials, we will learn about the collections framework (its interfaces and classes) in detail with the help of examples.","We do not have to write code to implement these data structures and algorithms manually.$$$Our code will be much more efficient as the collections framework is highly optimized.$$$If we want our data to be unique, then we can use the Set interface provided by the collections framework.$$$To store data in key/value pairs, we can use the Map interface.$$$The ArrayList class provides the functionality of resizable arrays.$$$Interfaces of Collections FrameWork$$$Java Collection Interface$$$Interfaces of the Collections Framework$$$Why the Collections Framework?",,
https://www.programiz.com/java-programming/collection-interface,Java Collection Interface,Subinterfaces of Collection$$$Methods of Collection$$$1. List Interface$$$2. Set Interface$$$3. Queue Interface$$$Table of Contents,,"In this tutorial, we will learn about the Java Collection interface and its subinterfaces.|||The Collection interface is the root interface of the Java collections framework.|||There is no direct implementation of this interface. However, it is implemented through its subinterfaces like List, Set, and Queue.|||For example, the ArrayList class implements the List interface which is a subinterface of the Collection Interface.||||||As mentioned above, the Collection interface includes subinterfaces that are implemented by various classes in Java.||||||The List interface is an ordered collection that allows us to add and remove elements like an array. To learn more, visit: Java List Interface.|||The Set interface allows us to store elements in different sets similar to the set in mathematics. It cannot have duplicate elements. To learn more, visit: Java Set Interface.|||The Queue interface is used when we want to store and access elements in First In, First Out(FIFO) manner. To learn more, visit: Java Queue Interface.|||The Collection interface includes various methods that can be used to perform different operations on objects. These methods are available in all its subinterfaces.",add() - inserts the specified element to the collection$$$size() - returns the size of the collection$$$remove() - removes the specified element from the collection$$$iterator() - returns an iterator to access elements of the collection$$$addAll() - adds all the elements of a specified collection to the collection$$$removeAll() - removes all the elements of the specified collection from the collection$$$clear() - removes all the elements of the collection$$$Subinterfaces of Collection$$$Methods of Collection,,
https://www.programiz.com/java-programming/list,Java List Interface,Classes that Implement List$$$How to use List?$$$Methods of List$$$Implementation of the List Interface$$$Java List vs. Set$$$Table of Contents,,"In this tutorial, we will learn about the List interface in Java and its methods.|||In Java, the List interface is an ordered collection that allows us to store and access elements sequentially. It extends the Collection interface.|||Since List is an interface, we cannot create objects from it.|||In order to use functionalities of the List interface, we can use these classes:||||||These classes are defined in the Collections framework and implement the List interface.|||In Java, we must import java.util.List package in order to use List.|||Here, we have created objects list1 and list2 of classes ArrayList and LinkedList. These objects can use the functionalities of the List interface.|||The List interface includes all the methods of the Collection interface. Its because Collection is a super interface of List.|||Some of the commonly used methods of the Collection interface that's also available in the List interface are:||||||1. Implementing the ArrayList Class |||Output|||To learn more about ArrayList, visit Java ArrayList.|||2. Implementing the LinkedList Class|||Output|||To learn more about LinkedList, visit Java LinkedList.|||Both the List interface and the Set interface inherits the Collection interface. However, there exists some difference between them.|||Now that we know what List is, we will see its implementations in ArrayList and LinkedList classes in detail in the next tutorials.","ArrayList$$$LinkedList$$$Vector$$$Stack$$$add() - adds an element to a list$$$addAll() - adds all elements of one list to another$$$get() - helps to randomly access elements from lists$$$iterator() - returns iterator object that can be used to sequentially access elements of lists$$$set() - changes elements of lists$$$remove() - removes an element from the list$$$removeAll() - removes all the elements from the list$$$clear() - removes all the elements from the list (more efficient than removeAll())$$$size() - returns the length of lists$$$toArray() - converts a list into an array$$$contains() - returns true if a list contains specified element$$$Lists can include duplicate elements. However, sets cannot have duplicate elements.$$$Elements in lists are stored in some order. However, elements in sets are stored in groups like sets in mathematics.$$$Introduction$$$Classes that Implement List$$$How to use List?$$$Methods of List$$$Implementation of the List Interface $$$Java List vs. Set",,
https://www.programiz.com/java-programming/arraylist,Java ArrayList (With Examples),Java ArrayList Vs Array$$$Creating an ArrayList$$$Basic Operations on ArrayList$$$Other way to add elements to arraylist$$$Methods of ArrayList Class$$$Iterate through an ArrayList$$$Frequently Asked Questions$$$Example: Create ArrayList in Java$$$1. Add Elements to an ArrayList$$$2. Access ArrayList Elements$$$3. Change ArrayList Elements$$$4. Remove ArrayList Elements$$$Table of Contents,,"In this tutorial, we will learn about the ArrayList class in Java. We will learn about different operations and methods of the arraylist with the help of examples.|||The ArrayList class of the Java collections framework provides the functionality of resizable-arrays.|||It implements the List interface.|||In Java, we need to declare the size of an array before we can use it. Once the size of an array is declared, it's hard to change it.|||To handle this issue, we can use the ArrayList class. It allows us to create resizable arrays.|||Unlike arrays, arraylists can automatically adjust its capacity when we add or remove elements from it. Hence, arraylists are also known as dynamic arrays.|||Before using ArrayList, we need to import the java.util.ArrayList package first. Here is how we can create arraylists in Java:|||Here, Type indicates the type of an arraylist. For example,|||In the above program, we have used Integer not int. It is because we cannot use primitive types while creating an arraylist. Instead, we have to use the corresponding wrapper classes.|||Here, Integer is the corresponding wrapper class of int. To learn more, visit the Java wrapper class.|||Output|||In the above example, we have created an ArrayList named languages.|||Here, we have used the add() method to add elements to the arraylist. We will learn more about the add() method later in this tutorial.|||The ArrayList class provides various methods to perform different operations on arraylists. We will look at some commonly used arraylist operations in this tutorial:|||To add a single element to the arraylist, we use the add() method of the ArrayList class. For example,|||Output|||In the above example, we have created an ArrayList named languages. Here, we have used the add() method to add elements to languages.|||To learn more, visit the Java ArrayList add().|||We can also pass an index number as an additional parameter to the add() method to add an element at the specified position. For example,|||We can also add all elements of a collection (set, map) to an arraylist using the addAll() method. For example,|||To learn more, visit Java ArrayList addAll().|||To access an element from the arraylist, we use the get() method of the ArrayList class. For example,|||Output|||In the above example, we have used the get() method with parameter 1. Here, the method returns the element at index 1.|||To learn more, visit the Java ArrayList get().|||We can also access elements of the ArrayList using the iterator() method. To learn more, visit Java ArrayList iterator().|||To change elements of the arraylist, we use the set() method of the ArrayList class. For example,|||Output|||In the above example, we have created an ArrayList named languages. Notice the line,||||||Here, the set() method changes the element at index 2 to JavaScript.|||To learn more, visit the Java ArrayList set().|||To remove an element from the arraylist, we can use the remove() method of the ArrayList class. For example,|||Output|||Here, the remove() method takes the index number as the parameter. And, removes the element specified by the index number.|||To learn more, visit the Java ArrayList remove().|||We can also remove all the elements from the arraylist at once. To learn more, visit|||In the previous section, we have learned about the add(), get(), set(), and remove() method of the ArrayList class.|||Besides those basic methods, here are some more ArrayList methods that are commonly used.|||If you want to learn about all the different methods of arraylist, visit Java ArrayList methods.|||We can use the Java for-each loop to loop through each element of the arraylist. For example,|||Output|||Some of the major differences between ArrayList and LinkedList in Java are:|||We can convert the ArrayList into an array using the toArray() method. For example,|||Output|||In the above example, the toArray() method converts the languages arraylist to an array and stores it in arr. To learn more, visit Java ArrayList toArray().|||We use the asList() method of the Arrays class. To use asList(), we must import the java.util.Arrays package first. For example,|||Output|||In the above program, we first created an array arr of the String type. Notice the expression,|||Here, the asList() method converts the array into an arraylist.|||We use the Arrays.asList() method to create and initialize an arraylist in a single line. For example,|||We use the toString() method of the ArrayList class to convert an arraylist into a string. For example,|||Output|||Here, the toString() method converts the whole arraylist into a single string. To learn more, visit Java ArrayList toString().|||We can also create an arraylist using the List interface. It's because the ArrayList class implements the List interface. Let's see an example,",Add elements$$$Access elements$$$Change elements$$$Remove elements$$$Java ArrayList removeAll()$$$Java ArrayList clear()$$$Introduction$$$Creating an ArrayList$$$Example: Create ArrayList in Java$$$Add Elements to an ArrayList$$$Access ArrayList Elements$$$Change ArrayList Elements$$$Remove ArrayList Elements$$$Methods of ArrayList Class$$$Iterate through an ArrayList,,"Methods|||Descriptions$$$size()|||Returns the length of the arraylist.$$$sort()|||Sort the arraylist elements.$$$clone()|||Creates a new arraylist with the same element, size, and capacity.$$$contains()|||Searches the arraylist for the specified element and returns a boolean result.$$$ensureCapacity()|||Specifies the total element the arraylist can contain.$$$isEmpty()|||Checks if the arraylist is empty.$$$indexOf()|||Searches a specified element in an arraylist and returns the index of the element.$$$ArrayList|||LinkedList$$$Implements List interface|||Implements List, Queue, and Deque interfaces.$$$Stores a single value.|||Stores 3 values: data, previous and next address$$$Provides the functionality of a resizable array.|||Provides the functionality of doubly-linked list"
https://www.programiz.com/java-programming/vector,Java Vector (With Examples),Java Vector vs. ArrayList$$$Creating a Vector$$$Methods of Vector$$$Add Elements to Vector$$$Access Vector Elements$$$Remove Vector Elements$$$Others Vector Methods$$$Table of Contents,,"In this tutorial, we will learn about the Vector class and how to use it. We will also learn how it is different from the ArrayList class, and why we should use array lists instead.|||The Vector class is an implementation of the List interface that allows us to create resizable-arrays similar to the ArrayList class.|||In Java, both ArrayList and Vector implements the List interface and provides the same functionalities. However, there exist some differences between them.|||The Vector class synchronizes each individual operation. This means whenever we want to perform some operation on vectors, the Vector class automatically applies a lock to that operation.|||It is because when one thread is accessing a vector, and at the same time another thread tries to access it, an exception called ConcurrentModificationException is generated. Hence, this continuous use of lock for each operation makes vectors less efficient.|||However, in array lists, methods are not synchronized. Instead, it uses the Collections.synchronizedList() method that synchronizes the list as a whole.|||Note: It is recommended to use ArrayList in place of Vector because vectors less efficient.|||Here is how we can create vectors in Java.|||Here, Type indicates the type of a linked list. For example,||||||The Vector class also provides the resizable-array implementations of the List interface (similar to the ArrayList class). Some of the Vector methods are:|||For example,|||Output|||For example,|||Output|||For example,|||Output","add(element) - adds an element to vectors$$$add(index, element) - adds an element to the specified position$$$addAll(vector) - adds all elements of a vector to another vector$$$get(index) - returns an element specified by the index$$$iterator() - returns an iterator object to sequentially access vector elements$$$remove(index) - removes an element from specified position$$$removeAll() - removes all the elements$$$clear() - removes all elements. It is more efficient than removeAll()$$$Java Vector vs. ArrayList$$$Creating a Vector$$$Add Elements to Vector$$$Access Vector Elements$$$Remove Vector Elements$$$Others Vector Methods",,Methods|||Descriptions$$$set()|||changes an element of the vector$$$size()|||returns the size of the vector$$$toArray()|||converts the vector into an array$$$toString()|||converts the vector into a String$$$contains()|||searches the vector for specified element and returns a boolean result
https://www.programiz.com/java-programming/stack,Java Stack Class,Stack Implementation$$$Creating a Stack$$$Stack Methods$$$Use ArrayDeque Instead of Stack$$$push() Method$$$pop() Method$$$peek() Method$$$search() Method$$$empty() Method$$$Table of Contents,,"In this tutorial, we will learn about the Java Stack class and its methods with the help of examples.|||The Java collections framework has a class named Stack that provides the functionality of the stack data structure.|||The Stack class extends the Vector class.||||||In stack, elements are stored and accessed in Last In First Out manner. That is, elements are added to the top of the stack and removed from the top of the stack.||||||In order to create a stack, we must import the java.util.Stack package first. Once we import the package, here is how we can create a stack in Java.|||Here, Type indicates the stack's type. For example,|||Since Stack extends the Vector class, it inherits all the methods Vector. To learn about different Vector methods, visit Java Vector Class.|||Besides these methods, the Stack class includes 5 more methods that distinguish it from Vector.|||To add an element to the top of the stack, we use the push() method. For example,|||Output||||||To remove an element from the top of the stack, we use the pop() method. For example,|||Output|||The peek() method returns an object from the top of the stack. For example,|||Output|||To search an element in the stack, we use the search() method. It returns the position of the element from the top of the stack. For example,|||Output|||To check whether a stack is empty or not, we use the empty() method. For example,|||Output|||The Stack class provides the direct implementation of the stack data structure. However, it is recommended not to use it. Instead, use the ArrayDeque class (implements the Deque interface) to implement the stack data structure in Java.|||To learn more, visit:",Java ArrayDeque$$$Why use Deque over Stack? $$$Stack Implementation$$$push() Method$$$pop() Method$$$peek() Method$$$search() Method$$$empty() Method$$$Use Deque over Stack,,
https://www.programiz.com/java-programming/queue,Java Queue Interface,Classes that Implement Queue$$$Interfaces that extend Queue$$$Working of Queue Data Structure$$$How to use Queue?$$$Methods of Queue$$$Implementation of the Queue Interface$$$Table of Contents,,"In this tutorial, we will learn about the Java Queue interface and its methods.|||The Queue interface of the Java collections framework provides the functionality of the queue data structure. It extends the Collection interface.|||Since the Queue is an interface, we cannot provide the direct implementation of it.|||In order to use the functionalities of Queue, we need to use classes that implement it:||||||The Queue interface is also extended by various subinterfaces:||||||In queues, elements are stored and accessed in First In, First Out manner. That is, elements are added from the behind and removed from the front.||||||In Java, we must import java.util.Queue package in order to use Queue.|||Here, we have created objects animal1, animal2 and animal3 of classes LinkedList, ArrayDeque and PriorityQueue respectively. These objects can use the functionalities of the Queue interface.||||||The Queue interface includes all the methods of the Collection interface. It is because Collection is the super interface of Queue.|||Some of the commonly used methods of the Queue interface are:|||1. Implementing the LinkedList Class |||Output|||To learn more, visit Java LinkedList.|||2. Implementing the PriorityQueue Class|||Output|||To learn more, visit Java PriorityQueue.|||In the next tutorials, we will learn about different subinterfaces of the Queue interface and its implementation in detail.","ArrayDeque$$$LinkedList$$$PriorityQueue$$$Deque$$$BlockingQueue$$$BlockingDeque$$$add() - Inserts the specified element into the queue. If the task is successful, add() returns true, if not it throws an exception.$$$offer() - Inserts the specified element into the queue. If the task is successful, offer() returns true, if not it returns false.$$$element() - Returns the head of the queue. Throws an exception if the queue is empty.$$$peek() - Returns the head of the queue. Returns null if the queue is empty.$$$remove() - Returns and removes the head of the queue. Throws an exception if the queue is empty.$$$poll() - Returns and removes the head of the queue. Returns null if the queue is empty.$$$Classes that Implement Queue$$$Working of Queue Data Structure$$$How to use Queue?$$$Methods of Queue$$$Implementation of the Queue Interface ",,
https://www.programiz.com/java-programming/priorityqueue,Java PriorityQueue,Creating PriorityQueue$$$Methods of PriorityQueue$$$Insert Elements to PriorityQueue$$$Access PriorityQueue Elements$$$Remove PriorityQueue Elements$$$Iterating Over a PriorityQueue$$$Other PriorityQueue Methods$$$PriorityQueue Comparator$$$Table of Contents,,"In this tutorial, we will learn about the PriorityQueue class of the Java collections framework with the help of examples.|||The PriorityQueue class provides the functionality of the heap data structure.|||It implements the Queue interface.||||||Unlike normal queues, priority queue elements are retrieved in sorted order.|||Suppose, we want to retrieve elements in the ascending order. In this case, the head of the priority queue will be the smallest element. Once this element is retrieved, the next smallest element will be the head of the queue.|||It is important to note that the elements of a priority queue may not be sorted. However, elements are always retrieved in sorted order.|||In order to create a priority queue, we must import the java.util.PriorityQueue package. Once we import the package, here is how we can create a priority queue in Java.|||Here, we have created a priority queue without any arguments. In this case, the head of the priority queue is the smallest element of the queue. And elements are removed in ascending order from the queue.|||However, we can customize the ordering of elements with the help of the Comparator interface. We will learn about that later in this tutorial.|||The PriorityQueue class provides the implementation of all the methods present in the Queue interface.|||For example,|||Output|||Here, we have created a priority queue named numbers. We have inserted 4 and 2 to the queue.|||Although 4 is inserted before 2, the head of the queue is 2. It is because the head of the priority queue is the smallest element of the queue.||||||We have then inserted 1 to the queue. The queue is now rearranged to store the smallest element 1 to the head of the queue.|||To access elements from a priority queue, we can use the peek() method. This method returns the head of the queue. For example,|||Output|||For example,|||Output|||To iterate over the elements of a priority queue, we can use the iterator() method. In order to use this method, we must import the java.util.Iterator package. For example,|||Output|||In all the examples above, priority queue elements are retrieved in the natural order (ascending order). However, we can customize this ordering.|||For this, we need to create our own comparator class that implements the Comparator interface. For example,|||Output|||In the above example, we have created a priority queue passing CustomComparator class as an argument.|||The CustomComparator class implements the Comparator interface.|||We then override the compare() method. The method now causes the head of the element to be the largest number.|||To learn more about the comparator, visit Java Comparator.","add() - Inserts the specified element to the queue. If the queue is full, it throws an exception.$$$offer() - Inserts the specified element to the queue. If the queue is full, it returns false.$$$remove() - removes the specified element from the queue$$$poll() - returns and removes the head of the queue$$$Creating PriorityQueue$$$Insert Elements to PriorityQueue$$$Access PriorityQueue Elements$$$Remove PriorityQueue Elements$$$Iterating Over a PriorityQueue$$$PriorityQueue Comparator",,"Methods|||Descriptions$$$contains(element)|||Searches the priority queue for the specified element. If the element is found, it returns true, if not it returns false.$$$size()|||Returns the length of the priority queue.$$$toArray()|||Converts a priority queue to an array and returns it."
https://www.programiz.com/java-programming/deque,Java Deque,Working of Deque$$$Classes that implement Deque$$$How to use Deque?$$$Methods of Deque$$$Deque as Stack Data Structure$$$Implementation of Deque in ArrayDeque Class$$$Table of Contents,,"In this tutorial, we will learn about the Deque interface, how to use it, and its methods.|||The Deque interface of the Java collections framework provides the functionality of a double-ended queue. It extends the Queue interface.|||In a regular queue, elements are added from the rear and removed from the front. However, in a deque, we can insert and remove elements from both front and rear.||||||In order to use the functionalities of the Deque interface, we need to use classes that implement it:||||||In Java, we must import the java.util.Deque package to use Deque.|||Here, we have created objects animal1 and animal2 of classes ArrayDeque and LinkedList, respectively. These objects can use the functionalities of the Deque interface.||||||Since Deque extends the Queue interface, it inherits all the methods of the Queue interface.|||Besides methods available in the Queue interface, the Deque interface also includes the following methods:|||The Stack class of the Java Collections framework provides the implementation of the stack.|||However, it is recommended to use Deque as a stack instead of the Stack class. It is because methods of Stack are synchronized.|||Here are the methods the Deque interface provides to implement stack:|||Output|||To learn more, visit Java ArrayDeque.",ArrayDeque$$$LinkedList$$$addFirst() - Adds the specified element at the beginning of the deque. Throws an exception if the deque is full.$$$addLast() - Adds the specified element at the end of the deque. Throws an exception if the deque is full.$$$offerFirst() - Adds the specified element at the beginning of the deque. Returns false if the deque is full.$$$offerLast() - Adds the specified element at the end of the deque. Returns false if the deque is full.$$$getFirst() - Returns the first element of the deque. Throws an exception if the deque is empty.$$$getLast() - Returns the last element of the deque. Throws an exception if the deque is empty.$$$peekFirst() - Returns the first element of the deque. Returns null if the deque is empty.$$$peekLast() - Returns the last element of the deque. Returns null if the deque is empty.$$$removeFirst() - Returns and removes the first element of the deque. Throws an exception if the deque is empty.$$$removeLast() - Returns and removes the last element of the deque. Throws an exception if the deque is empty.$$$pollFirst() - Returns and removes the first element of the deque. Returns null if the deque is empty.$$$pollLast() - Returns and removes the last element of the deque. Returns null if the deque is empty.$$$push() - adds an element at the beginning of deque$$$pop() - removes an element from the beginning of deque$$$peek() - returns an element from the beginning of deque$$$Working of Deque $$$Classes that implement Deque $$$How to use Deque? $$$Methods of Deque $$$Deque as Stack Data Structure $$$Implementation of Deque in ArrayDeque Class,,
https://www.programiz.com/java-programming/linkedlist,Java LinkedList (With Examples),Creating a Java LinkedList$$$Working of a Java LinkedList$$$Methods of Java LinkedList$$$Other Methods$$$LinkedList as Deque and Queue$$$Example: Java LinkedList as Queue$$$Example: LinkedList as Deque$$$Iterating through LinkedList$$$LinkedList Vs. ArrayList$$$Example: Create LinkedList in Java$$$1. Add elements to a LinkedList$$$2. Access LinkedList elements$$$3. Change Elements of a LinkedList$$$4. Remove element from a LinkedList$$$Table of Contents,,"In this tutorial, we will learn about the Java LinkedList in detail with the help of examples.|||The LinkedList class of the Java collections framework provides the functionality of the linked list data structure (doubly linkedlist).|||Each element in a linked list is known as a node. It consists of 3 fields:|||Here is how we can create linked lists in Java:|||Here, Type indicates the type of a linked list. For example,|||Output|||In the above example, we have created a LinkedList named animals.|||Here, we have used the add() method to add elements to the LinkedList. We will learn more about the add() method later in this tutorial.|||Elements in linked lists are not stored in sequence. Instead, they are scattered and connected through links (Prev and Next).|||Here we have 3 elements in a linked list.|||To learn more, visit the LinkedList Data Structure.|||LinkedList provides various methods that allow us to perform different operations in linked lists. We will look at four commonly used LinkedList Operators in this tutorial:|||We can use the add() method to add an element (node) at the end of the LinkedList. For example,|||Output|||In the above example, we have created a LinkedList named animals. Here, we have used the add() method to add elements to animals.|||Notice the statement,|||Here, we have used the index number parameter. It is an optional parameter that specifies the position where the new element is added.|||To learn more about adding elements to LinkedList, visit Java program to add elements to LinkedList.|||The get() method of the LinkedList class is used to access an element from the LinkedList. For example,|||Output||||||In the above example, we have used the get() method with parameter 1. Here, the method returns the element at index 1.|||We can also access elements of the LinkedList using the iterator() and the listIterator() method. To learn more, visit the Java program to access elements of LinkedList.|||The set() method of LinkedList class is used to change elements of the LinkedList. For example,|||Output|||In the above example, we have created a LinkedList named languages. Notice the line,|||Here, the set() method changes the element at index 3 to Kotlin.|||The remove() method of the LinkedList class is used to remove an element from the LinkedList. For example,|||Output|||Here, the remove() method takes the index number as the parameter. And, removes the element specified by the index number.|||To learn more about removing elements from the linkedlist, visit the Java program to remove elements from LinkedList..|||Since the LinkedList class also implements the Queue and the Deque interface, it can implement methods of these interfaces as well. Here are some of the commonly used methods:|||Output|||Output|||We can use the Java for-each loop to iterate through LinkedList. For example,|||Output|||Both the Java ArrayList and LinkedList implements the List interface of the Collections framework. However, there exists some difference between them.|||Note: We can also create a LinkedList using interfaces in Java. For example,|||Here, if the LinkedList is created using one interface, then we cannot use methods provided by other interfaces. That is, animals1 cannot use methods specific to Queue and Deque interfaces.",Prev - stores an address of the previous element in the list. It is null for the first element$$$Next - stores an address of the next element in the list. It is null for the last element$$$Data - stores the actual data$$$Dog - it is the first element that holds null as previous address and the address of Cat as the next address$$$Cat - it is the second element that holds an address of Dog as the previous address and the address of Cow as the next address$$$Cow - it is the last element that holds the address of Cat as the previous address and null as the next element$$$Add elements$$$Access elements$$$Change elements$$$Remove elements$$$Java LinkedList$$$Creating a LinkedList$$$Add elements to linkedlist$$$Access elements$$$Change element$$$Remove element$$$LinkedList as Queue/Deque$$$Iterating through LinkedList$$$LinkedList Vs. ArrayList,,"Methods|||Description$$$contains()|||checks if the LinkedList contains the element$$$indexOf()|||returns the index of the first occurrence of the element$$$lastIndexOf()|||returns the index of the last occurrence of the element$$$clear()|||removes all the elements of the LinkedList$$$iterator()|||returns an iterator to iterate over LinkedList$$$Methods|||Descriptions$$$addFirst()|||adds the specified element at the beginning of the linked list$$$addLast()|||adds the specified element at the end of the linked list$$$getFirst()|||returns the first element$$$getLast()|||returns the last element$$$removeFirst()|||removes the first element$$$removeLast()|||removes the last element$$$peek()|||returns the first element (head) of the linked list$$$poll()|||returns and removes the first element from the linked list$$$offer()|||adds the specified element at the end of the linked list$$$LinkedList|||ArrayList$$$Implements List, Queue, and Deque interfaces.|||Implements List interface.$$$Stores 3 values (previous address, data, and next address) in a single position.|||Stores a single value in a single position.$$$Provides the doubly-linked list implementation.|||Provides a resizable array implementation.$$$Whenever an element is added, prev and next address are changed.|||Whenever an element is added, all elements after that position are shifted.$$$To access an element, we need to iterate from the beginning to the element.|||Can randomly access elements using indexes."
https://www.programiz.com/java-programming/arraydeque,Java ArrayDeque (With Examples),Interfaces implemented by ArrayDeque$$$Creating ArrayDeque$$$Methods of ArrayDeque$$$Other Methods$$$ArrayDeque as a Stack$$$ArrayDeque Vs. LinkedList Class$$$Insert Elements to Deque$$$Access ArrayDeque Elements$$$Remove ArrayDeque Elements$$$Iterating the ArrayDeque$$$Table of Contents,,"In this tutorial, we will learn about the ArrayDeque class and its methods with the help of examples. Also, we will learn to use array deque to implement a stack.|||In Java, we can use the ArrayDeque class to implement queue and deque data structures using arrays.|||The ArrayDeque class implements these two interfaces:||||||In order to create an array deque, we must import the java.util.ArrayDeque package.|||Here is how we can create an array deque in Java:|||Here, Type indicates the type of the array deque. For example,|||The ArrayDeque class provides implementations for all the methods present in Queue and Deque interface.|||1. Add elements using add(), addFirst() and addLast()|||Note: If the array deque is full, all these methods add(), addFirst() and addLast() throws IllegalStateException.|||For example,|||Output|||2. Insert elements using offer(), offerFirst() and offerLast()|||Note: offer(), offerFirst() and offerLast() returns true if the element is successfully inserted; if the array deque is full, these methods return false.|||For example,|||Output|||Note: If the array deque is full|||1. Access elements using getFirst() and getLast()|||Note: If the array deque is empty, getFirst() and getLast() throws NoSuchElementException.|||For example,|||Output|||2. Access elements using peek(), peekFirst() and peekLast() method||||||For example,|||Output|||Note: If the array deque is empty, peek(), peekFirst() and getLast() throws NoSuchElementException. |||1. Remove elements using the remove(), removeFirst(), removeLast() method|||Note: If the array deque is empty, remove(), removeFirst() and removeLast() method throws an exception. Also, remove(element) throws an exception if the element is not found.|||For example,|||Output|||2. Remove elements using the poll(), pollFirst() and pollLast() method|||Note: If the array deque is empty, poll(), pollFirst() and pollLast() returns null if the element is not found.|||For example,|||Output|||3. Remove Element: using the clear() method|||To remove all the elements from the array deque, we use the clear() method. For example,|||Output|||In order to use these methods, we must import the java.util.Iterator package. For example,|||Output|||To implement a LIFO (Last-In-First-Out) stacks in Java, it is recommended to use a deque over the Stack class. The ArrayDeque class is likely to be faster than the Stack class.|||ArrayDeque provides the following methods that can be used for implementing a stack.|||For example,|||Output|||Both ArrayDeque and Java LinkedList implements the Deque interface. However, there exist some differences between them.","Java Queue Interface$$$Java Deque Interface$$$add() - inserts the specified element at the end of the array deque$$$addFirst() - inserts the specified element at the beginning of the array deque$$$addLast() - inserts the specified at the end of the array deque (equivalent to add())$$$offer() - inserts the specified element at the end of the array deque$$$offerFirst() - inserts the specified element at the beginning of the array deque$$$offerLast() - inserts the specified element at the end of the array deque$$$the add() method will throw an exception$$$the offer() method returns false$$$getFirst() - returns the first element of the array deque$$$getLast() - returns the last element of the array deque$$$peek() - returns the first element of the array deque$$$peekFirst() - returns the first element of the array deque (equivalent to peek())$$$peekLast() - returns the last element of the array deque$$$remove() - returns and removes an element from the first element of the array deque$$$remove(element) - returns and removes the specified element from the head of the array deque$$$removeFirst() - returns and removes the first element from the array deque (equivalent to remove())$$$removeLast() - returns and removes the last element from the array deque$$$poll() - returns and removes the first element of the array deque$$$pollFirst() - returns and removes the first element of the array deque (equivalent to poll())$$$pollLast() - returns and removes the last element of the array deque$$$iterator() - returns an iterator that can be used to iterate over the array deque$$$descendingIterator() - returns an iterator that can be used to iterate over the array deque in reverse order$$$push() - adds an element to the top of the stack$$$peek() - returns an element from the top of the stack$$$pop() - returns and removes an element from the top of the stack$$$LinkedList supports null elements, whereas ArrayDeque doesn't.$$$Each node in a linked list includes links to other nodes. That's why LinkedList requires more storage than ArrayDeque.$$$If you are implementing the queue or the deque data structure, an ArrayDeque is likely to faster than a LinkedList.$$$Creating ArrayDeque$$$Insert Elements to Deque$$$Access ArrayDeque Elements$$$Remove ArrayDeque Elements$$$Iterating the ArrayDeque$$$ArrayDeque as a Stack$$$ArrayDeque Vs LinkedList",,"Methods|||Descriptions$$$element()|||Returns an element from the head of the array deque.$$$contains(element)|||Searches the array deque for the specified element.
				If the element is found, it returns true, if not it returns false.$$$size()|||Returns the length of the array deque.$$$toArray()|||Converts array deque to array and returns it.$$$clone() |||Creates a copy of the array deque and returns it."
https://www.programiz.com/java-programming/blockingqueue,Java BlockingQueue Interface,Classes that Implement BlockingQueue$$$How to use blocking queues?$$$Methods of BlockingQueue$$$Implementation of BlockingQueue in ArrayBlockingQueue$$$Why BlockingQueue?$$$Methods that throw an exception$$$Methods that return some value$$$Methods that blocks the operation$$$Table of Contents,,"In this tutorial, we will learn about the Java BlockingQueue interface and its methods.|||The BlockingQueue interface of the Java Collections framework extends the Queue interface. It allows any operation to wait until it can be successfully performed.|||For example, if we want to delete an element from an empty queue, then the blocking queue allows the delete operation to wait until the queue contains some elements to be deleted.|||Since BlockingQueue is an interface, we cannot provide the direct implementation of it.|||In order to use the functionality of the BlockingQueue, we need to use classes that implement it.||||||We must import the java.util.concurrent.BlockingQueue package in order to use BlockingQueue.|||Here, we have created objects animal1 and animal2 of classes ArrayBlockingQueue and LinkedBlockingQueue, respectively. These objects can use the functionalities of the BlockingQueue interface.|||Based on whether a queue is full or empty, methods of a blocking queue can be divided into 3 categories:|||More on offer() and poll() |||The offer() and poll() method can be used with timeouts. That is, we can pass time units as a parameter. For example,||||||Here,|||This means the offer() method will try to insert an element to the blocking queue for 100 milliseconds. If the element cannot be inserted in 100 milliseconds, the method returns false.|||Note: Instead of milliseconds, we can also use these time units: days, hours, minutes, seconds, microseconds and nanoseconds in offer() and poll() methods.|||The BlockingQueue also provides methods to block the operations and wait if the queue is full or empty.|||Suppose, we want to insert elements into a queue. If the queue is full then the put() method will wait until the queue has space to insert elements.|||Similarly, if we want to delete elements from a queue. If the queue is empty then the take() method will wait until the queue contains elements to be deleted.|||Output|||To learn more about ArrayBlockingQueue, visit Java ArrayBlockingQueue.|||In Java, BlockingQueue is considered as the thread-safe collection. It is because it can be helpful in multi-threading operations.|||Suppose one thread is inserting elements to the queue and another thread is removing elements from the queue.|||Now, if the first thread runs slower, then the blocking queue can make the second thread wait until the first thread completes its operation.","ArrayBlockingQueue$$$LinkedBlockingQueue$$$add() - Inserts an element to the blocking queue at the end of the queue. Throws an exception if the queue is full.$$$element() - Returns the head of the blocking queue. Throws an exception if the queue is empty.$$$remove() - Removes an element from the blocking queue. Throws an exception if the queue is empty.$$$offer() - Inserts the specified element to the blocking queue at the end of the queue. Returns false if the queue is full.$$$peek() - Returns the head of the blocking queue. Returns null if the queue is empty.$$$poll() - Removes an element from the blocking queue. Returns null if the queue is empty.$$$value is the element to be inserted to the queue$$$And we have set a timeout of 100 milliseconds$$$put() - Inserts an element to the blocking queue. If the queue is full, it will wait until the queue has space to insert an element.$$$take() - Removes and returns an element from the blocking queue. If the queue is empty, it will wait until the queue has elements to be deleted.$$$Classes that Implement BlockingQueue $$$How to use blocking queues? $$$Methods of BlockingQueue $$$Implementation of BlockingQueue$$$Why BlockingQueue? ",,
https://www.programiz.com/java-programming/arrayblockingqueue,Java ArrayBlockingQueue,Creating ArrayBlockingQueue$$$Methods of ArrayBlockingQueue$$$put() and take() Method$$$Other Methods$$$Why use ArrayBlockingQueue?$$$Insert Elements$$$Access Elements$$$Remove Elements$$$put() method$$$take() Method$$$Table of Contents,,"In this tutorial, we will learn about the ArrayBlockingQueue class and its methods with the help of examples.|||The ArrayBlockingQueue class of the Java Collections framework provides the blocking queue implementation using an array.|||It implements the Java BlockingQueue interface.||||||In order to create an array blocking queue, we must import the java.util.concurrent.ArrayBlockingQueue package.|||Once we import the package, here is how we can create an array blocking queue in Java:|||Here,|||For example,|||Note: It is compulsory to provide the size of the array.|||The ArrayBlockingQueue class provides the implementation of all the methods in the BlockingQueue interface.|||These methods are used to insert, access and delete elements from array blocking queues.|||Also, we will learn about two methods put() and take() that support the blocking operation in the array blocking queue.|||These two methods distinguish the array blocking queue from other typical queues.|||For example,|||Output|||For example,|||Output|||For example,||||||Output|||In multithreading processes, we can use put() and take() to block the operation of one thread to synchronize it with another thread. These methods will wait until they can be successfully executed.|||To add an element to the end of an array blocking queue, we can use the put() method.|||If the array blocking queue is full, it waits until there is space in the array blocking queue to add an element.|||For example,|||Output|||Here, the put() method may throw an InterruptedException if it is interrupted while waiting. Hence, we must enclose it inside a try..catch block.|||To return and remove an element from the front of the array blocking queue, we can use the take() method.|||If the array blocking queue is empty, it waits until there are elements in the array blocking queue to be deleted.|||For example,|||Output|||Here, the take() method will throw an InterrupedException if it is interrupted while waiting. Hence, we must enclose it inside a try...catch block.|||The ArrayBlockingQueue uses arrays as its internal storage.|||It is considered as a thread-safe collection. Hence, it is generally used in multi-threading applications.|||Suppose, one thread is inserting elements to the queue and another thread is removing elements from the queue.|||Now, if the first thread is slower than the second thread, then the array blocking queue can make the second thread waits until the first thread completes its operations.",Type - the type of the array blocking queue$$$capacity - the size of the array blocking queue$$$add() - Inserts the specified element to the array blocking queue. It throws an exception if the queue is full.$$$offer() - Inserts the specified element to the array blocking queue. It returns false if the queue is full.$$$peek() - Returns an element from the front of the array blocking queue. It returns null if the queue is empty.$$$iterator() - Returns an iterator object to sequentially access elements from the array blocking queue. It throws an exception if the queue is empty. We must import the java.util.Iterator package to use it.$$$remove() - Returns and removes a specified element from the array blocking queue. It throws an exception if the queue is empty.$$$poll() - Returns and removes a specified element from the array blocking queue. It returns null if the queue is empty.$$$clear() - Removes all the elements from the array blocking queue.$$$Creating ArrayBlockingQueue$$$Insert Elements$$$Access Elements$$$Remove Elements$$$put() and take() Method$$$Why ArrayBlockingQueue?,,"Methods|||Descriptions$$$contains(element)|||Searches the array blocking queue for the specified element.If the element is found, it returns true, if not it returns false.$$$size()|||Returns the length of the array blocking queue.$$$toArray()|||Converts array blocking queue to an array and returns it.$$$toString() |||Converts the array blocking queue to string"
https://www.programiz.com/java-programming/linkedblockingqueue,Java LinkedBlockingQueue,Creating LinkedBlockingQueue$$$Methods of LinkedBlockingQueue$$$put() and take() Methods$$$Other Methods$$$Why use LinkedBlockingQueue?$$$Insert Elements$$$Access Elements$$$Remove Elements$$$put() Method$$$take() Method$$$Table of Contents,,"In this tutorial, we will learn about the LinkedBLockingQueue class and its methods with the help of examples.|||The LinkedBlockingQueue class of the Java Collections framework provides the blocking queue implementation using a linked list.|||It implements the Java BlockingQueue interface.||||||In order to create a linked blocking queue, we must import the java.util.concurrent.LinkedBlockingQueue package.|||Here is how we can create a linked blocking queue in Java:|||1. Without the initial capacity|||Here the default initial capacity will be 231-1.|||2. With the initial capacity |||Here,|||For example,|||Note: It is not compulsory to provide the size of the linked list.|||The LinkedBlockingQueue class provides the implementation of all the methods in the BlockingQueue interface.|||These methods are used to insert, access and delete elements from linked blocking queues.|||Also, we will learn about two methods put() and take() that support the blocking operation in the linked blocking queue.|||These two methods distinguish the linked blocking queue from other typical queues.|||For example,|||Output|||For example,||||||Output|||For example,|||Output|||In multithreading processes, we can use put() and take() to block the operation of one thread to synchronize it with another thread. These methods will wait until they can be successfully executed.|||To insert the specified element to the end of a linked blocking queue, we use the put() method.|||If the linked blocking queue is full, it waits until there is space in the linked blocking queue to insert the element.|||For example,|||Output|||Here, the put() method may throw an InterruptedException if it is interrupted while waiting. Hence, we must enclose it inside a try..catch block.|||To return and remove an element from the front of the linked blocking queue, we can use the take() method.|||If the linked blocking queue is empty, it waits until there are elements in the linked blocking queue to be deleted.|||For example,|||Output|||Here, the take() method will throw an InterrupedException if it is interrupted while waiting. Hence, we must enclose it inside a try...catch block.|||The LinkedBlockingQueue uses linked lists as its internal storage.|||It is considered as a thread-safe collection. Hence, it is generally used in multi-threading applications.|||Suppose, one thread is inserting elements to the queue and another thread is removing elements from the queue.|||Now, if the first thread is slower than the second thread, then the linked blocking queue can make the second thread waits until the first thread completes its operations.",Type - the type of the linked blocking queue$$$capacity - the size of the linked blocking queue$$$add() - Inserts a specified element to the linked blocking queue. It throws an exception if the queue is full.$$$offer() - Inserts a specified element to the linked blocking queue. It returns false if the queue is full.$$$peek() - Returns an element from the front of the linked blocking queue. It returns null if the queue is empty.$$$iterator() - Returns an iterator object to sequentially access an element from the linked blocking queue. It throws an exception if the queue is empty. We must import the java.util.Iterator package to use it.$$$remove() - Returns and removes a specified element from the linked blocking queue. It throws an exception if the queue is empty.$$$poll() - Returns and removes a specified element from the linked blocking queue. It returns null if the queue is empty.$$$clear() - Removes all the elements from the linked blocking queue.$$$Creating LinkedBlockingQueue$$$Insert Elements$$$Access Elements$$$Remove Elements$$$put() and take() Methods$$$Why LinkedBlockingQueue?,,"Methods|||Descriptions$$$contains(element)|||Searches the linked blocking queue for the specified element. If the element is found, it returns true, if not it returns false.$$$size()|||Returns the length of the linked blocking queue.$$$toArray()|||Converts linked blocking queue to an array and return the array.$$$toString() |||Converts the linked blocking queue to string"
https://www.programiz.com/java-programming/map,Java Map Interface,Working of Map$$$Classes that implement Map$$$Interfaces that extend Map$$$How to use Map?$$$Methods of Map$$$Implementation of the Map Interface$$$Table of Contents,,"In this tutorial, we will learn about the Java Map interface and its methods.|||The Map interface of the Java collections framework provides the functionality of the map data structure.|||In Java, elements of Map are stored in key/value pairs. Keys are unique values associated with individual Values.|||A map cannot contain duplicate keys. And, each key is associated with a single value.||||||We can access and modify values using the keys associated with them.|||In the above diagram, we have values: United States, Brazil, and Spain. And we have corresponding keys: us, br, and es.|||Now, we can access those values using their corresponding keys.|||Note: The Map interface maintains 3 different sets:|||Hence we can access keys, values, and associations individually.|||Since Map is an interface, we cannot create objects from it.|||In order to use functionalities of the Map interface, we can use these classes:|||These classes are defined in the collections framework and implement the Map interface.|||The Map interface is also extended by these subinterfaces:|||In Java, we must import the java.util.Map package in order to use Map. Once we import the package, here's how we can create a map.|||In the above code, we have created a Map named numbers. We have used the HashMap class to implement the Map interface.||||||Here,|||The Map interface includes all the methods of the Collection interface. It is because Collection is a super interface of Map.|||Besides methods available in the Collection interface, the Map interface also includes the following methods:|||1. Implementing HashMap Class |||Output|||To learn more about HashMap, visit Java HashMap.|||2. Implementing TreeMap Class|||Output|||To learn more about TreeMap, visit Java TreeMap.","the set of keys$$$the set of values$$$the set of key/value associations (mapping).$$$HashMap$$$EnumMap$$$LinkedHashMap$$$WeakHashMap$$$TreeMap$$$SortedMap$$$NavigableMap$$$ConcurrentMap$$$Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$put(K, V) - Inserts the association of a key K and a value V into the map. If the key is already present, the new value replaces the old value.$$$putAll() - Inserts all the entries from the specified map to this map.$$$putIfAbsent(K, V) - Inserts the association if the key K is not already associated with the value V.$$$get(K) - Returns the value associated with the specified key K. If the key is not found, it returns null.$$$getOrDefault(K, defaultValue) - Returns the value associated with the specified key K. If the key is not found, it returns the defaultValue.$$$containsKey(K) - Checks if the specified key K is present in the map or not.$$$containsValue(V) - Checks if the specified value V is present in the map or not.$$$replace(K, V) - Replace the value of the key K with the new specified value V.$$$replace(K, oldValue, newValue) - Replaces the value of the key K with the new value newValue only if the key K is associated with the value oldValue.$$$remove(K) - Removes the entry from the map represented by the key K.$$$remove(K, V) - Removes the entry from the map that has key K associated with value V.$$$keySet() - Returns a set of all the keys present in a map.$$$values() - Returns a set of all the values present in a map.$$$entrySet() - Returns a set of all the key/value mapping present in a map.$$$Working of Map$$$Classes that implement Map$$$Interfaces that extend Map$$$How to use Map?$$$Methods of Map$$$Implementation of the Map Interface",,
https://www.programiz.com/java-programming/hashmap,Java HashMap (With Examples),Create a HashMap$$$Basic Operations on Java HashMap$$$Other Methods of HashMap$$$Iterate through a HashMap$$$Creating HashMap from Other Maps$$$Example 1: Create HashMap in Java$$$1. Add elements to a HashMap$$$2. Access HashMap Elements$$$3. Change HashMap Value$$$4. Remove HashMap Elements$$$Table of Contents,,"In this tutorial, we will learn about the Java HashMap class and its various operations with the help of examples.|||The HashMap class of the Java collections framework provides the functionality of the hash table data structure.|||It stores elements in key/value pairs. Here, keys are unique identifiers used to associate each value on a map.|||The HashMap class implements the Map interface.|||In order to create a hash map, we must import the java.util.HashMap package first. Once we import the package, here is how we can create hashmaps in Java.|||In the above code, we have created a hashmap named numbers. Here, K represents the key type and V represents the type of values. For example,|||Here, the type of keys is String and the type of values is Integer.|||Output|||In the above example, we have created a HashMap named languages.|||Here, we have used the put() method to add elements to the hashmap. We will learn more about the put() method later in this tutorial.|||The HashMap class provides various methods to perform different operations on hashmaps. We will look at some commonly used arraylist operations in this tutorial:|||To add a single element to the hashmap, we use the put() method of the HashMap class. For example,|||Output|||In the above example, we have created a HashMap named numbers. Here, we have used the put() method to add elements to numbers.|||Notice the statement,|||Here, we are passing the String value One as the key and Integer value 1 as the value to the put() method.|||Recommended Readings|||We can use the get() method to access the value from the hashmap. For example,|||Output|||In the above example, notice the expression,|||Here, the get() method takes the key as its argument and returns the corresponding value associated with the key.|||We can also access the keys, values, and key/value pairs of the hashmap as set views using keySet(), values(), and entrySet() methods respectively. For example,|||Output||||||In the above example, we have created a hashmap named languages. Here, we are accessing the keys, values, and key/value mappings from the hashmap.|||Recommended Readings|||We can use the replace() method to change the value associated with a key in a hashmap. For example,|||Output|||In the above example, we have created a hashmap named languages. Notice the expression,|||Here, we are changing the value referred to by key 2 with the new value C++.|||The HashMap class also provides some variations of the replace() method. To learn more, visit|||To remove elements from a hashmap, we can use the remove() method. For example,|||Output|||Here, the remove() method takes the key as its parameter. It then returns the value associated with the key and removes the entry.|||We can also remove the entry only under certain conditions. For example,|||Here, the remove() method only removes the entry if the key 2 is associated with the value C++. Since 2 is not associated with C++, it doesn't remove the entry.|||To learn more, visit Java HashMap remove().|||To iterate through each entry of the hashmap, we can use Java for-each loop. We can iterate through keys only, vales only, and key/value mapping. For example,|||Output|||Note that we have used the Map.Entry in the above example. It is the nested class of the Map interface that returns a view (elements) of the map.|||We first need to import the java.util.Map.Entry package in order to use this class.|||This nested class returns a view (elements) of the map.|||In Java, we can also create a hashmap from other maps. For example,|||Output|||In the above example, we have created a TreeMap named evenNumbers. Notice the expression,|||Here, we are creating a HashMap named numbers using the TreeMap. To learn more about treemap, visit Java TreeMap.|||Note: While creating a hashmap, we can include optional parameters: capacity and load factor. For example,|||Here,|||If the optional parameters not used, then the default capacity will be 16 and the default load factor will be 0.75.","Add elements$$$Access elements$$$Change elements$$$Remove elements$$$Java HashMap put()$$$Java HashMap putAll()$$$Java HashMap putIfAbsent()$$$Java HashMap get()$$$Java Hashmap getOrDefault()$$$Java HashMap keySet()$$$Java HashMap values()$$$Java HashMap entrySet()$$$Java HashMap replace()$$$Java HashMap replaceAll()$$$8 (capacity is 8) - This means it can store 8 entries.$$$0.6f (load factor is 0.6) - This means whenever our hash table is filled by 60%, the entries are moved to a new hash table double the size of the original hash table.$$$Java HashMap$$$Create a HashMap$$$Add elements to a HashMap$$$Access HashMap Elements$$$Change HashMap Value$$$Remove HashMap Elements$$$Other Methods of HashMap$$$Iterate through a HashMap$$$Creating HashMap from Other Maps",,Method|||Description$$$clear()|||removes all mappings from the HashMap$$$compute()|||computes a new value for the specified key$$$computeIfAbsent()|||computes value if a mapping for the key is not present$$$computeIfPresent()|||computes a value for mapping if the key is present$$$merge()|||merges the specified mapping to the HashMap$$$clone()|||makes the copy of the HashMap$$$containsKey()|||checks if the specified key is present in Hashmap$$$containsValue()|||checks if Hashmap contains the specified value$$$size()|||returns the number of items in HashMap$$$isEmpty()|||checks if the Hashmap is empty
https://www.programiz.com/java-programming/linkedhashmap,Java LinkedHashMap,Creating a LinkedHashMap$$$Creating LinkedHashMap from Other Maps$$$Methods of LinkedHashMap$$$Insert Elements to LinkedHashMap$$$Access LinkedHashMap Elements$$$Removed LinkedHashMap Elements$$$Other Methods of LinkedHashMap$$$LinkedHashMap Vs. HashMap$$$Table of Contents,,"In this tutorial, we will learn about the Java LinkedHashMap class and its operations with the help of examples.|||The LinkedHashMap class of the Java collections framework provides the hash table and linked list implementation of the Map interface.|||The LinkedHashMap interface extends the HashMap class to store its entries in a hash table. It internally maintains a doubly-linked list among all of its entries to order its entries.||||||In order to create a linked hashmap, we must import the java.util.LinkedHashMap package first. Once we import the package, here is how we can create linked hashmaps in Java.|||In the above code, we have created a linked hashmap named numbers.|||Here,|||Notice the part new LinkedHashMap<>(8, 0.6). Here, the first parameter is capacity and the second parameter is loadFactor.|||Default capacity and load factor|||It's possible to create a linked hashmap without defining its capacity and load factor. For example,|||By default,|||Note: The LinkedHashMap class also allows us to define the order of its entries. For example|||Here, accessOrder is a boolean value. Its default value is false. In this case entries in the linked hashmap are ordered on the basis of their insertion order.|||However, if true is passed as accessOrder, entries in the linked hashmap will be ordered from least-recently accessed to most-recently accessed.|||Here is how we can create a linked hashmap containing all the elements of other maps.||||||Output|||The LinkedHashMap class provides methods that allow us to perform various operations on the map.|||For example,|||Output|||1. Using entrySet(), keySet() and values()|||For example,|||Output|||2. Using get() and getOrDefault()|||For example,|||Output|||For example,|||Output|||Both the LinkedHashMap and the HashMap implements the Map interface. However, there exist some differences between them.","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by the keys in a map$$$capacity - The capacity of this linked hashmap is 8. Meaning, it can store 8 entries.$$$loadFactor - The load factor of this linked hashmap is 0.6. This means, whenever our hash map is filled by 60%, the entries are moved to a new hash table of double the size of the original hash table.$$$the capacity of the linked hashmap will be 16$$$the load factor will be 0.75$$$put() - inserts the specified key/value mapping to the map$$$putAll() - inserts all the entries from the specified map to this map$$$putIfAbsent() - inserts the specified key/value mapping to the map if the specified key is not present in the map$$$entrySet() - returns a set of all the key/value mapping of the map$$$keySet() - returns a set of all the keys of the map$$$values() - returns a set of all the values of the map$$$get() - Returns the value associated with the specified key. If the key is not found, it returns null.$$$getOrDefault() - Returns the value associated with the specified key. If the key is not found, it returns the specified default value.$$$remove(key) - returns and removes the entry associated with the specified key from the map$$$remove(key, value) - removes the entry from the map only if the specified key mapped to be the specified value and return a boolean value$$$LinkedHashMap maintains a doubly-linked list internally. Due to this, it maintains the insertion order of its elements.$$$The LinkedHashMap class requires more storage than HashMap. This is because LinkedHashMap maintains linked lists internally.$$$The performance of LinkedHashMap is slower than HashMap.$$$Creating a LinkedHashMap$$$Insert Elements to LinkedHashMap$$$Access LinkedHashMap Elements$$$Removed LinkedHashMap Elements$$$LinkedHashMap Vs. HashMap",,Method|||Description$$$clear()|||removes all the entries from the map$$$containsKey()|||checks if the map contains the specified key and returns a boolean value$$$containsValue()|||checks if the map contains the specified value and returns a boolean value$$$size()|||returns the size of the map$$$isEmpty()|||checks if the map is empty and returns a boolean value
https://www.programiz.com/java-programming/weakhashmap,Java WeakHashMap,Create a WeakHashMap$$$Differences Between HashMap and WeakHashMap$$$Creating WeakHashMap from Other Maps$$$Methods of WeakHashMap$$$Insert Elements to WeakHashMap$$$Access WeakHashMap Elements$$$Remove WeakHashMap Elements$$$Other Methods of WeakHashMap$$$Table of Contents,,"In this tutorial, we will learn about Java WeakHashMap and its operations with the help of examples. We will also learn about the differences between WeakHashMap and HashMap|||The WeakHashMap class of the Java collections framework provides the feature of the hash table data structure..|||It implements the Map interface.||||||Note: Keys of the weak hashmap are of the WeakReference type.|||The object of a weak reference type can be garbage collected in Java if the reference is no longer used in the program.|||Let us learn to create a weak hash map first. Then, we will learn how it differs from a hashmap.|||In order to create a weak hashmap, we must import the java.util.WeakHashMap package first. Once we import the package, here is how we can create weak hashmaps in Java.|||In the above code, we have created a weak hashmap named numbers.|||Here,|||Notice the part new WeakHashMap<>(8, 0.6). Here, the first parameter is capacity and the second parameter is loadFactor.|||Default capacity and load factor|||It is possible to create a weak hashmap without defining its capacity and load factor. For example,|||By default,|||Let us see the implementation of a weak hashmap in Java.|||Output|||As we can see, when the key two of a weak hashmap is set to null and perform garbage collection, the key is removed.|||It is because unlike hashmaps, keys of weak hashmaps are of weak reference type. This means the entry of a map are removed by the garbage collector if the key to that entry is no longer used. This is useful to save resources.|||Now let us see the same implementation in a hashmap.||||||Output|||Here, when the key two of the hashmap is set to null and perform garbage collection, the key is not removed.|||This is because unlike weak hashmaps keys of hashmaps are of strong reference type. This means the entry of a map is not removed by the garbage collector even though the key to that entry is no longer used.|||Note: All functionalities of hashmaps and weak hashmaps are similar except keys of a weak hashmap are of weak reference, whereas keys of a hashmap are of strong reference.|||Here is how we can create a weak hashmap from other maps.|||Output|||The WeakHashMap class provides methods that allow us to perform various operations on the map.|||For example,|||Output|||1. Using entrySet(), keySet() and values() |||For example,|||Output|||2. Using get() and getOrDefault() |||For example,|||Output|||For example,|||Output|||To learn more, visit Java WeakHashMap (official Java documentation).","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$capacity - The capacity of this map is 8. Meaning, it can store 8 entries.$$$loadFactor - The load factor of this map is 0.6. This means whenever our hash table is filled by 60%, the entries are moved to a new hash table of double the size of the original hash table.$$$the capacity of the map will be 16$$$the load factor will be 0.75$$$put() - inserts the specified key/value mapping to the map$$$putAll() - inserts all the entries from specified map to this map$$$putIfAbsent() - inserts the specified key/value mapping to the map if the specified key is not present in the map$$$entrySet() - returns a set of all the key/value mapping of the map$$$keySet() - returns a set of all the keys of the map$$$values() - returns a set of all the values of the map$$$get() - Returns the value associated with the specified key. Returns null if the key is not found.$$$getOrDefault() - Returns the value associated with the specified key. Returns the specified default value if the key is not found.$$$remove(key) - returns and removes the entry associated with the specified key from the map$$$remove(key, value) - removes the entry from the map only if the specified key mapped to the specified value and return a boolean value$$$Create a WeakHashMap$$$Differences Between HashMap and WeakHashMap$$$Insert Elements to WeakHashMap$$$Access WeakHashMap Elements$$$Remove WeakHashMap Elements",,Method|||Description$$$clear()|||Removes all the entries from the map$$$containsKey()|||Checks if the map contains the specified key and returns a boolean value$$$containsValue()|||Checks if the map contains the specified value and returns a boolean value$$$size()|||Returns the size of the map$$$isEmpty()|||Checks if the map is empty and returns a boolean value
https://www.programiz.com/java-programming/enummap,Java EnumMap,Creating an EnumMap$$$Methods of EnumMap$$$Insert Elements to EnumMap$$$Access EnumMap Elements$$$Remove EnumMap Elements$$$Replace EnumMap Elements$$$Other Methods$$$EnumSet Vs. EnumMap$$$Clonable and Serializable Interfaces$$$Table of Contents,,"In this tutorial, we will learn about the Java EnumMap class and its operations with the help of examples.|||The EnumMap class of the Java collections framework provides a map implementation for elements of an enum.|||In EnumMap, enum elements are used as keys. It implements the Map interface.||||||Before we learn about EnumMap, make sure to know about the Java Enums.|||In order to create an enum map, we must import the java.util.EnumMap package first. Once we import the package, here is how we can create enum maps in Java.|||In the above example, we have created an enum map named sizes.|||Here,|||The EnumMap class provides methods that allow us to perform various elements on the enum maps.|||For example,|||Output|||In the above example, we have used the putAll() method to insert all the elements of an enum map sizes1 to an enum map of sizes2.|||It is also possible to insert elements from other maps such as HashMap, TreeMap, etc. to an enum map using putAll(). However, all maps should be of the same enum type.|||1. Using entrySet(), keySet() and values()|||For example,|||Output|||2. Using the get() Method||||||The get() method returns the value associated with the specified key. It returns null if the specified key is not found.|||For example,|||Output|||For example,|||Output|||Output|||In the above program, notice the statement|||Here, the method accesses all the entries of the map. It then replaces all the values with the new values provided by the lambda expressions.|||Both the EnumSet and EnumMap class provides data structures to store enum values. However, there exist some major differences between them.|||The EnumMap class also implements Cloneable and Serializable interfaces.|||Cloneable Interface|||It allows the EnumMap class to make a copy of instances of the class.|||Serializable Interface|||Whenever Java objects need to be transmitted over a network, objects need to be converted into bits or bytes. This is because Java objects cannot be transmitted over the network.|||The Serializable interface allows classes to be serialized. This means objects of the classes implementing Serializable can be converted into bits or bytes.","Size - keys of the enum that map to values$$$Integer - values of the enum map associated with the corresponding keys $$$put() - inserts the specified key/value mapping (entry) to the enum map$$$putAll() - inserts all the entries of a specified map to this map$$$entrySet() - returns a set of all the keys/values mapping (entry) of an enum map$$$keySet() - returns a set of all the keys of an enum map$$$values() - returns a set of all the values of an enum map$$$remove(key) - returns and removes the entry associated with the specified key from the map$$$remove(key, value) - removes the entry from the map only if the specified key mapped to the specified value and return a boolean value$$$replace(key, value) - replaces the value associated with the specified key by the new value$$$replace(key, old, new) - replaces the old value with the new value only if the old value is already associated with the specified key$$$replaceAll(function) - replaces each value of the map with the result of the specified function$$$Enum set is represented internally as a sequence of bits, whereas the enum map is represented internally as arrays.$$$Enum set is created using its predefined methods like allOf(), noneOf(), of(), etc. However, an enum map is created using its constructor.$$$Creating an EnumMap$$$Insert Elements to EnumMap$$$Access EnumMap Elements$$$Remove EnumMap Elements$$$Replace EnumMap Elements",,Method|||Description$$$clone()|||Creates a copy of the EnumMap$$$containsKey()|||Searches the EnumMap for the specified key and returns a boolean result$$$containsValue()|||Searches the EnumMap for the specified value and returns a boolean result$$$size()|||Returns the size of the EnumMap$$$clear() |||Removes all the entries from the EnumMap
https://www.programiz.com/java-programming/sortedmap,Java SortedMap Interface,Class that implements SortedMap$$$How to use SortedMap?$$$Methods of SortedMap$$$Implementation of SortedMap in TreeMap Class$$$Table of Contents,,"In this tutorial, we will learn about the Java SortedMap interface and its methods.|||The SortedMap interface of the Java collections framework provides sorting of keys stored in a map.|||It extends the Map interface.||||||Since SortedMap is an interface, we cannot create objects from it.|||In order to use the functionalities of the SortedMap interface, we need to use the class TreeMap that implements it.||||||To use the SortedMap, we must import the java.util.SortedMap package first. Once we import the package, here's how we can create a sorted map.|||We have created a sorted map called numbers using the TreeMap class.||||||Here,|||Here, we have used no arguments to create a sorted map. Hence the map will be sorted naturally (ascending order).|||The SortedMap interface includes all the methods of the Map interface. It is because Map is a super interface of SortedMap.|||Besides all those methods, here are the methods specific to the SortedMap interface.|||To learn more, visit Java SortedMap (official Java documentation).|||Output|||Here, we show how the SortedMap interface works. If you want to know more about its implementation, visit Java TreeMap.","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$comparator() - returns a comparator that can be used to order keys in a map$$$firstKey() - returns the first key of the sorted map$$$lastKey() - returns the last key of the sorted map$$$headMap(key) - returns all the entries of a map whose keys are less than the specified key$$$tailMap(key) - returns all the entries of a map whose keys are greater than or equal to the specified key$$$subMap(key1, key2) - returns all the entries of a map whose keys lies in between key1 and key2 including key1$$$Class that implements SortedMap$$$How to use SortedMap?$$$Methods of SortedMap$$$Implementation of SortedMap",,
https://www.programiz.com/java-programming/navigablemap,Java NavigableMap Interface,"Class that implements NavigableMap$$$How to use NavigableMap?$$$Methods of NavigableMap$$$Other Methods$$$Implementation of NavigableMap in TreeMap Class$$$headMap(key, booleanValue)$$$tailMap(key, booleanValue)$$$subMap(k1, bv1, k2, bv2)$$$Table of Contents",,"In this tutorial, we will learn about the Java NavigableMap interface and its methods with the help of a example.|||The NavigableMap interface of the Java collections framework provides the features to navigate among the map entries.|||It is considered as a type of SortedMap.|||Since NavigableMap is an interface, we cannot create objects from it.|||In order to use the functionalities of the NavigableMap interface, we need to use the TreeMap class that implements NavigableMap.||||||In Java, we must import the java.util.NavigableMap package to use NavigableMap. Once we import the package, here's how we can create a navigable map.|||In the above code, we have created a navigable map named numbers of the TreeMap class.|||Here,|||The NavigableMap is considered as a type of SortedMap. It is because NavigableMap extends the SortedMap interface.|||Hence, all SortedMap methods are also available in NavigableMap. To learn how these methods are defined in SortedMap, visit Java SortedMap.|||However, some of the methods of SortedMap (headMap(), tailMap(), and subMap() ) are defined differently in NavigableMap.|||Let's see how these methods are defined in NavigableMap.|||The headMap() method returns all the entries of a navigable map associated with all those keys before the specified key (which is passed as an argument).|||The booleanValue is an optional parameter. Its default value is false.||||||If true is passed as a booleanValue, the method returns all the entries associated with all those keys before the specified key, including the entry associated with the specified key.|||The tailMap() method returns all the entries of a navigable map associated with all those keys after the specified key (which is passed as an argument) including the entry associated with the specified key.|||The booleanValue is an optional parameter. Its default value is true.|||If false is passed as a booleanValue, the method returns all the entries associated with those keys after the specified key, without including the entry associated with the specified key.|||The subMap() method returns all the entries associated with keys between k1 and k2 including the entry associated with k1.|||The bv1 and bv2 are optional parameters. The default value of bv1 is true and the default value of bv2 is false.|||If false is passed as bv1, the method returns all the entries associated with keys between k1 and k2, without including the entry associated with k1.|||If true is passed as bv2, the method returns all the entries associated with keys between k1 and k2, including the entry associated with k1.|||The NavigableMap provides various methods that can be used to locate the entries of maps.|||To learn more, visit Java NavigableMap (official Java documentation).|||Output|||To learn more about TreeMap, visit Java TreeMap.|||Now we know about the NavigableMap interface, we will learn about its implementation using the TreeMap class in detail in the next tutorial.",Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$descendingMap() - reverse the order of entries in a map$$$descendingKeyMap() - reverses the order of keys in a map$$$ceilingEntry() - returns an entry with the lowest key among all those entries whose keys are greater than or equal to the specified key$$$ceilingKey() - returns the lowest key among those keys that are greater than or equal to the specified key$$$floorEntry() - returns an entry with the highest key among all those entries whose keys are less than or equal to the specified key$$$floorKey() - returns the highest key among those keys that are less than or equal to the specified key$$$higherEntry() - returns an entry with the lowest key among all those entries whose keys are greater than the specified key$$$higherKey() - returns the lowest key among those keys that are greater than the specified key$$$lowerEntry() - returns an entry with the highest key among all those entries whose keys are less than the specified key$$$lowerKey() - returns the highest key among those keys that are less than the specified key$$$firstEntry() - returns the first entry (the entry with the lowest key) of the map$$$lastEntry() - returns the last entry (the entry with the highest key) of the map$$$pollFirstEntry() - returns and removes the first entry of the map$$$pollLastEntry() - returns and removes the last entry of the map$$$Class that implements NavigableMap$$$How to use NavigableMap?$$$Methods of NavigableMap$$$Implementation of NavigableMap,,
https://www.programiz.com/java-programming/treemap,Java TreeMap (With Examples),"Creating a TreeMap$$$Methods of TreeMap$$$Insert Elements to TreeMap$$$Access TreeMap Elements$$$Remove TeeMap Elements$$$Replace TreeMap Elements$$$Methods for Navigation$$$Other Methods of TreeMap$$$TreeMap Comparator$$$1. First and Last Methods$$$2. Ceiling, Floor, Higher and Lower Methods$$$3. pollFirstEntry() and pollLastEntry() Methods$$$4. headMap(), tailMap() and subMap() Methods$$$Table of Contents",,"In this tutorial, we will learn about the Java TreeMap class and its operations with the help of examples.|||The TreeMap class of the Java collections framework provides the tree data structure implementation.|||It implements the NavigableMap interface.||||||In order to create a TreeMap, we must import the java.util.TreeMap package first. Once we import the package, here is how we can create a TreeMap in Java.|||In the above code, we have created a TreeMap named numbers without any arguments. In this case, the elements in TreeMap are sorted naturally (ascending order).|||However, we can customize the sorting of elements by using the Comparator interface. We will learn about it later in this tutorial.|||Here,|||The TreeMap class provides various methods that allow us to perform operations on the map.|||For example,|||Output|||1. Using entrySet(), keySet() and values()|||For example,|||Output|||2. Using get() and getOrDefault() |||For example,|||Output|||Here, the getOrDefault() method does not find the key Five. Hence it returns the specified default value 5.|||For example,|||Output|||For example,|||Output|||In the above program notice the statement|||Here, we have passed a lambda expression as an argument.|||The replaceAll() method accesses all the entries of the map. It then replaces all the elements with the new values (returned from the lambda expression).|||Since the TreeMap class implements NavigableMap, it provides various methods to navigate over the elements of the treemap.|||For example,|||Output|||For example,|||Output||||||For example,|||Output|||headMap(key, booleanValue)|||The headMap() method returns all the key/value pairs of a treemap before the specified key (which is passed as an argument).|||The booleanValue parameter is optional. Its default value is false.|||If true is passed as a booleanValue, the method also includes the key/value pair of the key which is passed as an argument.|||For example,|||Output|||tailMap(key, booleanValue)|||The tailMap() method returns all the key/value pairs of a treemap starting from the specified key (which is passed as an argument).|||The booleanValue is an optional parameter. Its default value is true.|||If false is passed as a booleanValue, the method doesn't include the key/value pair of the specified key.|||For example,|||Output|||subMap(k1, bV1, k2, bV2)|||The subMap() method returns all the entries associated with keys between k1 and k2 including the entry of k1.|||The bV1 and bV2 are optional boolean parameters. The default value of bV1 is true and the default value of bV2 is false.|||If false is passed as bV1, the method returns all the entries associated with keys between k1 and k2 without including the entry of k1.|||If true is passed as bV2, the method returns all the entries associated with keys between k1 and k2 including the entry of k2.|||For example,|||Output|||In all the examples above, treemap elements are sorted naturally (in ascending order). However, we can also customize the ordering of keys.|||For this, we need to create our own comparator class based on which keys in a treemap are sorted. For example,|||Output|||In the above example, we have created a treemap passing CustomComparator class as an argument.|||The CustomComparator class implements the Comparator interface.|||We then override the compare() method to sort elements in reverse order.|||To learn more, visit Java Comparator (official Java documentation).","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$put() - inserts the specified key/value mapping (entry) to the map$$$putAll() - inserts all the entries from specified map to this map$$$putIfAbsent() - inserts the specified key/value mapping to the map if the specified key is not present in the map$$$entrySet() - returns a set of all the key/values mapping (entry) of a treemap$$$keySet() - returns a set of all the keys of a tree map$$$values() - returns a set of all the maps of a tree map$$$get() - Returns the value associated with the specified key. Returns null if the key is not found.$$$getOrDefault() - Returns the value associated with the specified key. Returns the specified default value if the key is not found.$$$remove(key) - returns and removes the entry associated with the specified key from a TreeMap$$$remove(key, value) - removes the entry from the map only if the specified key is associated with the specified value and returns a boolean value$$$replace(key, value) - replaces the value mapped by the specified key with the new value$$$replace(key, old, new) - replaces the old value with the new value only if the old value is already associated with the specified key$$$replaceAll(function) - replaces each value of the map with the result of the specified function$$$firstKey() - returns the first key of the map$$$firstEntry() - returns the key/value mapping of the first key of the map$$$lastKey() - returns the last key of the map$$$lastEntry() - returns the key/value mapping of the last key of the map$$$higherKey() - Returns the lowest key among those keys that are greater than the specified key.$$$higherEntry() - Returns an entry associated with a key that is lowest among all those keys greater than the specified key.$$$lowerKey() - Returns the greatest key among all those keys that are less than the specified key.$$$lowerEntry() - Returns an entry associated with a key that is greatest among all those keys that are less than the specified key.$$$ceilingKey() - Returns the lowest key among those keys that are greater than the specified key. If the key passed as an argument is present in the map, it returns that key.$$$ceilingEntry() - Returns an entry associated with a key that is lowest among those keys that are greater than the specified key. It an entry associated with the key passed an argument is present in the map, it returns the entry associated with that key.$$$floorKey() - Returns the greatest key among those keys that are less than the specified key. If the key passed as an argument is present, it returns that key.$$$floorEntry() - Returns an entry associated with a key that is greatest among those keys that are less than the specified key. If the key passed as argument is present, it returns that key.$$$pollFirstEntry() - returns and removes the entry associated with the first key of the map$$$pollLastEntry() - returns and removes the entry associated with the last key of the map$$$Creating a TreeMap$$$Insert Elements to TreeMap$$$Access TreeMap Elements$$$Remove TeeMap Elements$$$Replace TreeMap Elements$$$Methods for Navigation$$$TreeMap Comparator",,Method|||Description$$$clone()|||Creates a copy of the TreeMap$$$containsKey()|||Searches the TreeMap for the specified key and returns a boolean result$$$containsValue()|||Searches the TreeMap for the specified value and returns a boolean result$$$size()|||Returns the size of the TreeMap$$$clear()|||Removes all the entries from the TreeMap
https://www.programiz.com/java-programming/concurrentmap,Java ConcurrentMap Interface,Class that implements ConcurrentMap$$$How to use ConcurrentMap?$$$Methods of ConcurrentMap$$$Implementation of ConcurrentMap in ConcurrentHashMap$$$Table of Contents,,"In this tutorial, we will learn about the Java ConcurrentMap interface and its methods.|||The ConcurrentMap interface of the Java collections framework provides a thread-safe map. That is, multiple threads can access the map at once without affecting the consistency of entries in a map.|||ConcurrentMap is known as a synchronized map.|||It extends the Map interface.|||Since ConcurrentMap is an interface, we cannot create objects from it.|||In order to use the functionalities of the ConcurrentMap interface, we need to use the class ConcurrentHashMap that implements it.||||||To use the ConcurrentMap, we must import the java.util.concurrent.ConcurrentMap package first. Once we import the package, here's how we can create a concurrent map.||||||In the above code, we have created a concurrent map named numbers.|||Here,|||The ConcurrentMap interface includes all the methods of the Map interface. It is because Map is the super interface of the ConcurrentMap interface.|||Besides all those methods, here are the methods specific to the ConcurrentMap interface.|||To learn more, visit Java ConcurrentMap (official Java documentation).|||Output|||To learn more about ConcurrentHashMap, visit Java ConcurrentHashMap.","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$putIfAbsent() - Inserts the specified key/value to the map if the specified key is not already associated with any value.$$$compute() - Computes an entry (key/value mapping) for the specified key and its previously mapped value.$$$computeIfAbsent() - Computes a value using the specified function for the specified key if the key is not already mapped with any value.$$$computeIfPresent() - Computes a new entry (key/value mapping) for the specified key if the key is already mapped with the specified value.$$$forEach() - Access all entries of a map and perform the specified actions.$$$merge() - Merges the new specified value with the old value of the specified key if the key is already mapped to a certain value. If the key is not already mapped, the method simply associates the specified value to our key.$$$Class that implements ConcurrentMap$$$How to use ConcurrentMap?$$$Methods of ConcurrentMap$$$Implementation of ConcurrentMap",,
https://www.programiz.com/java-programming/concurrenthashmap,Java ConcurrentHashMap,Create a ConcurrentHashMap$$$Creating ConcurrentHashMap from Other Maps$$$Methods of ConcurrentHashMap$$$Insert Elements to ConcurrentHashMap$$$Access ConcurrentHashMap Elements$$$Remove ConcurrentHashMap Elements$$$Bulk ConcurrentHashMap Operations$$$ConcurrentHashMap vs HashMap$$$Why ConcurrentHashMap?$$$1. forEach() Method$$$2. search() Method$$$3. reduce() Method$$$Table of Contents,,"In this tutorial, we will learn about the Java ConcurrentHashMap class and its operations with the help of examples.|||The ConcurrentHashMap class of the Java collections framework provides a thread-safe map. That is, multiple threads can access the map at once without affecting the consistency of entries in a map.|||It implements the ConcurrentMap interface.||||||In order to create a concurrent hashmap, we must import the java.util.concurrent.ConcurrentHashMap package first. Once we import the package, here is how we can create concurrent hashmaps in Java.|||In the above code, we have created a concurrent hashmap named numbers.|||Here,|||Notice the part new ConcurrentHashMap<>(8, 0.6). Here, the first parameter is capacity and the second parameter is loadFactor.|||Default capacity and load factor|||It's possible to create a concurrent hashmap without defining its capacity and load factor. For example,|||By default,|||Here is how we can create a concurrent hashmap containing all the elements of other maps.|||Output|||The ConcurrentHashMap class provides methods that allow us to perform various operations on the map.|||For example,|||Output|||1. Using entrySet(), keySet() and values() |||For example,|||Output|||2. Using get() and getOrDefault() |||For example,|||Output|||For example,||||||Output|||The ConcurrentHashMap class provides different bulk operations that can be applied safely to concurrent maps.|||The forEach() method iterates over our entries and executes the specified function.|||It includes two parameters.|||For example,|||Output|||In the above program, we have used parallel threshold 4. This means if the map contains 4 entries, the operation will be executed in parallel.|||Variation of forEach() Method|||The search() method searches the map based on the specified function and returns the matched entry.|||Here, the specified function determines what entry is to be searched.|||It also includes an optional parameter parallelThreshold. The parallel threshold specifies that after how many elements in the map the operation is executed in parallel.|||For example,|||Output|||Variants of search() Method|||The reduce() method accumulates (gather together) each entry in a map. This can be used when we need all the entries to perform a common task, like adding all the values of a map.|||It includes two parameters.|||For example,|||Output|||In the above program, notice the statement|||Here,|||Variants of reduce() Method|||Here are some of the differences between ConcurrentHashMap and HashMap,","Key - a unique identifier used to associate each element (value) in a map$$$Value - elements associated by keys in a map$$$capacity - The capacity of this map is 8. Meaning, it can store 8 entries.$$$loadFactor - The load factor of this map is 0.6. This means, whenever our hash table is filled by 60%, the entries are moved to a new hash table of double the size of the original hash table.$$$the capacity of the map will be 16$$$the load factor will be 0.75$$$put() - inserts the specified key/value mapping to the map$$$putAll() - inserts all the entries from specified map to this map$$$putIfAbsent() - inserts the specified key/value mapping to the map if the specified key is not present in the map$$$entrySet() - returns a set of all the key/value mapping of the map$$$keySet() - returns a set of all the keys of the map$$$values() - returns a set of all the values of the map$$$get() - Returns the value associated with the specified key. Returns null if the key is not found.$$$getOrDefault() - Returns the value associated with the specified key. Returns the specified default value if the key is not found.$$$remove(key) - returns and removes the entry associated with the specified key from the map$$$remove(key, value) - removes the entry from the map only if the specified key mapped to the specified value and return a boolean value$$$parallelismThreshold - It specifies that after how many elements operations in a map are executed in parallel.$$$transformer - This will transform the data before the data is passed to the specified function.$$$forEachEntry() - executes the specified function for each entry$$$forEachKey() - executes the specified function for each key$$$forEachValue() - executes the specified function for each value$$$searchEntries() - search function is applied to key/value mappings$$$searchKeys() - search function is only applied to the keys$$$searchValues() - search function is only applied to the values$$$parallelismThreshold - It specifies that after how many elements, operations in a map are executed in parallel.$$$transformer - This will transform the data before the data is passed to the specified function.$$$4 is a parallel threshold$$$(k, v) -> v is a transformer function. It transfers the key/value mappings into values only.$$$(v1, v2) -> v1+v2 is a reducer function. It gathers together all the values and adds all values.$$$reduceEntries() - returns the result of gathering all the entries using the specified reducer function$$$reduceKeys() - returns the result of gathering all the keys using the specified reducer function$$$reduceValues() - returns the result of gathering all the values using the specified reducer function$$$ConcurrentHashMap is a thread-safe collection. That is, multiple threads can access and modify it at the same time.$$$ConcurrentHashMap provides methods for bulk operations like forEach(), search() and reduce().$$$The ConcurrentHashMap class allows multiple threads to access its entries concurrently.$$$By default, the concurrent hashmap is divided into 16 segments. This is the reason why 16 threads are allowed to concurrently modify the map at the same time. However, any number of threads can access the map at a time.$$$The putIfAbsent() method will not override the entry in the map if the specified key already exists.$$$It provides its own synchronization.$$$Create a ConcurrentHashMap$$$Insert Elements to ConcurrentHashMap$$$Access ConcurrentHashMap Elements$$$Remove ConcurrentHashMap Elements$$$Bulk ConcurrentHashMap Operations$$$ConcurrentHashMap vs HashMap$$$Why ConcurrentHashMap?",,
https://www.programiz.com/java-programming/set,Java Set Interface,Classes that implement Set$$$Interfaces that extend Set$$$How to use Set?$$$Methods of Set$$$Set Operations$$$Implementation of the Set Interface$$$Table of Contents,,"In this tutorial, we will learn about the Set interface in Java and its methods.|||The Set interface of the Java Collections framework provides the features of the mathematical set in Java. It extends the Collection interface.|||Unlike the List interface, sets cannot contain duplicate elements.|||Since Set is an interface, we cannot create objects from it.|||In order to use functionalities of the Set interface, we can use these classes:|||These classes are defined in the Collections framework and implement the Set interface.||||||The Set interface is also extended by these subinterfaces:||||||In Java, we must import java.util.Set package in order to use Set.|||Here, we have created a Set called animals. We have used the HashSet class to implement the Set interface.|||The Set interface includes all the methods of the Collection interface. It's because Collection is a super interface of Set.||||||Some of the commonly used methods of the Collection interface that's also available in the Set interface are:|||To learn about more methods of the Set interface, visit Java Set (official Java documentation).|||The Java Set interface allows us to perform basic mathematical set operations like union, intersection, and subset.|||1. Implementing HashSet Class |||Output|||To learn more about HashSet, visit Java HashSet.|||2. Implementing TreeSet Class|||Output|||To learn more about TreeSet, visit Java TreeSet.|||Now that we know what Set is, we will see its implementations in classes like EnumSet, HashSet, LinkedHashSet and TreeSet in the next tutorials.","HashSet$$$LinkedHashSet$$$EnumSet$$$TreeSet$$$SortedSet$$$NavigableSet$$$add() - adds the specified element to the set$$$addAll() - adds all the elements of the specified collection to the set$$$iterator() - returns an iterator that can be used to access elements of the set sequentially$$$remove() - removes the specified element from the set$$$removeAll() - removes all the elements from the set that is present in another specified set$$$retainAll() - retains all the elements in the set that are also present in another specified set$$$clear() - removes all the elements from the set$$$size() - returns the length (number of elements) of the set$$$toArray() - returns an array containing all the elements of the set$$$contains() - returns true if the set contains the specified element$$$containsAll() - returns true if the set contains all the elements of the specified collection$$$hashCode() - returns a hash code value (address of the element in the set)$$$Union - to get the union of two sets x and y, we can use x.addAll(y)$$$Intersection - to get the intersection of two sets x and y, we can use x.retainAll(y)$$$Subset - to check if x is a subset of y, we can use y.containsAll(x)$$$Classes that implement Set$$$Interfaces that extend Set$$$How to use Set?$$$Methods of Set$$$Set Operations$$$Implementation of the Set Interface ",,
https://www.programiz.com/java-programming/hashset,Java HashSet,Creating a HashSet$$$Methods of HashSet$$$Insert Elements to HashSet$$$Access HashSet Elements$$$Remove Elements$$$Set Operations$$$Union of Sets$$$Intersection of Sets$$$Difference of Sets$$$Subset$$$Other Methods Of HashSet$$$Why HashSet?$$$Table of Contents,,"In this tutorial, we will learn about the Java HashSet class. We will learn about different hash set methods and operations with the help of examples.|||The HashSet class of the Java Collections framework provides the functionalities of the hash table data structure.|||It implements the Set interface.||||||In order to create a hash set, we must import the java.util.HashSet package first.|||Once we import the package, here is how we can create hash sets in Java.|||Here, we have created a hash set named numbers.|||Notice, the part new HashSet<>(8, 0.75). Here, the first parameter is capacity, and the second parameter is loadFactor.|||Default capacity and load factor|||It's possible to create a hash table without defining its capacity and load factor. For example,|||By default,|||The HashSet class provides various methods that allow us to perform various operations on the set.|||For example,|||Output|||To access the elements of a hash set, we can use the iterator() method. In order to use this method, we must import the java.util.Iterator package. For example,|||Output||||||For example,|||Output|||The various methods of the HashSet class can also be used to perform various set operations.|||To perform the union between two sets, we can use the addAll() method. For example,|||Output|||To perform the intersection between two sets, we can use the retainAll() method. For example|||Output|||To calculate the difference between the two sets, we can use the removeAll() method. For example,|||Output|||To check if a set is a subset of another set or not, we can use the containsAll() method. For example,|||Output|||To learn more about HashSet methods, visit Java HashSet (official Java documentation).|||In Java, HashSet is commonly used if we have to access elements randomly. It is because elements in a hash table are accessed using hash codes.|||The hashcode of an element is a unique identity that helps to identify the element in a hash table.|||HashSet cannot contain duplicate elements. Hence, each hash set element has a unique hashcode.|||Note: HashSet is not synchronized. That is if multiple threads access the hash set at the same time and one of the threads modifies the hash set. Then it must be externally synchronized.","capacity - The capacity of this hash set is 8. Meaning, it can store 8 elements.$$$loadFactor - The load factor of this hash set is 0.6. This means, whenever our hash set is filled by 60%, the elements are moved to a new hash table of double the size of the original hash table.$$$the capacity of the hash set will be 16$$$the load factor will be 0.75$$$add() - inserts the specified element to the set$$$addAll() - inserts all the elements of the specified collection to the set$$$remove() - removes the specified element from the set$$$removeAll() - removes all the elements from the set$$$Creating a HashSet$$$Insert Elements to HashSet$$$Access HashSet Elements$$$Remove Elements$$$Set Operations$$$Why HashSet?",,Method|||Description$$$clone()|||Creates a copy of the HashSet$$$contains()|||Searches the HashSet for the specified element and returns a boolean result$$$isEmpty()|||Checks if the HashSet is empty$$$size()|||Returns the size of the HashSet$$$clear()|||Removes all the elements from the HashSet
https://www.programiz.com/java-programming/enumset,Java EnumSet,"Creating EnumSet$$$Methods of EnumSet$$$Insert Elements to EnumSet$$$Access EnumSet Elements$$$Remove EnumSet Elements$$$Other Methods$$$Clonable and Serializable Interfaces$$$Why EnumSet?$$$1. Using allOf(Size)$$$2. Using noneOf(Size)$$$3. Using range(e1, e2) Method$$$4. Using of() Method$$$Table of Contents",,"In this tutorial, we will learn about the Java EnumSet class and its various methods with the help of examples.|||The EnumSet class of the Java collections framework provides a set implementation of elements of a single enum.|||Before you learn about EnumSet, make sure to know about Java Enums.|||It implements the Set interface.||||||In order to create an enum set, we must import the java.util.EnumSet package first.|||Unlike other set implementations, the enum set does not have public constructors. We must use the predefined methods to create an enum set.|||The allof() method creates an enum set that contains all the values of the specified enum type Size. For example,|||Output|||Notice the statement,|||Here, Size.class denotes the Size enum that we have created.|||The noneOf() method creates an empty enum set. For example,|||Output|||Here, we have created an empty enum named sizes.|||Note: We can only insert elements of enum type Size in the above program. It's because we created our empty enum set using Size enum.|||The range() method creates an enum set containing all the values of an enum between e1 and e2 including both values. For example,|||Output|||The of() method creates an enum set containing the specified elements. For example,|||Output|||The EnumSet class provides methods that allow us to perform various elements on the enum set.|||For example,||||||Output|||In the above example, we have used the addAll() method to insert all the elements of an enum set sizes1 to an enum set sizes2.|||It's also possible to insert elements from other collections such as ArrayList, LinkedList, etc. to an enum set using addAll(). However, all collections should be of the same enum type.|||To access elements of an enum set, we can use the iterator() method. In order to use this method, we must import the java.util.Iterator package. For example,|||Output|||Note:|||For example,|||Output|||The EnumSet class also implements Cloneable and Serializable interfaces.|||Cloneable Interface|||It allows the EnumSet class to make a copy of instances of the class.|||Serializable Interface|||Whenever Java objects need to be transmitted over a network, objects need to be converted into bits or bytes. This is because Java objects cannot be transmitted over the network.|||The Serializable interface allows classes to be serialized. This means objects of the classes implementing Serializable can be converted into bits or bytes.|||The EnumSet provides an efficient way to store enum values than other set implementations (like HashSet, TreeSet).|||An enum set only stores enum values of a specific enum. Hence, the JVM already knows all the possible values of the set.|||This is the reason why enum sets are internally implemented as a sequence of bits. Bits specifies whether elements are present in the enum set or not.|||The bit of a corresponding element is turned on if that element is present in the set.",add() - inserts specified enum values to the enum set$$$addAll() inserts all the elements of the specified collection to the set$$$hasNext() returns true if there is a next element in the enum set$$$next() returns the next element in the enum set$$$remove() - removes the specified element from the enum set$$$removeAll() - removes all the elements from the enum set$$$Creating EnumSet$$$Insert Elements to EnumSet$$$Access EnumSet Elements$$$Remove EnumSet Elements$$$Why EnumSet?,,Method|||Description$$$copyOf()|||Creates a copy of the EnumSet$$$contains()|||Searches the EnumSet for the specified element and returns a boolean result$$$isEmpty()|||Checks if the EnumSet is empty$$$size()|||Returns the size of the EnumSet$$$clear()|||Removes all the elements from the EnumSet
https://www.programiz.com/java-programming/linkedhashset,Java LinkedHashSet,Create a LinkedHashSet$$$Creating LinkedHashSet from Other Collections$$$Methods of LinkedHashSet$$$Insert Elements to LinkedHashSet$$$Access LinkedHashSet Elements$$$Remove Elements from HashSet$$$Set Operations$$$Other Methods Of LinkedHashSet$$$LinkedHashSet Vs. HashSet$$$LinkedHashSet Vs. TreeSet$$$Union of Sets$$$Intersection of Sets$$$Difference of Sets$$$Subset$$$Table of Contents,,"In this tutorial, we will learn about the Java LinkedHashSet class and its methods with the help of examples.|||The LinkedHashSet class of the Java collections framework provides functionalities of both the hashtable and the linked list data structure.|||It implements the Set interface.||||||Elements of LinkedHashSet are stored in hash tables similar to HashSet.|||However, linked hash sets maintain a doubly-linked list internally for all of its elements. The linked list defines the order in which elements are inserted in hash tables.|||In order to create a linked hash set, we must import the java.util.LinkedHashSet package first.|||Once we import the package, here is how we can create linked hash sets in Java.|||Here, we have created a linked hash set named numbers.|||Notice, the part new LinkedHashSet<>(8, 0.75). Here, the first parameter is capacity and the second parameter is loadFactor.|||Default capacity and load factor|||It's possible to create a linked hash set without defining its capacity and load factor. For example,|||By default,|||Here is how we can create a linked hash set containing all the elements of other collections.|||Output|||The LinkedHashSet class provides methods that allow us to perform various operations on the linked hash set.|||For example,|||Output||||||To access the elements of a linked hash set, we can use the iterator() method. In order to use this method, we must import the java.util.Iterator package. For example,|||Output|||Note:|||For example,|||Output|||The various methods of the LinkedHashSet class can also be used to perform various set operations.|||Two perform the union between two sets, we can use the addAll() method. For example,|||Output|||To perform the intersection between two sets, we can use the retainAll() method. For example|||Output|||To calculate the difference between the two sets, we can use the removeAll() method. For example,|||Output|||To check if a set is a subset of another set or not, we can use the containsAll() method. For example,|||Output|||To learn more about LinkedHashSet methods, visit Java LinkedHashSet (official Java documentation).|||Both LinkedHashSet and HashSet implements the Set interface. However, there exist some differences between them.|||Here are the major differences between LinkedHashSet and TreeSet:","capacity - The capacity of this hash set is 8. Meaning, it can store 8 elements.$$$loadFactor - The load factor of this hash set is 0.6. This means, whenever our hash table is filled by 60%, the elements are moved to a new hash table of double the size of the original hash table.$$$the capacity of the linked hash set will be 16$$$the load factor will be 0.75$$$add() - inserts the specified element to the linked hash set$$$addAll() - inserts all the elements of the specified collection to the linked hash set$$$hasNext() returns true if there is a next element in the linked hash set$$$next() returns the next element in the linked hash set$$$remove() - removes the specified element from the linked hash set$$$removeAll() - removes all the elements from the linked hash set$$$LinkedHashSet maintains a linked list internally. Due to this, it maintains the insertion order of its elements.$$$The LinkedHashSet class requires more storage than HashSet. This is because LinkedHashSet maintains linked lists internally.$$$The performance of LinkedHashSet is slower than HashSet. It is because of linked lists present in LinkedHashSet.$$$The TreeSet class implements the SortedSet interface. That's why elements in a tree set are sorted. However, the LinkedHashSet class only maintains the insertion order of its elements.$$$A TreeSet is usually slower than a LinkedHashSet. It is because whenever an element is added to a TreeSet, it has to perform the sorting operation.$$$LinkedHashSet allows the insertion of null values. However, we cannot insert a null value to TreeSet.$$$Create a LinkedHashSet$$$Insert Elements to LinkedHashSet$$$Access LinkedHashSet Elements$$$Remove Elements from HashSet$$$Set Operations$$$LinkedHashSet Vs. HashSet$$$LinkedHashSet Vs. TreeSet",,Method|||Description$$$clone()|||Creates a copy of the LinkedHashSet$$$contains()|||Searches the LinkedHashSet for the specified element and returns a boolean result$$$isEmpty()|||Checks if the LinkedHashSet is empty$$$size()|||Returns the size of the LinkedHashSet$$$clear()|||Removes all the elements from the LinkedHashSet
https://www.programiz.com/java-programming/sortedset,Java SortedSet Interface,Class that implements SortedSet$$$How to use SortedSet?$$$Methods of SortedSet$$$Implementation of SortedSet in TreeSet Class$$$Table of Contents,,"In this tutorial, we will learn about the SortedSet interface in Java and its methods with the help of an example.|||The SortedSet interface of the Java Collections framework is used to store elements with some order in a set.|||It extends the Set interface.||||||In order to use the functionalities of the SortedSet interface, we need to use the TreeSet class that implements it.||||||To use SortedSet, we must import the java.util.SortedSet package first.|||We have created a sorted set called animals using the TreeSet class.||||||Here we have used no arguments to create a sorted set. Hence the set will be sorted naturally.|||The SortedSet interface includes all the methods of the Set interface. It's because Set is a super interface of SortedSet.|||Besides methods included in the Set interface, the SortedSet interface also includes these methods:|||Output|||To learn more about TreeSet, visit Java TreeSet.|||Now that we know about the SortedSet interface, we will learn about its implementation using the TreeSet class.","comparator() - returns a comparator that can be used to order elements in the set$$$first() - returns the first element of the set$$$last() - returns the last element of the set$$$headSet(element) - returns all the elements of the set before the specified element$$$tailSet(element) - returns all the elements of the set after the specified element including the specified element$$$subSet(element1, element2) - returns all the elements between the element1 and element2 including element1$$$Classes that implements SortedSet$$$How to use SortedSet?$$$Methods of SortedSet$$$Implementation of SortedSet",,
https://www.programiz.com/java-programming/navigableset,Java NavigableSet Interface,"Class that implements NavigableSet$$$How to use NavigableSet?$$$Methods of NavigableSet$$$Methods for Navigation$$$Implementation of NavigableSet in TreeSet Class$$$headSet(element, booleanValue)$$$tailSet(element, booleanValue)$$$subSet(e1, bv1, e2, bv2)$$$Table of Contents",,"In this tutorial, we will learn about the Java NavigableSet interface and its methods with the help of an example.|||The NavigableSet interface of the Java Collections framework provides the features to navigate among the set elements.|||It is considered as a type of SortedSet.|||In order to use the functionalities of the NavigableSet interface, we need to use the TreeSet class that implements NavigableSet.||||||In Java, we must import the java.util.NavigableSet package to use NavigableSet. Once we import the package, here's how we can create navigable sets.|||Here, we have created a navigable set named numbers of the TreeSet class.|||The NavigableSet is considered as a type of SortedSet. It is because NavigableSet extends the SortedSet interface.|||Hence, all SortedSet methods are also available in NavigableSet. To learn how these methods, visit Java SortedSet.|||However, some of the methods of SortedSet (headSet(), tailSet() and subSet()) are defined differently in NavigableSet.|||Let's see how these methods are defined in NavigableSet.|||The headSet() method returns all the elements of a navigable set before the specified element (which is passed as an argument).|||The booleanValue parameter is optional. Its default value is false.|||If true is passed as a booleanValue, the method returns all the elements before the specified element including the specified element.||||||The tailSet() method returns all the elements of a navigable set after the specified element (which is passed as an argument) including the specified element.|||The booleanValue parameter is optional. Its default value is true.|||If false is passed as a booleanValue, the method returns all the elements after the specified element without including the specified element.|||The subSet() method returns all the elements between e1 and e2 including e1.|||The bv1 and bv2 are optional parameters. The default value of bv1 is true, and the default value of bv2 is false.|||If false is passed as bv1, the method returns all the elements between e1 and e2 without including e1.|||If true is passed as bv2, the method returns all the elements between e1 and e2, including e1.|||The NavigableSet provides various methods that can be used to navigate over its elements.|||To learn more about the NavigableSet, visit Java NavigableSet (official Java documentation).|||Output|||To learn more about TreeSet, visit Java TreeSet.|||Now that we know about the NavigableSet interface, we will learn about its implementation using the TreeSet class.",descendingSet() - reverses the order of elements in a set$$$descendingIterator() - returns an iterator that can be used to iterate over a set in reverse order$$$ceiling() - returns the lowest element among those elements that are greater than or equal to the specified element$$$floor() - returns the greatest element among those elements that are less than or equal to the specified element$$$higher() - returns the lowest element among those elements that are greater than the specified element$$$lower() - returns the greatest element among those elements that are less than the specified element$$$pollFirst() - returns and removes the first element from the set$$$pollLast() - returns and removes the last element from the set$$$Class that implements NavigableSet$$$How to use NavigableSet?$$$Methods of NavigableSet$$$Methods for Navigation$$$Implementation of NavigableSet,,
https://www.programiz.com/java-programming/treeset,Java TreeSet (With Examples),"Creating a TreeSet$$$Methods of TreeSet$$$Insert Elements to TreeSet$$$Access TreeSet Elements$$$Remove Elements$$$Methods for Navigation$$$Set Operations$$$Other Methods of TreeSet$$$TreeSet Vs. HashSet$$$TreeSet Comparator$$$1. first() and last() Methods$$$2. ceiling(), floor(), higher() and lower() Methods$$$3. pollfirst() and pollLast() Methods$$$4. headSet(), tailSet() and subSet() Methods$$$headSet(element, booleanValue)$$$tailSet(element, booleanValue)$$$subSet(e1, bv1, e2, bv2)$$$Union of Sets$$$Intersection of Sets$$$Difference of Sets$$$Subset of a Set$$$Table of Contents",,"In this tutorial, we will learn about the Java TreeSet class and its various operations and methods with the help of examples.|||The TreeSet class of the Java collections framework provides the functionality of a tree data structure.|||It extends the NavigableSet interface.||||||In order to create a tree set, we must import the java.util.TreeSet package first.|||Once we import the package, here is how we can create a TreeSet in Java.|||Here, we have created a TreeSet without any arguments. In this case, the elements in TreeSet are sorted naturally (ascending order).|||However, we can customize the sorting of elements by using the Comparator interface. We will learn about it later in this tutorial.|||The TreeSet class provides various methods that allow us to perform various operations on the set.|||For example,|||Output|||To access the elements of a tree set, we can use the iterator() method. In order to use this method, we must import java.util.Iterator package. For example,|||Output|||For example,|||Output|||Since the TreeSet class implements NavigableSet, it provides various methods to navigate over the elements of the tree set.|||For example,|||Output|||For example,|||Output|||For example,|||Output|||The headSet() method returns all the elements of a tree set before the specified element (which is passed as an argument).|||The booleanValue parameter is optional. Its default value is false.|||If true is passed as a booleanValue, the method returns all the elements before the specified element including the specified element.|||For example,|||Output|||The tailSet() method returns all the elements of a tree set after the specified element (which is passed as a parameter) including the specified element.|||The booleanValue parameter is optional. Its default value is true.||||||If false is passed as a booleanValue, the method returns all the elements after the specified element without including the specified element.|||For example,|||Output|||The subSet() method returns all the elements between e1 and e2 including e1.|||The bv1 and bv2 are optional parameters. The default value of bv1 is true, and the default value of bv2 is false.|||If false is passed as bv1, the method returns all the elements between e1 and e2 without including e1.|||If true is passed as bv2, the method returns all the elements between e1 and e2, including e1.|||For example,|||Output|||The methods of the TreeSet class can also be used to perform various set operations.|||To perform the union between two sets, we use the addAll() method. For example,|||Output|||To perform the intersection between two sets, we use the retainAll() method. For example,|||Output|||To calculate the difference between the two sets, we can use the removeAll() method. For example,|||Output|||To check if a set is a subset of another set or not, we use the containsAll() method. For example,|||Output|||To learn more, visit Java TreeSet (official Java documentation).|||Both the TreeSet as well as the HashSet implements the Set interface. However, there exist some differences between them.|||In all the examples above, tree set elements are sorted naturally. However, we can also customize the ordering of elements.|||For this, we need to create our own comparator class based on which elements in a tree set are sorted. For example,|||Output|||In the above example, we have created a tree set passing CustomComparator class as an argument.|||The CustomComparator class implements the Comparator interface.|||We then override the compare() method. The method will now sort elements in reverse order.|||To learn more, visit Java Comparator (official Java documentation).","add() - inserts the specified element to the set$$$addAll() - inserts all the elements of the specified collection to the set$$$remove() - removes the specified element from the set$$$removeAll() - removes all the elements from the set$$$first() - returns the first element of the set$$$last() - returns the last element of the set$$$higher(element) - Returns the lowest element among those elements that are greater than the specified element.$$$lower(element) - Returns the greatest element among those elements that are less than the specified element.$$$ceiling(element) - Returns the lowest element among those elements that are greater than the specified element. If the element passed exists in a tree set, it returns the element passed as an argument.$$$floor(element) - Returns the greatest element among those elements that are less than the specified element. If the element passed exists in a tree set, it returns the element passed as an argument.$$$pollFirst() - returns and removes the first element from the set$$$pollLast() - returns and removes the last element from the set$$$Unlike HashSet, elements in TreeSet are stored in some order. It is because TreeSet implements the SortedSet interface as well.$$$TreeSet provides some methods for easy navigation. For example, first(), last(), headSet(), tailSet(), etc. It is because TreeSet also implements the NavigableSet interface.$$$HashSet is faster than the TreeSet for basic operations like add, remove, contains and size.$$$Creating a TreeSet$$$Insert Elements to TreeSet$$$Access TreeSet Elements$$$Remove Elements$$$Methods for Navigation$$$Set Operations$$$TreeSet Vs. HashSet$$$TreeSet Comparator",,Method|||Description$$$clone()|||Creates a copy of the TreeSet$$$contains()|||Searches the TreeSet for the specified element and returns a boolean result$$$isEmpty()|||Checks if the TreeSet is empty$$$size()|||Returns the size of the TreeSet$$$clear()|||Removes all the elements from the TreeSet
https://www.programiz.com/java-programming/algorithms,Java Algorithms,1. Sorting Using sort()$$$2. Shuffling Using shuffle()$$$3. Routine Data Manipulation$$$4. Searching Using binarySearch()$$$5. Composition$$$6. Finding Extreme Values$$$Table of Contents,,"In this tutorial, we will learn about different algorithms provided by the Java collections framework with the help of examples.|||The Java collections framework provides various algorithms that can be used to manipulate elements stored in data structures.|||Algorithms in Java are static methods that can be used to perform various operations on collections.|||Since algorithms can be used on various collections, these are also known as generic algorithms.|||Let's see the implementation of different methods available in the collections framework.|||The sort() method provided by the collections framework is used to sort elements. For example,|||Output|||Here the sorting occurs in natural order (ascending order). However, we can customize the sorting order of the sort() method using the Comparator interface.|||To learn more, visit Java Sorting.|||The shuffle() method of the Java collections framework is used to destroy any kind of order present in the data structure. It does just the opposite of the sorting. For example,|||Output|||When we run the program, the shuffle() method will return a random output.||||||The shuffling algorithm is mainly used in games where we want random output.|||In Java, the collections framework provides different methods that can be used to manipulate data.|||For example,|||Output|||Note: While performing the copy() method both the lists should be of the same size.|||The binarySearch() method of the Java collections framework searches for the specified element. It returns the position of the element in the specified collections. For example,|||Output|||Note: The collection should be sorted before performing the binarySearch() method.|||To know more, visit Java Binary Search.|||For example,|||Output|||The min() and max() methods of the Java collections framework are used to find the minimum and the maximum elements, respectively. For example,|||Output",reverse() - reverses the order of elements$$$fill() - replace every element in a collection with the specified value$$$copy() - creates a copy of elements from the specified source to destination$$$swap() - swaps the position of two elements in a collection$$$addAll() - adds all the elements of a collection to other collection$$$frequency() - returns the count of the number of times an element is present in the collection$$$disjoint() - checks if two collections contain some common element$$$Sorting Using sort()$$$Shuffling Using shuffle()$$$Routine Data Manipulation$$$Searching Using binarySearch()$$$Composition$$$Finding Extreme Values,,
https://www.programiz.com/java-programming/iterator,Java Iterator,Methods of Iterator$$$Example: Implementation of Iterator$$$Table of Contents,,"In this tutorial, we will learn about the Java Iterator interface with the help of an example.|||The Iterator interface of the Java collections framework allows us to access elements of a collection. It has a subinterface ListIterator.||||||All the Java collections include an iterator() method. This method returns an instance of iterator used to iterate over elements of collections.|||The Iterator interface provides 4 methods that can be used to perform various operations on elements of collections.|||In the example below, we have implemented the hasNext(), next(), remove() and forEachRemining() methods of the Iterator interface in an array list.||||||Output|||In the above example, notice the statement:|||Here, we have passed the lambda expression as an argument of the forEachRemaining() method.|||Now the method will print all the remaining elements of the array list.",hasNext() - returns true if there exists an element in the collection$$$next() - returns the next element of the collection$$$remove() - removes the last element returned by the next()$$$forEachRemaining() - performs the specified action for each remaining element of the collection$$$Methods of Iterator$$$Example: Implementation of Iterator,,
https://www.programiz.com/java-programming/listiterator,Java ListIterator Interface,Methods of ListIterator$$$Example 1: Implementation of ListIterator$$$Example 2: Implementation of ListIterator$$$Table of Contents,,"In this tutorial, we will learn about the Java ListIterator interface with the help of an example.|||The ListIterator interface of the Java collections framework provides the functionality to access elements of a list.|||It is bidirectional. This means it allows us to iterate elements of a list in both the direction.|||It extends the Iterator interface.||||||The List interface provides a listIterator() method that returns an instance of the ListIterator interface.|||The ListIterator interface provides methods that can be used to perform various operations on the elements of a list.|||In the example below, we have implemented the next(), nextIndex() and hasNext() methods of the ListIterator interface in an array list.||||||Output|||In the example below, we have implemented the previous() and previousIndex() methods of the ListIterator interface in an array list.|||Output|||In the above example, initially, the instance of the Iterator was before 1. Since there was no element before 1 so calling the previous() method will throw an exception.|||We then used the next() methods 2 times. Now the Iterator instance will be between 3 and 2.|||Hence, the previous() method returns 3.",hasNext() - returns true if there exists an element in the list$$$next() - returns the next element of the list$$$nextIndex() returns the index of the element that the next() method will return$$$previous() - returns the previous element of the list$$$previousIndex() - returns the index of the element that the previous() method will return$$$remove() - removes the element returned by either next() or previous()$$$set() - replaces the element returned by either next() or previous() with the specified element$$$Methods of ListIterator$$$Example 1: Implementation of ListIterator$$$Example 2: Implementation of ListIterator,,
https://www.programiz.com/java-programming/io-streams,Java I/O Streams,Types of Streams$$$Byte Stream$$$Character Stream$$$Table of Contents,,"In this tutorial, we will learn about Java input/output streams and their types.|||In Java, streams are the sequence of data that are read from the source and written to the destination.|||An input stream is used to read data from the source. And, an output stream is used to write data to the destination.|||For example, in our first Hello World example, we have used System.out to print a string. Here, the System.out is a type of output stream.|||Similarly, there are input streams to take input.||||||We will learn about input streams and output streams in detail in the later tutorials.|||Depending upon the data a stream holds, it can be classified into:||||||Byte stream is used to read and write a single byte (8 bits) of data.|||All byte stream classes are derived from base abstract classes called InputStream and OutputStream.|||To learn more, visit|||Character stream is used to read and write a single character of data.|||All the character stream classes are derived from base abstract classes Reader and Writer.|||To learn more, visit",Byte Stream$$$Character Stream$$$Java InputStream Class$$$Java OutputStream Class$$$Java Reader Class$$$Java Writer Class$$$Java Streams (Introduction)$$$Byte Stream $$$Character Stream ,,
https://www.programiz.com/java-programming/inputstream,Java InputStream (With Example),Subclasses of InputStream$$$Create an InputStream$$$Methods of InputStream$$$Example: InputStream Using FileInputStream$$$Table of Contents,,"In this tutorial, we will learn about the Java InputStream class and its methods with the help of an example.|||The InputStream class of the java.io package is an abstract superclass that represents an input stream of bytes.|||Since InputStream is an abstract class, it is not useful by itself. However, its subclasses can be used to read data.|||In order to use the functionality of InputStream, we can use its subclasses. Some of them are:||||||We will learn about all these subclasses in the next tutorial.|||In order to create an InputStream, we must import the java.io.InputStream package first. Once we import the package, here is how we can create the input stream.|||Here, we have created an input stream using FileInputStream. It is because InputStream is an abstract class. Hence we cannot create an object of InputStream.|||Note: We can also create an input stream from other subclasses of InputStream.|||The InputStream class provides different methods that are implemented by its subclasses. Here are some of the commonly used methods:||||||Here is how we can implement InputStream using the FileInputStream class.|||Suppose we have a file named input.txt with the following content.|||Let's try to read this file using FileInputStream (a subclass of InputStream).|||Output|||In the above example, we have created an input stream using the FileInputStream class. The input stream is linked with the file input.txt.|||To read data from the input.txt file, we have implemented these two methods.|||To learn more, visit Java InputStream (official Java documentation).",FileInputStream$$$ByteArrayInputStream$$$ObjectInputStream$$$read() - reads one byte of data from the input stream$$$read(byte[] array) - reads bytes from the stream and stores in the specified array$$$available() - returns the number of bytes available in the input stream$$$mark() - marks the position in the input stream up to which data has been read$$$reset() - returns the control to the point in the stream where the mark was set$$$markSupported() - checks if the mark() and reset() method is supported in the stream$$$skips() - skips and discards the specified number of bytes from the input stream$$$close() - closes the input stream$$$Introduction$$$Subclasses of InputStream$$$Create an InputStream$$$Methods of InputStream$$$Example: InputStream Using FileInputStream,,
https://www.programiz.com/java-programming/outputstream,Java OutputStream (With Example),Subclasses of OutputStream$$$Create an OutputStream$$$Methods of OutputStream$$$Example: OutputStream Using FileOutputStream$$$Table of Contents,,"In this tutorial, we will learn about the Java OutputStream and its methods with the help of an example.|||The OutputStream class of the java.io package is an abstract superclass that represents an output stream of bytes.|||Since OutputStream is an abstract class, it is not useful by itself. However, its subclasses can be used to write data.|||In order to use the functionality of OutputStream, we can use its subclasses. Some of them are:||||||We will learn about all these subclasses in the next tutorial.|||In order to create an OutputStream, we must import the java.io.OutputStream package first. Once we import the package, here is how we can create the output stream.|||Here, we have created an object of output stream using FileOutputStream. It is because OutputStream is an abstract class, so we cannot create an object of OutputStream.|||Note: We can also create the output stream from other subclasses of the OutputStream class.||||||The OutputStream class provides different methods that are implemented by its subclasses. Here are some of the methods:|||Here is how we can implement OutputStream using the FileOutputStream class.|||In the above example, we have created an output stream using the FileOutputStream class. The output stream is now linked with the file output.txt.|||To write data to the output.txt file, we have implemented these methods.|||When we run the program, the output.txt file is filled with the following content.|||To learn more, visit Java OutputStream (official Java documentation).",FileOutputStream$$$ByteArrayOutputStream$$$ObjectOutputStream$$$write() - writes the specified byte to the output stream$$$write(byte[] array) - writes the bytes from the specified array to the output stream$$$flush() - forces to write all data present in output stream to the destination$$$close() - closes the output stream$$$Introduction$$$Subclasses of OutputStream$$$Create an OutputStream$$$Methods of OutputStream$$$Example: OutputStream Using FileOutputStream,,
https://www.programiz.com/java-programming/fileinputstream,Java FileInputStream (With Examples),Create a FileInputStream$$$Methods of FileInputStream$$$Other Methods Of FileInputStream$$$read() Method$$$available() Method$$$skip() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java FileInputStream and its methods with the help of examples.|||The FileInputStream class of the java.io package can be used to read data (in bytes) from files.|||It extends the InputStream abstract class.||||||Before we learn about FileInputStream, make sure to know about Java Files.|||In order to create a file input stream, we must import the java.io.FileInputStream package first. Once we import the package, here is how we can create a file input stream in Java.|||1. Using the path to file |||Here, we have created an input stream that will be linked to the file specified by the path.|||2. Using an object of the file |||Here, we have created an input stream that will be linked to the file specified by fileObject.|||The FileInputStream class provides implementations for different methods present in the InputStream class.|||Suppose we have a file named input.txt with the following content.|||Let's try to read this file using FileInputStream.|||Output||||||In the above example, we have created a file input stream named input. The input stream is linked with the input.txt file.|||To read data from the file, we have used the read() method inside the while loop.|||To get the number of available bytes, we can use the available() method. For example,|||Output|||In the above example,|||To discard and skip the specified number of bytes, we can use the skip() method. For example,|||Output|||In the above example, we have used the skip() method to skip 5 bytes of data from the file input stream. Hence, the bytes representing the text ""This "" is not read from the input stream.|||To close the file input stream, we can use the close() method. Once the close() method is called, we cannot use the input stream to read data.|||In all the above examples, we have used the close() method to close the file input stream.|||To learn more, visit Java FileInputStream (official Java documentation).","read() - reads a single byte from the file$$$read(byte[] array) - reads the bytes from the file and stores in the specified array$$$read(byte[] array, int start, int length) - reads the number of bytes equal to length from the file and stores in the specified array starting from the position start$$$Introduction$$$Create a FileInputStream$$$read() Method$$$available() Method$$$skip() Method$$$Other Methods Of FileInputStream","We first use the available() method to check the number of available bytes in the file input stream.$$$We then have used the read() method 3 times to read 3 bytes from the file input stream.$$$Now, after reading the bytes we again have checked the available bytes. This time the available bytes decreased by 3.",Methods|||Descriptions$$$finalize() |||ensures that the close() method is called$$$getChannel() |||returns the object of FileChannel associated with the input stream$$$getFD() |||returns the file descriptor associated with the input stream$$$mark() |||mark the position in input stream up to which data has been read$$$reset() |||returns the control to the point in the input stream where the mark was set
https://www.programiz.com/java-programming/fileoutputstream,Java FileOutputStream (With Examples),Create a FileOutputStream$$$Methods of FileOutputStream$$$Other Methods Of FileOutputStream$$$write() Method$$$Example: FileOutputStream to write data to a File$$$flush() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java FileOutputStream and its methods with the help of examples.|||The FileOutputStream class of the java.io package can be used to write data (in bytes) to the files.|||It extends the OutputStream abstract class.||||||Before you learn about FileOutputStream, make sure to know about Java Files.|||In order to create a file output stream, we must import the java.io.FileOutputStream package first. Once we import the package, here is how we can create a file output stream in Java.|||1. Using the path to file|||Here, we have created an output stream that will be linked to the file specified by the path.|||Also, value is an optional boolean parameter. If it is set to true, the new data will be appended to the end of the existing data in the file. Otherwise, the new data overwrites the existing data in the file.|||2. Using an object of the file|||Here, we have created an output stream that will be linked to the file specified by fileObject.||||||The FileOutputStream class provides implementations for different methods present in the OutputStream class.|||In the above example, we have created a file output stream named output. The file output stream is linked with the file output.txt.|||To write data to the file, we have used the write() method.|||Here, when we run the program, the output.txt file is filled with the following content.|||Note: The getBytes() method used in the program converts a string into an array of bytes.|||To clear the output stream, we can use the flush() method. This method forces the output stream to write all data to the destination. For example,|||When we run the program, the file flush.txt is filled with the text represented by the string data.|||To close the file output stream, we can use the close() method. Once the method is called, we cannot use the methods of FileOutputStream.|||To learn more, visit Java FileOutputStream (official Java documentation).","write() - writes the single byte to the file output stream$$$write(byte[] array) - writes the bytes from the specified array to the output stream$$$write(byte[] array, int start, int length) - writes the number of bytes equal to length to the output stream from an array starting from the position start$$$Introduction$$$Create a FileOutputStream$$$write() Method$$$flush() Method$$$Other Methods Of FileOutputStream",,Methods|||Descriptions$$$finalize()|||ensures that the close() method is called$$$getChannel()|||returns the object of FileChannel associated with the output stream$$$getFD()|||returns the file descriptor associated with the output stream
https://www.programiz.com/java-programming/bytearrayinputstream,Java ByteArrayInputStream (With Examples),Create a ByteArrayInputStream$$$Methods of ByteArrayInputStream$$$Other Methods Of ByteArrayInputStream$$$read() Method$$$Example: ByteArrayInputStream to read data$$$available() Method$$$skip() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java ByteArrayInputStream and its methods with the help of examples.|||The ByteArrayInputStream class of the java.io package can be used to read an array of input data (in bytes).|||It extends the InputStream abstract class.||||||Note: In ByteArrayInputStream, the input stream is created using the array of bytes. It includes an internal array to store data of that particular byte array.|||In order to create a byte array input stream, we must import the java.io.ByteArrayInputStream package first. Once we import the package, here is how we can create an input stream.|||Here, we have created an input stream that reads entire data from the arr array. However, we can also create the input stream that reads only some data from the array.|||Here the input stream reads the number of bytes equal to length from the array starting from the start position.|||The ByteArrayInputStream class provides implementations for different methods present in the InputStream class.|||Output|||In the above example, we have created a byte array input stream named input.|||Here, the input stream includes all the data from the specified array. To read data from the input stream, we have used the read() method.||||||To get the number of available bytes in the input stream, we can use the available() method. For example,|||Output|||In the above example,|||To discard and skip the specified number of bytes, we can use the skip() method. For example,|||Output|||In the above example, we have used the skip() method to skip 2 bytes of data from the input stream. Hence 1 and 2 are not read from the input stream.|||To close the input stream, we can use the close() method.|||However, the close() method has no effect in ByteArrayInputStream class. We can use the methods of this class even after the close() method is called.|||To learn more, visit Java ByteArrayInputStream (official Java documentation).","read() - reads the single byte from the array present in the input stream$$$read(byte[] array) - reads bytes from the input stream and stores in the specified array$$$read(byte[] array, int start, int length) - reads the number of bytes equal to length from the stream and stores in the specified array starting from the position start$$$Introduction$$$Create a ByteArrayInputStream$$$read() Method$$$available() Method$$$skip() Method$$$Other Methods Of ByteArrayInputStream","We have used the available() method to check the number of available bytes in the input stream.$$$We have then used the read() method 2 times to read 2 bytes from the input stream.$$$Now, after reading the 2 bytes, we have checked the available bytes. This time the available bytes decreased by 2.",Methods|||Descriptions$$$finalize()|||ensures that the close() method is called$$$mark()|||marks the position in input stream up to which data has been read$$$reset()|||returns the control to the point in the input stream where the mark was set$$$markSupported()|||checks if the input stream supports mark() and reset()
https://www.programiz.com/java-programming/bytearrayoutputstream,Java ByteArrayOutputStream (With Examples),Create a ByteArrayOutputStream$$$Methods of ByteArrayOutputStream$$$Other Methods of ByteArrayOutputStream$$$write() Method$$$Example: ByteArrayOutputStream to write data$$$Access Data from ByteArrayOutputStream$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java ByteArrayOutputStream and its methods with the help of examples.|||The ByteArrayOutputStream class of the java.io package can be used to write an array of output data (in bytes).|||It extends the OutputStream abstract class.||||||Note: In ByteArrayOutputStream maintains an internal array of bytes to store the data.|||In order to create a byte array output stream, we must import the java.io.ByteArrayOutputStream package first. Once we import the package, here is how we can create an output stream.|||Here, we have created an output stream that will write data to an array of bytes with default size 32 bytes. However, we can change the default size of the array.|||Here, the size specifies the length of the array.|||The ByteArrayOutputStream class provides the implementation of the different methods present in the OutputStream class.|||Output|||In the above example, we have created a byte array output stream named output.||||||To write the data to the output stream, we have used the write() method.|||Note: The getBytes() method used in the program converts a string into an array of bytes.|||For example,|||Output|||In the above example, we have created an array of bytes to store the data returned by the toByteArray() method.|||We then have used the for loop to access each byte from the array. Here, each byte is converted into the corresponding character using typecasting.|||To close the output stream, we can use the close() method.|||However, the close() method has no effect in ByteArrayOutputStream class. We can use the methods of this class even after the close() method is called.|||To learn more, visit Java ByteArrayOutputStream (official Java documentation).","write(int byte) - writes the specified byte to the output stream$$$write(byte[] array) - writes the bytes from the specified array to the output stream$$$write(byte[] arr, int start, int length) - writes the number of bytes equal to length to the output stream from an array starting from the position start$$$writeTo(ByteArrayOutputStream out1) - writes the entire data of the current output stream to the specified output stream$$$toByteArray() - returns the array present inside the output stream$$$toString() - returns the entire data of the output stream in string form$$$Introduction$$$Create a ByteArrayOutputStream$$$write() Method$$$Access Data from ByteArrayOutputStream$$$Other Methods of ByteArrayOutputStream",,Methods|||Descriptions$$$size() |||returns the size of the array in the output stream$$$flush() |||clears the output stream
https://www.programiz.com/java-programming/objectinputstream,Java ObjectInputStream (With Examples),Working of ObjectInputStream$$$Create an ObjectInputStream$$$Methods of ObjectInputStream$$$read() Method$$$Other Methods Of ObjectInputStream$$$Example 1: Java ObjectInputStream$$$Example 2: Java ObjectInputStream$$$Table of Contents,,"In this tutorial, we will learn about Java ObjectOutputStream and its methods with the help of examples.|||The ObjectInputStream class of the java.io package can be used to read objects that were previously written by ObjectOutputStream.|||It extends the InputStream abstract class.||||||Before you learn about the ObjectInputStream class, make sure you know about the ObjectOutputStream Class.|||The ObjectInputStream is mainly used to read data written by the ObjectOutputStream.|||Basically, the ObjectOutputStream converts Java objects into corresponding streams. This is known as serialization. Those converted streams can be stored in files or transferred through networks.|||Now, if we need to read those objects, we will use the ObjectInputStream that will convert the streams back to corresponding objects. This is known as deserialization.|||In order to create an object input stream, we must import the java.io.ObjectInputStream package first. Once we import the package, here is how we can create an input stream.|||In the above example, we have created an object input stream named objStream that is linked with the file input stream named fileStream.|||Now, the objStream can be used to read objects from the file.|||The ObjectInputStream class provides implementations of different methods present in the InputStream class.||||||Let's see how we can use the ObjectInputStream class to read objects written by the ObjectOutputStream class.|||Output|||In the above example, we have used the readInt() and readObject() method to read integer data and object data from the file.|||Here, we have used the ObjectOutputStream to write data to the file. We then read the data from the file using the ObjectInputStream.|||Let's see another practical example,|||Output|||In the above example, we have created|||Here, we have then used the object output stream to write the object to the file. And, the object input stream to read the object from the file.|||Note: The Dog class implements the Serializable interface. It is because the ObjectOutputStream only writes the serializable objects to the output stream.|||To learn more, visit Java ObjectInputStream (official Java documentation).",read() - reads a byte of data from the input stream$$$readBoolean() - reads data in boolean form$$$readChar() - reads data in character form$$$readInt() - reads data in integer form$$$readObject() - reads the object from the input stream$$$ObjectOutputStream named output using the FileOutputStream named file$$$ObjectInputStream named input using the FileInputStream named fileStream$$$An object dog of the Dog class$$$Introduction$$$Working of ObjectInputStream$$$Create an ObjectInputStream$$$Example: ObjectInputStream$$$Example: ObjectInputStream$$$Other Methods Of ObjectInputStream,,Methods|||Descriptions$$$available() |||returns the available number of bytes in the input stream$$$mark() |||marks the position in input stream up to which data has been read$$$reset() |||returns the control to the point in the input stream where the mark was set$$$skipBytes() |||skips and discards the specified bytes from the input stream$$$close() |||closes the object input stream
https://www.programiz.com/java-programming/objectoutputstream,Java ObjectOutputStream (With Examples),Working of ObjectOutputStream$$$Create an ObjectOutputStream$$$Methods of ObjectOutputStream$$$write() Method$$$Other Methods Of ObjectOutputStream$$$Example 1: Java ObjectOutputStream$$$Example 2: Java ObjectOutputStream$$$Table of Contents,,"In this tutorial, we will learn about Java ObjectOutputStream and its methods with the help of examples.|||The ObjectOutputStream class of the java.io package can be used to write objects that can be read by ObjectInputStream.|||It extends the OutputStream abstract class.||||||Basically, the ObjectOutputStream encodes Java objects using the class name and object values. And, hence generates corresponding streams. This process is known as serialization.|||Those converted streams can be stored in files and can be transferred among networks.|||Note: The ObjectOutputStream class only writes those objects that implement the Serializable interface. This is because objects need to be serialized while writing to the stream|||In order to create an object output stream, we must import the java.io.ObjectOutputStream package first. Once we import the package, here is how we can create an output stream.|||In the above example, we have created an object output stream named objStream that is linked with the file output stream named fileStream.|||The ObjectOutputStream class provides implementations for different methods present in the OutputStream class.|||Let's see how we can use ObjectOutputStream to store objects in a file and ObjectInputStream to read those objects from the files||||||Output|||In the above example, we have used the readInt() method and readObject() method to read an integer data and object data from the files.|||Here, we have used the ObjectOutputStream to write data to the file. We then read the data from the file using the ObjectInputStream.|||Let's take another example,|||Output|||In the above example, we have created|||Here, we have then used the object output stream to write the object to the file. And, the object input stream to read the object from the file.|||Note: The Dog class implements the Serializable interface. It is because the ObjectOutputStream only writes objects that can be serialized to the output stream.|||To learn more, visit Java ObjectOutputStream (official Java documentation).",write() - writes a byte of data to the output stream$$$writeBoolean() - writes data in boolean form$$$writeChar() - writes data in character form$$$writeInt() - writes data in integer form$$$writeObject() - writes object to the output stream$$$ObjectOutputStream named objOut using the FileOutputStream named fileOut$$$ObjectInputStream named objIn using the FileInputStream named fileIn.$$$An object dog1 of the Dog class.$$$Introduction$$$Working of ObjectOutputStream$$$Create an ObjectOutputStream$$$Example: ObjectOutputStream$$$Example: ObjectOutputStream$$$Other Methods Of ObjectOutputStream,,Methods|||Descriptions$$$flush()|||clears all the data from the output stream$$$drain()|||puts all the buffered data in the output stream$$$close()|||closes the output stream
https://www.programiz.com/java-programming/bufferedinputstream,Java BufferedInputStream (With Examples),Working of BufferedInputStream$$$Create a BufferedInputStream$$$Methods of BufferedInputStream$$$Other Methods Of BufferedInputStream$$$read() Method$$$available() Method$$$skip() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java BufferedInputStream and its methods with the help of examples.|||The BufferedInputStream class of the java.io package is used with other input streams to read the data (in bytes) more efficiently.|||It extends the InputStream abstract class.||||||The BufferedInputStream maintains an internal buffer of 8192 bytes.|||During the read operation in BufferedInputStream, a chunk of bytes is read from the disk and stored in the internal buffer. And from the internal buffer bytes are read individually.|||Hence, the number of communication to the disk is reduced. This is why reading bytes is faster using the BufferedInputStream.|||In order to create a BufferedInputStream, we must import the java.io.BufferedInputStream package first. Once we import the package here is how we can create the input stream.|||In the above example, we have created a BufferdInputStream named buffer with the FileInputStream named file.|||Here, the internal buffer has the default size of 8192 bytes. However, we can specify the size of the internal buffer as well.|||The buffer will help to read bytes from the files more quickly.|||The BufferedInputStream class provides implementations for different methods present in the InputStream class.|||Suppose we have a file named input.txt with the following content.|||Let's try to read the file using BufferedInputStream.||||||Output|||In the above example, we have created a buffered input stream named buffer along with FileInputStream. The input stream is linked with the file input.txt.|||Here, we have used the read() method to read an array of bytes from the internal buffer of the buffered reader.|||To get the number of available bytes in the input stream, we can use the available() method. For example,|||Output|||In the above example,|||To discard and skip the specified number of bytes, we can use the skip() method. For example,|||Output|||In the above example, we have used the skip() method to skip 5 bytes from the file input stream. Hence, the bytes 'T', 'h', 'i', 's' and ' ' are skipped from the input stream.|||To close the buffered input stream, we can use the close() method. Once the close() method is called, we cannot use the input stream to read the data.|||To learn more, visit Java BufferdInputStream (official Java documentation).","read() - reads a single byte from the input stream$$$read(byte[] arr) - reads bytes from the stream and stores in the specified array$$$read(byte[] arr, int start, int length) - reads the number of bytes equal to the length from the stream and stores in the specified array starting from the position start$$$Introduction$$$Working of BufferedInputStream$$$Create a BufferedInputStream$$$read() Method$$$available() Method$$$skip() Method$$$Other Methods Of BufferedInputStream","We first use the available() method to check the number of available bytes in the input stream.$$$Then, we have used the read() method 3 times to read 3 bytes from the input stream.$$$Now, after reading the bytes we again have checked the available bytes. This time the available bytes decreased by 3.",Methods|||Descriptions$$$mark() |||mark the position in input stream up to which data has been read$$$reset() |||returns the control to the point in the input stream where the mark was set
https://www.programiz.com/java-programming/bufferedoutputstream,Java BufferedOutputStream (With Examples),Working of BufferedOutputStream$$$Create a BufferedOutputStream$$$Methods of BufferedOutputStream$$$flush() Method$$$write() Method$$$Example: BufferedOutputStream to write data to a File$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java BufferedOutputStream and its methods with the help of examples.|||The BufferedOutputStream class of the java.io package is used with other output streams to write the data (in bytes) more efficiently.|||It extends the OutputStream abstract class.||||||The BufferedOutputStream maintains an internal buffer of 8192 bytes.|||During the write operation, the bytes are written to the internal buffer instead of the disk. Once the buffer is filled or the stream is closed, the whole buffer is written to the disk.|||Hence, the number of communication to the disk is reduced. This is why writing bytes is faster using BufferedOutputStream.|||In order to create a BufferedOutputStream, we must import the java.io.BufferedOutputStream package first. Once we import the package here is how we can create the output stream.|||In the above example, we have created a BufferdOutputStream named buffer with the FileOutputStream named file.|||Here, the internal buffer has the default size of 8192 bytes. However, we can specify the size of the internal buffer as well.|||The buffer will help to write bytes to files more quickly.||||||The BufferedOutputStream class provides implementations for different methods in the OutputStream class.|||In the above example, we have created a buffered output stream named output along with FileOutputStream. The output stream is linked with the file output.txt.|||To write data to the file, we have used the write() method.|||Here when we run the program, the output.txt file is filled with the following content.|||Note: The getBytes() method used in the program converts a string into an array of bytes.|||To clear the internal buffer, we can use the flush() method. This method forces the output stream to write all data present in the buffer to the destination file. For example,|||Output|||When we run the program, the file flush.txt is filled with the text represented by the string data.|||To close the buffered output stream, we can use the close() method. Once the method is called, we cannot use the output stream to write the data.|||To learn more, visit Java BufferedOutputStream (official Java documentation).","write() - writes a single byte to the internal buffer of the output stream$$$write(byte[] array) - writes the bytes from the specified array to the output stream$$$write(byte[] arr, int start, int length) - writes the number of bytes equal to length to the output stream from an array starting from the position start$$$Introduction$$$Working of BufferedOutputStream$$$Create a BufferedOutputStream$$$write() Method$$$flush() Method",,
https://www.programiz.com/java-programming/printstream,Java PrintStream (With Examples),Working of PrintStream$$$Create a PrintStream$$$Methods of PrintStream$$$Other Methods Of PrintStream$$$print() Method$$$Example: print() method with System class$$$Example: print() method with PrintStream class$$$printf() Method$$$Example: printf() method using PrintStream$$$Table of Contents,,"In this tutorial, we will learn about the Java PrintStream class and its print() and printf() methods with the help of examples.|||The PrintStream class of the java.io package can be used to write output data in commonly readable form (text) instead of bytes.|||It extends the abstract class OutputStream.||||||Unlike other output streams, the PrintStream converts the primitive data (integer, character) into the text format instead of bytes. It then writes that formatted data to the output stream.|||And also, the PrintStream class does not throw any input/output exception. Instead, we need to use the checkError() method to find any error in it.|||Note: The PrintStream class also has a feature of auto flushing. This means it forces the output stream to write all the data to the destination under one of the following conditions:|||In order to create a PrintStream, we must import the java.io.PrintStream package first. Once we import the package here is how we can create the print stream.|||1. Using other output streams|||Here,|||2. Using filename|||Here,|||Note: In both the case, the PrintStream write data to the file using some default character encoding. However, we can specify the character encoding (UTF8 or UTF16) as well.|||Here, we have used the Charset class to specify the character encoding. To learn more, visit Java Charset (official Java documentation).|||The PrintStream class provides various methods that allow us to print data to the output.|||Output|||In the above example, we have not created a print stream. However, we can use the print() method of the PrintStream class.|||You might be wondering how is this possible. Well, let me explain what is happening here.||||||Notice the line,|||Here,|||Now since out is of PrintStream type, we can use it to call all the methods of PrintStream class.|||In the above example, we have created a print stream named output. The print stream is linked with the output.txt file.|||To print data to the file, we have used the print() method.|||Here, when we run the program, the output.txt file is filled with the following content.|||The printf() method can be used to print the formatted string. It includes 2 parameters: formatted string and arguments. For example,|||Here,|||The formatted string includes both text and data. And, the arguments replace the data inside the formatted string.|||Hence the %d is replaced by 25.|||In the above example, we have created a print stream named output. The print stream is linked with the file output.txt.|||To print the formatted text to the file, we have used the printf() method.|||Here, when we run the program, the output.txt file is filled with the following content.|||To learn more, visit Java PrintStream (official Java documentation).",if newline character \n is written in the print stream$$$if the println() method is invoked$$$if an array of bytes is written in the print stream$$$we have created a print stream that will write formatted data to the file represented by FileOutputStream$$$the autoFlush is an optional boolean parameter that specifies whether to perform auto flushing or not$$$we have created a print stream that will write formatted data to the specified file$$$autoFlush is an optional boolean parameter that specifies whether to perform autoflush or not$$$print() - prints the specified data to the output stream$$$println() - prints the data to the output stream along with a new line character at the end$$$System is a final class that is responsible to perform standard input/output operation$$$out is a class variable of PrintStream type declared in System class$$$I am %d years old is a formatted string$$$%d is integer data in the formatted string$$$25 is an argument$$$Introduction$$$Working of PrintStream$$$Create a PrintStream$$$print() Method$$$Example: print() method with PrintStream class$$$printf() Method$$$Other Methods Of PrintStream,,Methods|||Descriptions$$$close()|||closes the print stream$$$checkError()|||checks if there is an error in the stream and returns a boolean result$$$append()|||appends the specified data to the stream
https://www.programiz.com/java-programming/reader,Java Reader (With Example),Subclasses of Reader$$$Create a Reader$$$Methods of Reader$$$Example: Reader Using FileReader$$$Table of Contents,,"In this tutorial, we will learn about Java Reader, its subclasses and its methods with the help of an example.|||The Reader class of the java.io package is an abstract superclass that represents a stream of characters.|||Since Reader is an abstract class, it is not useful by itself. However, its subclasses can be used to read data.|||In order to use the functionality of Reader, we can use its subclasses. Some of them are:||||||We will learn about all these subclasses in the next tutorial.|||In order to create a Reader, we must import the java.io.Reader package first. Once we import the package, here is how we can create the reader.|||Here, we have created a reader using the FileReader class. It is because Reader is an abstract class. Hence we cannot create an object of Reader.|||Note: We can also create readers from other subclasses of Reader.|||The Reader class provides different methods that are implemented by its subclasses. Here are some of the commonly used methods:||||||Here is how we can implement Reader using the FileReader class.|||Suppose we have a file named input.txt with the following content.|||Let's try to read this file using FileReader (a subclass of Reader).|||Output|||In the above example, we have created a reader using the FileReader class. The reader is linked with the file input.txt.|||To read data from the input.txt file, we have implemented these methods.|||To learn more, visit Java Reader (official Java documentation).","BufferedReader$$$InputStreamReader$$$FileReader$$$StringReader$$$ready() - checks if the reader is ready to be read$$$read(char[] array) - reads the characters from the stream and stores in the specified array$$$read(char[] array, int start, int length) - reads the number of characters equal to length from the stream and stores in the specified array starting from the start$$$mark() - marks the position in the stream up to which data has been read$$$reset() - returns the control to the point in the stream where the mark is set$$$skip() - discards the specified number of characters from the stream$$$Introduction$$$Subclasses of Reader$$$Create a Reader$$$Methods of Reader$$$Example: Reader Using FileReader",,
https://www.programiz.com/java-programming/writer,Java Writer (With Example),Subclasses of Writer$$$Create a Writer$$$Methods of Writer$$$Example: Writer Using FileWriter$$$Table of Contents,,"In this tutorial, we will learn about Java Writer, its subclasses and its methods with the help of an example.|||The Writer class of the java.io package is an abstract superclass that represents a stream of characters.|||Since Writer is an abstract class, it is not useful by itself. However, its subclasses can be used to write data.|||In order to use the functionality of the Writer, we can use its subclasses. Some of them are:||||||We will learn about all these subclasses in the next tutorial.|||In order to create a Writer, we must import the java.io.Writer package first. Once we import the package, here is how we can create the writer.|||Here, we have created a writer named output using the FileWriter class. It is because the Writer is an abstract class. Hence we cannot create an object of Writer.|||Note: We can also create writers from other subclasses of the Writer class.||||||The Writer class provides different methods that are implemented by its subclasses. Here are some of the methods:|||Here is how we can implement the Writer using the FileWriter class.|||In the above example, we have created a writer using the FileWriter class. The writer is linked with the file output.txt.|||To write data to the output.txt file, we have implemented these methods.|||When we run the program, the output.txt file is filled with the following content.|||To learn more, visit Java Writer (official Java documentation).",BufferedWriter$$$OutputStreamWriter$$$FileWriter$$$StringWriter$$$write(char[] array) - writes the characters from the specified array to the output stream$$$write(String data) - writes the specified string to the writer$$$append(char c) - inserts the specified character to the current writer$$$flush() - forces to write all the data present in the writer to the corresponding destination$$$close() - closes the writer$$$Introduction$$$Subclasses of Writer$$$Create a Writer$$$Methods of Writer$$$Example: Writer Using FileWriter,,
https://www.programiz.com/java-programming/inputstreamreader,Java InputStreamReader (With Examples),Create an InputStreamReader$$$Methods of InputStreamReader$$$getEncoding() Method$$$Other Methods of InputStreamReader$$$read() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java InputStreamReader and its methods with the help of examples.|||The InputStreamReader class of the java.io package can be used to convert data in bytes into data in characters.|||It extends the abstract class Reader.||||||The InputStreamReader class works with other input streams. It is also known as a bridge between byte streams and character streams. This is because the InputStreamReader reads bytes from the input stream as characters.|||For example, some characters required 2 bytes to be stored in the storage. To read such data we can use the input stream reader that reads the 2 bytes together and converts into the corresponding character.|||In order to create an InputStreamReader, we must import the java.io.InputStreamReader package first. Once we import the package here is how we can create the input stream reader.|||In the above example, we have created an InputStreamReader named input along with the FileInputStream named file.|||Here, the data in the file are stored using some default character encoding.|||However, we can specify the type of character encoding (UTF8 or UTF16) in the file as well.|||Here, we have used the Charset class to specify the character encoding in the file.|||The InputStreamReader class provides implementations for different methods present in the Reader class.||||||For example, suppose we have a file named input.txt with the following content.|||Let's try to read this file using InputStreamReader.|||Output|||In the above example, we have created an input stream reader using the file input stream. The input stream reader is linked with the file input.txt.|||To read characters from the file, we have used the read() method.|||The getEncoding() method can be used to get the type of encoding that is used to store data in the input stream. For example,|||Output|||In the above example, we have created 2 input stream reader named input1 and input2.|||Note: We have used the Charset.forName() method to specify the type of character encoding. To learn more, visit Java Charset (official Java documentation).|||To close the input stream reader, we can use the close() method. Once the close() method is called, we cannot use the reader to read the data.|||To learn more, visit Java InputStreamReader (official Java documentation).","read() - reads a single character from the reader$$$read(char[] array) - reads the characters from the reader and stores in the specified array$$$read(char[] array, int start, int length) - reads the number of characters equal to length from the reader and stores in the specified array starting from the start$$$input1 does not specify the character encoding. Hence the getEncoding() method returns the canonical name of the default character encoding.$$$input2 specifies the character encoding, UTF8. Hence the getEncoding() method returns the specified character encoding.$$$Introduction$$$Create an InputStreamReader$$$read() Method$$$getEncoding() Method$$$Other Methods of InputStreamReader",,Method|||Description$$$ready()|||checks if the stream is ready to be read$$$mark()|||mark the position in stream up to which data has been read$$$reset()|||returns the control to the point in the stream where the mark was set
https://www.programiz.com/java-programming/outputstreamwriter,Java OutputStreamWriter (With Examples),Create an OutputStreamWriter$$$Methods of OutputStreamWriter$$$getEncoding() Method$$$close() Method$$$Other methods of OutputStreamWriter$$$write() Method$$$Example: OutputStreamWriter to write data to a File$$$Table of Contents,,"In this tutorial, we will learn about Java OutputStreamWriter and its methods with the help of examples.|||The OutputStreamWriter class of the java.io package can be used to convert data in character form into data in bytes form.|||It extends the abstract class Writer.||||||The OutputStreamWriter class works with other output streams. It is also known as a bridge between byte streams and character streams. This is because the OutputStreamWriter converts its characters into bytes.|||For example, some characters require 2 bytes to be stored in the storage. To write such data we can use the output stream writer that converts the character into corresponding bytes and stores the bytes together.|||In order to create an OutputStreamWriter, we must import the java.io.OutputStreamWriter package first. Once we import the package here is how we can create the output stream writer.|||In the above example, we have created an OutputStreamWriter named output along with the FileOutputStream named file.|||Here, we are using the default character encoding to write characters to the output stream.|||However, we can specify the type of character encoding (UTF8 or UTF16) to be used to write data.|||Here, we have used the Charset class to specify the type of character encoding.||||||The OutputStreamWriter class provides implementations for different methods present in the Writer class.|||In the above example, we have created an output stream reader using the file output stream. The output stream reader is linked with the output.txt file.|||To write data to the file, we have used the write() method.|||Here, when we run the program, the output.txt file is filled with the following content.|||The getEncoding() method can be used to get the type of encoding that is used to write data to the output stream. For example,|||Output|||In the above example, we have created 2 output stream writer named output1 and output2.|||Note: We have used the Charset.forName() method to specify the type of character encoding. To learn more, visit Java Charset (official Java documentation).|||To close the output stream writer, we can use the close() method. Once the close() method is called, we cannot use the writer to write the data.|||To learn more, visit Java OutputStreamWriter (official Java documentation).","write() - writes a single character to the writer$$$write(char[] array) - writes the characters from the specified array to the writer$$$write(String data) - writes the specified string to the writer$$$output1 does not specify the character encoding. Hence the getEncoding() method returns the default character encoding.$$$output2 specifies the character encoding, UTF8. Hence the getEncoding() method returns the specified character encoding.$$$Introduction$$$Create an OutputStreamWriter$$$write() Method$$$getEncoding() Method$$$Other methods of OutputStreamWriter",,Method|||Description$$$flush()|||forces to write all the data present in the writer to the corresponding destination$$$append()|||inserts the specified character to the current writer
https://www.programiz.com/java-programming/filereader,Java FileReader (With Examples),Create a FileReader$$$Methods of FileReader$$$getEncoding() Method$$$Other Methods of FileReader$$$read() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java FileReader and its methods with the help of examples.|||The FileReader class of the java.io package can be used to read data (in characters) from files.|||It extends the InputSreamReader class.||||||Before you learn about FileReader, make sure you know about the Java File.|||In order to create a file reader, we must import the java.io.FileReader package first. Once we import the package, here is how we can create the file reader.|||1. Using the name of the file |||Here, we have created a file reader that will be linked to the file specified by the name.|||2. Using an object of the file |||Here, we have created a file reader that will be linked to the file specified by the object of the file.|||In the above example, the data in the file are stored using some default character encoding.|||However, since Java 11 we can specify the type of character encoding (UTF-8 or UTF-16) in the file as well.|||Here, we have used the Charset class to specify the character encoding of the file reader.||||||The FileReader class provides implementations for different methods present in the Reader class.|||For example, suppose we have a file named input.txt with the following content.|||Let's try to read the file using FileReader.|||Output|||In the above example, we have created a file reader named input. The file reader is linked with the file input.txt.|||To read data from the file, we have used the read() method.|||Note: The file input.txt should be present in the current working directory.|||The getEncoding() method can be used to get the type of encoding that is used to store data in the file. For example,|||Output|||In the above example, we have created 2 file reader named input1 and input2.|||Note: We have used the Charset.forName() method to specify the type of character encoding. To learn more, visit Java Charset (official Java documentation).|||To close the file reader, we can use the close() method. Once the close() method is called, we cannot use the reader to read the data.|||To learn more, visit Java FileReader (official Java documentation).","read() - reads a single character from the reader$$$read(char[] array) - reads the characters from the reader and stores in the specified array$$$read(char[] array, int start, int length) - reads the number of characters equal to length from the reader and stores in the specified array starting from the position start$$$input1 does not specify the character encoding. Hence the getEncoding() method returns the default character encoding.$$$input2 specifies the character encoding, UTF8. Hence the getEncoding() method returns the specified character encoding.$$$Introduction$$$Create a FileReader$$$read() Method$$$getEncoding() Method$$$Other Methods of FileReader",,Method|||Description$$$ready()|||checks if the file reader is ready to be read$$$mark()|||mark the position in file reader up to which data has been read$$$reset()|||returns the control to the point in the reader where the mark was set
https://www.programiz.com/java-programming/filewriter,Java FileWriter (With Examples),Create a FileWriter$$$Methods of FileWriter$$$getEncoding() Method$$$close() Method$$$Other methods of FileWriter$$$write() Method$$$Example: FileWriter to write data to a File$$$Table of Contents,,"In this tutorial, we will learn about Java FileWriter and its methods with the help of examples.|||The FileWriter class of the java.io package can be used to write data (in characters) to files.|||It extends the OutputStreamWriter class.||||||Before you learn more about FileWriter, make sure to know about Java File.|||In order to create a file writer, we must import the Java.io.FileWriter package first. Once we import the package, here is how we can create the file writer.|||1. Using the name of the file |||Here, we have created a file writer that will be linked to the file specified by the name.|||2. Using an object of the file |||Here, we have created a file writer that will be linked to the file specified by the object of the file.|||In the above example, the data are stored using some default character encoding.|||However, since Java 11 we can specify the type of character encoding (UTF8 or UTF16) as well.||||||Here, we have used the Charset class to specify the character encoding of the file writer.|||The FileWriter class provides implementations for different methods present in the Writer class.|||In the above example, we have created a file writer named output. The output reader is linked with the output.txt file.|||To write data to the file, we have used the write() method.|||Here when we run the program, the output.txt file is filled with the following content.|||The getEncoding() method can be used to get the type of encoding that is used to write data. For example,|||Output|||In the above example, we have created 2 file writer named output1 and output2.|||Note: We have used the Charset.forName() method to specify the type of character encoding. To learn more, visit Java Charset (official Java documentation).|||To close the file writer, we can use the close() method. Once the close() method is called, we cannot use the writer to write the data.|||To learn more, visit Java FileWriter (official Java documentation).","write() - writes a single character to the writer$$$write(char[] array) - writes the characters from the specified array to the writer$$$write(String data) - writes the specified string to the writer$$$output1 does not specify the character encoding. Hence the getEncoding() method returns the default character encoding.$$$output2 specifies the character encoding, UTF8. Hence the getEncoding() method returns the specified character encoding.$$$Introduction$$$Create a FileWriter$$$write() Method$$$getEncoding() Method$$$Other methods of FileWriter",,Method|||Description$$$flush()|||forces to write all the data present in the writer to the corresponding destination$$$append()|||inserts the specified character to the current writer
https://www.programiz.com/java-programming/bufferedreader,Java BufferedReader (With Examples),Working of BufferedReader$$$Create a BufferedReader$$$Methods of BufferedReader$$$Other Methods of BufferedReader$$$read() Method$$$skip() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java BufferedReader and its methods with the help of examples.|||The BufferedReader class of the java.io package can be used with other readers to read data (in characters) more efficiently.|||It extends the abstract class Reader.|||""""|||The BufferedReader maintains an internal buffer of 8192 characters.|||During the read operation in BufferedReader, a chunk of characters is read from the disk and stored in the internal buffer. And from the internal buffer characters are read individually.|||Hence, the number of communication to the disk is reduced. This is why reading characters is faster using BufferedReader.|||In order to create a BufferedReader, we must import the java.io.BuferedReader package first. Once we import the package, here is how we can create the reader.|||In the above example, we have created a BufferedReader named buffer with the FileReader named file.|||Here, the internal buffer of the BufferedReader has the default size of 8192 characters. However, we can specify the size of the internal buffer as well.|||The buffer will help to read characters from the files more quickly.|||The BufferedReader class provides implementations for different methods present in Reader.||||||For example, suppose we have a file named input.txt with the following content.|||Let's try to read the file using BufferedReader.|||Output|||In the above example, we have created a buffered reader named input. The buffered reader is linked with the input.txt file.|||Here, we have used the read() method to read an array of characters from the internal buffer of the buffered reader.|||To discard and skip the specified number of characters, we can use the skip() method. For example,|||Output|||In the above example, we have used the skip() method to skip 5 characters from the file reader. Hence, the characters 'T', 'h', 'i', 's' and ' ' are skipped from the original file.|||To close the buffered reader, we can use the close() method. Once the close() method is called, we cannot use the reader to read the data.|||To learn more, visit Java BufferedReader (official Java documentation).","read() - reads a single character from the internal buffer of the reader$$$read(char[] array) - reads the characters from the reader and stores in the specified array$$$read(char[] array, int start, int length) - reads the number of characters equal to length from the reader and stores in the specified array starting from the position start$$$Introduction$$$Working of BufferedReader$$$Create a BufferedReader$$$read() Method$$$skip() Method$$$Other Methods of BufferedReader",,Method|||Description$$$ready() |||checks if the file reader is ready to be read$$$mark() |||mark the position in reader up to which data has been read$$$reset() |||returns the control to the point in the reader where the mark was set
https://www.programiz.com/java-programming/bufferedwriter,Java BufferedWriter (With Examples),Working of BufferedWriter$$$Create a BufferedWriter$$$Methods of BufferedWriter$$$Other Methods of BufferedWriter$$$write() Method$$$Example: BufferedWriter to write data to a File$$$flush() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java BufferedWriter and its methods with the help of examples.|||The BufferedWriter class of the java.io package can be used with other writers to write data (in characters) more efficiently.|||It extends the abstract class Writer.||||||The BufferedWriter maintains an internal buffer of 8192 characters.|||During the write operation, the characters are written to the internal buffer instead of the disk. Once the buffer is filled or the writer is closed, the whole characters in the buffer are written to the disk.|||Hence, the number of communication to the disk is reduced. This is why writing characters is faster using BufferedWriter.|||In order to create a BufferedWriter, we must import the java.io.BufferedWriter package first. Once we import the package here is how we can create the buffered writer.|||In the above example, we have created a BufferedWriter named buffer with the FileWriter named file.|||Here, the internal buffer of the BufferedWriter has the default size of 8192 characters. However, we can specify the size of the internal buffer as well.|||The buffer will help to write characters to the files more efficiently.|||The BufferedWriter class provides implementations for different methods present in Writer.||||||In the above example, we have created a buffered writer named output along with FileWriter. The buffered writer is linked with the output.txt file.|||To write data to the file, we have used the write() method.|||Here when we run the program, the output.txt file is filled with the following content.|||To clear the internal buffer, we can use the flush() method. This method forces the writer to write all data present in the buffer to the destination file.|||For example, suppose we have an empty file named output.txt.|||Output|||When we run the program, the file output.txt is filled with the text represented by the string data.|||To close the buffered writer, we can use the close() method. Once the close() method is called, we cannot use the writer to write the data.|||To learn more, visit Java BufferedWriter (official Java documentation).",write() - writes a single character to the internal buffer of the writer$$$write(char[] array) - writes the characters from the specified array to the writer$$$write(String data) - writes the specified string to the writer$$$Introduction$$$Working of BufferedWriter$$$Create a BufferedWriter$$$write() Method$$$flush() Method$$$Other Methods of BufferedWriter,,Method|||Description$$$newLine() |||inserts a new line to the writer$$$append() |||inserts the specified character to the current writer
https://www.programiz.com/java-programming/stringreader,Java StringReader (With Examples),Create a StringReader$$$Methods of StringReader$$$Other Methods of StringReader$$$read() Method$$$Example: Java StringReader$$$skip() Method$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java StringReader and its methods with the help of examples.|||The StringReader class of the java.io package can be used to read data (in characters) from strings.|||It extends the abstract class Reader.||||||Note: In StringReader, the specified string acts as a source from where characters are read individually.|||In order to create a StringReader, we must import the java.io.StringReader package first. Once we import the package here is how we can create the string reader.|||Here, we have created a StringReader that reads characters from the specified string named data.|||The StringReader class provides implementations for different methods present in the Reader class.|||Output|||In the above example, we have created a string reader named input. The string reader is linked to the string data.||||||To read data from the string, we have used the read() method.|||Here, the method reads an array of characters from the reader and stores in the specified array.|||To discard and skip the specified number of characters, we can use the skip() method. For example,|||Output|||In the above example, we have used the skip() method to skip 5 characters from the string reader. Hence, the characters 'T', 'h', 'i', 's' and ' ' are skipped from the original string reader.|||To close the string reader, we can use the close() method. Once the close() method is called, we cannot use the reader to read data from the string.|||To learn more, visit Java StringReader (official Java documentation).","read() - reads a single character from the string reader$$$read(char[] array) - reads the characters from the reader and stores in the specified array$$$read(char[] array, int start, int length) - reads the number of characters equal to length from the reader and stores in the specified array starting from the position start$$$Introduction$$$Create a StringReader$$$read() Method$$$skip() Method$$$Other Methods of StringReader",,Method|||Description$$$ready() |||checks if the string reader is ready to be read$$$mark() |||marks the position in reader up to which data has been read$$$reset() |||returns the control to the point in the reader where the mark was set
https://www.programiz.com/java-programming/stringwriter,Java StringWriter (With Examples),Create a StringWriter$$$Methods of StringWriter$$$Other methods of StringWriter$$$write() Method$$$Example: Java StringWriter$$$Access Data from StringBuffer$$$close() Method$$$Table of Contents,,"In this tutorial, we will learn about Java StringWriter and its subclasses with the help of examples.|||The StringWriter class of the java.io package can be used to write data (in characters) to the string buffer.|||It extends the abstract class Writer.||||||Note: In Java, string buffer is considered as a mutable string. That is, we can modify the string buffer. To convert from string buffer to string, we can use the toString() method.|||In order to create a StringWriter, we must import the java.io.StringWriter package first. Once we import the package here is how we can create the string writer.|||Here, we have created the string writer with default string buffer capacity. However, we can specify the string buffer capacity as well.|||Here, the size specifies the capacity of the string buffer.|||The StringWriter class provides implementations for different methods present in the Writer class.|||Output|||In the above example, we have created a string writer named output.||||||We then use the write() method to write the string data to the string buffer.|||Note: We have used the toString() method to get the output data from string buffer in string form.|||For example,|||Output|||Here we have used the getBuffer() method to get the data present in the string buffer. And also the method toString() returns the data present in the string buffer as a string.|||To close the string writer, we can use the close() method.|||However, the close() method has no effect in the StringWriter class. We can use the methods of this class even after the close() method is called.|||To learn more, visit Java StringWriter (official Java documentation).",write() - writes a single character to the string writer$$$write(char[] array) - writes the characters from the specified array to the writer$$$write(String data) - writes the specified string to the writer$$$getBuffer() - returns the data present in the string buffer$$$toString() - returns the data present in the string buffer as a string$$$Introduction$$$Create a StringWriter$$$write() Method$$$Access Data from StringBuffer$$$Other methods of StringWriter,,Method|||Description$$$flush()|||forces to write all the data present in the writer to the string buffer$$$append()|||inserts the specified character to the current writer
https://www.programiz.com/java-programming/printwriter,Java PrintWriter (With Examples),Working of PrintWriter$$$Create a PrintWriter$$$Methods of PrintWriter$$$Other Methods Of PrintWriter$$$print() Method$$$printf() Method$$$Example: printf() Method using PrintWriter$$$Table of Contents,,"In this tutorial, we will learn about Java PrintWriter and its print() and printf() methods with the help of examples.|||The PrintWriter class of the java.io package can be used to write output data in a commonly readable form (text).|||It extends the abstract class Writer.||||||Unlike other writers, PrintWriter converts the primitive data (int, float, char, etc.) into the text format. It then writes that formatted data to the writer.|||Also, the PrintWriter class does not throw any input/output exception. Instead, we need to use the checkError() method to find any error in it.|||Note: The PrintWriter class also has a feature of auto flushing. This means it forces the writer to write all data to the destination if one of the println() or printf() methods is called.|||In order to create a print writer, we must import the java.io.PrintWriter package first. Once we import the package here is how we can create the print writer.|||1. Using other writers|||Here,|||2. Using other output streams|||Here,|||3. Using filename |||Here,|||Note: In all the above cases, the PrintWriter writes data to the file using some default character encoding. However, we can specify the character encoding (UTF8 or UTF16) as well.|||Here, we have used the Charset class to specify the character encoding. To know more, visit Java Charset (official Java documentation).|||The PrintWriter class provides various methods that allow us to print data to the output.||||||For example,|||In the above example, we have created a print writer named output. This print writer is linked with the file output.txt.|||To print data to the file, we have used the print() method.|||Here when we run the program, the output.txt file is filled with the following content.|||The printf() method can be used to print the formatted string. It includes 2 parameters: formatted string and arguments. For example,|||Here,|||The formatted string includes both text and data. And, the arguments replace the data inside the formatted string.|||Hence the %d is replaced by 25.|||In the above example, we have created a print writer named output. The print writer is linked with the file output.txt.|||To print the formatted text to the file, we have used the printf() method.|||Here when we run the program, the output.txt file is filled with the following content.|||To learn more, visit Java PrintWriter (official Java documentation).",we have created a print writer that will write data to the file represented by the FileWriter$$$autoFlush is an optional parameter that specifies whether to perform auto flushing or not$$$we have created a print writer that will write data to the file represented by the FileOutputStream$$$the autoFlush is an optional parameter that specifies whether to perform auto flushing or not$$$we have created a print writer that will write data to the specified file$$$the autoFlush is an optional boolean parameter that specifies whether to perform auto flushing or nor$$$print() - prints the specified data to the writer$$$println() - prints the data to the writer along with a new line character at the end$$$I am %d years old is a formatted string$$$%d is integer data in the formatted string$$$25 is an argument$$$Introduction$$$Working of PrintWriter$$$Create a PrintWriter$$$print() Method$$$printf() Method$$$Other Methods Of PrintWriter,,Method|||Description$$$close()|||closes the print writer$$$checkError()|||checks if there is an error in the writer and returns a boolean result$$$append()|||appends the specified data to the writer
https://www.programiz.com/java-programming/scanner,Java Scanner (With Examples),Example 1: Read a Line of Text Using Scanner$$$Import Scanner Class$$$Create a Scanner Object in Java$$$Java Scanner Methods to Take Input$$$Java Scanner with BigInteger and BigDecimal$$$Working of Java Scanner$$$Example 2: Java Scanner nextInt()$$$Example 3: Java Scanner nextDouble()$$$Example 4: Java Scanner next()$$$Example 5: Java Scanner nextLine()$$$Example 4: Read BigInteger and BigDecimal$$$Table of Contents,,"In this tutorial, we will learn about the Java Scanner and its methods with the help of examples.|||The Scanner class of the java.util package is used to read input data from different sources like input streams, users, files, etc. Let's take an example.|||Output|||In the above example, notice the line|||Here, we have created an object of Scanner named input.|||The System.in parameter is used to take input from the standard input. It works just like taking inputs from the keyboard.|||We have then used the nextLine() method of the Scanner class to read a line of text from the user.|||Now that you have some idea about Scanner, let's explore more about it.|||As we can see from the above example, we need to import the java.util.Scanner package before we can use the Scanner class.|||To learn more about importing packages, visit Java Packages.|||Once we import the package, here is how we can create Scanner objects.|||Here, we have created objects of the Scanner class that will read input from InputStream, File, and String respectively.|||The Scanner class provides various methods that allow us to read inputs of different types.|||Output|||In the above example, we have used the nextInt() method to read an integer value.|||Output|||In the above example, we have used the nextDouble() method to read a floating-point value.||||||Output|||In the above example, we have used the next() method to read a string from the user.|||Here, we have provided the full name. However, the next() method only reads the first name.|||This is because the next() method reads input up to the whitespace character. Once the whitespace is encountered, it returns the string (excluding the whitespace).|||Output|||In the first example, we have used the nextLine() method to read a string from the user.|||Unlike next(), the nextLine() method reads the entire line of input including spaces. The method is terminated when it encounters a next line character, \n.|||Recommended Reading: Java Scanner skipping the nextLine().|||Java scanner can also be used to read the big integer and big decimal numbers.|||Output|||In the above example, we have used the java.math.BigInteger and java.math.BigDecimal package to read BigInteger and BigDecimal respectively.|||The Scanner class reads an entire line and divides the line into tokens. Tokens are small elements that have some meaning to the Java compiler. For example,|||Suppose there is an input string:|||In this case, the scanner object will read the entire line and divides the string into tokens: ""He"", ""is"" and ""22"". The object then iterates over each token and reads each token using its different methods.|||Note: By default, whitespace is used to divide tokens.",nextBigInteger() - reads the big integer value from the user$$$nextBigDecimal() - reads the big decimal value from the user$$$Introduction$$$Example Java Scanner$$$Import Scanner Class$$$Create Objects of Scanner$$$Scanner nextInt() Method$$$nextDouble() Method$$$Scanner next() Method$$$nextLine() Method$$$Scanner with BigInteger and BigDecimal$$$Working of Java Scanner,,Method|||Description$$$nextInt()|||reads an int value from the user$$$nextFloat()|||reads a float value form the user$$$nextBoolean()|||reads a boolean value from the user$$$nextLine()|||reads a line of text from the user$$$next()|||reads a word from the user$$$nextByte()|||reads a byte value from the user$$$nextDouble()|||reads a double value from the user$$$nextShort()|||reads a short value from the user$$$nextLong()|||reads a long value from the user
https://www.programiz.com/java-programming/typecasting,Java Type Casting (With Examples),Type Casting$$$Widening Type Casting$$$Narrowing Type Casting$$$Example 1: Type conversion from int to String$$$Example 2: Type conversion from String to int$$$Example: Converting int to double$$$Example: Converting double into an int$$$Table of Contents,,"In this tutorial, we will learn about the Java Type Casting and its types with the help of examples.|||Before you learn about Java Type Casting, make sure you know about Java Data Types.|||The process of converting the value of one data type (int, float, double, etc.) to another data type is known as typecasting.|||In Java, there are 13 types of type conversion. However, in this tutorial, we will only focus on the major 2 types.|||1. Widening Type Casting|||2. Narrowing Type Casting|||To learn about other types of type conversion, visit Java Type Conversion (official Java documentation).|||In Widening Type Casting, Java automatically converts one data type to another data type.|||Output|||In the above example, we are assigning the int type variable named num to a double type variable named data.|||Here, the Java first converts the int type data into the double type. And then assign it to the double variable.|||In the case of Widening Type Casting, the lower data type (having smaller size) is converted into the higher data type (having larger size). Hence there is no loss in data. This is why this type of conversion happens automatically.|||Note: This is also known as Implicit Type Casting.|||In Narrowing Type Casting, we manually convert one data type into another using the parenthesis.|||Output||||||In the above example, we are assigning the double type variable named num to an int type variable named data.|||Notice the line,|||Here, the int keyword inside the parenthesis indicates that that the num variable is converted into the int type.|||In the case of Narrowing Type Casting, the higher data types (having larger size) are converted into lower data types (having smaller size). Hence there is the loss of data. This is why this type of conversion does not happen automatically.|||Note: This is also known as Explicit Type Casting.|||Let's see some of the examples of other type conversions in Java.|||Output|||In the above program, notice the line|||Here, we have used the valueOf() method of the Java String class to convert the int type variable into a string.|||Output|||In the above example, notice the line|||Here, we have used the parseInt() method of the Java Integer class to convert a string type variable into an int variable.|||Note: If the string variable cannot be converted into the integer variable then an exception named NumberFormatException occurs.",Introduction$$$Widening Type Casting$$$Narrowing Type Casting$$$Example: Conversion from int to String$$$Example: Conversion from String to int,,
https://www.programiz.com/java-programming/autoboxing-unboxing,Java autoboxing and unboxing,Java Autoboxing - Primitive Type to Wrapper Object$$$Java Unboxing - Wrapper Objects to Primitive Types$$$Example 1: Java Autoboxing$$$Example 2: Java Unboxing$$$Table of Contents,,"In this tutorial, we will learn about Java autoboxing and unboxing with the help of examples.|||In autoboxing, the Java compiler automatically converts primitive types into their corresponding wrapper class objects. For example,|||Autoboxing has a great advantage while working with Java collections.|||Output|||In the above example, we have created an array list of Integer type. Hence the array list can only hold objects of Integer type.|||Notice the line,|||Here, we are passing primitive type value. However, due to autoboxing, the primitive value is automatically converted into an Integer object and stored in the array list.||||||In unboxing, the Java compiler automatically converts wrapper class objects into their corresponding primitive types. For example,|||Like autoboxing, unboxing can also be used with Java collections.|||Output|||In the above example, notice the line,|||Here, the get() method returns the object at index 0. However, due to unboxing, the object is automatically converted into the primitive type int and assigned to the variable a.",Java Autoboxing$$$Example 1: Autoboxing$$$Java Unboxing$$$Example 2: Unboxing,,
https://www.programiz.com/java-programming/lambda-expression,Java Lambda Expressions (With Examples),What is Functional Interface?$$$Introduction to lambda expressions$$$Example 3: Lambda Expression$$$Lambda Expressions with parameters$$$Generic Functional Interface$$$Lambda Expression and Stream API$$$Example 1: Define a Functional Interface in java$$$Example 2: Implement SAM with anonymous classes in java$$$How to define lambda expression in Java?$$$Types of Lambda Body$$$Example 4: Using lambda expression with parameters$$$Example 5: Generic Functional Interface and Lambda Expressions$$$Example 6: Demonstration of using lambdas with the Stream API$$$Table of Contents,,"In this article, we will learn about Java lambda expression and the use of lambda expression with functional interfaces, generic functional interface, and stream API with the help of examples.|||The lambda expression was introduced first time in Java 8. Its main objective to increase the expressive power of the language.|||But, before getting into lambdas, we first need to understand functional interfaces.|||If a Java interface contains one and only one abstract method then it is termed as functional interface. This only one method specifies the intended purpose of the interface.|||For example, the Runnable interface from package java.lang; is a functional interface because it constitutes only one method i.e. run().|||In the above example, the interface MyInterface has only one abstract method getValue(). Hence, it is a functional interface.|||Here, we have used the annotation @FunctionalInterface. The annotation forces the Java compiler to indicate that the interface is a functional interface. Hence, does not allow to have more than one abstract method. However, it is not compulsory though.|||In Java 7, functional interfaces were considered as Single Abstract Methods or SAM type. SAMs were commonly implemented with Anonymous Classes in Java 7.|||Output:|||Here, we can pass an anonymous class to a method. This helps to write programs with fewer codes in Java 7. However, the syntax was still difficult and a lot of extra lines of code were required.|||Java 8 extended the power of a SAMs by going a step further. Since we know that a functional interface has just one method, there should be no need to define the name of that method when passing it as an argument. Lambda expression allows us to do exactly that.|||Lambda expression is, essentially, an anonymous or unnamed method. The lambda expression does not execute on its own. Instead, it is used to implement a method defined by a functional interface.|||Here is how we can define lambda expression in Java.|||The new operator (->) used is known as an arrow operator or a lambda operator. The syntax might not be clear at the moment. Let's explore some examples,|||Suppose, we have a method like this:|||We can write this method using lambda expression as:|||Here, the method does not have any parameters. Hence, the left side of the operator includes an empty parameter. The right side is the lambda body that specifies the action of the lambda expression. In this case, it returns the value 3.1415.|||In Java, the lambda body is of two types.|||1. A body with a single expression|||This type of lambda body is known as the expression body.|||2. A body that consists of a block of code.|||This type of the lambda body is known as a block body. The block body allows the lambda body to include multiple statements. These statements are enclosed inside the braces and you have to add a semi-colon after the braces.|||Note: For the block body, you can have a return statement if the body returns a value. However, the expression body does not require a return statement.||||||Let's write a Java program that returns the value of Pi using the lambda expression.|||As mentioned earlier, a lambda expression is not executed on its own. Rather, it forms the implementation of the abstract method defined by the functional interface.|||So, we need to define a functional interface first.|||Output:|||In the above example,|||Till now we have created lambda expressions without any parameters. However, similar to methods, lambda expressions can also have parameters. For example,|||Here, the variable n inside the parenthesis is a parameter passed to the lambda expression. The lambda body takes the parameter and checks if it is even or odd.|||Output:|||Till now we have used the functional interface that accepts only one type of value. For example,|||The above functional interface only accepts String and returns String. However, we can make the functional interface generic, so that any data type is accepted. If you are not sure about generics, visit Java Generics.|||Output:|||In the above example, we have created a generic functional interface named GenericInterface. It contains a generic method named func().|||Here, inside the Main class,|||The new java.util.stream package has been added to JDK8 which allows java developers to perform operations like search, filter, map, reduce, or manipulate collections like Lists.|||For example, we have a stream of data (in our case a List of String) where each string is a combination of country name and place of the country. Now, we can process this stream of data and retrieve only the places from Nepal.|||For this, we can perform bulk operations in the stream by the combination of Stream API and Lambda expression.|||Output:|||In the above example, notice the statement,|||Here, we are using the methods like filter(), map() and forEach() of the Stream API. These methods can take a lambda expression as input.|||We can also define our own expressions based on the syntax we learned above. This allows us to reduce the lines of code drastically as we saw in the above example.","We have created a functional interface named MyInterface. It contains a single abstract method named getPiValue()$$$Inside the Main class, we have declared a reference to MyInterface. Note that we can declare a reference of an interface but we cannot instantiate an interface. That is, // it will throw an errorMyInterface ref = new myInterface();// it is validMyInterface ref;$$$We then assigned a lambda expression to the reference.ref = () -> 3.1415;$$$Finally, we call the method getPiValue() using the reference interface. When System.out.println(""Value of Pi = "" + ref.getPiValue());$$$GenericInterface<String> reverse - creates a reference to the interface. The interface now operates on String type of data.$$$GenericInterface<Integer> factorial - creates a reference to the interface. The interface, in this case, operates on the Integer type of data.$$$What is Functional Interface?$$$Introduction to lambda expression$$$Types of Lambda Body$$$Example 3: Lambda Expression$$$Lambda Expressions with parameters$$$Generic Functional Interface$$$Lambda Expression and Stream API",,
https://www.programiz.com/java-programming/generics,Java Generics (With Examples),Java Generics Class$$$Java Generics Method$$$Bounded Types$$$Advantages of Java Generics$$$Example: Create a Generics Class$$$Example: Create a Generics Method$$$Example: Bounded Types$$$1. Code Reusability$$$2. Compile-time Type Checking$$$3. Used with Collections$$$Table of Contents,,"In this tutorial, we will learn about Java Generics, how to create generics class and methods and its advantages with the help of examples.|||The Java Generics allows us to create a single class, interface, and method that can be used with different types of data (objects).|||This helps us to reuse our code.|||Note: Generics does not work with primitive types (int, float, char, etc).|||We can create a class that can be used with any type of data. Such a class is known as Generics Class.|||Here's is how we can create a generics class in Java:|||Output|||In the above example, we have created a generic class named GenericsClass. This class can be used to work with any type of data.|||Here, T used inside the angle bracket <> indicates the type parameter. Inside the Main class, we have created two objects of GenericsClass|||Similar to the generics class, we can also create a method that can be used with any type of data. Such a class is known as Generics Method.|||Here's is how we can create a generics class in Java:|||Output|||In the above example, we have created a generic method named genericsMethod.|||Here, the type parameter <T> is inserted after the modifier public and before the return type void.|||We can call the generics method by placing the actual type <String> and <Integer> inside the bracket before the method name.|||Note: We can call the generics method without including the type parameter. For example,|||In this case, the compiler can match the type parameter based on the value passed to the method.|||In general, the type parameter can accept any data types (except primitive types).||||||However, if we want to use generics for some specific types (such as accept data of number types) only, then we can use bounded types.|||In the case of bound types, we use the extends keyword. For example,|||This means T can only accept data that are subtypes of A.|||In the above example, we have created a class named GenericsClass. Notice the expression, notice the expression|||Here, GenericsClass is created with bounded type. This means GenericsClass can only work with data types that are children of Number (Integer, Double, and so on).|||However, we have created an object of the generics class with String. In this case, we will get the following error.|||With the help of generics in Java, we can write code that will work with different types of data. For example,|||Here, we have created a generics method. This same method can be used to perform operations on integer data, string data, and so on.|||The type parameter of generics provides information about the type of data used in the generics code. For example,|||Here, we know that GenericsClass is working with Integer data only.|||Now, if we try to pass data other than Integer to this class, the program will generate an error at compile time.|||The collections framework uses the concept of generics in Java. For example,|||In the above example, we have used the same ArrayList class to work with different types of data.|||Similar to ArrayList, other collections (LinkedList, Queue, Maps, and so on) are also generic in Java.","intObj - Here, the type parameter T is replaced by Integer. Now, the GenericsClass works with integer data.$$$stringObj - Here, the type parameter T is replaced by String. Now, the GenericsClass works with string data.$$$Introduction$$$Java Generics Class$$$Java Generics Method$$$Bounded Types$$$Advantages",,
https://www.programiz.com/java-programming/file,Java File (With Examples),File and Directory$$$Create a Java File Object$$$Java File Operation Methods$$$Java create files$$$Example: Create a new File$$$Java read files$$$Example: Read a file using FileReader$$$Java write to files$$$Example: Write to file using FileWriter$$$Java delete files$$$Example: Delete a file$$$Table of Contents,,"In this tutorial, we will learn about Java File and its various operations with the help of examples.|||The File class of the java.io package is used to perform various operations on files and directories.|||There is another package named java.nio that can be used to work with files. However, in this tutorial, we will focus on the java.io package.|||A file is a named location that can be used to store related information. For example,|||main.java is a Java file that contains information about the Java program.|||A directory is a collection of files and subdirectories. A directory inside a directory is known as subdirectory.|||To create an object of File, we need to import the java.io.File package first. Once we import the package, here is how we can create objects of file.|||Here, we have created a file object named file. The object can be used to work with files and directories.|||Note: In Java, creating a file object does not mean creating a file. Instead, a file object is an abstract representation of the file or directory pathname (specified in the parenthesis).|||To create a new file, we can use the createNewFile() method. It returns|||In the above example, we have created a file object named file. The file object is linked with the specified file path.|||Here, we have used the file object to create the new file with the specified path.If newFile.txt doesn't exist in the current location, the file is created and this message is shown.|||However, if newFile.txt already exists, we will see this message.|||To read data from the file, we can use subclasses of either InputStream or Reader.|||Suppose we have a file named input.txt with the following content.|||Now let's try to read the file using Java FileReader.||||||Output|||In the above example, we have used created an object of FileReader named input. It is now linked with the input.txt file.|||To read the data from the input.txt file, we have used the read() method of FileReader.|||To write data to the file, we can use subclasses of either OutputStream or Writer.|||Output |||In the above example, we have created a writer using the FileWriter class. The writer is linked with the output.txt file.|||To write data to the file, we have used the write() method.|||Here when we run the program, the output.txt file is filled with the following content.|||We can use the delete() method of the File class to delete the specified file or directory. It returns|||Note: We can only delete empty directories.|||Output|||In the above example, we have created an object of File named file. The file now holds the information about the specified file.|||Here we have used the delete() method to delete the file specified by the object.|||Related Examples ",true if a new file is created.$$$false if the file already exists in the specified location.$$$true if the file is deleted.$$$false if the file does not exist.$$$Java create directory$$$Java rename file$$$Java list files in a directory$$$Java copy files$$$Introduction$$$File and Directory$$$Create a Java File Object$$$Java File Operation Methods$$$Java create files$$$Java read files$$$Java write to files$$$Java delete files$$$Related Examples,,Operation|||Method|||Package$$$To create file|||createNewFile()|||java.io.File$$$To read file|||read()|||java.io.FileReader$$$To write file|||write()|||java.io.FileWriter$$$To delete file|||delete()|||java.io.File
https://www.programiz.com/java-programming/wrapper,Java Wrapper Class (With Examples),Convert Primitive Type to Wrapper Objects$$$Wrapper Objects into Primitive Types$$$Advantages of Wrapper Classes$$$Example 1: Primitive Types to Wrapper Objects$$$Example 2: Wrapper Objects into Primitive Types$$$Table of Contents,,"In this tutorial, we will learn about the Java Wrapper class with the help of examples.|||The wrapper classes in Java are used to convert primitive types (int, char, float, etc) into corresponding objects.|||Each of the 8 primitive types has corresponding wrapper classes.|||We can also use the valueOf() method to convert primitive types into corresponding objects.|||Output|||In the above example, we have used the valueOf() method to convert the primitive types into objects.|||Here, we have used the instanceof operator to check whether the generated objects are of Integer or Double type or not.|||However, the Java compiler can directly convert the primitive types into corresponding objects. For example,||||||This process is known as auto-boxing. To learn more, visit Java autoboxing and unboxing.|||Note: We can also convert primitive types into wrapper objects using Wrapper class constructors. But the use of constructors is discarded after Java 9.|||To convert objects into the primitive types, we can use the corresponding value methods (intValue(), doubleValue(), etc) present in each wrapper class.|||Output|||In the above example, we have used the intValue() and doubleValue() method to convert the Integer and Double objects into corresponding primitive types.|||However, the Java compiler can automatically convert objects into corresponding primitive types. For example,|||This process is known as unboxing. To learn more, visit Java autoboxing and unboxing.|||Note: Primitive types are more efficient than corresponding objects. Hence, when efficiency is the requirement, it is always recommended primitive types.","In Java, sometimes we might need to use objects instead of primitive data types. For example, while working with collections.// errorArrayList<int> list = new ArrayList<>();// runs perfectlyArrayList<Integer> list = new ArrayList<>();In such cases, wrapper classes help us to use primitive data types as objects.$$$We can store the null value in wrapper objects. For example,// generates an errorint a = null;// runs perfectlyInteger a = null;$$$Introduction$$$Java Primitive types to objects$$$Java objects into Primitive types$$$Advantages of Wrapper Classes",,Primitive Type|||Wrapper Class$$$byte|||Byte$$$boolean|||Boolean$$$char|||Character$$$double|||Double$$$float|||Float$$$int|||Integer$$$long|||Long$$$short|||Short
https://www.programiz.com/java-programming/command-line-arguments,Java Command-Line Arguments,Passing Numeric Command-Line Arguments$$$Example: Command-Line Arguments$$$Example: Numeric Command-Line Arguments$$$Table of Contents,,"In this tutorial, we will learn about the Java command-line arguments with the help of examples.|||The command-line arguments in Java allow us to pass arguments during the execution of the program.|||As the name suggests arguments are passed through the command line.|||Let's try to run this program using the command line.|||1. To compile the code |||2. To run the code |||Now suppose we want to pass some arguments while running the program, we can pass the arguments after the class name. For example,|||Here apple, ball, and cat are arguments passed to the program through the command line. Now, we will get the following output.|||In the above program, the main() method includes an array of strings named args as its parameter.|||The String array stores all the arguments passed through the command line.|||Note: Arguments are always stored as strings and always separated by white-space.||||||The main() method of every Java program only accepts string arguments. Hence it is not possible to pass numeric arguments through the command line.|||However, we can later convert string arguments into numeric values.|||Let's try to run the program through the command line.|||Here 11 and 23 are command-line arguments. Now, we will get the following output.|||In the above example, notice the line|||Here, the parseInt() method of the Integer class converts the string argument into an integer.|||Similarly, we can use the parseDouble() and parseFloat() method to convert the string into double and float respectively.|||Note: If the arguments cannot be converted into the specified numeric value then an exception named NumberFormatException occurs.",Introduction$$$Example: Command-Line Arguments$$$Passing Numeric Arguments$$$Example: Numeric Arguments,,
https://www.programiz.com/Java-programming/guide,Java Programming,Features of Java Programming$$$Applications of Java Programming$$$How you can learn to code in Java?$$$Java Programming Best Practices$$$Final Words$$$Java is platform-independent$$$An object-oriented Language$$$Java is fast$$$Java is secure$$$Large Standard Library$$$1. Android apps$$$2. Web apps$$$3. Big Data Processing$$$4. Embedded Devices$$$Learn Java from Programiz$$$Learn from Official Java Documentation$$$Table of Contents,,"Java is a powerful general-purpose programming language. It is one of the most popular programming languages used to develop desktop and mobile applications, big data processing, embedded systems and so on.|||To get started with Java programming, visit Java Tutorials.|||Java was built with the philosophy of ""write once, run anywhere"" (WORA). The Java code you write on one platform (operating system) will run on other platforms with no modification.|||The object-oriented approach is one of the popular programming styles. In object-oriented programming, a complex problem is divided into smaller sets by creating objects. This makes Java code reusable, has design benefits and makes code easier to maintain.|||The earlier version of Java was criticized for being slow. However, the new version of Java is one of the fastest programming languages.|||A well-optimized Java code is nearly as fast as lower-level languages like C/C++ and much faster than Python, PHP, etc.|||Some of the high-level features for security that Java handles are:|||One of the reasons why Java is widely used is because of the availability of a huge standard library. The Java environment has hundreds of classes and methods under different packages to help software developers like us. For example,|||According to Oracle, the company that owns Java, Java runs on 3 billion devices worldwide, which makes Java one of the most popular programming languages.|||Java programming language using Android SDK (Software Development Kit) is usually used for developing Android apps.||||||Java is used to create Web applications through Servlets, Struts or JSPs. Some of the popular web applications written in Java are Google.com, Facebook.com, eBay.com, LinkedIn.com, etc.|||You can use a popular software framework like Hadoop (which is written in Java) to process Big Data.|||Oracle's Java Embedded technologies provide a platform and runtime for billions of embedded devices like televisions, SIM cards, Blu-ray Disc players, etc.|||Besides these applications, Java is also used for game development, scientific applications (like natural language processing), and many others.|||Programiz offers a complete series of easy to follow Java tutorials along with suitable examples. These tutorials are targeted at absolute beginners with no prior knowledge of the Java programming language.|||Oracle, the company that owns Java, provides quality Java documentation. The official documentation is continuously updated. However, it may not be the easiest of tutorials to follow for beginners.|||You must be eager to learn Java by now. However, here are some tips and best practices to follow before you learn Java.|||You cannot go wrong with learning Java. Its wide range of applications makes it the language of opportunities and possibilities.","provides a secure platform for developing and running applications$$$automatic memory management reduces memory corruption and vulnerabilities$$$java.lang- for advanced features of strings, arrays, etc$$$java.util - for data structures, regular expressions, date and time functions, etc$$$java.io - for file i/o, exception handling, etc$$$Don't read Java tutorials and examples like a novel: The only way to get better in programming is by writing a lot of code.$$$Learn Java language the right way: If you are switching from another programming language (let's say C#), don't write C# style code in Java. Also, check this article on How to write good Java code?$$$Join Java communities: Once you get the hang of writing simple Java programs, join Java communities and forums. Then, try to solve other programmers' Java problems. It's a good way to expand your Java knowledge. Also, you can get help when you are stuck.$$$What is Java Programming?$$$Features$$$Applications of Java$$$How to learn Java?$$$Best Practices$$$Final Words",,
https://www.programiz.com/java-programming/examples,Java Examples | Programiz,,The best way to learn Java programming is by practicing examples. The page         contains examples on basic concepts of Java. You are advised to take the         references from these examples and try them on your own.                 All the programs on this page are tested and should work on all platforms.,,,Java Program to Print an Integer (Entered by the User)$$$Java Program to Add Two Integers$$$Java Program to Multiply two Floating Point Numbers$$$Java Program to Find ASCII Value of a character$$$Java Program to Compute Quotient and Remainder$$$Java Program to Swap Two Numbers$$$Java Program to Check Whether a Number is Even or Odd$$$Java Program to Check Whether an Alphabet is Vowel or Consonant$$$Java Program to Find the Largest Among Three Numbers$$$Java Program to Find all Roots of a Quadratic Equation$$$Java Program to Check Leap Year $$$Java Program to Check Whether a Number is Positive or Negative$$$Java Program to Check Whether a Character is Alphabet or Not$$$Java Program to Calculate the Sum of Natural Numbers$$$Java Program to Find Factorial of a Number$$$Java Program to Generate Multiplication Table$$$Java Program to Display Fibonacci Series$$$Java Program to Find GCD of two Numbers$$$Java Program to Find LCM of two Numbers$$$Java Program to Display Alphabets (A to Z) using loop$$$Java Program to Count Number of Digits in an Integer$$$Java Program to Reverse a Number$$$Java Program to Calculate the Power of a Number$$$Java Program to Check Palindrome$$$Java Program to Check Whether a Number is Prime or Not$$$Java Program to Display Prime Numbers Between Two Intervals$$$Java Program to Check Armstrong Number$$$Java Program to Display Armstrong Number Between Two Intervals$$$Java Program to Display Prime Numbers Between Intervals Using Function$$$Java Program to Display Armstrong Numbers Between Intervals Using Function$$$Java Program to Display Factors of a Number$$$Java Program to Make a Simple Calculator Using switch...case$$$Java Program to Check Whether a Number can be Expressed as Sum of Two Prime Numbers$$$Java Program to Find the Sum of Natural Numbers using Recursion$$$Java Program to Find Factorial of a Number Using Recursion$$$Java Program to Find G.C.D Using Recursion$$$Java Program to Convert Binary Number to Decimal and vice-versa$$$Java Program to Convert Octal Number to Decimal and vice-versa$$$Java Program to Convert Binary Number to Octal and vice-versa$$$Java Program to Reverse a Sentence Using Recursion$$$Java Program to calculate the power using recursion$$$Java Program to Calculate Average Using Arrays$$$Java Program to Find Largest Element of an Array$$$Java Program to Calculate Standard Deviation$$$Java Program to Add Two Matrix Using Multi-dimensional Arrays$$$Java Program to Multiply to Matrix Using Multi-dimensional Arrays$$$Java Program to Multiply two Matrices by Passing Matrix to a Function$$$Java Program to Find Transpose of a Matrix$$$Java Program to Find the Frequency of Character in a String$$$Java Program to Count the Number of Vowels and Consonants in a Sentence$$$Java Program to Sort Elements in Lexicographical Order (Dictionary Order)$$$Java Program to Add Two Complex Numbers by Passing Class to a Function$$$Java Program to Calculate Difference Between Two Time Periods$$$Java Code To Create Pyramid and Pattern$$$Java Program to Remove All Whitespaces from a String$$$Java Program to Print an Array$$$Java Program to Convert String to Date$$$Java Program to Round a Number to n Decimal Places$$$Java Program to Concatenate Two Arrays$$$Java Program to Convert Character to String and Vice-Versa$$$Java Program to Check if An Array Contains a Given Value$$$Java Program to Check if a String is Empty or Null$$$Java Program to Get Current Date/TIme$$$Java Program to Convert Milliseconds to Minutes and Seconds$$$Java Program to Add Two Dates$$$Java Program to Join Two Lists$$$Java Program to Convert a List to Array and Vice Versa$$$Java Program to Get Current Working Directory$$$Java Program to Convert Map (HashMap) to List$$$Java Program to Convert Array to Set (HashSet) and Vice-Versa$$$Java Program to Convert Byte Array to Hexadecimal$$$Java Program to Create String from Contents of a File$$$Java Program to Append Text to an Existing File$$$Java Program to Convert a Stack Trace to a String$$$Java Program to Convert File to byte array and Vice-Versa$$$Java Program to Convert InputStream to String$$$Java Program to Convert OutputStream to String$$$Java Program to Lookup enum by String value$$$Java Program to Compare Strings$$$Java Program to Sort a Map By Values$$$Java Program to Sort ArrayList of Custom Objects By Property$$$Java Program to Check if a String is Numeric$$$Java Program to Create Directories$$$Java Program to Rename File$$$Java Program to Get all Files Present in a Directory$$$Java Program to Copy File$$$Java Program to convert char type variables to int$$$Java Program to convert int type variables to char$$$Java Program to convert long type variables into int$$$Java Program to convert int type variables to long$$$Java Program to convert boolean variables into string$$$Java Program to convert string type variables into boolean$$$Java Program to convert string type variables into int$$$Java Program to convert int type variables to String$$$Java Program to convert int type variables to double$$$Java Program to convert double type variables to int$$$Java Program to convert string variables to double$$$Java Program to convert double type variables to string$$$Java Program to convert primitive types to objects and vice versa$$$Java Program to Implement Bubble Sort algorithm$$$Java Program to Implement Quick Sort Algorithm$$$Java Program to Implement Merge Sort Algorithm$$$Java Program to Implement Binary Search Algorithm$$$Java Program to Call One Constructor from another$$$Java Program to implement private constructors$$$Java Program to pass lambda expression as a method argument$$$Java Program to pass method call as arguments to another method$$$Java Program to Calculate the Execution Time of Methods$$$Java Program to Convert a String into the InputStream$$$Java Program to Convert the InputStream into Byte Array$$$Java Program to Load File as InputStream$$$Java Program to Create File and Write to the File$$$Java Program to Read the Content of a File Line by Line$$$Java Program to Delete File in Java$$$Java Program to Delete Empty and Non-empty Directory$$$Java Program to Get the File Extension$$$Java Program to Get the name of the file from the absolute path$$$Java Program to Get the relative path from two absolute paths$$$Java Program to Count number of lines present in the file$$$Java Program to Determine the class of an object$$$Java Program to Create an enum class$$$Java Program to Print object of a class$$$Java Program to Create custom exception$$$Java Program to Create an Immutable Class$$$Java Program to Check if two strings are anagram$$$Java Program to Compute all the permutations of the string$$$Java Program to Create random strings$$$Java Program to Clear the StringBuffer$$$Java Program to Capitalize the first character of each word in a String$$$Java Program to Iterate through each characters of the string.$$$Java Program to Differentiate String == operator and equals() method$$$Java Program to Implement switch statement on strings$$$Java Program to Calculate simple interest and compound interest$$$Java Program to Implement multiple inheritance$$$Java Program to Determine the name and version of the operating system$$$Java Program to Check if two of three boolean variables are true$$$Java Program to Iterate over enum$$$Java Program to Check the birthday and print Happy Birthday message$$$Java Program to Implement LinkedList$$$Java Program to Implement stack data structure$$$Java Program to Implement the queue data structure$$$Java Program to Get the middle element of LinkedList in a single iteration$$$Java Program to Convert the LinkedList into an Array and vice versa$$$Java Program to Convert the ArrayList into a string and vice versa$$$Java Program to Iterate over an ArrayList$$$Java Program to Iterate over a HashMap$$$Java Program to Iterate over a Set$$$Java Program to Merge two lists$$$Java Program to Update value of HashMap using key$$$Java Program to Remove duplicate elements from ArrayList$$$Java Program to Get key from HashMap using the value$$$Java Program to Detect loop in a LinkedList$$$Java Program to Calculate union of two sets$$$Java Program to Calculate the intersection of two sets$$$Java Program to Calculate the difference between two sets$$$Java Program to Check if a set is the subset of another set$$$Java Program to Sort map by keys$$$Java Program to Pass ArrayList as the function argument$$$Java Program to Iterate over ArrayList using Lambda Expression$$$Java Program to Implement Binary Tree Data Structure$$$Java Program to Perform the preorder tree traversal$$$Java Program to Perform the postorder tree traversal$$$Java Program to Perform the inorder tree traversal$$$Java Program to Count number of leaf nodes in a tree$$$Java Program to Check if a string contains a substring$$$Java Program to Access private members of a class$$$Java Program to Check if a string is a valid shuffle of two distinct strings$$$Java Program to Implement the graph data structure$$$Java Program to Remove elements from the LinkedList.$$$Java Program to Add elements to a LinkedList$$$Java Program to Access elements from a LinkedList.,
https://www.programiz.com/java-programming/library,Java Library Functions | Programiz, Java String Methods$$$Java String split()$$$Java String compareTo()$$$Java String compareToIgnoreCase()$$$Java String length()$$$Java String replace()$$$Java String replaceAll()$$$Java String substring()$$$Java String equals()$$$Java String equalsIgnoreCase()$$$Java String contains()$$$Java String indexOf()$$$Java String trim()$$$Java String charAt()$$$Java String toLowerCase()$$$Java String concat()$$$Java String valueOf()$$$Java String matches()$$$Java String startsWith()$$$Java String endsWith()$$$Java String isEmpty()$$$Java String intern()$$$Java String getBytes()$$$Java String contentEquals()$$$Java String hashCode()$$$Java String join()$$$Java String replaceFirst()$$$Java String subSequence()$$$Java String toCharArray()$$$Java String format(),,,,,
