Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Scala,Scala Tutorial,Scala Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala is a modern multi-paradigm programming language designed to express common programming patterns in a concise, elegant, and type-safe way. Scala has been created by Martin Odersky and he released the first version in 2003. Scala smoothly integrates the features of object-oriented and functional languages. This tutorial explains the basics of Scala in a simple and reader-friendly way.|||This tutorial has been prepared for beginners to help them understand the basics of Scala in simple and easy steps. After completing this tutorial, you will find yourself at a moderate level of expertise in using Scala from where you can take yourself to next levels.|||Scala Programming is based on Java, so if you are aware of Java syntax, then it's pretty easy to learn Scala. Further if you do not have expertise in Java but if you know any other programming language like C, C++ or Python then it will also help in grasping Scala concepts very quickly.",,,,
Learn Scala,Scala - Overview,Scala - Overview|||Scala vs Java@@@Scala Web Frameworks@@@Useful Video Courses|||Scala is object-oriented@@@Scala is functional@@@Scala is statically typed@@@Scala runs on the JVM@@@Scala can Execute Java Code@@@Scala can do Concurrent & Synchronize processing|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala, short for Scalable Language, is a hybrid functional programming language. It was created by Martin Odersky. Scala smoothly integrates the features of object-oriented and functional languages. Scala is compiled to run on the Java Virtual Machine. Many existing companies, who depend on Java for business critical applications, are turning to Scala to boost their development productivity, applications scalability and overall reliability.|||Here we have presented a few points that makes Scala the first choice of application developers.|||Scala is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes and traits which will be explained in subsequent chapters.|||Classes are extended by subclassing and a flexible mixin-based composition mechanism as a clean replacement for multiple inheritance.|||Scala is also a functional language in the sense that every function is a value and every value is an object so ultimately every function is an object.|||Scala provides a lightweight syntax for defining anonymous functions, it supports higher-order functions, it allows functions to be nested, and supports currying. These concepts will be explained in subsequent chapters.|||Scala, unlike some of the other statically typed languages (C, Pascal, Rust, etc.), does not expect you to provide redundant type information. You don't have to specify a type in most cases, and you certainly don't have to repeat it.|||Scala is compiled into Java Byte Code which is executed by the Java Virtual Machine (JVM). This means that Scala and Java have a common runtime platform. You can easily move from Java to Scala.|||The Scala compiler compiles your Scala code into Java Byte Code, which can then be executed by the 'scala' command. The 'scala' command is similar to the java command, in that it executes your compiled Scala code.|||Scala enables you to use all the classes of the Java SDK and also your own custom Java classes, or your favorite Java open source projects.|||Scala allows you to express general programming patterns in an effective way. It reduces the number of lines and helps the programmer to code in a type-safe way. It allows you to write codes in an immutable manner, which makes it easy to apply concurrency and parallelism (Synchronize).|||Scala has a set of features that completely differ from Java. Some of these are −|||Scala is being used everywhere and importantly in enterprise web applications. You can check a few of the most popular Scala web frameworks −|||The Lift Framework|||The Play framework|||The Bowler framework",All types are objects@@@Type inference@@@Nested Functions@@@Functions are objects@@@Domain specific language (DSL) support@@@Traits@@@Closures@@@Concurrency support inspired by Erlang|||The Lift Framework@@@The Play framework@@@The Bowler framework,,,
Learn Scala,Scala - Environment Setup,Scala - Environment Setup|||Step 1: Verify Your Java Installation@@@Step 2: Set Your Java Environment@@@Step 3: Install Scala@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala can be installed on any UNIX flavored or Windows based system. Before you start installing Scala on your machine, you must have Java 1.8 or greater installed on your computer.|||Follow the steps given below to install Scala.|||First of all, you need to have Java Software Development Kit (SDK) installed on your system. To verify this, execute any of the following two commands depending on the platform you are working on.|||If the Java installation has been done properly, then it will display the current version and specification of your Java installation. A sample output is given in the following table.|||Open Command Console and type −|||\>java –version|||Java version ""1.8.0_31""|||Java (TM) SE Run Time|||Environment (build 1.8.0_31-b31)|||Java Hotspot (TM) 64-bit Server|||VM (build 25.31-b07, mixed mode)|||Open Command terminal and type −|||$java –version|||Java version ""1.8.0_31""|||Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)|||Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)|||We assume that the readers of this tutorial have Java SDK version 1.8.0_31 installed on their system.|||In case you do not have Java SDK, download its current version from http://www.oracle.com/technetwork/java/javase/downloads/index.html and install it.|||Set the environment variable JAVA_HOME to point to the base directory location where Java is installed on your machine. For example,|||Windows|||Set JAVA_HOME to C:\ProgramFiles\java\jdk1.7.0_60|||Linux|||Export JAVA_HOME=/usr/local/java-current|||Append the full path of Java compiler location to the System Path.|||Windows|||Append the String ""C:\Program Files\Java\jdk1.7.0_60\bin"" to the end of the system variable PATH.|||Linux|||Export PATH=$PATH:$JAVA_HOME/bin/|||Execute the command java -version from the command prompt as explained above.|||You can download Scala from http://www.scala-lang.org/downloads. At the time of writing this tutorial, I downloaded ‘scala-2.11.5-installer.jar’. Make sure you have admin privilege to proceed. Now, execute the following command at the command prompt −|||\>java –jar scala-2.11.5-installer.jar\>|||This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path “C:\Program Files\Scala”, you can select a suitable path as per your convenience.|||Command −|||$java –jar scala-2.9.0.1-installer.jar|||Output −|||Welcome to the installation of Scala 2.9.0.1!|||The homepage is at − http://Scala-lang.org/|||press 1 to continue, 2 to quit, 3 to redisplay|||1................................................|||[ Starting to unpack ]|||[ Processing package: Software Package Installation (1/1) ]|||[ Unpacking finished ]|||[ Console installation done ]|||During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.|||Finally, open a new command prompt and type Scala -version and press Enter. You should see the following −|||\>scala -version|||Scala code runner version 2.11.5 -- Copyright 2002-2013, LAMP/EPFL|||$scala -version|||Scala code runner version 2.9.0.1 – Copyright 2002-2013, LAMP/EPFL",,,"Platform@@@Command@@@Sample Output|||Windows@@@
Open Command Console and type −
\>java –version
@@@
Java version ""1.8.0_31""
Java (TM) SE Run Time
Environment (build 1.8.0_31-b31)
Java Hotspot (TM) 64-bit Server
VM (build 25.31-b07, mixed mode)|||Linux@@@
Open Command terminal and type −
$java –version@@@
Java version ""1.8.0_31""
Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)
Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Set JAVA_HOME to C:\ProgramFiles\java\jdk1.7.0_60
|||2@@@
Linux
Export JAVA_HOME=/usr/local/java-current
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Append the String ""C:\Program Files\Java\jdk1.7.0_60\bin"" to the end of the system variable PATH.|||2@@@
Linux
Export PATH=$PATH:$JAVA_HOME/bin/
&&&Platform@@@Command & Output@@@Description|||Windows@@@\>java –jar scala-2.11.5-installer.jar\>@@@This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path “C:\Program Files\Scala”, you can select a suitable path as per your convenience.|||Linux@@@
Command −
$java –jar scala-2.9.0.1-installer.jar
Output −
Welcome to the installation of Scala 2.9.0.1!
The homepage is at − http://Scala-lang.org/
press 1 to continue, 2 to quit, 3 to redisplay
1................................................
[ Starting to unpack ]
[ Processing package: Software Package Installation (1/1) ]
[ Unpacking finished ]
[ Console installation done ]
@@@
During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.
&&&Platform@@@Command@@@Output|||Windows@@@\>scala -version@@@Scala code runner version 2.11.5 -- Copyright 2002-2013, LAMP/EPFL|||Linux@@@$scala -version@@@Scala code runner version 2.9.0.1 – Copyright 2002-2013, LAMP/EPFL",
Learn Scala,Scala - Basic Syntax,Scala - Basic Syntax|||First Scala Program@@@Script Mode@@@Basic Syntax@@@Scala Identifiers@@@Scala Keywords@@@Comments in Scala@@@Blank Lines and Whitespace@@@Newline Characters@@@Scala Packages@@@Apply Dynamic@@@Useful Video Courses|||Interactive Mode@@@Example@@@Output@@@Alphanumeric Identifiers@@@Operator Identifiers@@@Mixed Identifiers@@@Literal Identifiers|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"If you have a good understanding on Java, then it will be very easy for you to learn Scala. The biggest syntactic difference between Scala and Java is that the ';' line end character is optional.|||When we consider a Scala program, it can be defined as a collection of objects that communicate via invoking each other’s methods. Let us now briefly look into what do class, object, methods and instance variables mean.|||Object − Objects have states and behaviors. An object is an instance of a class. Example − A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating.|||Class  − A class can be defined as a template/blueprint that describes the behaviors/states that are related to the class.|||Methods − A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.|||Fields − Each object has its unique set of instance variables, which are called fields. An object's state is created by the values assigned to these fields.|||Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.|||Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.|||We can execute a Scala program in two modes: one is interactive mode and another is script mode.|||Open the command prompt and use the following command to open Scala.|||If Scala is installed in your system, the following output will be displayed −|||Type the following text to the right of the Scala prompt and press the Enter key −|||It will produce the following result −|||Use the following instructions to write a Scala program in script mode. Open notepad and add the following code into it.|||Save the file as − HelloWorld.scala.|||Open the command prompt window and go to the directory where the program file is saved. The ‘scalac’ command is used to compile the Scala program and it will generate a few class files in the current directory. One of them will be called HelloWorld.class. This is a bytecode which will run on Java Virtual Machine (JVM) using ‘scala’ command.|||Use the following command to compile and execute your Scala program.|||The following are the basic syntaxes and coding conventions in Scala programming.|||Case Sensitivity − Scala is case-sensitive, which means identifier Hello and hello would have different meaning in Scala.|||Class Names − For all class names, the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.|||Example − class MyFirstScalaClass.|||Method Names − All method names should start with a Lower Case letter. If multiple words are used to form the name of the method, then each inner word's first letter should be in Upper Case.|||Example − def myMethodName()|||Program File Name − Name of the program file should exactly match the object name. When saving the file you should save it using the object name (Remember Scala is case-sensitive) and append ‘.scala’ to the end of the name. (If the file name and the object name do not match your program will not compile).|||Example − Assume 'HelloWorld' is the object name. Then the file should be saved as 'HelloWorld.scala'.|||def main(args: Array[String]) − Scala program processing starts from the main() method which is a mandatory part of every Scala Program.|||All Scala components require names. Names used for objects, classes, variables and methods are called identifiers. A keyword cannot be used as an identifier and identifiers are case-sensitive. Scala supports four types of identifiers.|||An alphanumeric identifier starts with a letter or an underscore, which can be followed by further letters, digits, or underscores. The '$' character is a reserved keyword in Scala and should not be used in identifiers.|||Following are legal alphanumeric identifiers −|||Following are illegal identifiers −|||An operator identifier consists of one or more operator characters. Operator characters are printable ASCII characters such as +, :, ?, ~ or #.|||Following are legal operator identifiers −|||The Scala compiler will internally ""mangle"" operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-> would be represented internally as $colon$minus$greater.|||A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier.|||Following are legal mixed identifiers −|||Here, unary_+ used as a method name defines a unary + operator and myvar_= used as method name defines an assignment operator (operator overloading).|||A literal identifier is an arbitrary string enclosed in back ticks (` . . . `).|||Following are legal literal identifiers −|||The following list shows the reserved words in Scala. These reserved words may not be used as constant or variable or any other identifier names.|||Scala supports single-line and multi-line comments very similar to Java. Multi-line comments may be nested, but are required to be properly nested. All characters available inside any comment are ignored by Scala compiler.|||A line containing only whitespace, possibly with a comment, is known as a blank line, and Scala totally ignores it. Tokens may be separated by whitespace characters and/or comments.|||Scala is a line-oriented language where statements may be terminated by semicolons (;) or newlines. A semicolon at the end of a statement is usually optional. You can type one if you want but you don't have to if the statement appears by itself on a single line. On the other hand, a semicolon is required if you write multiple statements on a single line. Below syntax is the usage of multiple statements.|||A package is a named module of code. For example, the Lift utility package is net.liftweb.util. The package declaration is the first non-comment line in the source file as follows −|||Scala packages can be imported so that they can be referenced in the current compilation scope. The following statement imports the contents of the scala.xml package −|||You can import a single class and object, for example, HashMap from the scala.collection.mutable package −|||You can import more than one class or object from a single package, for example, TreeMap and TreeSet from the scala.collection.immutable package −|||A marker trait that enables dynamic invocations. Instances x of this trait allow method invocations x.meth(args) for arbitrary method names meth and argument lists args as well as field accesses x.field for arbitrary field namesfield. This feature is introduced in Scala-2.10.|||If a call is not natively supported by x (i.e. if type checking fails), it is rewritten according to the following rules −","Object − Objects have states and behaviors. An object is an instance of a class. Example − A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating.@@@Class  − A class can be defined as a template/blueprint that describes the behaviors/states that are related to the class.@@@Methods − A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.@@@Fields − Each object has its unique set of instance variables, which are called fields. An object's state is created by the values assigned to these fields.@@@Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.@@@Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.|||Case Sensitivity − Scala is case-sensitive, which means identifier Hello and hello would have different meaning in Scala.@@@Class Names − For all class names, the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.
Example − class MyFirstScalaClass.@@@Method Names − All method names should start with a Lower Case letter. If multiple words are used to form the name of the method, then each inner word's first letter should be in Upper Case.
Example − def myMethodName()@@@Program File Name − Name of the program file should exactly match the object name. When saving the file you should save it using the object name (Remember Scala is case-sensitive) and append ‘.scala’ to the end of the name. (If the file name and the object name do not match your program will not compile).
Example − Assume 'HelloWorld' is the object name. Then the file should be saved as 'HelloWorld.scala'.@@@def main(args: Array[String]) − Scala program processing starts from the main() method which is a mandatory part of every Scala Program.",,abstract@@@case@@@catch@@@class|||def@@@do@@@else@@@extends|||false@@@final@@@finally@@@for|||forSome@@@if@@@implicit@@@import|||lazy@@@match@@@new@@@Null|||object@@@override@@@package@@@private|||protected@@@return@@@sealed@@@super|||this@@@throw@@@trait@@@Try|||true@@@type@@@val@@@Var|||while@@@with@@@yield@@@ |||-@@@:@@@=@@@=>|||<-@@@<:@@@<%@@@>:|||#@@@@@@@@@@,"object HelloWorld {   /* This is my first java program.     * This will print 'Hello World' as the output   */   def main(args: Array[String]) {      println(""Hello, world!"") // prints Hello World   }}|||+ ++ ::: <?> :>|||object HelloWorld {   /* This is my first java program.      * This will print 'Hello World' as the output    * This is an example of multi-line comments.    */   def main(args: Array[String]) {      // Prints Hello World      // This is also an example of single line comment.      println(""Hello, world!"")    }}|||val s = ""hello""; println(s)|||import scala.collection.immutable.{TreeMap, TreeSet}"
Learn Scala,Scala - Data Types,Scala - Data Types|||Scala Basic Literals@@@Escape Sequences@@@Useful Video Courses|||Integral Literals@@@Floating Point Literal@@@Boolean Literals@@@Symbol Literals@@@Character Literals@@@String Literals@@@Multi-Line Strings@@@Null Values@@@Example@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala has all the same data types as Java, with the same memory footprint and precision. Following is the table giving details about all the data types available in Scala −|||Byte|||8 bit signed value. Range from -128 to 127|||Short|||16 bit signed value. Range -32768 to 32767|||Int|||32 bit signed value. Range -2147483648 to 2147483647|||Long|||64 bit signed value. -9223372036854775808 to 9223372036854775807|||Float|||32 bit IEEE 754 single-precision float|||Double|||64 bit IEEE 754 double-precision float|||Char|||16 bit unsigned Unicode character. Range from U+0000 to U+FFFF|||String|||A sequence of Chars|||Boolean|||Either the literal true or the literal false|||Unit|||Corresponds to no value|||Null|||null or empty reference|||Nothing|||The subtype of every other type; includes no values|||Any|||The supertype of any type; any object is of type Any|||AnyRef|||The supertype of any reference type|||All the data types listed above are objects. There are no primitive types like in Java. This means that you can call methods on an Int, Long, etc.|||The rules Scala uses for literals are simple and intuitive. This section explains all basic Scala Literals.|||Integer literals are usually of type Int, or of type Long when followed by a L or l suffix. Here are some integer literals −|||Floating point literals are of type Float when followed by a floating point type suffix F or f, and are of type Double otherwise. Here are some floating point literals −|||The Boolean literals true and false are members of type Boolean.|||A symbol literal 'x is a shorthand for the expression scala.Symbol(""x""). Symbol is a case class, which is defined as follows.|||A character literal is a single character enclosed in quotes. The character is either a printable Unicode character or is described by an escape sequence. Here are some character literals −|||A string literal is a sequence of characters in double quotes. The characters are either printable Unicode character or are described by escape sequences. Here are some string literals −|||A multi-line string literal is a sequence of characters enclosed in triple quotes """""" ... """""". The sequence of characters is arbitrary, except that it may contain three or more consecutive quote characters only at the very end.|||Characters must not necessarily be printable; newlines or other control characters are also permitted. Here is a multi-line string literal −|||The null value is of type scala.Null and is thus compatible with every reference type. It denotes a reference value which refers to a special ""null"" object.|||The following escape sequences are recognized in character and string literals.|||A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e., a backslash '\' followed by a sequence of up to three octal characters. Following is the example to show few escape sequence characters −|||When the above code is compiled and executed, it produces the following result −",,,"Sr.No@@@Data Type & Description|||1@@@
Byte
8 bit signed value. Range from -128 to 127
|||2@@@
Short
16 bit signed value. Range -32768 to 32767
|||3@@@
Int
32 bit signed value. Range -2147483648 to 2147483647
|||4@@@
Long
64 bit signed value. -9223372036854775808 to 9223372036854775807
|||5@@@
Float
32 bit IEEE 754 single-precision float
|||6@@@
Double
64 bit IEEE 754 double-precision float
|||7@@@
Char
16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
|||8@@@
String
A sequence of Chars
|||9@@@
Boolean
Either the literal true or the literal false
|||10@@@
Unit
Corresponds to no value
|||11@@@
Null
null or empty reference
|||12@@@
Nothing
The subtype of every other type; includes no values
|||13@@@
Any
The supertype of any type; any object is of type Any
|||14@@@
AnyRef
The supertype of any reference type
&&&Escape Sequences@@@Unicode@@@Description|||\b@@@\u0008@@@backspace BS|||\t@@@\u0009@@@horizontal tab HT|||\n@@@\u000c@@@formfeed FF|||\f@@@\u000c@@@formfeed FF|||\r@@@\u000d@@@carriage return CR|||\""@@@\u0022@@@double quote ""|||\'@@@\u0027@@@single quote .|||\\@@@\u005c@@@backslash \","object Test {   def main(args: Array[String]) {      println(""Hello\tWorld\n\n"" );   }} "
Learn Scala,Scala - Variables,Scala - Variables|||Variable Declaration@@@Variable Data Types@@@Variable Type Inference@@@Multiple assignments@@@Example Program@@@Variable Scope@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Example@@@Command@@@Output@@@Fields@@@Method Parameters@@@Local Variables|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Variables are nothing but reserved memory locations to store values. This means that when you create a variable, you reserve some space in memory.|||Based on the data type of a variable, the compiler allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.|||Scala has a different syntax for declaring variables. They can be defined as value, i.e., constant or a variable. Here, myVar is declared using the keyword var. It is a variable that can change value and this is called mutable variable. Following is the syntax to define a variable using var keyword −|||Here, myVal is declared using the keyword val. This means that it is a variable that cannot be changed and this is called immutable variable. Following is the syntax to define a variable using val keyword −|||The type of a variable is specified after the variable name and before equals sign. You can define any type of Scala variable by mentioning its data type as follows −|||If you do not assign any initial value to a variable, then it is valid as follows −|||When you assign an initial value to a variable, the Scala compiler can figure out the type of the variable based on the value assigned to it. This is called variable type inference. Therefore, you could write these variable declarations like this −|||Here, by default, myVar will be Int type and myVal will become String type variable.|||Scala supports multiple assignments. If a code block or method returns a Tuple (Tuple − Holds collection of Objects of different types), the Tuple can be assigned to a val variable. [Note − We will study Tuples in subsequent chapters.]|||And the type inference gets it right −|||The following is an example program that explains the process of variable declaration in Scala. This program declares four variables — two variables are defined with type declaration and remaining two are without type declaration.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Variables in Scala can have three different scopes depending on the place where they are being used. They can exist as fields, as method parameters and as local variables. Below are the details about each type of scope.|||Fields are variables that belong to an object. The fields are accessible from inside every method in the object. Fields can also be accessible outside the object depending on what access modifiers the field is declared with. Object fields can be both mutable and immutable types and can be defined using either var or val.|||Method parameters are variables, which are used to pass the value inside a method, when the method is called. Method parameters are only accessible from inside the method but the objects passed in may be accessible from the outside, if you have a reference to the object from outside the method. Method parameters are always immutable which are defined by val keyword.|||Local variables are variables declared inside a method. Local variables are only accessible from inside the method, but the objects you create may escape the method if you return them from the method. Local variables can be both mutable and immutable types and can be defined using either var or val.",,,,"object Demo {   def main(args: Array[String]) {      var myVar :Int = 10;      val myVal :String = ""Hello Scala with datatype declaration."";      var myVar1 = 20;      val myVal1 = ""Hello Scala new without datatype declaration."";            println(myVar); println(myVal); println(myVar1);       println(myVal1);   }}"
Learn Scala,Scala - Classes & Objects,Scala - Classes & Objects|||Basic Class@@@Extending a Class@@@Implicit Classes@@@Singleton Objects@@@Useful Video Courses|||Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter takes you through how to use classes and objects in Scala programming. A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword new. Through the object you can use all functionalities of the defined class.|||The following diagram demonstrates the class and object by taking an example of class student, which contains the member variables (name and roll no) and member methods (setName() and setRollNo()). Finally all are members of the class. Class is a blue print and objects are real here. In the following diagram, Student is a class and Harini, John, and Maria are the objects of Student class, those are having name and roll-number.|||Following is a simple syntax to define a basic class in Scala. This class defines two variables x and y and a method: move, which does not return a value. Class variables are called, fields of the class and methods are called class methods.|||The class name works as a class constructor which can take a number of parameters. The above code defines two constructor arguments, xc and yc; they are both visible in the whole body of the class.|||As mentioned earlier in this chapter, you can create objects using a keyword new and then you can access class fields and methods as shown below in the example −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can extend a base Scala class and you can design an inherited class in the same way you do it in Java (use extends key word), but there are two restrictions: method overriding requires the override keyword, and only the primary constructor can pass parameters to the base constructor. Let us extend our above class and add one more class method.|||Let us take an example of two classes Point class (as same example as above) and Location class is inherited class using extends keyword. Such an ‘extends’ clause has two effects: it makes Location class inherit all non-private members from Point class, and it makes the type Location a subtype of the type Point class. So here the Point class is called superclass and the class Location is called subclass. Extending a class and inheriting all the features of a parent class is called inheritance but Scala allows the inheritance from just one class only.|||Note − Methods move() method in Point class and move() method in Location class do not override the corresponding definitions of move since they are different definitions (for example, the former take two arguments while the latter take three arguments).|||Try the following example program to implement inheritance.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Implicit classes allow implicit conversations with class’s primary constructor when the class is in scope. Implicit class is a class marked with ‘implicit’ keyword. This feature is introduced in Scala 2.10.|||Syntax − The following is the syntax for implicit classes. Here implicit class is always in the object scope where all method definitions are allowed because implicit class cannot be a top level class.|||Let us take an example of an implicit class named IntTimes with the method times(). It means the times () contain a loop transaction that will execute the given statement in number of times that we give. Let us assume the given statement is “4 times println (“Hello”)” means the println (“”Hello”) statement will execute 4 times.|||The following is the program for the given example. In this example two object classes are used (Run and Demo) so that we have to save those two classes in different files with their respective names as follows.|||Run.scala − Save the following program in Run.scala.|||Demo.scala − Save the following program in Demo.scala.|||The following commands are used to compile and execute these two programs.|||Note −|||Implicit classes must be defined inside another class/object/trait (not in top level).|||Implicit classes may only take one non –implicit argument in their constructor.|||Implicit classes may not be any method, member or object in scope with the same name as the implicit class.|||Scala is more object-oriented than Java because in Scala, we cannot have static members. Instead, Scala has singleton objects. A singleton is a class that can have only one instance, i.e., Object. You create singleton using the keyword object instead of class keyword. Since you can't instantiate a singleton object, you can't pass parameters to the primary constructor. You already have seen all the examples using singleton objects where you called Scala's main method.|||Following is the same example program to implement singleton.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.","Implicit classes must be defined inside another class/object/trait (not in top level).@@@Implicit classes may only take one non –implicit argument in their constructor.@@@Implicit classes may not be any method, member or object in scope with the same name as the implicit class.",,,"import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy      println (""Point x location : "" + x);      println (""Point y location : "" + y);   }}object Demo {   def main(args: Array[String]) {      val pt = new Point(10, 20);      // Move to a new location      pt.move(10, 10);   }}|||import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy      println (""Point x location : "" + x);      println (""Point y location : "" + y);   }}class Location(override val xc: Int, override val yc: Int,   val zc :Int) extends Point(xc, yc){   var z: Int = zc   def move(dx: Int, dy: Int, dz: Int) {      x = x + dx      y = y + dy      z = z + dz      println (""Point x location : "" + x);      println (""Point y location : "" + y);      println (""Point z location : "" + z);   }}object Demo {   def main(args: Array[String]) {      val loc = new Location(10, 20, 15);      // Move to a new location      loc.move(10, 10, 5);   }}|||object <object name> {   implicit class <class name>(<Variable>: Data type) {      def <method>(): Unit =   }}|||object Run {   implicit class IntTimes(x: Int) {      def times [A](f: =>A): Unit = {         def loop(current: Int): Unit =                  if(current > 0){            f            loop(current - 1)         }         loop(x)      }   }}|||import Run._object Demo {   def main(args: Array[String]) {      4 times println(""hello"")   }}|||import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy   }}object Demo {   def main(args: Array[String]) {      val point = new Point(10, 20)      printPoint      def printPoint{         println (""Point x location : "" + point.x);         println (""Point y location : "" + point.y);      }   }}|||\>scalac Demo.scala\>scala Demo"
Learn Scala,Scala - Access Modifiers,Scala - Access Modifiers|||Private Members@@@Protected Members@@@Public Members@@@Scope of Protection@@@Useful Video Courses|||Example@@@Example@@@Example@@@Example|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter takes you through the Scala access modifiers. Members of packages, classes or objects can be labeled with the access modifiers private and protected, and if we are not using either of these two keywords, then access will be assumed as public. These modifiers restrict accesses to the members to certain regions of code. To use an access modifier, you include its keyword in the definition of members of package, class or object as we will see in the following section.|||A private member is visible only inside the class or object that contains the member definition.|||Following is the example code snippet to explain Private member −|||In Scala, the access (new Inner). f() is illegal because f is declared private in Inner and the access is not from within class Inner. By contrast, the first access to f in class Innermost is OK, because that access is contained in the body of class Inner. Java would permit both accesses because it lets an outer class access private members of its inner classes.|||A protected member is only accessible from subclasses of the class in which the member is defined.|||Following is the example code snippet to explain protected member −|||The access to f in class Sub is OK because f is declared protected in ‘Super’ class and ‘Sub’ class is a subclass of Super. By contrast the access to f in ‘Other’ class is not permitted, because class ‘Other’ does not inherit from class ‘Super’. In Java, the latter access would be still permitted because ‘Other’ class is in the same package as ‘Sub’ class.|||Unlike private and protected members, it is not required to specify Public keyword for Public members. There is no explicit modifier for public members. Such members can be accessed from anywhere.|||Following is the example code snippet to explain public member −|||Access modifiers in Scala can be augmented with qualifiers. A modifier of the form private[X] or protected[X] means that access is private or protected ""up to"" X, where X designates some enclosing package, class or singleton object.|||Consider the following example −|||Note − the following points from the above example −|||Variable workDetails will be accessible to any class within the enclosing package professional.|||Variable friends will be accessible to any class within the enclosing package society.|||Variable secrets will be accessible only on the implicit object within instance methods (this).",Variable workDetails will be accessible to any class within the enclosing package professional.@@@Variable friends will be accessible to any class within the enclosing package society.@@@Variable secrets will be accessible only on the implicit object within instance methods (this).,,,"class Outer {   class Inner {      private def f() { println(""f"") }            class InnerMost {         f() // OK      }   }   (new Inner).f() // Error: f is not accessible}|||package p {   class Super {      protected def f() { println(""f"") }   }      class Sub extends Super {      f()   }      class Other {      (new Super).f() // Error: f is not accessible   }}|||class Outer {   class Inner {      def f() { println(""f"") }            class InnerMost {         f() // OK      }   }   (new Inner).f() // OK because now f() is public}|||package society {   package professional {      class Executive {         private[professional] var workDetails = null         private[society] var friends = null         private[this] var secrets = null         def help(another : Executive) {            println(another.workDetails)            println(another.secrets) //ERROR         }      }   }}"
Learn Scala,Scala - Operators,Scala - Operators|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Assignment Operators@@@Operators Precedence in Scala@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Scala is rich in built-in operators and provides the following types of operators −|||This chapter will examine the arithmetic, relational, logical, bitwise, assignment and other operators one by one.|||The following arithmetic operators are supported by Scala language. For example, let us assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||The following relational operators are supported by Scala language. For example let us assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||The following logical operators are supported by Scala language. For example, assume variable A holds 1 and variable B holds 0, then −|||Show Examples|||Bitwise operator works on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows −|||Assume if A = 60; and B = 13; now in binary format they will be as follows −|||The Bitwise operators supported by Scala language is listed in the following table. Assume variable A holds 60 and variable B holds 13, then −|||Show Examples|||There are following assignment operators supported by Scala language −|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator −|||For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.|||Take a look at the following table. Operators with the highest precedence appear at the top of the table and those with the lowest precedence appear at the bottom. Within an expression, higher precedence operators will be evaluated first.",Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Assignment Operators,,"Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiplies both operands@@@A * B will give 200|||/@@@Divides numerator by de-numerator@@@B / A will give 2|||%@@@Modulus operator finds the remainder after division of one number by another@@@B % A will give 0&&&Operator@@@Description@@@Example|||==@@@Checks if the values of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||!=@@@Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||&&@@@It is called Logical AND  operator. If both the operands are non zero then condition becomes true.@@@(A && B) is false.|||||@@@It is called Logical OR Operator. If any of the two operands is non zero then condition becomes true.@@@(A || B) is true.|||!@@@It is called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A && B) is true.&&&p@@@q@@@p & q@@@p | q@@@p ^ q|||0@@@0@@@0@@@0@@@0|||0@@@1@@@0@@@1@@@1|||1@@@1@@@1@@@1@@@0|||1@@@0@@@0@@@1@@@1&&&Operator@@@Description@@@Example|||&@@@Binary AND Operator copies a bit to the result if it exists in both operands. @@@(A & B) will give 12, which is 0000 1100||||@@@Binary OR Operator copies a bit if it exists in either operand.@@@(A | B) will give 61, which is 0011 1101|||^@@@Binary XOR Operator copies the bit if it is set in one operand but not both.@@@(A ^ B) will give 49, which is 0011 0001|||~@@@Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. @@@(~A ) will give -61, which is 1100 0011 in 2's complement form due to a signed binary number.|||<<@@@Binary Left Shift Operator. The bit positions of the left operands value is moved left by the number of bits specified by the right operand.@@@A << 2 will give 240, which is 1111 0000|||>>@@@Binary Right Shift Operator. The Bit positions of the left operand value is moved right by the number of bits specified by the right operand.@@@A >> 2 will give 15, which is 1111|||>>>@@@Shift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros.@@@A >>>2 will give 15 which is 0000 1111&&&Operator@@@Description@@@Example|||=@@@Simple assignment operator, Assigns values from right side operands to left side operand@@@C = A + B will assign value of A + B into C|||+=@@@Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand@@@C += A is equivalent to C = C + A|||-=@@@Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand@@@C -= A is equivalent to C = C - A|||*=@@@Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand@@@C *= A is equivalent to C = C * A|||/=@@@Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand@@@C /= A is equivalent to C = C / A|||%=@@@Modulus AND assignment operator, It takes modulus using two operands and assign the result to  left operand@@@C %= A is equivalent to C = C % A|||<<=@@@Left shift AND assignment operator @@@C <<= 2 is same as  C = C << 2|||>>=@@@Right shift AND assignment operator @@@C >>= 2 is same as  C = C >> 2|||&=@@@Bitwise AND assignment operator@@@C &= 2 is same as  C = C & 2|||^=@@@bitwise exclusive OR and assignment operator@@@C ^= 2 is same as C = C ^ 2||||=@@@bitwise inclusive OR and assignment operator@@@C |= 2 is same as  C = C | 2&&&Category@@@Operator@@@Associativity|||Postfix@@@() []@@@Left to right|||Unary@@@!  ~ @@@Right to left|||Multiplicative @@@*  /  %@@@Left to right|||Additive @@@+  -@@@Left to right|||Shift @@@>> >>> << @@@Left to right|||Relational @@@> >=  < <= @@@Left to right|||Equality @@@==  !=@@@Left to right|||Bitwise AND@@@&@@@Left to right|||Bitwise XOR@@@^@@@Left to right|||Bitwise OR@@@|@@@Left to right|||Logical AND@@@&&@@@Left to right|||Logical OR@@@||@@@Left to right|||Assignment@@@=  +=  -=  *=  /=  %= >>=  <<=  &=  ^=   |=@@@Right to left|||Comma@@@,@@@Left to right",
Learn Scala,Scala - IF ELSE Statements,Scala - IF ELSE Statements|||Flow Chart@@@if Statement@@@If-else Statement@@@If-else-if-else Statement@@@Nested if-else Statement@@@Useful Video Courses|||Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter takes you through the conditional construction statements in Scala programming. Following is the general form of a typical decision making IF...ELSE structure found in most of the programming languages.|||The following is a flow chart diagram for conditional statement.|||‘if’ statement consists of a Boolean expression followed by one or more statements.|||The syntax of an ‘if’ statement is as follows.|||If the Boolean expression evaluates to true then the block of code inside the ‘if’ expression will be executed. If not, the first set of code after the end of the ‘if’ expression (after the closing curly brace) will be executed.|||Try the following example program to understand conditional expressions (if expression) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An ‘if’ statement can be followed by an optional else statement, which executes when the Boolean expression is false.|||The syntax of a if...else is −|||Try the following example program to understand conditional statements (if- else statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An 'if' statement can be followed by an optional 'else if...else' statement, which is very useful to test various conditions using single if...else if statement.|||When using if , else if , else statements there are few points to keep in mind.|||An 'if' can have zero or one else's and it must come after any else if's.|||An 'if' can have zero to many else if's and they must come before the else.|||Once an else if succeeds, none of he remaining else if's or else's will be tested.|||The following is the syntax of an ‘if...else if...else’ is as follows −|||Try the following example program to understand conditional statements (if- else- if- else statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It is always legal to nest if-else statements, which means you can use one if or else-if statement inside another if or else-if statement.|||The syntax for a nested if-else is as follows −|||Try the following example program to understand conditional statements (nested- if statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.","An 'if' can have zero or one else's and it must come after any else if's.@@@An 'if' can have zero to many else if's and they must come before the else.@@@Once an else if succeeds, none of he remaining else if's or else's will be tested.",,,"object Demo {   def main(args: Array[String]) {      var x = 10;      if( x < 20 ){         println(""This is if statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      if( x < 20 ){         println(""This is if statement"");      } else {         println(""This is else statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      if( x == 10 ){         println(""Value of X is 10"");      } else if( x == 20 ){         println(""Value of X is 20"");      } else if( x == 30 ){         println(""Value of X is 30"");      } else{         println(""This is else statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      var y = 10;            if( x == 30 ){         if( y == 10 ){            println(""X = 30 and Y = 10"");         }      }   }}"
Learn Scala,Scala - Loop Statements,Scala - Loop Statements|||Flow Chart@@@Loop Control Statements@@@The infinite Loop@@@Useful Video Courses|||Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter takes you through the loop control structures in Scala programming languages.|||There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −|||Scala programming language provides the following types of loops to handle looping requirements. Click the following links in the table to check their detail.|||while loop|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||do-while loop|||Like a while statement, except that it tests the condition at the end of the loop body.|||for loop|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. As such Scala does not support break or continue statement like Java does but starting from Scala version 2.8, there is a way to break the loops. Click the following links to check the detail.|||break statement|||Terminates the loop statement and transfers execution to the statement immediately following the loop.|||A loop becomes an infinite loop if a condition never becomes false. If you are using Scala, the while loop is the best way to implement infinite loop.|||The following program implements infinite loop.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||If you will execute above code, it will go in infinite loop which you can terminate by pressing Ctrl + C keys.",,,"Sr.No@@@Loop Type & Description|||1@@@
while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.
|||2@@@
do-while loop
Like a while statement, except that it tests the condition at the end of the loop body.
|||3@@@
for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.
&&&Sr.No@@@Control Statement & Description|||1@@@
break statement
Terminates the loop statement and transfers execution to the statement immediately following the loop.
","object Demo {   def main(args: Array[String]) {      var a = 10;            // An infinite loop.      while( true ){         println( ""Value of a: "" + a );      }   }}"
Learn Scala,Scala - Functions,Scala - Functions|||Function Declarations@@@Function Definitions@@@Calling Functions@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"A function is a group of statements that perform a task. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically, the division usually is so that each function performs a specific task.|||Scala has both functions and methods and we use the terms method and function interchangeably with a minor difference. A Scala method is a part of a class which has a name, a signature, optionally some annotations, and some bytecode where as a function in Scala is a complete object which can be assigned to a variable. In other words, a function, which is defined as a member of some object, is called a method.|||A function definition can appear anywhere in a source file and Scala permits nested function definitions, that is, function definitions inside other function definitions. Most important point to note is that Scala function's name can have characters like +, ++, ~, &,-, --, \, /, :, etc.|||A Scala function declaration has the following form −|||Methods are implicitly declared abstract if you don’t use the equals sign and the method body.|||A Scala function definition has the following form −|||Here, return type could be any valid Scala data type and list of parameters will be a list of variables separated by comma and list of parameters and return type are optional. Very similar to Java, a return statement can be used along with an expression in case function returns a value. Following is the function which will add two integers and return their sum −|||A function, that does not return anything can return a Unit that is equivalent to void in Java and indicates that function does not return anything. The functions which do not return anything in Scala, they are called procedures.|||Here is the syntax −|||Scala provides a number of syntactic variations for invoking methods. Following is the standard way to call a method −|||If a function is being called using an instance of the object, then we would use dot notation similar to Java as follows −|||Try the following example program to define and then call the same function.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala functions are the heart of Scala programming and that's why Scala is assumed as a functional programming language. Following are few important concepts related to Scala functions which should be understood by a Scala programmer.",,,Functions Call-by-Name@@@Functions with Named Arguments|||Function with Variable Arguments@@@Recursion Functions|||Default Parameter Values@@@Higher-Order Functions|||Nested Functions@@@Anonymous Functions|||Partially Applied Functions@@@Currying Functions,"def functionName ([list of parameters]) : [return type]|||object Demo {   def main(args: Array[String]) {      println( ""Returned Value : "" + addInt(5,7) );   }      def addInt( a:Int, b:Int ) : Int = {      var sum:Int = 0      sum = a + b      return sum   }}"
Learn Scala,Scala - Closures,Scala - Closures|||Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"A closure is a function, whose return value depends on the value of one or more variables declared outside this function.|||The following piece of code with anonymous function.|||Here the only variable used in the function body, i * 10 , is i, which is defined as a parameter to the function. Try the following code −|||There are two free variables in multiplier: i and factor. One of them, i, is a formal parameter to the function. Hence, it is bound to a new value each time multiplier is called. However, factor is not a formal parameter, then what is this? Let us add one more line of code.|||Now factor has a reference to a variable outside the function but in the enclosing scope. The function references factor and reads its current value each time. If a function has no external references, then it is trivially closed over itself. No external context is required.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) {      println( ""multiplier(1) value = "" +  multiplier(1) )      println( ""multiplier(2) value = "" +  multiplier(2) )   }   var factor = 3   val multiplier = (i:Int) => i * factor}"
Learn Scala,Scala - Strings,Scala - Strings|||Creating a String@@@String Length@@@Concatenating Strings@@@Creating Format Strings@@@String Interpolation@@@The ‘s’ String Interpolator@@@The ‘ f ’ Interpolator@@@‘raw’ Interpolator@@@String Methods@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter takes you through the Scala Strings. In Scala, as in Java, a string is an immutable object, that is, an object that cannot be modified. On the other hand, objects that can be modified, like arrays, are called mutable objects. Strings are very useful objects, in the rest of this section, we present important methods of java.lang.String class.|||The following code can be used to create a String −|||Whenever compiler encounters a string literal in the code, it creates a String object with its value, in this case, “Hello world!”. String keyword can also be given in alternate declaration as shown above.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||As mentioned earlier, String class is immutable. String object once created cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters then use String Builder Class available in Scala!.|||Methods used to obtain information about an object are known as accessor methods. One accessor method that can be used with strings is the length() method, which returns the number of characters contained in the string object.|||Use the following code segment to find the length of a string −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The String class includes a method for concatenating two strings −|||This returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in −|||Strings are more commonly concatenated with the + operator, as in −|||Which results in −|||The following lines of code to find string length.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.|||Try the following example program, which makes use of printf() method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||String Interpolation is the new way to create Strings in Scala programming language. This feature supports the versions of Scala-2.10 and later. String Interpolation: The mechanism to embed variable references directly in process string literal.|||There are three types (interpolators) of implementations in String Interpolation.|||The literal ‘s’ allows the usage of variable directly in processing a string, when you prepend ‘s’ to it. Any String variable with in a scope that can be used with in a String. The following are the different usages of ‘s’ String interpolator.|||The following example code snippet for the implementation of ‘s’ interpolator in appending String variable ($name) to a normal String (Hello) in println statement.|||String interpolater can also process arbitrary expressions. The following code snippet for Processing a String (1 + 1) with arbitrary expression (${1 + 1}) using ‘s’ String interpolator. Any arbitrary expression can be embedded in ‘${}’.|||Try the following example program of implementing ‘s’ interpolator.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The literal ‘f’ interpolator allows to create a formatted String, similar to printf in C language. While using ‘f’ interpolator, all variable references should be followed by the printf style format specifiers such as %d, %i, %f, etc.|||Let us take an example of append floating point value (height = 1.9d) and String variable (name = “James”) with normal string. The following code snippet of implementing ‘f’ Interpolator. Here $name%s to print (String variable) James and $height%2.2f to print (floating point value) 1.90.|||It is type safe (i.e.) the variable reference and following format specifier should match otherwise it is showing error. The ‘ f ’ interpolator makes use of the String format utilities (format specifiers) available in Java. By default means, there is no % character after variable reference. It will assume as %s (String).|||The ‘raw’ interpolator is similar to ‘s’ interpolator except that it performs no escaping of literals within a string. The following code snippets in a table will differ the usage of ‘s’ and ‘raw’ interpolators. In outputs of ‘s’ usage ‘\n’ effects as new line and in output of ‘raw’ usage the ‘\n’ will not effect. It will print the complete string with escape letters.|||Program −|||Program −|||Output −|||Output −|||Following is the list of methods defined by java.lang.String class and can be used directly in your Scala programs −|||char charAt(int index)|||Returns the character at the specified index.|||int compareTo(Object o)|||Compares this String to another Object.|||int compareTo(String anotherString)|||Compares two strings lexicographically.|||int compareToIgnoreCase(String str)|||Compares two strings lexicographically, ignoring case differences.|||String concat(String str)|||Concatenates the specified string to the end of this string.|||boolean contentEquals(StringBuffer sb)|||Returns true if and only if this String represents the same sequence of characters as the specified StringBuffer.|||static String copyValueOf(char[] data)|||Returns a String that represents the character sequence in the array specified.|||static String copyValueOf(char[] data, int offset, int count)|||Returns a String that represents the character sequence in the array specified.|||boolean endsWith(String suffix)|||Tests if this string ends with the specified suffix.|||boolean equals(Object anObject)|||Compares this string to the specified object.|||boolean equalsIgnoreCase(String anotherString)|||Compares this String to another String, ignoring case considerations.|||byte getBytes()|||Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.|||byte[] getBytes(String charsetName)|||Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.|||void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)|||Copies characters from this string into the destination character array.|||int hashCode()|||Returns a hash code for this string.|||int indexOf(int ch)|||Returns the index within this string of the first occurrence of the specified character.|||int indexOf(int ch, int fromIndex)|||Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.|||int indexOf(String str)|||Returns the index within this string of the first occurrence of the specified substring.|||int indexOf(String str, int fromIndex)|||Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.|||String intern()|||Returns a canonical representation for the string object.|||int lastIndexOf(int ch)|||Returns the index within this string of the last occurrence of the specified character.|||int lastIndexOf(int ch, int fromIndex)|||Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.|||int lastIndexOf(String str)|||Returns the index within this string of the rightmost occurrence of the specified substring.|||int lastIndexOf(String str, int fromIndex)|||Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.|||int length()|||Returns the length of this string.|||boolean matches(String regex)|||Tells whether or not this string matches the given regular expression.|||boolean regionMatches(boolean ignoreCase, int toffset, String other, int offset, int len)|||Tests if two string regions are equal.|||boolean regionMatches(int toffset, String other, int offset, int len)|||Tests if two string regions are equal.|||String replace(char oldChar, char newChar)|||Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.|||String replaceAll(String regex, String replacement|||Replaces each substring of this string that matches the given regular expression with the given replacement.|||String replaceFirst(String regex, String replacement)|||Replaces the first substring of this string that matches the given regular expression with the given replacement.|||String[] split(String regex)|||Splits this string around matches of the given regular expression.|||String[] split(String regex, int limit)|||Splits this string around matches of the given regular expression.|||boolean startsWith(String prefix)|||Tests if this string starts with the specified prefix.|||boolean startsWith(String prefix, int toffset)|||Tests if this string starts with the specified prefix beginning a specified index.|||CharSequence subSequence(int beginIndex, int endIndex)|||Returns a new character sequence that is a subsequence of this sequence.|||String substring(int beginIndex)|||Returns a new string that is a substring of this string.|||String substring(int beginIndex, int endIndex)|||Returns a new string that is a substring of this string.|||char[] toCharArray()|||Converts this string to a new character array.|||String toLowerCase()|||Converts all of the characters in this String to lower case using the rules of the default locale.|||String toLowerCase(Locale locale)|||Converts all of the characters in this String to lower case using the rules of the given Locale.|||String toString()|||This object (which is already a string!) is itself returned.|||String toUpperCase()|||Converts all of the characters in this String to upper case using the rules of the default locale.|||String toUpperCase(Locale locale)|||Converts all of the characters in this String to upper case using the rules of the given Locale.|||String trim()|||Returns a copy of the string, with leading and trailing whitespace omitted.|||static String valueOf(primitive data type x)|||Returns the string representation of the passed data type argument.",,,"‘s’ interpolator usage@@@‘raw’ interpolator usage|||
Program −

object Demo {
   def main(args: Array[String]) {
      println(s""Result = \n a \n b"")
   }
}

@@@
Program −

object Demo {
   def main(args: Array[String]) {
      println(raw""Result = \n a \n b"")
   }
}

|||
Output −

Result =
a
b

@@@
Output −

Result = \n a \n b

&&&Sr.No@@@Methods with Description|||1@@@
char charAt(int index)
Returns the character at the specified index.
|||2@@@
int compareTo(Object o)
Compares this String to another Object.
|||3@@@
int compareTo(String anotherString)
Compares two strings lexicographically.
|||4@@@
int compareToIgnoreCase(String str)
Compares two strings lexicographically, ignoring case differences.
|||5@@@
String concat(String str)
Concatenates the specified string to the end of this string.
|||6@@@
boolean contentEquals(StringBuffer sb)
Returns true if and only if this String represents the same sequence of characters as the specified StringBuffer.
|||7@@@
static String copyValueOf(char[] data)
Returns a String that represents the character sequence in the array specified.
|||8@@@
static String copyValueOf(char[] data, int offset, int count)
Returns a String that represents the character sequence in the array specified.
|||9@@@
boolean endsWith(String suffix)
Tests if this string ends with the specified suffix.
|||10@@@
boolean equals(Object anObject)
Compares this string to the specified object.
|||11@@@
boolean equalsIgnoreCase(String anotherString)
Compares this String to another String, ignoring case considerations.
|||12@@@
byte getBytes()
Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.
|||13@@@
byte[] getBytes(String charsetName)
Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.
|||14@@@
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
Copies characters from this string into the destination character array.
|||15@@@
int hashCode()
Returns a hash code for this string.
|||16@@@
int indexOf(int ch)
Returns the index within this string of the first occurrence of the specified character.
|||17@@@
int indexOf(int ch, int fromIndex)
Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.
|||18@@@
int indexOf(String str)
Returns the index within this string of the first occurrence of the specified substring.
|||19@@@
int indexOf(String str, int fromIndex)
Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.
|||20@@@
String intern()
Returns a canonical representation for the string object.
|||21@@@
int lastIndexOf(int ch)
Returns the index within this string of the last occurrence of the specified character.
|||22@@@
int lastIndexOf(int ch, int fromIndex)
Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.
|||23@@@
int lastIndexOf(String str)
Returns the index within this string of the rightmost occurrence of the specified substring.
|||24@@@
int lastIndexOf(String str, int fromIndex)
Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.
|||25@@@
int length()
Returns the length of this string.
|||26@@@
boolean matches(String regex)
Tells whether or not this string matches the given regular expression.
|||27@@@
boolean regionMatches(boolean ignoreCase, int toffset, String other, int offset, int len)
Tests if two string regions are equal.
|||28@@@
boolean regionMatches(int toffset, String other, int offset, int len)
Tests if two string regions are equal.
|||29@@@
String replace(char oldChar, char newChar)
Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
|||30@@@
String replaceAll(String regex, String replacement
Replaces each substring of this string that matches the given regular expression with the given replacement.
|||31@@@
String replaceFirst(String regex, String replacement)
Replaces the first substring of this string that matches the given regular expression with the given replacement.
|||32@@@
String[] split(String regex)
Splits this string around matches of the given regular expression.
|||33@@@
String[] split(String regex, int limit)
Splits this string around matches of the given regular expression.
|||34@@@
boolean startsWith(String prefix)
Tests if this string starts with the specified prefix.
|||35@@@
boolean startsWith(String prefix, int toffset)
Tests if this string starts with the specified prefix beginning a specified index.
|||36@@@
CharSequence subSequence(int beginIndex, int endIndex)
Returns a new character sequence that is a subsequence of this sequence.
|||37@@@
String substring(int beginIndex)
Returns a new string that is a substring of this string.
|||38@@@
String substring(int beginIndex, int endIndex)
Returns a new string that is a substring of this string.
|||39@@@
char[] toCharArray()
Converts this string to a new character array.
|||40@@@
String toLowerCase()
Converts all of the characters in this String to lower case using the rules of the default locale.
|||41@@@
String toLowerCase(Locale locale)
Converts all of the characters in this String to lower case using the rules of the given Locale.
|||42@@@
String toString()
This object (which is already a string!) is itself returned.
|||43@@@
String toUpperCase()
Converts all of the characters in this String to upper case using the rules of the default locale.
|||44@@@
String toUpperCase(Locale locale)
Converts all of the characters in this String to upper case using the rules of the given Locale.
|||45@@@
String trim()
Returns a copy of the string, with leading and trailing whitespace omitted.
|||46@@@
static String valueOf(primitive data type x)
Returns the string representation of the passed data type argument.","object Demo {   val greeting: String = ""Hello, world!""   def main(args: Array[String]) {      println( greeting )   }}|||object Demo {   def main(args: Array[String]) {      var palindrome = ""Dot saw I was Tod"";      var len = palindrome.length();            println( ""String Length is : "" + len );   }}|||object Demo {   def main(args: Array[String]) {      var str1 = ""Dot saw I was "";      var str2 =  ""Tod"";            println(""Dot "" + str1 + str2);   }}|||object Demo {   def main(args: Array[String]) {      var floatVar = 12.456      var intVar = 2000      var stringVar = ""Hello, Scala!""            var fs = printf(""The value of the float variable is "" + ""%f, while the value of the integer "" + ""variable is %d, and the string"" + ""is %s"", floatVar, intVar, stringVar);            println(fs)   }}|||object Demo {   def main(args: Array[String]) {      val name = ""James""            println(s""Hello, $name"")      println(s""1 + 1 = ${1 + 1}"")   }}|||object Demo {   def main(args: Array[String]) {      println(s""Result = \n a \n b"")   }}|||object Demo {   def main(args: Array[String]) {      println(raw""Result = \n a \n b"")   }}"
Learn Scala,Scala - Arrays,Scala - Arrays|||Declaring Array Variables@@@Processing Arrays@@@Multi-Dimensional Arrays@@@Concatenate Arrays@@@Create Array with Range@@@Scala Array Methods@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.|||Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables. The index of the first element of an array is the number zero and the index of the last element is the total number of elements minus one.|||To use an array in a program, you must declare a variable to reference the array and you must specify the type of array the variable can reference.|||The following is the syntax for declaring an array variable.|||Here, z is declared as an array of Strings that may hold up to three elements. Values can be assigned to individual elements or get access to individual elements, it can be done by using commands like the following −|||Here, the last example shows that in general the index can be any expression that yields a whole number. There is one more way of defining an array −|||Following picture represents an array myList. Here, myList holds ten double values and the indices are from 0 to 9.|||When processing array elements, we often use loop contol structures because all of the elements in an array are of the same type and the size of the array is known.|||Below is an example program of showing how to create, initialize and process arrays −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala does not directly support various array operations and provides various methods to process arrays in any dimension. If you want to use the different methods then it is required to import Array._ package.|||There are many situations where you would need to define and use multi-dimensional arrays (i.e., arrays whose elements are arrays). For example, matrices and tables are examples of structures that can be realized as two-dimensional arrays.|||The following is the example of defining a two-dimensional array −|||This is an array that has three elements each being an array of integers that has three elements.|||Try the following example program to process a multi-dimensional array −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Try the following example which makes use of concat() method to concatenate two arrays. You can pass more than one array as arguments to concat() method.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Use of range() method to generate an array containing a sequence of increasing integers in a given range. You can use final argument as step to create the sequence; if you do not use final argument, then step would be assumed as 1.|||Let us take an example of creating an array of range (10, 20, 2): It means creating an array with elements between 10 and 20 and range difference 2. Elements in the array are 10, 12, 14, 16, and 18.|||Another example: range (10, 20). Here range difference is not given so by default it assumes 1 element. It create an array with the elements in between 10 and 20 with range difference 1. Elements in the array are 10, 11, 12, 13, …, and 19.|||The following example program shows how to create an array with ranges.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following are the important methods, which you can use while playing with array. As shown above, you would have to import Array._ package before using any of the mentioned methods. For a complete list of methods available, please check official documentation of Scala.|||def apply( x: T, xs: T* ): Array[T]|||Creates an array of T objects, where T can be Unit, Double, Float, Long, Int, Char, Short, Byte, Boolean.|||def concat[T]( xss: Array[T]* ): Array[T]|||Concatenates all arrays into a single array.|||def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit|||Copy one array to another. Equivalent to Java's System.arraycopy(src, srcPos, dest, destPos, length).|||def empty[T]: Array[T]|||Returns an array of length 0|||def iterate[T]( start: T, len: Int )( f: (T) => T ): Array[T]|||Returns an array containing repeated applications of a function to a start value.|||def fill[T]( n: Int )(elem: =>  T): Array[T]|||Returns an array that contains the results of some element computation a number of times.|||def fill[T]( n1: Int, n2: Int )( elem: => T ): Array[Array[T]]|||Returns a two-dimensional array that contains the results of some element computation a number of times.|||def iterate[T]( start: T, len: Int)( f: (T) => T ): Array[T]|||Returns an array containing repeated applications of a function to a start value.|||def ofDim[T]( n1: Int ): Array[T]|||Creates array with given dimensions.|||def ofDim[T]( n1: Int, n2: Int ): Array[Array[T]]|||Creates a 2-dimensional array|||def ofDim[T]( n1: Int, n2: Int, n3: Int ): Array[Array[Array[T]]]|||Creates a 3-dimensional array|||def range( start: Int, end: Int, step: Int ): Array[Int]|||Returns an array containing equally spaced values in some integer interval.|||def range( start: Int, end: Int ): Array[Int]|||Returns an array containing a sequence of increasing integers in a range.|||def tabulate[T]( n: Int )(f: (Int)=> T): Array[T]|||Returns an array containing values of a given function over a range of integer values starting from 0.|||def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) => T): Array[Array[T]]|||Returns a two-dimensional array containing values of a given function over ranges of integer values starting from 0.",,,"Sr.No@@@Methods with Description|||1@@@
def apply( x: T, xs: T* ): Array[T]
Creates an array of T objects, where T can be Unit, Double, Float, Long, Int, Char, Short, Byte, Boolean.
|||2@@@
def concat[T]( xss: Array[T]* ): Array[T]
Concatenates all arrays into a single array.
|||3@@@
def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit
Copy one array to another. Equivalent to Java's System.arraycopy(src, srcPos, dest, destPos, length).
|||4@@@
def empty[T]: Array[T]
Returns an array of length 0
|||5@@@
def iterate[T]( start: T, len: Int )( f: (T) => T ): Array[T]
Returns an array containing repeated applications of a function to a start value.
|||6@@@
def fill[T]( n: Int )(elem: =>  T): Array[T]
Returns an array that contains the results of some element computation a number of times.
|||7@@@
def fill[T]( n1: Int, n2: Int )( elem: => T ): Array[Array[T]]
Returns a two-dimensional array that contains the results of some element computation a number of times.
|||8@@@
def iterate[T]( start: T, len: Int)( f: (T) => T ): Array[T]
Returns an array containing repeated applications of a function to a start value.
|||9@@@
def ofDim[T]( n1: Int ): Array[T]
Creates array with given dimensions.
|||10@@@
def ofDim[T]( n1: Int, n2: Int ): Array[Array[T]]
Creates a 2-dimensional array
|||11@@@
def ofDim[T]( n1: Int, n2: Int, n3: Int ): Array[Array[Array[T]]]
Creates a 3-dimensional array
|||12@@@
def range( start: Int, end: Int, step: Int ): Array[Int]
Returns an array containing equally spaced values in some integer interval.
|||13@@@
def range( start: Int, end: Int ): Array[Int]
Returns an array containing a sequence of increasing integers in a range.
|||14@@@
def tabulate[T]( n: Int )(f: (Int)=> T): Array[T]
Returns an array containing values of a given function over a range of integer values starting from 0.
|||15@@@
def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) => T): Array[Array[T]]
Returns a two-dimensional array containing values of a given function over ranges of integer values starting from 0.
","object Demo {   def main(args: Array[String]) {      var myList = Array(1.9, 2.9, 3.4, 3.5)            // Print all the array elements      for ( x <- myList ) {         println( x )      }      // Summing all elements      var total = 0.0;            for ( i <- 0 to (myList.length - 1)) {         total += myList(i);      }      println(""Total is "" + total);      // Finding the largest element      var max = myList(0);            for ( i <- 1 to (myList.length - 1) ) {         if (myList(i) > max) max = myList(i);      }            println(""Max is "" + max);   }}|||var myMatrix = ofDim[Int](3,3)|||import Array._object Demo {   def main(args: Array[String]) {      var myMatrix = ofDim[Int](3,3)            // build a matrix      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            myMatrix(i)(j) = j;         }      }            // Print two dimensional array      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            print("" "" + myMatrix(i)(j));         }         println();      }   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myList1 = Array(1.9, 2.9, 3.4, 3.5)      var myList2 = Array(8.9, 7.9, 0.4, 1.5)      var myList3 =  concat( myList1, myList2)            // Print all the array elements      for ( x <- myList3 ) {         println( x )      }   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myList1 = range(10, 20, 2)      var myList2 = range(10,20)      // Print all the array elements      for ( x <- myList1 ) {         print( "" "" + x )      }            println()      for ( x <- myList2 ) {         print( "" "" + x )      }   }}"
Learn Scala,Scala - Collections,Scala - Collections|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map, etc. The collections may have an arbitrary number of elements or be bounded to zero or one element (e.g., Option).|||Collections may be strict or lazy. Lazy collections have elements that may not consume memory until they are accessed, like Ranges. Additionally, collections may be mutable (the contents of the reference can change) or immutable (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.|||For some problems, mutable collections work better, and for others, immutable collections work better. When in doubt, it is better to start with an immutable collection and change it later if you need mutable ones.|||This chapter throws light on the most commonly used collection types and most frequently used operations over those collections.|||Scala Lists|||Scala's List[T] is a linked list of type T.|||Scala Sets|||A set is a collection of pairwise different elements of the same type.|||Scala Maps|||A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||Scala Tuples|||Unlike an array or list, a tuple can hold objects with different types.|||Scala Options|||Option[T] provides a container for zero or one element of a given type.|||Scala Iterators|||An iterator is not a collection, but rather a way to access the elements of a collection one by one.",,,"Sr.No@@@Collections with Description|||1@@@Scala Lists
Scala's List[T] is a linked list of type T.
|||2@@@Scala Sets
A set is a collection of pairwise different elements of the same type.|||3@@@
Scala Maps
A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||4@@@Scala Tuples
Unlike an array or list, a tuple can hold objects with different types.|||5@@@Scala Options
Option[T] provides a container for zero or one element of a given type.|||6@@@Scala Iterators
An iterator is not a collection, but rather a way to access the elements of a collection one by one.",
Learn Scala,Scala - Traits,Scala - Traits|||Value classes and Universal Traits@@@When to Use Traits?@@@Useful Video Courses|||Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits.|||Traits are used to define object types by specifying the signature of the supported methods. Scala also allows traits to be partially implemented but traits may not have constructor parameters.|||A trait definition looks just like a class definition except that it uses the keyword trait. The following is the basic example syntax of trait.|||This trait consists of two methods isEqual and isNotEqual. Here, we have not given any implementation for isEqual where as another method has its implementation. Child classes extending a trait can give implementation for the un-implemented methods. So a trait is very similar to what we have abstract classes in Java.|||Let us assume an example of trait Equal contain two methods isEqual() and isNotEqual(). The trait Equal contain one implemented method that is isEqual() so when user defined class Point extends the trait Equal, implementation to isEqual() method in Point class should be provided.|||Here it is required to know two important method of Scala, which are used in the following example.|||obj.isInstanceOf [Point] To check Type of obj and Point are same are not.|||obj.asInstanceOf [Point] means exact casting by taking the object obj type and returns the same obj as Point type.|||Try the following example program to implement traits.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Value classes are new mechanism in Scala to avoid allocating runtime objects. It contains a primary constructor with exactly one val parameter. It contains only methods (def) not allowed var, val, nested classes, traits, or objects. Value class cannot be extended by another class. This can be possible by extending your value class with AnyVal. The typesafety of custom datatypes without the runtime overhead.|||Let us take an examples of value classes Weight, Height, Email, Age, etc. For all these examples it is not required to allocate memory in the application.|||A value class not allowed to extend traits. To permit value classes to extend traits, universal traits are introduced which extends for Any.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It will give you the hash code of Wrapper class.|||There is no firm rule, but here are few guidelines to consider −|||If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.|||If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.|||If you want to inherit from it in Java code, use an abstract class.|||If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.|||If efficiency is very important, lean towards using a class.","obj.isInstanceOf [Point] To check Type of obj and Point are same are not.@@@obj.asInstanceOf [Point] means exact casting by taking the object obj type and returns the same obj as Point type.|||If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.@@@If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.@@@If you want to inherit from it in Java code, use an abstract class.@@@If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.@@@If efficiency is very important, lean towards using a class.",,,"trait Equal {   def isEqual(x: Any): Boolean   def isNotEqual(x: Any): Boolean = !isEqual(x)}class Point(xc: Int, yc: Int) extends Equal {   var x: Int = xc   var y: Int = yc      def isEqual(obj: Any) = obj.isInstanceOf[Point] && obj.asInstanceOf[Point].x == y}object Demo {   def main(args: Array[String]) {      val p1 = new Point(2, 3)      val p2 = new Point(2, 4)      val p3 = new Point(3, 3)      println(p1.isNotEqual(p2))      println(p1.isNotEqual(p3))      println(p1.isNotEqual(2))   }}|||trait Printable extends Any {   def print(): Unit = println(this)}class Wrapper(val underlying: Int) extends AnyVal with Printableobject Demo {   def main(args: Array[String]) {      val w = new Wrapper(3)      w.print() // actually requires instantiating a Wrapper instance   }}"
Learn Scala,Scala - Pattern Matching,Scala - Pattern Matching|||Matching using Case Classes@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Pattern matching is the second most widely used feature of Scala, after function values and closures. Scala provides great support for pattern matching, in processing the messages.|||A pattern match includes a sequence of alternatives, each starting with the keyword case. Each alternative includes a pattern and one or more expressions, which will be evaluated if the pattern matches. An arrow symbol => separates the pattern from the expressions.|||Try the following example program, which shows how to match against an integer value.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The block with the case statements defines a function, which maps integers to strings. The match keyword provides a convenient way of applying a function (like the pattern matching function above) to an object.|||Try the following example program, which matches a value against patterns of different types.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The case classes are special classes that are used in pattern matching with case expressions. Syntactically, these are standard classes with a special modifier: case.|||Try the following, it is a simple pattern matching example using case class.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Adding the case keyword causes the compiler to add a number of useful features automatically. The keyword suggests an association with case expressions in pattern matching.|||First, the compiler automatically converts the constructor arguments into immutable fields (vals). The val keyword is optional. If you want mutable fields, use the var keyword. So, our constructor argument lists are now shorter.|||Second, the compiler automatically implements equals, hashCode, and toString methods to the class, which use the fields specified as constructor arguments. So, we no longer need our own toString() methods.|||Finally, also, the body of Person class becomes empty because there are no methods that we need to define!",,,,"object Demo {   def main(args: Array[String]) {      println(matchTest(3))   }      def matchTest(x: Int): String = x match {      case 1 => ""one""      case 2 => ""two""      case _ => ""many""   }}|||object Demo {   def main(args: Array[String]) {      println(matchTest(""two""))      println(matchTest(""test""))      println(matchTest(1))   }      def matchTest(x: Any): Any = x match {      case 1 => ""one""      case ""two"" => 2      case y: Int => ""scala.Int""      case _ => ""many""   }}|||object Demo {   def main(args: Array[String]) {      val alice = new Person(""Alice"", 25)      val bob = new Person(""Bob"", 32)      val charlie = new Person(""Charlie"", 32)         for (person <- List(alice, bob, charlie)) {         person match {            case Person(""Alice"", 25) => println(""Hi Alice!"")            case Person(""Bob"", 32) => println(""Hi Bob!"")            case Person(name, age) => println(               ""Age: "" + age + "" year, name: "" + name + ""?"")         }      }   }   case class Person(name: String, age: Int)}"
Learn Scala,Scala - Regular Expressions,Scala - Regular Expressions|||Forming Regular Expressions@@@Regular-Expression Examples@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"This chapter explains how Scala supports regular expressions through Regex class available in the scala.util.matching package.|||Try the following example program where we will try to find out word Scala from a statement.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||We create a String and call the r( ) method on it. Scala implicitly converts the String to a RichString and invokes that method to get an instance of Regex. To find a first match of the regular expression, simply call the findFirstIn() method. If instead of finding only the first occurrence we would like to find all occurrences of the matching word, we can use the findAllIn( ) method and in case there are multiple Scala words available in the target string, this will return a collection of all matching words.|||You can make use of the mkString( ) method to concatenate the resulting list and you can use a pipe (|) to search small and capital case of Scala and you can use Regex constructor instead or r() method to create a pattern.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||If you would like to replace matching text, we can use replaceFirstIn( ) to replace the first match or replaceAllIn( ) to replace  all occurrences.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl. Here are just some examples that should be enough as refreshers −|||Following is the table listing down all the regular expression Meta character syntax available in Java.|||Note − that every backslash appears twice in the string above. This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string. So instead of ‘\’, you need to write ‘\\’ to get a single backslash in the string.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,"Subexpression@@@Matches|||^@@@Matches beginning of line.|||$@@@Matches end of line.|||.@@@Matches any single character except newline. Using m option allows it to match newline as well.|||[...]@@@Matches any single character in brackets.|||[^...]@@@Matches any single character not in brackets|||\\A@@@Beginning of entire string|||\\z@@@End of entire string|||\\Z@@@End of entire string except allowable final line terminator.|||re*@@@Matches 0 or more occurrences of preceding expression.|||re+@@@Matches 1 or more of the previous thing|||re?@@@Matches 0 or 1 occurrence of preceding expression.|||re{ n}@@@Matches exactly n number of occurrences of preceding expression.|||re{ n,}@@@Matches n or more occurrences of preceding expression.|||re{ n, m}@@@Matches at least n and at most m occurrences of preceding expression.|||a|b@@@Matches either a or b.|||(re)@@@Groups regular expressions and remembers matched text.|||(?: re)@@@Groups regular expressions without remembering matched text.|||(?> re)@@@Matches independent pattern without backtracking.|||\\w@@@Matches word characters.|||\\W@@@Matches nonword characters.|||\\s@@@Matches whitespace. Equivalent to [\t\n\r\f].|||\\S@@@Matches nonwhitespace.|||\\d@@@Matches digits. Equivalent to [0-9].|||\\D@@@Matches nondigits.|||\\A@@@Matches beginning of string.|||\\Z@@@Matches end of string. If a newline exists, it matches just before newline.|||\\z@@@Matches end of string.|||\\G@@@Matches point where last match finished.|||\\n@@@Back-reference to capture group number ""n""|||\\b@@@Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.|||\\B@@@Matches nonword boundaries.|||\\n, \\t, etc.@@@Matches newlines, carriage returns, tabs, etc.|||\\Q@@@Escape (quote) all characters up to \\E|||\\E@@@Ends quoting begun with \\Q&&&Example@@@Description|||.@@@Match any character except newline|||[Rr]uby@@@Match ""Ruby"" or ""ruby""|||rub[ye]@@@Match ""ruby"" or ""rube""|||[aeiou]@@@Match any one lowercase vowel|||[0-9]@@@Match any digit; same as [0123456789]|||[a-z]@@@Match any lowercase ASCII letter|||[A-Z]@@@Match any uppercase ASCII letter|||[a-zA-Z0-9]@@@Match any of the above|||[^aeiou]@@@Match anything other than a lowercase vowel|||[^0-9]@@@Match anything other than a digit|||\\d@@@Match a digit: [0-9]|||\\D@@@Match a nondigit: [^0-9]|||\\s@@@Match a whitespace character: [ \t\r\n\f]|||\\S@@@Match nonwhitespace: [^ \t\r\n\f]|||\\w@@@Match a single word character: [A-Za-z0-9_]|||\\W@@@Match a nonword character: [^A-Za-z0-9_]|||ruby?@@@Match ""rub"" or ""ruby"": the y is optional|||ruby*@@@Match ""rub"" plus 0 or more ys|||ruby+@@@Match ""rub"" plus 1 or more ys|||\\d{3}@@@Match exactly 3 digits|||\\d{3,}@@@Match 3 or more digits|||\\d{3,5}@@@Match 3, 4, or 5 digits|||\\D\\d+@@@No group: + repeats \\d|||(\\D\\d)+/ @@@Grouped: + repeats \\D\d pair|||([Rr]uby(, )?)+@@@Match ""Ruby"", ""Ruby, ruby, ruby"", etc.","import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = ""Scala"".r      val str = ""Scala is Scalable and cool""            println(pattern findFirstIn str)   }}|||import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = new Regex(""(S|s)cala"")      val str = ""Scala is scalable and cool""            println((pattern findAllIn str).mkString("",""))   }}|||object Demo {   def main(args: Array[String]) {      val pattern = ""(S|s)cala"".r      val str = ""Scala is scalable and cool""            println(pattern replaceFirstIn(str, ""Java""))   }}|||import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = new Regex(""abl[ae]\\d+"")      val str = ""ablaw is able1 and cool""            println((pattern findAllIn str).mkString("",""))   }}"
Learn Scala,Scala - Exception Handling,Scala - Exception Handling|||Throwing Exceptions@@@Catching Exceptions@@@The finally Clause@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala's exceptions work like exceptions in many other languages like Java. Instead of returning a value in the normal way, a method can terminate by throwing an exception. However, Scala doesn't actually have checked exceptions.|||When you want to handle exceptions, you use a try{...}catch{...} block like you would in Java except that the catch block uses matching to identify and handle the exceptions.|||Throwing an exception looks the same as in Java. You create an exception object and then you throw it with the throw keyword as follows.|||Scala allows you to try/catch any exception in a single block and then perform pattern matching against it using case blocks. Try the following example program to handle exception.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The behavior of this try-catch expression is the same as in other languages with exceptions. The body is executed, and if it throws an exception, each catch clause is tried in turn.|||You can wrap an expression with a finally clause if you want to cause some code to execute no matter how the expression terminates. Try the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOExceptionobject Demo {   def main(args: Array[String]) {      try {         val f = new FileReader(""input.txt"")      } catch {         case ex: FileNotFoundException =>{            println(""Missing file exception"")         }                  case ex: IOException => {            println(""IO Exception"")         }      }   }}|||import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOExceptionobject Demo {   def main(args: Array[String]) {      try {         val f = new FileReader(""input.txt"")      } catch {         case ex: FileNotFoundException => {            println(""Missing file exception"")         }                  case ex: IOException => {            println(""IO Exception"")         }      } finally {         println(""Exiting finally..."")      }   }}"
Learn Scala,Scala - Extractors,Scala - Extractors|||Pattern Matching with Extractors@@@Useful Video Courses|||Example@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"An extractor in Scala is an object that has a method called unapply as one of its members. The purpose of that unapply method is to match a value and take it apart. Often, the extractor object also defines a dual method apply for building values, but this is not required.|||Let us take an example of object defines both apply and unapply methods. The apply method has the same meaning as always: it turns Test into an object that can be applied to arguments in parentheses in the same way a method is applied. So you can write Test (""Zara"", ""gmail.com"") to construct the string ""Zara@gmail.com"".|||The unapply method is what turns Test class into an extractor and it reverses the construction process of apply. Where apply takes two strings and forms an email address string out of them, unapply takes an email address and returns potentially two strings: the user and the domain of the address.|||The unapply must also handle the case where the given string is not an email address. That's why unapply returns an Option-type over pairs of strings. Its result is either Some (user, domain) if the string str is an email address with the given user and domain parts, or None, if str is not an email address. Here are some examples as follows.|||Following example program shows an extractor object for email addresses.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||When an instance of a class is followed by parentheses with a list of zero or more parameters, the compiler invokes the apply method on that instance. We can define apply both in objects and in classes.|||As mentioned above, the purpose of the unapply method is to extract a specific value we are looking for. It does the opposite operation apply does. When comparing an extractor object using the match statement the unapply method will be automatically executed.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) {      println (""Apply method : "" + apply(""Zara"", ""gmail.com""));      println (""Unapply method : "" + unapply(""Zara@gmail.com""));      println (""Unapply method : "" + unapply(""Zara Ali""));   }      // The injection method (optional)   def apply(user: String, domain: String) = {      user +""@""+ domain   }   // The extraction method (mandatory)   def unapply(str: String): Option[(String, String)] = {      val parts = str split ""@""            if (parts.length == 2){         Some(parts(0), parts(1))       } else {         None      }   }}|||object Demo {   def main(args: Array[String]) {      val x = Demo(5)      println(x)      x match {         case Demo(num) => println(x+"" is bigger two times than ""+num)                  //unapply is invoked         case _ => println(""i cannot calculate"")      }   }   def apply(x: Int) = x*2   def unapply(z: Int): Option[Int] = if (z%2==0) Some(z/2) else None}"
Learn Scala,Scala - Files I/O,Scala - Files I/O|||Reading a Line from Command Line@@@Reading File Content@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala is open to make use of any Java objects and java.io.File is one of the objects which can be used in Scala programming to read and write files.|||The following is an example program to writing to a file.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It will create a file named Demo.txt in the current directory, where the program is placed. The following is the content of that file.|||Sometime you need to read user input from the screen and then proceed for some further processing. Following example program shows you how to read input from the command line.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Reading from files is really simple. You can use Scala's Source class and its companion object to read files. Following is the example which shows you how to read from ""Demo.txt"" file which we created earlier.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import java.io._object Demo {   def main(args: Array[String]) {      val writer = new PrintWriter(new File(""test.txt"" ))      writer.write(""Hello Scala"")      writer.close()   }}|||object Demo {   def main(args: Array[String]) {      print(""Please enter your input : "" )      val line = Console.readLine            println(""Thanks, you just typed: "" + line)   }}|||import scala.io.Sourceobject Demo {   def main(args: Array[String]) {      println(""Following is the content read:"" )      Source.fromFile(""Demo.txt"" ).foreach {          print       }   }}"
Learn Scala,Scala - Quick Guide,Scala - Quick Guide@@@Scala - Overview@@@Scala - Environment Setup@@@Scala - Basic Syntax@@@Scala - Data Types@@@Scala - Variables@@@Scala - Classes & Objects@@@Scala - Access Modifiers@@@Scala - Operators@@@Scala - IF ELSE Statements@@@Scala - Loop Statements@@@Scala - Functions@@@Scala - Closures@@@Scala - Strings@@@Scala - Arrays@@@Scala - Collections@@@Scala - Traits@@@Scala - Pattern Matching@@@Scala - Regular Expressions@@@Scala - Exception Handling@@@Scala - Extractors@@@Scala - Files I/O|||Scala vs Java@@@Scala Web Frameworks@@@Step 1: Verify Your Java Installation@@@Step 2: Set Your Java Environment@@@Step 3: Install Scala@@@First Scala Program@@@Script Mode@@@Basic Syntax@@@Scala Identifiers@@@Scala Keywords@@@Comments in Scala@@@Blank Lines and Whitespace@@@Newline Characters@@@Scala Packages@@@Apply Dynamic@@@Scala Basic Literals@@@Escape Sequences@@@Variable Declaration@@@Variable Data Types@@@Variable Type Inference@@@Multiple assignments@@@Example Program@@@Variable Scope@@@Basic Class@@@Extending a Class@@@Implicit Classes@@@Singleton Objects@@@Private Members@@@Protected Members@@@Public Members@@@Scope of Protection@@@Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Assignment Operators@@@Operators Precedence in Scala@@@Flow Chart@@@if Statement@@@If-else Statement@@@If-else-if-else Statement@@@Nested if-else Statement@@@Flow Chart@@@Loop Control Statements@@@The infinite Loop@@@Function Declarations@@@Function Definitions@@@Calling Functions@@@Example@@@Command@@@Output@@@Creating a String@@@String Length@@@Concatenating Strings@@@Creating Format Strings@@@String Interpolation@@@The ‘s’ String Interpolator@@@The ‘ f ’ Interpolator@@@‘raw’ Interpolator@@@String Methods@@@Declaring Array Variables@@@Processing Arrays@@@Multi-Dimensional Arrays@@@Concatenate Arrays@@@Create Array with Range@@@Scala Array Methods@@@Value classes and Universal Traits@@@When to Use Traits?@@@Matching using Case Classes@@@Forming Regular Expressions@@@Regular-Expression Examples@@@Throwing Exceptions@@@Catching Exceptions@@@The finally Clause@@@Pattern Matching with Extractors@@@Reading a Line from Command Line@@@Reading File Content@@@Useful Video Courses|||Scala is object-oriented@@@Scala is functional@@@Scala is statically typed@@@Scala runs on the JVM@@@Scala can Execute Java Code@@@Scala can do Concurrent & Synchronize processing@@@Interactive Mode@@@Example@@@Output@@@Alphanumeric Identifiers@@@Operator Identifiers@@@Mixed Identifiers@@@Literal Identifiers@@@Integral Literals@@@Floating Point Literal@@@Boolean Literals@@@Symbol Literals@@@Character Literals@@@String Literals@@@Multi-Line Strings@@@Null Values@@@Example@@@Output@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Example@@@Command@@@Output@@@Fields@@@Method Parameters@@@Local Variables@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Example@@@Example@@@Example@@@Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Syntax@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala, short for Scalable Language, is a hybrid functional programming language. It was created by Martin Odersky. Scala smoothly integrates the features of object-oriented and functional languages. Scala is compiled to run on the Java Virtual Machine. Many existing companies, who depend on Java for business critical applications, are turning to Scala to boost their development productivity, applications scalability and overall reliability.|||Here we have presented a few points that makes Scala the first choice of application developers.|||Scala is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes and traits which will be explained in subsequent chapters.|||Classes are extended by subclassing and a flexible mixin-based composition mechanism as a clean replacement for multiple inheritance.|||Scala is also a functional language in the sense that every function is a value and every value is an object so ultimately every function is an object.|||Scala provides a lightweight syntax for defining anonymous functions, it supports higher-order functions, it allows functions to be nested, and supports currying. These concepts will be explained in subsequent chapters.|||Scala, unlike some of the other statically typed languages (C, Pascal, Rust, etc.), does not expect you to provide redundant type information. You don't have to specify a type in most cases, and you certainly don't have to repeat it.|||Scala is compiled into Java Byte Code which is executed by the Java Virtual Machine (JVM). This means that Scala and Java have a common runtime platform. You can easily move from Java to Scala.|||The Scala compiler compiles your Scala code into Java Byte Code, which can then be executed by the 'scala' command. The 'scala' command is similar to the java command, in that it executes your compiled Scala code.|||Scala enables you to use all the classes of the Java SDK and also your own custom Java classes, or your favorite Java open source projects.|||Scala allows you to express general programming patterns in an effective way. It reduces the number of lines and helps the programmer to code in a type-safe way. It allows you to write codes in an immutable manner, which makes it easy to apply concurrency and parallelism (Synchronize).|||Scala has a set of features that completely differ from Java. Some of these are −|||Scala is being used everywhere and importantly in enterprise web applications. You can check a few of the most popular Scala web frameworks −|||The Lift Framework|||The Play framework|||The Bowler framework|||Scala can be installed on any UNIX flavored or Windows based system. Before you start installing Scala on your machine, you must have Java 1.8 or greater installed on your computer.|||Follow the steps given below to install Scala.|||First of all, you need to have Java Software Development Kit (SDK) installed on your system. To verify this, execute any of the following two commands depending on the platform you are working on.|||If the Java installation has been done properly, then it will display the current version and specification of your Java installation. A sample output is given in the following table.|||Open Command Console and type −|||\>java –version|||Java version ""1.8.0_31""|||Java (TM) SE Run Time|||Environment (build 1.8.0_31-b31)|||Java Hotspot (TM) 64-bit Server|||VM (build 25.31-b07, mixed mode)|||Open Command terminal and type −|||$java –version|||Java version ""1.8.0_31""|||Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)|||Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)|||We assume that the readers of this tutorial have Java SDK version 1.8.0_31 installed on their system.|||In case you do not have Java SDK, download its current version from http://www.oracle.com/technetwork/java/javase/downloads/index.html and install it.|||Set the environment variable JAVA_HOME to point to the base directory location where Java is installed on your machine. For example,|||Windows|||Set JAVA_HOME to C:\ProgramFiles\java\jdk1.7.0_60|||Linux|||Export JAVA_HOME=/usr/local/java-current|||Append the full path of Java compiler location to the System Path.|||Windows|||Append the String ""C:\Program Files\Java\jdk1.7.0_60\bin"" to the end of the system variable PATH.|||Linux|||Export PATH=$PATH:$JAVA_HOME/bin/|||Execute the command java -version from the command prompt as explained above.|||You can download Scala from http://www.scala-lang.org/downloads. At the time of writing this tutorial, I downloaded ‘scala-2.11.5-installer.jar’. Make sure you have admin privilege to proceed. Now, execute the following command at the command prompt −|||\>java –jar scala-2.11.5-installer.jar\>|||This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path “C:\Program Files\Scala”, you can select a suitable path as per your convenience.|||Command −|||$java –jar scala-2.9.0.1-installer.jar|||Output −|||Welcome to the installation of Scala 2.9.0.1!|||The homepage is at − http://Scala-lang.org/|||press 1 to continue, 2 to quit, 3 to redisplay|||1................................................|||[ Starting to unpack ]|||[ Processing package: Software Package Installation (1/1) ]|||[ Unpacking finished ]|||[ Console installation done ]|||During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.|||Finally, open a new command prompt and type Scala -version and press Enter. You should see the following −|||\>scala -version|||Scala code runner version 2.11.5 -- Copyright 2002-2013, LAMP/EPFL|||$scala -version|||Scala code runner version 2.9.0.1 – Copyright 2002-2013, LAMP/EPFL|||If you have a good understanding on Java, then it will be very easy for you to learn Scala. The biggest syntactic difference between Scala and Java is that the ';' line end character is optional.|||When we consider a Scala program, it can be defined as a collection of objects that communicate via invoking each other’s methods. Let us now briefly look into what do class, object, methods and instance variables mean.|||Object − Objects have states and behaviors. An object is an instance of a class. Example − A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating.|||Class  − A class can be defined as a template/blueprint that describes the behaviors/states that are related to the class.|||Methods − A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.|||Fields − Each object has its unique set of instance variables, which are called fields. An object's state is created by the values assigned to these fields.|||Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.|||Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.|||We can execute a Scala program in two modes: one is interactive mode and another is script mode.|||Open the command prompt and use the following command to open Scala.|||If Scala is installed in your system, the following output will be displayed −|||Type the following text to the right of the Scala prompt and press the Enter key −|||It will produce the following result −|||Use the following instructions to write a Scala program in script mode. Open notepad and add the following code into it.|||Save the file as − HelloWorld.scala.|||Open the command prompt window and go to the directory where the program file is saved. The ‘scalac’ command is used to compile the Scala program and it will generate a few class files in the current directory. One of them will be called HelloWorld.class. This is a bytecode which will run on Java Virtual Machine (JVM) using ‘scala’ command.|||Use the following command to compile and execute your Scala program.|||The following are the basic syntaxes and coding conventions in Scala programming.|||Case Sensitivity − Scala is case-sensitive, which means identifier Hello and hello would have different meaning in Scala.|||Class Names − For all class names, the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.|||Example − class MyFirstScalaClass.|||Method Names − All method names should start with a Lower Case letter. If multiple words are used to form the name of the method, then each inner word's first letter should be in Upper Case.|||Example − def myMethodName()|||Program File Name − Name of the program file should exactly match the object name. When saving the file you should save it using the object name (Remember Scala is case-sensitive) and append ‘.scala’ to the end of the name. (If the file name and the object name do not match your program will not compile).|||Example − Assume 'HelloWorld' is the object name. Then the file should be saved as 'HelloWorld.scala'.|||def main(args: Array[String]) − Scala program processing starts from the main() method which is a mandatory part of every Scala Program.|||All Scala components require names. Names used for objects, classes, variables and methods are called identifiers. A keyword cannot be used as an identifier and identifiers are case-sensitive. Scala supports four types of identifiers.|||An alphanumeric identifier starts with a letter or an underscore, which can be followed by further letters, digits, or underscores. The '$' character is a reserved keyword in Scala and should not be used in identifiers.|||Following are legal alphanumeric identifiers −|||Following are illegal identifiers −|||An operator identifier consists of one or more operator characters. Operator characters are printable ASCII characters such as +, :, ?, ~ or #.|||Following are legal operator identifiers −|||The Scala compiler will internally ""mangle"" operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-> would be represented internally as $colon$minus$greater.|||A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier.|||Following are legal mixed identifiers −|||Here, unary_+ used as a method name defines a unary + operator and myvar_= used as method name defines an assignment operator (operator overloading).|||A literal identifier is an arbitrary string enclosed in back ticks (` . . . `).|||Following are legal literal identifiers −|||The following list shows the reserved words in Scala. These reserved words may not be used as constant or variable or any other identifier names.|||Scala supports single-line and multi-line comments very similar to Java. Multi-line comments may be nested, but are required to be properly nested. All characters available inside any comment are ignored by Scala compiler.|||A line containing only whitespace, possibly with a comment, is known as a blank line, and Scala totally ignores it. Tokens may be separated by whitespace characters and/or comments.|||Scala is a line-oriented language where statements may be terminated by semicolons (;) or newlines. A semicolon at the end of a statement is usually optional. You can type one if you want but you don't have to if the statement appears by itself on a single line. On the other hand, a semicolon is required if you write multiple statements on a single line. Below syntax is the usage of multiple statements.|||A package is a named module of code. For example, the Lift utility package is net.liftweb.util. The package declaration is the first non-comment line in the source file as follows −|||Scala packages can be imported so that they can be referenced in the current compilation scope. The following statement imports the contents of the scala.xml package −|||You can import a single class and object, for example, HashMap from the scala.collection.mutable package −|||You can import more than one class or object from a single package, for example, TreeMap and TreeSet from the scala.collection.immutable package −|||A marker trait that enables dynamic invocations. Instances x of this trait allow method invocations x.meth(args) for arbitrary method names meth and argument lists args as well as field accesses x.field for arbitrary field namesfield. This feature is introduced in Scala-2.10.|||If a call is not natively supported by x (i.e. if type checking fails), it is rewritten according to the following rules −|||Scala has all the same data types as Java, with the same memory footprint and precision. Following is the table giving details about all the data types available in Scala −|||Byte|||8 bit signed value. Range from -128 to 127|||Short|||16 bit signed value. Range -32768 to 32767|||Int|||32 bit signed value. Range -2147483648 to 2147483647|||Long|||64 bit signed value. -9223372036854775808 to 9223372036854775807|||Float|||32 bit IEEE 754 single-precision float|||Double|||64 bit IEEE 754 double-precision float|||Char|||16 bit unsigned Unicode character. Range from U+0000 to U+FFFF|||String|||A sequence of Chars|||Boolean|||Either the literal true or the literal false|||Unit|||Corresponds to no value|||Null|||null or empty reference|||Nothing|||The subtype of every other type; includes no values|||Any|||The supertype of any type; any object is of type Any|||AnyRef|||The supertype of any reference type|||All the data types listed above are objects. There are no primitive types like in Java. This means that you can call methods on an Int, Long, etc.|||The rules Scala uses for literals are simple and intuitive. This section explains all basic Scala Literals.|||Integer literals are usually of type Int, or of type Long when followed by a L or l suffix. Here are some integer literals −|||Floating point literals are of type Float when followed by a floating point type suffix F or f, and are of type Double otherwise. Here are some floating point literals −|||The Boolean literals true and false are members of type Boolean.|||A symbol literal 'x is a shorthand for the expression scala.Symbol(""x""). Symbol is a case class, which is defined as follows.|||A character literal is a single character enclosed in quotes. The character is either a printable Unicode character or is described by an escape sequence. Here are some character literals −|||A string literal is a sequence of characters in double quotes. The characters are either printable Unicode character or are described by escape sequences. Here are some string literals −|||A multi-line string literal is a sequence of characters enclosed in triple quotes """""" ... """""". The sequence of characters is arbitrary, except that it may contain three or more consecutive quote characters only at the very end.|||Characters must not necessarily be printable; newlines or other control characters are also permitted. Here is a multi-line string literal −|||The null value is of type scala.Null and is thus compatible with every reference type. It denotes a reference value which refers to a special ""null"" object.|||The following escape sequences are recognized in character and string literals.|||A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e., a backslash '\' followed by a sequence of up to three octal characters. Following is the example to show few escape sequence characters −|||When the above code is compiled and executed, it produces the following result −|||Variables are nothing but reserved memory locations to store values. This means that when you create a variable, you reserve some space in memory.|||Based on the data type of a variable, the compiler allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.|||Scala has a different syntax for declaring variables. They can be defined as value, i.e., constant or a variable. Here, myVar is declared using the keyword var. It is a variable that can change value and this is called mutable variable. Following is the syntax to define a variable using var keyword −|||Here, myVal is declared using the keyword val. This means that it is a variable that cannot be changed and this is called immutable variable. Following is the syntax to define a variable using val keyword −|||The type of a variable is specified after the variable name and before equals sign. You can define any type of Scala variable by mentioning its data type as follows −|||If you do not assign any initial value to a variable, then it is valid as follows −|||When you assign an initial value to a variable, the Scala compiler can figure out the type of the variable based on the value assigned to it. This is called variable type inference. Therefore, you could write these variable declarations like this −|||Here, by default, myVar will be Int type and myVal will become String type variable.|||Scala supports multiple assignments. If a code block or method returns a Tuple (Tuple − Holds collection of Objects of different types), the Tuple can be assigned to a val variable. [Note − We will study Tuples in subsequent chapters.]|||And the type inference gets it right −|||The following is an example program that explains the process of variable declaration in Scala. This program declares four variables — two variables are defined with type declaration and remaining two are without type declaration.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Variables in Scala can have three different scopes depending on the place where they are being used. They can exist as fields, as method parameters and as local variables. Below are the details about each type of scope.|||Fields are variables that belong to an object. The fields are accessible from inside every method in the object. Fields can also be accessible outside the object depending on what access modifiers the field is declared with. Object fields can be both mutable and immutable types and can be defined using either var or val.|||Method parameters are variables, which are used to pass the value inside a method, when the method is called. Method parameters are only accessible from inside the method but the objects passed in may be accessible from the outside, if you have a reference to the object from outside the method. Method parameters are always immutable which are defined by val keyword.|||Local variables are variables declared inside a method. Local variables are only accessible from inside the method, but the objects you create may escape the method if you return them from the method. Local variables can be both mutable and immutable types and can be defined using either var or val.|||This chapter takes you through how to use classes and objects in Scala programming. A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword new. Through the object you can use all functionalities of the defined class.|||The following diagram demonstrates the class and object by taking an example of class student, which contains the member variables (name and roll no) and member methods (setName() and setRollNo()). Finally all are members of the class. Class is a blue print and objects are real here. In the following diagram, Student is a class and Harini, John, and Maria are the objects of Student class, those are having name and roll-number.|||Following is a simple syntax to define a basic class in Scala. This class defines two variables x and y and a method: move, which does not return a value. Class variables are called, fields of the class and methods are called class methods.|||The class name works as a class constructor which can take a number of parameters. The above code defines two constructor arguments, xc and yc; they are both visible in the whole body of the class.|||As mentioned earlier in this chapter, you can create objects using a keyword new and then you can access class fields and methods as shown below in the example −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can extend a base Scala class and you can design an inherited class in the same way you do it in Java (use extends key word), but there are two restrictions: method overriding requires the override keyword, and only the primary constructor can pass parameters to the base constructor. Let us extend our above class and add one more class method.|||Let us take an example of two classes Point class (as same example as above) and Location class is inherited class using extends keyword. Such an ‘extends’ clause has two effects: it makes Location class inherit all non-private members from Point class, and it makes the type Location a subtype of the type Point class. So here the Point class is called superclass and the class Location is called subclass. Extending a class and inheriting all the features of a parent class is called inheritance but Scala allows the inheritance from just one class only.|||Note − Methods move() method in Point class and move() method in Location class do not override the corresponding definitions of move since they are different definitions (for example, the former take two arguments while the latter take three arguments).|||Try the following example program to implement inheritance.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Implicit classes allow implicit conversations with class’s primary constructor when the class is in scope. Implicit class is a class marked with ‘implicit’ keyword. This feature is introduced in Scala 2.10.|||Syntax − The following is the syntax for implicit classes. Here implicit class is always in the object scope where all method definitions are allowed because implicit class cannot be a top level class.|||Let us take an example of an implicit class named IntTimes with the method times(). It means the times () contain a loop transaction that will execute the given statement in number of times that we give. Let us assume the given statement is “4 times println (“Hello”)” means the println (“”Hello”) statement will execute 4 times.|||The following is the program for the given example. In this example two object classes are used (Run and Demo) so that we have to save those two classes in different files with their respective names as follows.|||Run.scala − Save the following program in Run.scala.|||Demo.scala − Save the following program in Demo.scala.|||The following commands are used to compile and execute these two programs.|||Note −|||Implicit classes must be defined inside another class/object/trait (not in top level).|||Implicit classes may only take one non –implicit argument in their constructor.|||Implicit classes may not be any method, member or object in scope with the same name as the implicit class.|||Scala is more object-oriented than Java because in Scala, we cannot have static members. Instead, Scala has singleton objects. A singleton is a class that can have only one instance, i.e., Object. You create singleton using the keyword object instead of class keyword. Since you can't instantiate a singleton object, you can't pass parameters to the primary constructor. You already have seen all the examples using singleton objects where you called Scala's main method.|||Following is the same example program to implement singleton.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||This chapter takes you through the Scala access modifiers. Members of packages, classes or objects can be labeled with the access modifiers private and protected, and if we are not using either of these two keywords, then access will be assumed as public. These modifiers restrict accesses to the members to certain regions of code. To use an access modifier, you include its keyword in the definition of members of package, class or object as we will see in the following section.|||A private member is visible only inside the class or object that contains the member definition.|||Following is the example code snippet to explain Private member −|||In Scala, the access (new Inner). f() is illegal because f is declared private in Inner and the access is not from within class Inner. By contrast, the first access to f in class Innermost is OK, because that access is contained in the body of class Inner. Java would permit both accesses because it lets an outer class access private members of its inner classes.|||A protected member is only accessible from subclasses of the class in which the member is defined.|||Following is the example code snippet to explain protected member −|||The access to f in class Sub is OK because f is declared protected in ‘Super’ class and ‘Sub’ class is a subclass of Super. By contrast the access to f in ‘Other’ class is not permitted, because class ‘Other’ does not inherit from class ‘Super’. In Java, the latter access would be still permitted because ‘Other’ class is in the same package as ‘Sub’ class.|||Unlike private and protected members, it is not required to specify Public keyword for Public members. There is no explicit modifier for public members. Such members can be accessed from anywhere.|||Following is the example code snippet to explain public member −|||Access modifiers in Scala can be augmented with qualifiers. A modifier of the form private[X] or protected[X] means that access is private or protected ""up to"" X, where X designates some enclosing package, class or singleton object.|||Consider the following example −|||Note − the following points from the above example −|||Variable workDetails will be accessible to any class within the enclosing package professional.|||Variable friends will be accessible to any class within the enclosing package society.|||Variable secrets will be accessible only on the implicit object within instance methods (this).|||An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Scala is rich in built-in operators and provides the following types of operators −|||This chapter will examine the arithmetic, relational, logical, bitwise, assignment and other operators one by one.|||The following arithmetic operators are supported by Scala language. For example, let us assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||The following relational operators are supported by Scala language. For example let us assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||The following logical operators are supported by Scala language. For example, assume variable A holds 1 and variable B holds 0, then −|||Show Examples|||Bitwise operator works on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows −|||Assume if A = 60; and B = 13; now in binary format they will be as follows −|||The Bitwise operators supported by Scala language is listed in the following table. Assume variable A holds 60 and variable B holds 13, then −|||Show Examples|||There are following assignment operators supported by Scala language −|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator −|||For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.|||Take a look at the following table. Operators with the highest precedence appear at the top of the table and those with the lowest precedence appear at the bottom. Within an expression, higher precedence operators will be evaluated first.|||This chapter takes you through the conditional construction statements in Scala programming. Following is the general form of a typical decision making IF...ELSE structure found in most of the programming languages.|||The following is a flow chart diagram for conditional statement.|||‘if’ statement consists of a Boolean expression followed by one or more statements.|||The syntax of an ‘if’ statement is as follows.|||If the Boolean expression evaluates to true then the block of code inside the ‘if’ expression will be executed. If not, the first set of code after the end of the ‘if’ expression (after the closing curly brace) will be executed.|||Try the following example program to understand conditional expressions (if expression) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An ‘if’ statement can be followed by an optional else statement, which executes when the Boolean expression is false.|||The syntax of a if...else is −|||Try the following example program to understand conditional statements (if- else statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An 'if' statement can be followed by an optional 'else if...else' statement, which is very useful to test various conditions using single if...else if statement.|||When using if , else if , else statements there are few points to keep in mind.|||An 'if' can have zero or one else's and it must come after any else if's.|||An 'if' can have zero to many else if's and they must come before the else.|||Once an else if succeeds, none of he remaining else if's or else's will be tested.|||The following is the syntax of an ‘if...else if...else’ is as follows −|||Try the following example program to understand conditional statements (if- else- if- else statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It is always legal to nest if-else statements, which means you can use one if or else-if statement inside another if or else-if statement.|||The syntax for a nested if-else is as follows −|||Try the following example program to understand conditional statements (nested- if statement) in Scala Programming Language.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||This chapter takes you through the loop control structures in Scala programming languages.|||There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −|||Scala programming language provides the following types of loops to handle looping requirements. Click the following links in the table to check their detail.|||while loop|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||do-while loop|||Like a while statement, except that it tests the condition at the end of the loop body.|||for loop|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. As such Scala does not support break or continue statement like Java does but starting from Scala version 2.8, there is a way to break the loops. Click the following links to check the detail.|||break statement|||Terminates the loop statement and transfers execution to the statement immediately following the loop.|||A loop becomes an infinite loop if a condition never becomes false. If you are using Scala, the while loop is the best way to implement infinite loop.|||The following program implements infinite loop.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||If you will execute above code, it will go in infinite loop which you can terminate by pressing Ctrl + C keys.|||A function is a group of statements that perform a task. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically, the division usually is so that each function performs a specific task.|||Scala has both functions and methods and we use the terms method and function interchangeably with a minor difference. A Scala method is a part of a class which has a name, a signature, optionally some annotations, and some bytecode where as a function in Scala is a complete object which can be assigned to a variable. In other words, a function, which is defined as a member of some object, is called a method.|||A function definition can appear anywhere in a source file and Scala permits nested function definitions, that is, function definitions inside other function definitions. Most important point to note is that Scala function's name can have characters like +, ++, ~, &,-, --, \, /, :, etc.|||A Scala function declaration has the following form −|||Methods are implicitly declared abstract if you don’t use the equals sign and the method body.|||A Scala function definition has the following form −|||Here, return type could be any valid Scala data type and list of parameters will be a list of variables separated by comma and list of parameters and return type are optional. Very similar to Java, a return statement can be used along with an expression in case function returns a value. Following is the function which will add two integers and return their sum −|||A function, that does not return anything can return a Unit that is equivalent to void in Java and indicates that function does not return anything. The functions which do not return anything in Scala, they are called procedures.|||Here is the syntax −|||Scala provides a number of syntactic variations for invoking methods. Following is the standard way to call a method −|||If a function is being called using an instance of the object, then we would use dot notation similar to Java as follows −|||Try the following example program to define and then call the same function.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala functions are the heart of Scala programming and that's why Scala is assumed as a functional programming language. Following are few important concepts related to Scala functions which should be understood by a Scala programmer.|||A closure is a function, whose return value depends on the value of one or more variables declared outside this function.|||The following piece of code with anonymous function.|||Here the only variable used in the function body, i * 10 , is i, which is defined as a parameter to the function. Try the following code −|||There are two free variables in multiplier: i and factor. One of them, i, is a formal parameter to the function. Hence, it is bound to a new value each time multiplier is called. However, factor is not a formal parameter, then what is this? Let us add one more line of code.|||Now factor has a reference to a variable outside the function but in the enclosing scope. The function references factor and reads its current value each time. If a function has no external references, then it is trivially closed over itself. No external context is required.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||This chapter takes you through the Scala Strings. In Scala, as in Java, a string is an immutable object, that is, an object that cannot be modified. On the other hand, objects that can be modified, like arrays, are called mutable objects. Strings are very useful objects, in the rest of this section, we present important methods of java.lang.String class.|||The following code can be used to create a String −|||Whenever compiler encounters a string literal in the code, it creates a String object with its value, in this case, “Hello world!”. String keyword can also be given in alternate declaration as shown above.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||As mentioned earlier, String class is immutable. String object once created cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters then use String Builder Class available in Scala!.|||Methods used to obtain information about an object are known as accessor methods. One accessor method that can be used with strings is the length() method, which returns the number of characters contained in the string object.|||Use the following code segment to find the length of a string −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The String class includes a method for concatenating two strings −|||This returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in −|||Strings are more commonly concatenated with the + operator, as in −|||Which results in −|||The following lines of code to find string length.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.|||Try the following example program, which makes use of printf() method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||String Interpolation is the new way to create Strings in Scala programming language. This feature supports the versions of Scala-2.10 and later. String Interpolation: The mechanism to embed variable references directly in process string literal.|||There are three types (interpolators) of implementations in String Interpolation.|||The literal ‘s’ allows the usage of variable directly in processing a string, when you prepend ‘s’ to it. Any String variable with in a scope that can be used with in a String. The following are the different usages of ‘s’ String interpolator.|||The following example code snippet for the implementation of ‘s’ interpolator in appending String variable ($name) to a normal String (Hello) in println statement.|||String interpolater can also process arbitrary expressions. The following code snippet for Processing a String (1 + 1) with arbitrary expression (${1 + 1}) using ‘s’ String interpolator. Any arbitrary expression can be embedded in ‘${}’.|||Try the following example program of implementing ‘s’ interpolator.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The literal ‘f’ interpolator allows to create a formatted String, similar to printf in C language. While using ‘f’ interpolator, all variable references should be followed by the printf style format specifiers such as %d, %i, %f, etc.|||Let us take an example of append floating point value (height = 1.9d) and String variable (name = “James”) with normal string. The following code snippet of implementing ‘f’ Interpolator. Here $name%s to print (String variable) James and $height%2.2f to print (floating point value) 1.90.|||It is type safe (i.e.) the variable reference and following format specifier should match otherwise it is showing error. The ‘ f ’ interpolator makes use of the String format utilities (format specifiers) available in Java. By default means, there is no % character after variable reference. It will assume as %s (String).|||The ‘raw’ interpolator is similar to ‘s’ interpolator except that it performs no escaping of literals within a string. The following code snippets in a table will differ the usage of ‘s’ and ‘raw’ interpolators. In outputs of ‘s’ usage ‘\n’ effects as new line and in output of ‘raw’ usage the ‘\n’ will not effect. It will print the complete string with escape letters.|||Program −|||Program −|||Output −|||Output −|||Following is the list of methods defined by java.lang.String class and can be used directly in your Scala programs −|||char charAt(int index)|||Returns the character at the specified index.|||int compareTo(Object o)|||Compares this String to another Object.|||int compareTo(String anotherString)|||Compares two strings lexicographically.|||int compareToIgnoreCase(String str)|||Compares two strings lexicographically, ignoring case differences.|||String concat(String str)|||Concatenates the specified string to the end of this string.|||boolean contentEquals(StringBuffer sb)|||Returns true if and only if this String represents the same sequence of characters as the specified StringBuffer.|||static String copyValueOf(char[] data)|||Returns a String that represents the character sequence in the array specified.|||static String copyValueOf(char[] data, int offset, int count)|||Returns a String that represents the character sequence in the array specified.|||boolean endsWith(String suffix)|||Tests if this string ends with the specified suffix.|||boolean equals(Object anObject)|||Compares this string to the specified object.|||boolean equalsIgnoreCase(String anotherString)|||Compares this String to another String, ignoring case considerations.|||byte getBytes()|||Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.|||byte[] getBytes(String charsetName)|||Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.|||void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)|||Copies characters from this string into the destination character array.|||int hashCode()|||Returns a hash code for this string.|||int indexOf(int ch)|||Returns the index within this string of the first occurrence of the specified character.|||int indexOf(int ch, int fromIndex)|||Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.|||int indexOf(String str)|||Returns the index within this string of the first occurrence of the specified substring.|||int indexOf(String str, int fromIndex)|||Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.|||String intern()|||Returns a canonical representation for the string object.|||int lastIndexOf(int ch)|||Returns the index within this string of the last occurrence of the specified character.|||int lastIndexOf(int ch, int fromIndex)|||Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.|||int lastIndexOf(String str)|||Returns the index within this string of the rightmost occurrence of the specified substring.|||int lastIndexOf(String str, int fromIndex)|||Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.|||int length()|||Returns the length of this string.|||boolean matches(String regex)|||Tells whether or not this string matches the given regular expression.|||boolean regionMatches(boolean ignoreCase, int toffset, String other, int offset, int len)|||Tests if two string regions are equal.|||boolean regionMatches(int toffset, String other, int offset, int len)|||Tests if two string regions are equal.|||String replace(char oldChar, char newChar)|||Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.|||String replaceAll(String regex, String replacement|||Replaces each substring of this string that matches the given regular expression with the given replacement.|||String replaceFirst(String regex, String replacement)|||Replaces the first substring of this string that matches the given regular expression with the given replacement.|||String[] split(String regex)|||Splits this string around matches of the given regular expression.|||String[] split(String regex, int limit)|||Splits this string around matches of the given regular expression.|||boolean startsWith(String prefix)|||Tests if this string starts with the specified prefix.|||boolean startsWith(String prefix, int toffset)|||Tests if this string starts with the specified prefix beginning a specified index.|||CharSequence subSequence(int beginIndex, int endIndex)|||Returns a new character sequence that is a subsequence of this sequence.|||String substring(int beginIndex)|||Returns a new string that is a substring of this string.|||String substring(int beginIndex, int endIndex)|||Returns a new string that is a substring of this string.|||char[] toCharArray()|||Converts this string to a new character array.|||String toLowerCase()|||Converts all of the characters in this String to lower case using the rules of the default locale.|||String toLowerCase(Locale locale)|||Converts all of the characters in this String to lower case using the rules of the given Locale.|||String toString()|||This object (which is already a string!) is itself returned.|||String toUpperCase()|||Converts all of the characters in this String to upper case using the rules of the default locale.|||String toUpperCase(Locale locale)|||Converts all of the characters in this String to upper case using the rules of the given Locale.|||String trim()|||Returns a copy of the string, with leading and trailing whitespace omitted.|||static String valueOf(primitive data type x)|||Returns the string representation of the passed data type argument.|||Scala provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.|||Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables. The index of the first element of an array is the number zero and the index of the last element is the total number of elements minus one.|||To use an array in a program, you must declare a variable to reference the array and you must specify the type of array the variable can reference.|||The following is the syntax for declaring an array variable.|||Here, z is declared as an array of Strings that may hold up to three elements. Values can be assigned to individual elements or get access to individual elements, it can be done by using commands like the following −|||Here, the last example shows that in general the index can be any expression that yields a whole number. There is one more way of defining an array −|||Following picture represents an array myList. Here, myList holds ten double values and the indices are from 0 to 9.|||When processing array elements, we often use loop contol structures because all of the elements in an array are of the same type and the size of the array is known.|||Below is an example program of showing how to create, initialize and process arrays −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala does not directly support various array operations and provides various methods to process arrays in any dimension. If you want to use the different methods then it is required to import Array._ package.|||There are many situations where you would need to define and use multi-dimensional arrays (i.e., arrays whose elements are arrays). For example, matrices and tables are examples of structures that can be realized as two-dimensional arrays.|||The following is the example of defining a two-dimensional array −|||This is an array that has three elements each being an array of integers that has three elements.|||Try the following example program to process a multi-dimensional array −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Try the following example which makes use of concat() method to concatenate two arrays. You can pass more than one array as arguments to concat() method.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Use of range() method to generate an array containing a sequence of increasing integers in a given range. You can use final argument as step to create the sequence; if you do not use final argument, then step would be assumed as 1.|||Let us take an example of creating an array of range (10, 20, 2): It means creating an array with elements between 10 and 20 and range difference 2. Elements in the array are 10, 12, 14, 16, and 18.|||Another example: range (10, 20). Here range difference is not given so by default it assumes 1 element. It create an array with the elements in between 10 and 20 with range difference 1. Elements in the array are 10, 11, 12, 13, …, and 19.|||The following example program shows how to create an array with ranges.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following are the important methods, which you can use while playing with array. As shown above, you would have to import Array._ package before using any of the mentioned methods. For a complete list of methods available, please check official documentation of Scala.|||def apply( x: T, xs: T* ): Array[T]|||Creates an array of T objects, where T can be Unit, Double, Float, Long, Int, Char, Short, Byte, Boolean.|||def concat[T]( xss: Array[T]* ): Array[T]|||Concatenates all arrays into a single array.|||def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit|||Copy one array to another. Equivalent to Java's System.arraycopy(src, srcPos, dest, destPos, length).|||def empty[T]: Array[T]|||Returns an array of length 0|||def iterate[T]( start: T, len: Int )( f: (T) => T ): Array[T]|||Returns an array containing repeated applications of a function to a start value.|||def fill[T]( n: Int )(elem: =>  T): Array[T]|||Returns an array that contains the results of some element computation a number of times.|||def fill[T]( n1: Int, n2: Int )( elem: => T ): Array[Array[T]]|||Returns a two-dimensional array that contains the results of some element computation a number of times.|||def iterate[T]( start: T, len: Int)( f: (T) => T ): Array[T]|||Returns an array containing repeated applications of a function to a start value.|||def ofDim[T]( n1: Int ): Array[T]|||Creates array with given dimensions.|||def ofDim[T]( n1: Int, n2: Int ): Array[Array[T]]|||Creates a 2-dimensional array|||def ofDim[T]( n1: Int, n2: Int, n3: Int ): Array[Array[Array[T]]]|||Creates a 3-dimensional array|||def range( start: Int, end: Int, step: Int ): Array[Int]|||Returns an array containing equally spaced values in some integer interval.|||def range( start: Int, end: Int ): Array[Int]|||Returns an array containing a sequence of increasing integers in a range.|||def tabulate[T]( n: Int )(f: (Int)=> T): Array[T]|||Returns an array containing values of a given function over a range of integer values starting from 0.|||def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) => T): Array[Array[T]]|||Returns a two-dimensional array containing values of a given function over ranges of integer values starting from 0.|||Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map, etc. The collections may have an arbitrary number of elements or be bounded to zero or one element (e.g., Option).|||Collections may be strict or lazy. Lazy collections have elements that may not consume memory until they are accessed, like Ranges. Additionally, collections may be mutable (the contents of the reference can change) or immutable (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.|||For some problems, mutable collections work better, and for others, immutable collections work better. When in doubt, it is better to start with an immutable collection and change it later if you need mutable ones.|||This chapter throws light on the most commonly used collection types and most frequently used operations over those collections.|||Scala Lists|||Scala's List[T] is a linked list of type T.|||Scala Sets|||A set is a collection of pairwise different elements of the same type.|||Scala Maps|||A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||Scala Tuples|||Unlike an array or list, a tuple can hold objects with different types.|||Scala Options|||Option[T] provides a container for zero or one element of a given type.|||Scala Iterators|||An iterator is not a collection, but rather a way to access the elements of a collection one by one.|||A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits.|||Traits are used to define object types by specifying the signature of the supported methods. Scala also allows traits to be partially implemented but traits may not have constructor parameters.|||A trait definition looks just like a class definition except that it uses the keyword trait. The following is the basic example syntax of trait.|||This trait consists of two methods isEqual and isNotEqual. Here, we have not given any implementation for isEqual where as another method has its implementation. Child classes extending a trait can give implementation for the un-implemented methods. So a trait is very similar to what we have abstract classes in Java.|||Let us assume an example of trait Equal contain two methods isEqual() and isNotEqual(). The trait Equal contain one implemented method that is isEqual() so when user defined class Point extends the trait Equal, implementation to isEqual() method in Point class should be provided.|||Here it is required to know two important method of Scala, which are used in the following example.|||obj.isInstanceOf [Point] To check Type of obj and Point are same are not.|||obj.asInstanceOf [Point] means exact casting by taking the object obj type and returns the same obj as Point type.|||Try the following example program to implement traits.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Value classes are new mechanism in Scala to avoid allocating runtime objects. It contains a primary constructor with exactly one val parameter. It contains only methods (def) not allowed var, val, nested classes, traits, or objects. Value class cannot be extended by another class. This can be possible by extending your value class with AnyVal. The typesafety of custom datatypes without the runtime overhead.|||Let us take an examples of value classes Weight, Height, Email, Age, etc. For all these examples it is not required to allocate memory in the application.|||A value class not allowed to extend traits. To permit value classes to extend traits, universal traits are introduced which extends for Any.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It will give you the hash code of Wrapper class.|||There is no firm rule, but here are few guidelines to consider −|||If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.|||If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.|||If you want to inherit from it in Java code, use an abstract class.|||If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.|||If efficiency is very important, lean towards using a class.|||Pattern matching is the second most widely used feature of Scala, after function values and closures. Scala provides great support for pattern matching, in processing the messages.|||A pattern match includes a sequence of alternatives, each starting with the keyword case. Each alternative includes a pattern and one or more expressions, which will be evaluated if the pattern matches. An arrow symbol => separates the pattern from the expressions.|||Try the following example program, which shows how to match against an integer value.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The block with the case statements defines a function, which maps integers to strings. The match keyword provides a convenient way of applying a function (like the pattern matching function above) to an object.|||Try the following example program, which matches a value against patterns of different types.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The case classes are special classes that are used in pattern matching with case expressions. Syntactically, these are standard classes with a special modifier: case.|||Try the following, it is a simple pattern matching example using case class.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Adding the case keyword causes the compiler to add a number of useful features automatically. The keyword suggests an association with case expressions in pattern matching.|||First, the compiler automatically converts the constructor arguments into immutable fields (vals). The val keyword is optional. If you want mutable fields, use the var keyword. So, our constructor argument lists are now shorter.|||Second, the compiler automatically implements equals, hashCode, and toString methods to the class, which use the fields specified as constructor arguments. So, we no longer need our own toString() methods.|||Finally, also, the body of Person class becomes empty because there are no methods that we need to define!|||This chapter explains how Scala supports regular expressions through Regex class available in the scala.util.matching package.|||Try the following example program where we will try to find out word Scala from a statement.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||We create a String and call the r( ) method on it. Scala implicitly converts the String to a RichString and invokes that method to get an instance of Regex. To find a first match of the regular expression, simply call the findFirstIn() method. If instead of finding only the first occurrence we would like to find all occurrences of the matching word, we can use the findAllIn( ) method and in case there are multiple Scala words available in the target string, this will return a collection of all matching words.|||You can make use of the mkString( ) method to concatenate the resulting list and you can use a pipe (|) to search small and capital case of Scala and you can use Regex constructor instead or r() method to create a pattern.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||If you would like to replace matching text, we can use replaceFirstIn( ) to replace the first match or replaceAllIn( ) to replace  all occurrences.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl. Here are just some examples that should be enough as refreshers −|||Following is the table listing down all the regular expression Meta character syntax available in Java.|||Note − that every backslash appears twice in the string above. This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string. So instead of ‘\’, you need to write ‘\\’ to get a single backslash in the string.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala's exceptions work like exceptions in many other languages like Java. Instead of returning a value in the normal way, a method can terminate by throwing an exception. However, Scala doesn't actually have checked exceptions.|||When you want to handle exceptions, you use a try{...}catch{...} block like you would in Java except that the catch block uses matching to identify and handle the exceptions.|||Throwing an exception looks the same as in Java. You create an exception object and then you throw it with the throw keyword as follows.|||Scala allows you to try/catch any exception in a single block and then perform pattern matching against it using case blocks. Try the following example program to handle exception.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The behavior of this try-catch expression is the same as in other languages with exceptions. The body is executed, and if it throws an exception, each catch clause is tried in turn.|||You can wrap an expression with a finally clause if you want to cause some code to execute no matter how the expression terminates. Try the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An extractor in Scala is an object that has a method called unapply as one of its members. The purpose of that unapply method is to match a value and take it apart. Often, the extractor object also defines a dual method apply for building values, but this is not required.|||Let us take an example of object defines both apply and unapply methods. The apply method has the same meaning as always: it turns Test into an object that can be applied to arguments in parentheses in the same way a method is applied. So you can write Test (""Zara"", ""gmail.com"") to construct the string ""Zara@gmail.com"".|||The unapply method is what turns Test class into an extractor and it reverses the construction process of apply. Where apply takes two strings and forms an email address string out of them, unapply takes an email address and returns potentially two strings: the user and the domain of the address.|||The unapply must also handle the case where the given string is not an email address. That's why unapply returns an Option-type over pairs of strings. Its result is either Some (user, domain) if the string str is an email address with the given user and domain parts, or None, if str is not an email address. Here are some examples as follows.|||Following example program shows an extractor object for email addresses.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||When an instance of a class is followed by parentheses with a list of zero or more parameters, the compiler invokes the apply method on that instance. We can define apply both in objects and in classes.|||As mentioned above, the purpose of the unapply method is to extract a specific value we are looking for. It does the opposite operation apply does. When comparing an extractor object using the match statement the unapply method will be automatically executed.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala is open to make use of any Java objects and java.io.File is one of the objects which can be used in Scala programming to read and write files.|||The following is an example program to writing to a file.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||It will create a file named Demo.txt in the current directory, where the program is placed. The following is the content of that file.|||Sometime you need to read user input from the screen and then proceed for some further processing. Following example program shows you how to read input from the command line.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Reading from files is really simple. You can use Scala's Source class and its companion object to read files. Following is the example which shows you how to read from ""Demo.txt"" file which we created earlier.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.","All types are objects@@@Type inference@@@Nested Functions@@@Functions are objects@@@Domain specific language (DSL) support@@@Traits@@@Closures@@@Concurrency support inspired by Erlang|||The Lift Framework@@@The Play framework@@@The Bowler framework|||Object − Objects have states and behaviors. An object is an instance of a class. Example − A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating.@@@Class  − A class can be defined as a template/blueprint that describes the behaviors/states that are related to the class.@@@Methods − A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.@@@Fields − Each object has its unique set of instance variables, which are called fields. An object's state is created by the values assigned to these fields.@@@Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.@@@Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.|||Case Sensitivity − Scala is case-sensitive, which means identifier Hello and hello would have different meaning in Scala.@@@Class Names − For all class names, the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.
Example − class MyFirstScalaClass.@@@Method Names − All method names should start with a Lower Case letter. If multiple words are used to form the name of the method, then each inner word's first letter should be in Upper Case.
Example − def myMethodName()@@@Program File Name − Name of the program file should exactly match the object name. When saving the file you should save it using the object name (Remember Scala is case-sensitive) and append ‘.scala’ to the end of the name. (If the file name and the object name do not match your program will not compile).
Example − Assume 'HelloWorld' is the object name. Then the file should be saved as 'HelloWorld.scala'.@@@def main(args: Array[String]) − Scala program processing starts from the main() method which is a mandatory part of every Scala Program.|||Implicit classes must be defined inside another class/object/trait (not in top level).@@@Implicit classes may only take one non –implicit argument in their constructor.@@@Implicit classes may not be any method, member or object in scope with the same name as the implicit class.|||Variable workDetails will be accessible to any class within the enclosing package professional.@@@Variable friends will be accessible to any class within the enclosing package society.@@@Variable secrets will be accessible only on the implicit object within instance methods (this).|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Assignment Operators|||An 'if' can have zero or one else's and it must come after any else if's.@@@An 'if' can have zero to many else if's and they must come before the else.@@@Once an else if succeeds, none of he remaining else if's or else's will be tested.|||obj.isInstanceOf [Point] To check Type of obj and Point are same are not.@@@obj.asInstanceOf [Point] means exact casting by taking the object obj type and returns the same obj as Point type.|||If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.@@@If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.@@@If you want to inherit from it in Java code, use an abstract class.@@@If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.@@@If efficiency is very important, lean towards using a class.",,"Platform@@@Command@@@Sample Output|||Windows@@@
Open Command Console and type −
\>java –version
@@@
Java version ""1.8.0_31""
Java (TM) SE Run Time
Environment (build 1.8.0_31-b31)
Java Hotspot (TM) 64-bit Server
VM (build 25.31-b07, mixed mode)|||Linux@@@
Open Command terminal and type −
$java –version@@@
Java version ""1.8.0_31""
Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)
Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Set JAVA_HOME to C:\ProgramFiles\java\jdk1.7.0_60
|||2@@@
Linux
Export JAVA_HOME=/usr/local/java-current
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Append the String ""C:\Program Files\Java\jdk1.7.0_60\bin"" to the end of the system variable PATH.|||2@@@
Linux
Export PATH=$PATH:$JAVA_HOME/bin/
&&&Platform@@@Command & Output@@@Description|||Windows@@@\>java –jar scala-2.11.5-installer.jar\>@@@This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path “C:\Program Files\Scala”, you can select a suitable path as per your convenience.|||Linux@@@
Command −
$java –jar scala-2.9.0.1-installer.jar
Output −
Welcome to the installation of Scala 2.9.0.1!
The homepage is at − http://Scala-lang.org/
press 1 to continue, 2 to quit, 3 to redisplay
1................................................
[ Starting to unpack ]
[ Processing package: Software Package Installation (1/1) ]
[ Unpacking finished ]
[ Console installation done ]
@@@
During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.
&&&Platform@@@Command@@@Output|||Windows@@@\>scala -version@@@Scala code runner version 2.11.5 -- Copyright 2002-2013, LAMP/EPFL|||Linux@@@$scala -version@@@Scala code runner version 2.9.0.1 – Copyright 2002-2013, LAMP/EPFL&&&abstract@@@case@@@catch@@@class|||def@@@do@@@else@@@extends|||false@@@final@@@finally@@@for|||forSome@@@if@@@implicit@@@import|||lazy@@@match@@@new@@@Null|||object@@@override@@@package@@@private|||protected@@@return@@@sealed@@@super|||this@@@throw@@@trait@@@Try|||true@@@type@@@val@@@Var|||while@@@with@@@yield@@@ |||-@@@:@@@=@@@=>|||<-@@@<:@@@<%@@@>:|||#@@@@@@@@@@&&&Sr.No@@@Data Type & Description|||1@@@
Byte
8 bit signed value. Range from -128 to 127
|||2@@@
Short
16 bit signed value. Range -32768 to 32767
|||3@@@
Int
32 bit signed value. Range -2147483648 to 2147483647
|||4@@@
Long
64 bit signed value. -9223372036854775808 to 9223372036854775807
|||5@@@
Float
32 bit IEEE 754 single-precision float
|||6@@@
Double
64 bit IEEE 754 double-precision float
|||7@@@
Char
16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
|||8@@@
String
A sequence of Chars
|||9@@@
Boolean
Either the literal true or the literal false
|||10@@@
Unit
Corresponds to no value
|||11@@@
Null
null or empty reference
|||12@@@
Nothing
The subtype of every other type; includes no values
|||13@@@
Any
The supertype of any type; any object is of type Any
|||14@@@
AnyRef
The supertype of any reference type
&&&Escape Sequences@@@Unicode@@@Description|||\b@@@\u0008@@@backspace BS|||\t@@@\u0009@@@horizontal tab HT|||\n@@@\u000c@@@formfeed FF|||\f@@@\u000c@@@formfeed FF|||\r@@@\u000d@@@carriage return CR|||\""@@@\u0022@@@double quote ""|||\'@@@\u0027@@@single quote .|||\\@@@\u005c@@@backslash \&&&Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiplies both operands@@@A * B will give 200|||/@@@Divides numerator by de-numerator@@@B / A will give 2|||%@@@Modulus operator finds the remainder after division of one number by another@@@B % A will give 0&&&Operator@@@Description@@@Example|||==@@@Checks if the values of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||!=@@@Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||&&@@@It is called Logical AND  operator. If both the operands are non zero then condition becomes true.@@@(A && B) is false.|||||@@@It is called Logical OR Operator. If any of the two operands is non zero then condition becomes true.@@@(A || B) is true.|||!@@@It is called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A && B) is true.&&&p@@@q@@@p & q@@@p | q@@@p ^ q|||0@@@0@@@0@@@0@@@0|||0@@@1@@@0@@@1@@@1|||1@@@1@@@1@@@1@@@0|||1@@@0@@@0@@@1@@@1&&&Operator@@@Description@@@Example|||&@@@Binary AND Operator copies a bit to the result if it exists in both operands. @@@(A & B) will give 12, which is 0000 1100||||@@@Binary OR Operator copies a bit if it exists in either operand.@@@(A | B) will give 61, which is 0011 1101|||^@@@Binary XOR Operator copies the bit if it is set in one operand but not both.@@@(A ^ B) will give 49, which is 0011 0001|||~@@@Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. @@@(~A ) will give -61, which is 1100 0011 in 2's complement form due to a signed binary number.|||<<@@@Binary Left Shift Operator. The bit positions of the left operands value is moved left by the number of bits specified by the right operand.@@@A << 2 will give 240, which is 1111 0000|||>>@@@Binary Right Shift Operator. The Bit positions of the left operand value is moved right by the number of bits specified by the right operand.@@@A >> 2 will give 15, which is 1111|||>>>@@@Shift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros.@@@A >>>2 will give 15 which is 0000 1111&&&Operator@@@Description@@@Example|||=@@@Simple assignment operator, Assigns values from right side operands to left side operand@@@C = A + B will assign value of A + B into C|||+=@@@Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand@@@C += A is equivalent to C = C + A|||-=@@@Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand@@@C -= A is equivalent to C = C - A|||*=@@@Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand@@@C *= A is equivalent to C = C * A|||/=@@@Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand@@@C /= A is equivalent to C = C / A|||%=@@@Modulus AND assignment operator, It takes modulus using two operands and assign the result to  left operand@@@C %= A is equivalent to C = C % A|||<<=@@@Left shift AND assignment operator @@@C <<= 2 is same as  C = C << 2|||>>=@@@Right shift AND assignment operator @@@C >>= 2 is same as  C = C >> 2|||&=@@@Bitwise AND assignment operator@@@C &= 2 is same as  C = C & 2|||^=@@@bitwise exclusive OR and assignment operator@@@C ^= 2 is same as C = C ^ 2||||=@@@bitwise inclusive OR and assignment operator@@@C |= 2 is same as  C = C | 2&&&Category@@@Operator@@@Associativity|||Postfix@@@() []@@@Left to right|||Unary@@@!  ~ @@@Right to left|||Multiplicative @@@*  /  %@@@Left to right|||Additive @@@+  -@@@Left to right|||Shift @@@>> >>> << @@@Left to right|||Relational @@@> >=  < <= @@@Left to right|||Equality @@@==  !=@@@Left to right|||Bitwise AND@@@&@@@Left to right|||Bitwise XOR@@@^@@@Left to right|||Bitwise OR@@@|@@@Left to right|||Logical AND@@@&&@@@Left to right|||Logical OR@@@||@@@Left to right|||Assignment@@@=  +=  -=  *=  /=  %= >>=  <<=  &=  ^=   |=@@@Right to left|||Comma@@@,@@@Left to right&&&Sr.No@@@Loop Type & Description|||1@@@
while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.
|||2@@@
do-while loop
Like a while statement, except that it tests the condition at the end of the loop body.
|||3@@@
for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.
&&&Sr.No@@@Control Statement & Description|||1@@@
break statement
Terminates the loop statement and transfers execution to the statement immediately following the loop.
&&&Functions Call-by-Name@@@Functions with Named Arguments|||Function with Variable Arguments@@@Recursion Functions|||Default Parameter Values@@@Higher-Order Functions|||Nested Functions@@@Anonymous Functions|||Partially Applied Functions@@@Currying Functions&&&‘s’ interpolator usage@@@‘raw’ interpolator usage|||
Program −

object Demo {
   def main(args: Array[String]) {
      println(s""Result = \n a \n b"")
   }
}

@@@
Program −

object Demo {
   def main(args: Array[String]) {
      println(raw""Result = \n a \n b"")
   }
}

|||
Output −

Result =
a
b

@@@
Output −

Result = \n a \n b

&&&Sr.No@@@Methods with Description|||1@@@
char charAt(int index)
Returns the character at the specified index.
|||2@@@
int compareTo(Object o)
Compares this String to another Object.
|||3@@@
int compareTo(String anotherString)
Compares two strings lexicographically.
|||4@@@
int compareToIgnoreCase(String str)
Compares two strings lexicographically, ignoring case differences.
|||5@@@
String concat(String str)
Concatenates the specified string to the end of this string.
|||6@@@
boolean contentEquals(StringBuffer sb)
Returns true if and only if this String represents the same sequence of characters as the specified StringBuffer.
|||7@@@
static String copyValueOf(char[] data)
Returns a String that represents the character sequence in the array specified.
|||8@@@
static String copyValueOf(char[] data, int offset, int count)
Returns a String that represents the character sequence in the array specified.
|||9@@@
boolean endsWith(String suffix)
Tests if this string ends with the specified suffix.
|||10@@@
boolean equals(Object anObject)
Compares this string to the specified object.
|||11@@@
boolean equalsIgnoreCase(String anotherString)
Compares this String to another String, ignoring case considerations.
|||12@@@
byte getBytes()
Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.
|||13@@@
byte[] getBytes(String charsetName)
Encodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.
|||14@@@
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)
Copies characters from this string into the destination character array.
|||15@@@
int hashCode()
Returns a hash code for this string.
|||16@@@
int indexOf(int ch)
Returns the index within this string of the first occurrence of the specified character.
|||17@@@
int indexOf(int ch, int fromIndex)
Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.
|||18@@@
int indexOf(String str)
Returns the index within this string of the first occurrence of the specified substring.
|||19@@@
int indexOf(String str, int fromIndex)
Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.
|||20@@@
String intern()
Returns a canonical representation for the string object.
|||21@@@
int lastIndexOf(int ch)
Returns the index within this string of the last occurrence of the specified character.
|||22@@@
int lastIndexOf(int ch, int fromIndex)
Returns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.
|||23@@@
int lastIndexOf(String str)
Returns the index within this string of the rightmost occurrence of the specified substring.
|||24@@@
int lastIndexOf(String str, int fromIndex)
Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.
|||25@@@
int length()
Returns the length of this string.
|||26@@@
boolean matches(String regex)
Tells whether or not this string matches the given regular expression.
|||27@@@
boolean regionMatches(boolean ignoreCase, int toffset, String other, int offset, int len)
Tests if two string regions are equal.
|||28@@@
boolean regionMatches(int toffset, String other, int offset, int len)
Tests if two string regions are equal.
|||29@@@
String replace(char oldChar, char newChar)
Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
|||30@@@
String replaceAll(String regex, String replacement
Replaces each substring of this string that matches the given regular expression with the given replacement.
|||31@@@
String replaceFirst(String regex, String replacement)
Replaces the first substring of this string that matches the given regular expression with the given replacement.
|||32@@@
String[] split(String regex)
Splits this string around matches of the given regular expression.
|||33@@@
String[] split(String regex, int limit)
Splits this string around matches of the given regular expression.
|||34@@@
boolean startsWith(String prefix)
Tests if this string starts with the specified prefix.
|||35@@@
boolean startsWith(String prefix, int toffset)
Tests if this string starts with the specified prefix beginning a specified index.
|||36@@@
CharSequence subSequence(int beginIndex, int endIndex)
Returns a new character sequence that is a subsequence of this sequence.
|||37@@@
String substring(int beginIndex)
Returns a new string that is a substring of this string.
|||38@@@
String substring(int beginIndex, int endIndex)
Returns a new string that is a substring of this string.
|||39@@@
char[] toCharArray()
Converts this string to a new character array.
|||40@@@
String toLowerCase()
Converts all of the characters in this String to lower case using the rules of the default locale.
|||41@@@
String toLowerCase(Locale locale)
Converts all of the characters in this String to lower case using the rules of the given Locale.
|||42@@@
String toString()
This object (which is already a string!) is itself returned.
|||43@@@
String toUpperCase()
Converts all of the characters in this String to upper case using the rules of the default locale.
|||44@@@
String toUpperCase(Locale locale)
Converts all of the characters in this String to upper case using the rules of the given Locale.
|||45@@@
String trim()
Returns a copy of the string, with leading and trailing whitespace omitted.
|||46@@@
static String valueOf(primitive data type x)
Returns the string representation of the passed data type argument.&&&Sr.No@@@Methods with Description|||1@@@
def apply( x: T, xs: T* ): Array[T]
Creates an array of T objects, where T can be Unit, Double, Float, Long, Int, Char, Short, Byte, Boolean.
|||2@@@
def concat[T]( xss: Array[T]* ): Array[T]
Concatenates all arrays into a single array.
|||3@@@
def copy( src: AnyRef, srcPos: Int, dest: AnyRef, destPos: Int, length: Int ): Unit
Copy one array to another. Equivalent to Java's System.arraycopy(src, srcPos, dest, destPos, length).
|||4@@@
def empty[T]: Array[T]
Returns an array of length 0
|||5@@@
def iterate[T]( start: T, len: Int )( f: (T) => T ): Array[T]
Returns an array containing repeated applications of a function to a start value.
|||6@@@
def fill[T]( n: Int )(elem: =>  T): Array[T]
Returns an array that contains the results of some element computation a number of times.
|||7@@@
def fill[T]( n1: Int, n2: Int )( elem: => T ): Array[Array[T]]
Returns a two-dimensional array that contains the results of some element computation a number of times.
|||8@@@
def iterate[T]( start: T, len: Int)( f: (T) => T ): Array[T]
Returns an array containing repeated applications of a function to a start value.
|||9@@@
def ofDim[T]( n1: Int ): Array[T]
Creates array with given dimensions.
|||10@@@
def ofDim[T]( n1: Int, n2: Int ): Array[Array[T]]
Creates a 2-dimensional array
|||11@@@
def ofDim[T]( n1: Int, n2: Int, n3: Int ): Array[Array[Array[T]]]
Creates a 3-dimensional array
|||12@@@
def range( start: Int, end: Int, step: Int ): Array[Int]
Returns an array containing equally spaced values in some integer interval.
|||13@@@
def range( start: Int, end: Int ): Array[Int]
Returns an array containing a sequence of increasing integers in a range.
|||14@@@
def tabulate[T]( n: Int )(f: (Int)=> T): Array[T]
Returns an array containing values of a given function over a range of integer values starting from 0.
|||15@@@
def tabulate[T]( n1: Int, n2: Int )( f: (Int, Int ) => T): Array[Array[T]]
Returns a two-dimensional array containing values of a given function over ranges of integer values starting from 0.
&&&Sr.No@@@Collections with Description|||1@@@Scala Lists
Scala's List[T] is a linked list of type T.
|||2@@@Scala Sets
A set is a collection of pairwise different elements of the same type.|||3@@@
Scala Maps
A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||4@@@Scala Tuples
Unlike an array or list, a tuple can hold objects with different types.|||5@@@Scala Options
Option[T] provides a container for zero or one element of a given type.|||6@@@Scala Iterators
An iterator is not a collection, but rather a way to access the elements of a collection one by one.&&&Subexpression@@@Matches|||^@@@Matches beginning of line.|||$@@@Matches end of line.|||.@@@Matches any single character except newline. Using m option allows it to match newline as well.|||[...]@@@Matches any single character in brackets.|||[^...]@@@Matches any single character not in brackets|||\\A@@@Beginning of entire string|||\\z@@@End of entire string|||\\Z@@@End of entire string except allowable final line terminator.|||re*@@@Matches 0 or more occurrences of preceding expression.|||re+@@@Matches 1 or more of the previous thing|||re?@@@Matches 0 or 1 occurrence of preceding expression.|||re{ n}@@@Matches exactly n number of occurrences of preceding expression.|||re{ n,}@@@Matches n or more occurrences of preceding expression.|||re{ n, m}@@@Matches at least n and at most m occurrences of preceding expression.|||a|b@@@Matches either a or b.|||(re)@@@Groups regular expressions and remembers matched text.|||(?: re)@@@Groups regular expressions without remembering matched text.|||(?> re)@@@Matches independent pattern without backtracking.|||\\w@@@Matches word characters.|||\\W@@@Matches nonword characters.|||\\s@@@Matches whitespace. Equivalent to [\t\n\r\f].|||\\S@@@Matches nonwhitespace.|||\\d@@@Matches digits. Equivalent to [0-9].|||\\D@@@Matches nondigits.|||\\A@@@Matches beginning of string.|||\\Z@@@Matches end of string. If a newline exists, it matches just before newline.|||\\z@@@Matches end of string.|||\\G@@@Matches point where last match finished.|||\\n@@@Back-reference to capture group number ""n""|||\\b@@@Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.|||\\B@@@Matches nonword boundaries.|||\\n, \\t, etc.@@@Matches newlines, carriage returns, tabs, etc.|||\\Q@@@Escape (quote) all characters up to \\E|||\\E@@@Ends quoting begun with \\Q&&&Example@@@Description|||.@@@Match any character except newline|||[Rr]uby@@@Match ""Ruby"" or ""ruby""|||rub[ye]@@@Match ""ruby"" or ""rube""|||[aeiou]@@@Match any one lowercase vowel|||[0-9]@@@Match any digit; same as [0123456789]|||[a-z]@@@Match any lowercase ASCII letter|||[A-Z]@@@Match any uppercase ASCII letter|||[a-zA-Z0-9]@@@Match any of the above|||[^aeiou]@@@Match anything other than a lowercase vowel|||[^0-9]@@@Match anything other than a digit|||\\d@@@Match a digit: [0-9]|||\\D@@@Match a nondigit: [^0-9]|||\\s@@@Match a whitespace character: [ \t\r\n\f]|||\\S@@@Match nonwhitespace: [^ \t\r\n\f]|||\\w@@@Match a single word character: [A-Za-z0-9_]|||\\W@@@Match a nonword character: [^A-Za-z0-9_]|||ruby?@@@Match ""rub"" or ""ruby"": the y is optional|||ruby*@@@Match ""rub"" plus 0 or more ys|||ruby+@@@Match ""rub"" plus 1 or more ys|||\\d{3}@@@Match exactly 3 digits|||\\d{3,}@@@Match 3 or more digits|||\\d{3,5}@@@Match 3, 4, or 5 digits|||\\D\\d+@@@No group: + repeats \\d|||(\\D\\d)+/ @@@Grouped: + repeats \\D\d pair|||([Rr]uby(, )?)+@@@Match ""Ruby"", ""Ruby, ruby, ruby"", etc.","object HelloWorld {   /* This is my first java program.     * This will print 'Hello World' as the output   */   def main(args: Array[String]) {      println(""Hello, world!"") // prints Hello World   }}|||+ ++ ::: <?> :>|||object HelloWorld {   /* This is my first java program.      * This will print 'Hello World' as the output    * This is an example of multi-line comments.    */   def main(args: Array[String]) {      // Prints Hello World      // This is also an example of single line comment.      println(""Hello, world!"")    }}|||val s = ""hello""; println(s)|||import scala.collection.immutable.{TreeMap, TreeSet}|||object Test {   def main(args: Array[String]) {      println(""Hello\tWorld\n\n"" );   }} |||object Demo {   def main(args: Array[String]) {      var myVar :Int = 10;      val myVal :String = ""Hello Scala with datatype declaration."";      var myVar1 = 20;      val myVal1 = ""Hello Scala new without datatype declaration."";            println(myVar); println(myVal); println(myVar1);       println(myVal1);   }}|||import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy      println (""Point x location : "" + x);      println (""Point y location : "" + y);   }}object Demo {   def main(args: Array[String]) {      val pt = new Point(10, 20);      // Move to a new location      pt.move(10, 10);   }}|||import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy      println (""Point x location : "" + x);      println (""Point y location : "" + y);   }}class Location(override val xc: Int, override val yc: Int,   val zc :Int) extends Point(xc, yc){   var z: Int = zc   def move(dx: Int, dy: Int, dz: Int) {      x = x + dx      y = y + dy      z = z + dz      println (""Point x location : "" + x);      println (""Point y location : "" + y);      println (""Point z location : "" + z);   }}object Demo {   def main(args: Array[String]) {      val loc = new Location(10, 20, 15);      // Move to a new location      loc.move(10, 10, 5);   }}|||object <object name> {   implicit class <class name>(<Variable>: Data type) {      def <method>(): Unit =   }}|||object Run {   implicit class IntTimes(x: Int) {      def times [A](f: =>A): Unit = {         def loop(current: Int): Unit =                  if(current > 0){            f            loop(current - 1)         }         loop(x)      }   }}|||import Run._object Demo {   def main(args: Array[String]) {      4 times println(""hello"")   }}|||import java.io._class Point(val xc: Int, val yc: Int) {   var x: Int = xc   var y: Int = yc      def move(dx: Int, dy: Int) {      x = x + dx      y = y + dy   }}object Demo {   def main(args: Array[String]) {      val point = new Point(10, 20)      printPoint      def printPoint{         println (""Point x location : "" + point.x);         println (""Point y location : "" + point.y);      }   }}|||\>scalac Demo.scala\>scala Demo|||class Outer {   class Inner {      private def f() { println(""f"") }            class InnerMost {         f() // OK      }   }   (new Inner).f() // Error: f is not accessible}|||package p {   class Super {      protected def f() { println(""f"") }   }      class Sub extends Super {      f()   }      class Other {      (new Super).f() // Error: f is not accessible   }}|||class Outer {   class Inner {      def f() { println(""f"") }            class InnerMost {         f() // OK      }   }   (new Inner).f() // OK because now f() is public}|||package society {   package professional {      class Executive {         private[professional] var workDetails = null         private[society] var friends = null         private[this] var secrets = null         def help(another : Executive) {            println(another.workDetails)            println(another.secrets) //ERROR         }      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 10;      if( x < 20 ){         println(""This is if statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      if( x < 20 ){         println(""This is if statement"");      } else {         println(""This is else statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      if( x == 10 ){         println(""Value of X is 10"");      } else if( x == 20 ){         println(""Value of X is 20"");      } else if( x == 30 ){         println(""Value of X is 30"");      } else{         println(""This is else statement"");      }   }}|||object Demo {   def main(args: Array[String]) {      var x = 30;      var y = 10;            if( x == 30 ){         if( y == 10 ){            println(""X = 30 and Y = 10"");         }      }   }}|||object Demo {   def main(args: Array[String]) {      var a = 10;            // An infinite loop.      while( true ){         println( ""Value of a: "" + a );      }   }}|||def functionName ([list of parameters]) : [return type]|||object Demo {   def main(args: Array[String]) {      println( ""Returned Value : "" + addInt(5,7) );   }      def addInt( a:Int, b:Int ) : Int = {      var sum:Int = 0      sum = a + b      return sum   }}|||object Demo {   def main(args: Array[String]) {      println( ""multiplier(1) value = "" +  multiplier(1) )      println( ""multiplier(2) value = "" +  multiplier(2) )   }   var factor = 3   val multiplier = (i:Int) => i * factor}|||object Demo {   val greeting: String = ""Hello, world!""   def main(args: Array[String]) {      println( greeting )   }}|||object Demo {   def main(args: Array[String]) {      var palindrome = ""Dot saw I was Tod"";      var len = palindrome.length();            println( ""String Length is : "" + len );   }}|||object Demo {   def main(args: Array[String]) {      var str1 = ""Dot saw I was "";      var str2 =  ""Tod"";            println(""Dot "" + str1 + str2);   }}|||object Demo {   def main(args: Array[String]) {      var floatVar = 12.456      var intVar = 2000      var stringVar = ""Hello, Scala!""            var fs = printf(""The value of the float variable is "" + ""%f, while the value of the integer "" + ""variable is %d, and the string"" + ""is %s"", floatVar, intVar, stringVar);            println(fs)   }}|||object Demo {   def main(args: Array[String]) {      val name = ""James""            println(s""Hello, $name"")      println(s""1 + 1 = ${1 + 1}"")   }}|||object Demo {   def main(args: Array[String]) {      println(s""Result = \n a \n b"")   }}|||object Demo {   def main(args: Array[String]) {      println(raw""Result = \n a \n b"")   }}|||object Demo {   def main(args: Array[String]) {      var myList = Array(1.9, 2.9, 3.4, 3.5)            // Print all the array elements      for ( x <- myList ) {         println( x )      }      // Summing all elements      var total = 0.0;            for ( i <- 0 to (myList.length - 1)) {         total += myList(i);      }      println(""Total is "" + total);      // Finding the largest element      var max = myList(0);            for ( i <- 1 to (myList.length - 1) ) {         if (myList(i) > max) max = myList(i);      }            println(""Max is "" + max);   }}|||var myMatrix = ofDim[Int](3,3)|||import Array._object Demo {   def main(args: Array[String]) {      var myMatrix = ofDim[Int](3,3)            // build a matrix      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            myMatrix(i)(j) = j;         }      }            // Print two dimensional array      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            print("" "" + myMatrix(i)(j));         }         println();      }   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myList1 = Array(1.9, 2.9, 3.4, 3.5)      var myList2 = Array(8.9, 7.9, 0.4, 1.5)      var myList3 =  concat( myList1, myList2)            // Print all the array elements      for ( x <- myList3 ) {         println( x )      }   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myList1 = range(10, 20, 2)      var myList2 = range(10,20)      // Print all the array elements      for ( x <- myList1 ) {         print( "" "" + x )      }            println()      for ( x <- myList2 ) {         print( "" "" + x )      }   }}|||trait Equal {   def isEqual(x: Any): Boolean   def isNotEqual(x: Any): Boolean = !isEqual(x)}class Point(xc: Int, yc: Int) extends Equal {   var x: Int = xc   var y: Int = yc      def isEqual(obj: Any) = obj.isInstanceOf[Point] && obj.asInstanceOf[Point].x == y}object Demo {   def main(args: Array[String]) {      val p1 = new Point(2, 3)      val p2 = new Point(2, 4)      val p3 = new Point(3, 3)      println(p1.isNotEqual(p2))      println(p1.isNotEqual(p3))      println(p1.isNotEqual(2))   }}|||trait Printable extends Any {   def print(): Unit = println(this)}class Wrapper(val underlying: Int) extends AnyVal with Printableobject Demo {   def main(args: Array[String]) {      val w = new Wrapper(3)      w.print() // actually requires instantiating a Wrapper instance   }}|||object Demo {   def main(args: Array[String]) {      println(matchTest(3))   }      def matchTest(x: Int): String = x match {      case 1 => ""one""      case 2 => ""two""      case _ => ""many""   }}|||object Demo {   def main(args: Array[String]) {      println(matchTest(""two""))      println(matchTest(""test""))      println(matchTest(1))   }      def matchTest(x: Any): Any = x match {      case 1 => ""one""      case ""two"" => 2      case y: Int => ""scala.Int""      case _ => ""many""   }}|||object Demo {   def main(args: Array[String]) {      val alice = new Person(""Alice"", 25)      val bob = new Person(""Bob"", 32)      val charlie = new Person(""Charlie"", 32)         for (person <- List(alice, bob, charlie)) {         person match {            case Person(""Alice"", 25) => println(""Hi Alice!"")            case Person(""Bob"", 32) => println(""Hi Bob!"")            case Person(name, age) => println(               ""Age: "" + age + "" year, name: "" + name + ""?"")         }      }   }   case class Person(name: String, age: Int)}|||import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = ""Scala"".r      val str = ""Scala is Scalable and cool""            println(pattern findFirstIn str)   }}|||import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = new Regex(""(S|s)cala"")      val str = ""Scala is scalable and cool""            println((pattern findAllIn str).mkString("",""))   }}|||object Demo {   def main(args: Array[String]) {      val pattern = ""(S|s)cala"".r      val str = ""Scala is scalable and cool""            println(pattern replaceFirstIn(str, ""Java""))   }}|||import scala.util.matching.Regexobject Demo {   def main(args: Array[String]) {      val pattern = new Regex(""abl[ae]\\d+"")      val str = ""ablaw is able1 and cool""            println((pattern findAllIn str).mkString("",""))   }}|||import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOExceptionobject Demo {   def main(args: Array[String]) {      try {         val f = new FileReader(""input.txt"")      } catch {         case ex: FileNotFoundException =>{            println(""Missing file exception"")         }                  case ex: IOException => {            println(""IO Exception"")         }      }   }}|||import java.io.FileReaderimport java.io.FileNotFoundExceptionimport java.io.IOExceptionobject Demo {   def main(args: Array[String]) {      try {         val f = new FileReader(""input.txt"")      } catch {         case ex: FileNotFoundException => {            println(""Missing file exception"")         }                  case ex: IOException => {            println(""IO Exception"")         }      } finally {         println(""Exiting finally..."")      }   }}|||object Demo {   def main(args: Array[String]) {      println (""Apply method : "" + apply(""Zara"", ""gmail.com""));      println (""Unapply method : "" + unapply(""Zara@gmail.com""));      println (""Unapply method : "" + unapply(""Zara Ali""));   }      // The injection method (optional)   def apply(user: String, domain: String) = {      user +""@""+ domain   }   // The extraction method (mandatory)   def unapply(str: String): Option[(String, String)] = {      val parts = str split ""@""            if (parts.length == 2){         Some(parts(0), parts(1))       } else {         None      }   }}|||object Demo {   def main(args: Array[String]) {      val x = Demo(5)      println(x)      x match {         case Demo(num) => println(x+"" is bigger two times than ""+num)                  //unapply is invoked         case _ => println(""i cannot calculate"")      }   }   def apply(x: Int) = x*2   def unapply(z: Int): Option[Int] = if (z%2==0) Some(z/2) else None}|||import java.io._object Demo {   def main(args: Array[String]) {      val writer = new PrintWriter(new File(""test.txt"" ))      writer.write(""Hello Scala"")      writer.close()   }}|||object Demo {   def main(args: Array[String]) {      print(""Please enter your input : "" )      val line = Console.readLine            println(""Thanks, you just typed: "" + line)   }}|||import scala.io.Sourceobject Demo {   def main(args: Array[String]) {      println(""Following is the content read:"" )      Source.fromFile(""Demo.txt"" ).foreach {          print       }   }}"
Learn Scala,Scala - Useful Resources,Scala - Useful Resources|||Useful Video Courses@@@Useful eBooks|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala@@@Scala Tutorial@@@Scala Test-Driven Development@@@Scala Programming Projects@@@Modern Scala Projects@@@Learn Scala Programming@@@Hands-On Data Analysis with Scala,The following resources contain additional information on Scala. Please use them to get more in-depth knowledge on this topic.,,,,
Learn Scala,Discuss Scala,Discuss Scala|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala is a modern multi-paradigm programming language designed to express common programming patterns in a concise, elegant, and type-safe way. Scala has been created by Martin Odersky and he released the first version in 2003. Scala smoothly integrates the features of object-oriented and functional languages. This tutorial explains the basics of Scala in a simple and reader-friendly way.",,,,
