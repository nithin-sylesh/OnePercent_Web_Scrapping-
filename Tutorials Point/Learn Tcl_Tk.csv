Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Tcl/Tk,Tcl/Tk Tutorial,Tcl/Tk Tutorial@@@Audience@@@Prerequisites,"Tcl is a general purpose multi-paradigm system programming language. It is a scripting language that aims at providing the ability for applications to communicate with each other. On the other hand, Tk is a cross platform widget toolkit used for building GUI in many languages. This tutorial covers various topics ranging from the basics of the Tcl/Tk to its scope in various applications.|||This tutorial is designed for all those individuals who are looking for a starting point of learning Tcl/Tk. Therefore, we cover all those topics that are required for a beginner and an advanced user.|||Before proceeding with this tutorial, it is advisable for you to understand the basic concepts of computer programming. This tutorial is self-contained and you will be able to learn various concepts of Tcl/Tk even if you are a beginner. You just need to have a basic understanding of working with a simple text editor and command line.",,,,
Learn Tcl/Tk,Tcl - Overview,Tcl - Overview|||Features of Tcl@@@Applications,"Tcl is shortened form of Tool Command Language. John Ousterhout of the University of California, Berkeley, designed it. It is a combination of a scripting language and its own interpreter that gets embedded to the application, we develop with it.|||Tcl was developed initially for Unix. It was then ported to Windows, DOS, OS/2, and Mac OSX. Tcl is much similar to other unix shell languages like Bourne Shell (Sh), the C Shell (csh), the Korn Shell (sh), and Perl.|||It aims at providing ability for programs to interact with other programs and also for acting as an embeddable interpreter. Even though, the original aim was to enable programs to interact, you can find full-fledged applications written in Tcl/Tk.|||The features of Tcl are as follows −|||Reduced development time.|||Powerful and simple user interface kit with integration of TK.|||Write once, run anywhere. It runs on Windows, Mac OS X, and almost on every Unix platform.|||Quite easy to get started for experienced programmers; since, the language is so simple that they can learn Tcl in a few hours or days.|||You can easily extend existing applications with Tcl. Also, it is possible to include Tcl in C, C++, or Java to Tcl or vice versa.|||Have a powerful set of networking functions.|||Finally, it's an open source, free, and can be used for commercial applications without any limit.|||Tcl is a general-purpose language and you can find Tcl everywhere. It includes,","Reduced development time.@@@Powerful and simple user interface kit with integration of TK.@@@Write once, run anywhere. It runs on Windows, Mac OS X, and almost on every Unix platform.@@@Quite easy to get started for experienced programmers; since, the language is so simple that they can learn Tcl in a few hours or days.@@@You can easily extend existing applications with Tcl. Also, it is possible to include Tcl in C, C++, or Java to Tcl or vice versa.@@@Have a powerful set of networking functions.@@@Finally, it's an open source, free, and can be used for commercial applications without any limit.|||Scalable websites that are often backed by databases.@@@High performance web servers build with TclHttpd.@@@Tcl with CGI based websites.@@@Desktop GUI applications.@@@Embedded applications.",,,
Learn Tcl/Tk,Tcl - Environment Setup,Tcl - Environment Setup|||Local Environment Setup@@@Text Editor@@@The Tcl Interpreter@@@Installation on Windows@@@Installation on Linux@@@Installation on Debian based Systems@@@Installation on Mac OS X@@@Installation from Source Files,"If you are willing to set up your environment for Tcl, you need the following two software applications available on your computer −|||This will be used to type your program. Examples of a few text editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of a text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.|||The files you create with your text editor are called source files and contain program source code. The source files for Tcl programs are named with the extension "".tcl"".|||Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, build it, and finally execute it.|||It is just a small program that enables you to type Tcl commands and have them executed line by line. It stops execution of a tcl file, in case, it encounters an error unlike a compiler that executes fully.|||Let's have a helloWorld.tcl file as follows. We will use this as a first program, we run on a platform you choose.|||Download the latest version for windows installer from the list of Active Tcl binaries available. The active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps|||We can see the following output.|||C:\Tcl is the folder, I am using to save my samples. You can change it to the folder in which you have saved Tcl programs.|||Most of the Linux operating systems come with Tcl inbuilt and you can get started right away in those systems. In case, it's not available, you can use the following command to download and install Tcl-Tk.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps −|||We can see the following output −|||In case, it's not available in your OS, you can use the following command to download and install Tcl-Tk −|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps −|||We can see the following output −|||Download the latest version for Mac OS X package from the list of Active Tcl binaries available. The active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Active Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' and then execute the program using the following steps −|||We can see the following output −|||You can use the option of installing from source files when a binary package is not available. It is generally preferred to use Tcl binaries for Windows and Mac OS X, so only compilation of sources on unix based system is shown below.|||Download the source files.|||Now, use the following commands to extract, compile, and build after switching to the downloaded folder.|||Note − Make sure, you change the file name to the version you downloaded on commands 1 and 2 given above.","Text Editor@@@Tcl Interpreter.|||Download the source files.@@@Now, use the following commands to extract, compile, and build after switching to the downloaded folder.",,,"#!/usr/bin/tclshputs ""Hello World!"" |||$ tclsh helloWorld.tcl"
Learn Tcl/Tk,Tcl - Special Variables,Tcl - Special Variables|||Examples for using Tcl special variables|||Tcl version@@@Tcl Environment Path@@@Tcl Package Path@@@Tcl Library@@@Tcl Patch Level@@@Tcl Precision@@@Tcl Startup File,"In Tcl, we classify some of the variables as special variables and they have a predefined usage/functionality. The list of specials variables is listed below.|||argc|||Refers to a number of command-line arguments.|||argv|||Refers to the list containing the command-line arguments.|||argv0|||Refers to the file name of the file being interpreted or the name by which we invoke the script.|||env|||Used for representing the array of elements that are environmental variables.|||errorCode|||Provides the error code for last Tcl error.|||errorInfo|||Provides the stack trace for last Tcl error.|||tcl_interactive|||Used to switch between interactive and non-interactive modes by setting this to 1 and 0 respectively.|||tcl_library|||Used for setting the location of standard Tcl libraries.|||tcl_pkgPath|||Provides the list of directories where packages are generally installed.|||tcl_patchLevel|||Refers to the current patch level of the Tcl interpreter.|||tcl_platform|||Used for representing the array of elements with objects including byteOrder, machine, osVersion, platform, and os.|||tcl_precision|||Refers to the precision i.e. number of digits to retain when converting to floating-point numbers to strings. The default value is 12.|||tcl_prompt1|||Refers to the primary prompt.|||tcl_prompt2|||Refers to the secondary prompt with invalid commands.|||tcl_rcFileName|||Provides the user specific startup file.|||tcl_traceCompile|||Used for controlling the tracing of bytecode compilation. Use 0 for no output, 1 for summary, and 2 for detailed.|||tcl_traceExec|||Used for controlling the tracing of bytecode execution. Use 0 for no output, 1 for summary, and 2 for detailed.|||tcl_version|||Returns the current version of the Tcl interpreter.|||The above special variables have their special meanings for the Tcl interpreter.|||Let's see some examples for special variables.|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −",,,"Sr.No.@@@Special Variable & Description|||1@@@argc
Refers to a number of command-line arguments.|||2@@@argv
Refers to the list containing the command-line arguments.|||3@@@argv0
Refers to the file name of the file being interpreted or the name by which we invoke the script.|||4@@@env
Used for representing the array of elements that are environmental variables.|||5@@@errorCode
Provides the error code for last Tcl error.|||6@@@errorInfo
Provides the stack trace for last Tcl error.|||7@@@tcl_interactive
Used to switch between interactive and non-interactive modes by setting this to 1 and 0 respectively.|||8@@@tcl_library
Used for setting the location of standard Tcl libraries.|||9@@@tcl_pkgPath
Provides the list of directories where packages are generally installed.|||10@@@tcl_patchLevel
Refers to the current patch level of the Tcl interpreter.|||11@@@tcl_platform
Used for representing the array of elements with objects including byteOrder, machine, osVersion, platform, and os.|||12@@@tcl_precision
Refers to the precision i.e. number of digits to retain when converting to floating-point numbers to strings. The default value is 12.|||13@@@tcl_prompt1
Refers to the primary prompt.|||14@@@tcl_prompt2
Refers to the secondary prompt with invalid commands.|||15@@@tcl_rcFileName
Provides the user specific startup file.|||16@@@tcl_traceCompile
Used for controlling the tracing of bytecode compilation. Use 0 for no output, 1 for summary, and 2 for detailed.|||17@@@tcl_traceExec
Used for controlling the tracing of bytecode execution. Use 0 for no output, 1 for summary, and 2 for detailed.|||18@@@tcl_version
Returns the current version of the Tcl interpreter.",#!/usr/bin/tclshputs $tcl_version|||#!/usr/bin/tclshputs $env(PATH)|||#!/usr/bin/tclshputs $tcl_pkgPath|||#!/usr/bin/tclshputs $tcl_library|||#!/usr/bin/tclshputs $tcl_patchLevel|||#!/usr/bin/tclshputs $tcl_precision|||#!/usr/bin/tclshputs $tcl_rcFileName
Learn Tcl/Tk,Tcl - Basic Syntax,Tcl - Basic Syntax|||First Tcl Program@@@Comments@@@Identifiers@@@Whitespace in Tcl,"Tcl is quite simple to learn and let's start creating our first Tcl program!|||Let us write a simple Tcl program. All Tcl files will have an extension, i.e., .tcl. So, put the following source code in a test.tcl file.|||Assuming, Tcl environment is setup correctly; let's run the program after switching to file's directory and then execute the program using −|||We will get the following output −|||Let us now see the basic structure of Tcl program, so that it will be easy for you to understand basic building blocks of the Tcl language. In Tcl, we use new line or semicolon to terminate the previous line of code. But semicolon is not necessary, if you are using newline for each command.|||Comments are like helping text in your Tcl program and the interpreter ignores them. Comments can be written using a hash_(#) sign in the beginning.|||When the above code is executed, it produces the following result −|||Multiline or block comment is written using 'if' with condition '0'. An example is shown below.|||When the above code is executed, it produces the following result −|||Inline comments use ;#. An example is given below.|||When the above code is executed, it produces the following result −|||A Tcl identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore (_) followed by zero or more letters, underscores, dollars ($) , and digits (0 to 9).|||Tcl does not allow punctuation characters such as @, and % within identifiers. Tcl is a case sensitive_ language. Thus Manpower and manpower are two different identifiers in Tcl. Here are some of the examples of acceptable identifiers −|||A line containing only whitespace, possibly with a comment, is known as a blank line, and a Tcl interpreter totally ignores it.|||Whitespace is the term used in Tcl to describe blanks, tabs, newline characters, and comments. Whitespace separates one part of a statement from another and enables the interpreter to identify where one element in a statement, such as puts, ends and the next element begins. Therefore, in the following statement −|||There must be at least one whitespace character (usually a space) between “puts” and ""Hello World!"" for the interpreter to be able to distinguish them. On the other hand, in the following statement −|||When the above code is executed, it produces the following result −|||No whitespace characters are necessary between 3 and +, or between + and 2; although, you are free to include some if you wish for the readability purpose.",,,,"#!/usr/bin/tclshputs ""Hello, World!"" |||#!/usr/bin/tclsh# my first program in Tclputs ""Hello World!"" |||#!/usr/bin/tclshif 0 {   my first program in Tcl program   Its very simple}puts ""Hello World!"" |||#!/usr/bin/tclshputs ""Hello World!"" ;# my first print in Tcl program|||#!/usr/bin/tclshputs ""Hello World!"" |||#!/usr/bin/tclshputs [expr 3 + 2] ;# print sum of the 3 and 2"
Learn Tcl/Tk,Tcl - Commands,Tcl - Commands|||Command Substitution@@@Variable Substitution@@@Backslash Substitution,"As you know, Tcl is a Tool command language, commands are the most vital part of the language. Tcl commands are built in-to the language with each having its own predefined function. These commands form the reserved words of the language and cannot be used for other variable naming. The advantage with these Tcl commands is that, you can define your own implementation for any of these commands to replace the original built-in functionality.|||Each of the Tcl commands validates the input and it reduces the work of the interpreter.|||Tcl command is actually a list of words, with the first word representing the command to be executed. The next words represent the arguments. In order to group the words into a single argument, we enclose multiple words with """" or {}.|||The syntax of Tcl command is as follows −|||Let's see a simple example of Tcl command −|||When the above code is executed, it produces the following result −|||In the above code, ‘puts’ is the Tcl command and ""Hello World"" is the argument1. As said before, we have used """" to group two words.|||Let's see another example of Tcl command with two arguments −|||When the above code is executed, it produces the following result −|||In the above code, ‘puts’ is the Tcl command, ‘stdout’ is argument1, and ""Hello World"" is argument2. Here, stdout makes the program to print in the standard output device.|||In command substitutions, square brackets are used to evaluate the scripts inside the square brackets. A simple example to add two numbers is shown below −|||When the above code is executed, it produces following result −|||In variable substitutions, $ is used before the variable name and this returns the contents of the variable. A simple example to set a value to a variable and print it is shown below.|||When the above code is executed, it produces the following result −|||These are commonly called escape sequences; with each backslash, followed by a letter having its own meaning. A simple example for newline substitution is shown below −|||When the above code is executed, it produces the following result −",,,,"commandName argument1 argument2 ... argumentN|||#!/usr/bin/tclshputs ""Hello, world!""|||#!/usr/bin/tclshputs stdout ""Hello, world!""|||#!/usr/bin/tclshputs [expr 1 + 6 + 9]|||#!/usr/bin/tclshset a 3puts $a|||#!/usr/bin/tclshputs ""Hello\nWorld"""
Learn Tcl/Tk,Tcl - Data Types,Tcl - Data Types|||Simple Tcl Objects@@@String Representations@@@List@@@Associative Array@@@Handles,"The primitive data-type of Tcl is string and often we can find quotes on Tcl as string only language. These primitive data-types in turn create composite data-types for list and associative array. In Tcl, data-types can represent not only the simple Tcl objects, but also can represent complex objects such as handles, graphic objects (mostly widgets), and I/O channels. Let's look into the details about each of the above.|||In Tcl, whether it is an integer number, boolean, floating point number, or a string. When you want to use a variable, you can directly assign a value to it, there is no step of declaration in Tcl. There can be internal representations for these different types of objects. It can transform one data-type to another when required. The syntax for assigning value to variable is as follows −|||When the above code is executed, it produces the following result −|||The above statement will create a variable name myVariable and stores it as a string even though, we have not used double quotations. Now, if we try to make an arithmetic on the variable, it is automatically turned to an integer. A simple example is shown below −|||When the above code is executed, it produces the following result −|||One important thing to note is that, these variables don't have any default values and must be assigned value before they are used.|||If we try to print using puts, the number is transformed into proper string. Having two representations, internal and external, help Tcl to create complex data structures easily compared to other languages. Also, Tcl is more efficient due to its dynamic object nature.|||Unlike other languages, in Tcl, you need not include double quotes when it's only a single word. An example can be −|||When the above code is executed, it produces the following result −|||When we want to represent multiple strings, we can use either double quotes or curly braces. It is shown below −|||When the above code is executed, it produces the following result −|||List is nothing but a group of elements. A group of words either using double quotes or curly braces can be used to represent a simple list. A simple list is shown below −|||When the above code is executed, it produces the following result −|||Associative arrays have an index (key) that is not necessarily an integer. It is generally a string that acts like key value pairs. A simple example is shown below −|||When the above code is executed, it produces the following result −|||Tcl handles are commonly used to represent files and graphics objects. These can include handles to network requests and also other channels like serial port communication, sockets, or I/O devices. The following is an example where a file handle is created.|||You will see more detail on files in the Tcl file I/O chapter.",,,,"#!/usr/bin/tclshset myVariable 18puts $myVariable|||#!/usr/bin/tclshset myVariable 18puts [expr $myVariable + 6 + 9]|||#!/usr/bin/tclshset myVariable helloputs $myVariable|||#!/usr/bin/tclshset myVariable ""hello world""puts $myVariableset myVariable {hello world}puts $myVariable|||#!/usr/bin/tclshset myVariable {red green blue}puts [lindex $myVariable 2]set myVariable ""red green blue""puts [lindex $myVariable 1]|||#!/usr/bin/tclshset  marks(english) 80puts $marks(english)set  marks(mathematics) 90puts $marks(mathematics)"
Learn Tcl/Tk,Tcl - Variables,Tcl - Variables|||Variable Naming@@@Dynamic Typing@@@Mathematical Expressions,"In Tcl, there is no concept of variable declaration. Once, a new variable name is encountered, Tcl will define a new variable.|||The name of variables can contain any characters and length. You can even have white spaces by enclosing the variable in curly braces, but it is not preferred.|||The set command is used for assigning value to a variable. The syntax for set command is,|||A few examples of variables are shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above program, the $variableName is used to get the value of the variable.|||Tcl is a dynamically typed language. The value of the variable can be dynamically converted to the required type when required. For example, a number 5 that is stored as string will be converted to number when doing an arithmetic operation. It is shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above example, expr is used for representing mathematical expression. The default precision of Tcl is 12 digits. In order to get floating point results, we should add at least a single decimal digit. A simple example explains the above.|||When the above code is executed, it produces the following result −|||In the above example, you can see three cases. In the first case, the dividend and the divisor are whole numbers and we get a whole number as result. In the second case, the divisor alone is a decimal number and in the third case, the dividend is a decimal number. In both second and third cases, we get a decimal number as result.|||In the above code, you can change the precision by using tcl_precision special variable. It is shown below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshset variableA 10set {variable B} testputs $variableAputs ${variable B}|||#!/usr/bin/tclshset variableA ""10""puts $variableAset sum [expr $variableA +20];puts $sum|||#!/usr/bin/tclshset variableA ""10""set result [expr $variableA / 9];puts $resultset result [expr $variableA / 9.0];puts $resultset variableA ""10.0""set result [expr $variableA / 9];puts $result|||#!/usr/bin/tclshset variableA ""10""set tcl_precision 5set result [expr $variableA / 9.0];puts $result"
Learn Tcl/Tk,Tcl - Operators,Tcl - Operators|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Ternary Operator@@@Operators Precedence in Tcl,"An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Tcl language is rich in built-in operators and provides the following types of operators −|||This chapter will explain the arithmetic, relational, logical, bitwise, and ternary operators one by one.|||Following table shows all the arithmetic operators supported by Tcl language. Assume variable ‘A’ holds 10 and variable ‘B’ holds 20, then −|||Show Examples|||Following table shows all the relational operators supported by Tcl language. Assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||Following table shows all the logical operators supported by Tcl language. Assume variable A holds 1 and variable B holds 0, then −|||Show Examples|||Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &, |, and ^ are as follows −|||Assume if A = 60; and B = 13; now in binary format they will be as follows −|||A = 0011 1100|||B = 0000 1101|||----------------------|||A&B = 0000 1100|||A|B = 0011 1101|||A^B = 0011 0001|||The Bitwise operators supported by Tcl language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then −|||Show Examples|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.|||For example : x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3 * 2 and then adds into 7.|||Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.|||Show Examples",Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Ternary Operator,,"Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiplies both operands@@@A * B will give 200|||/@@@Divides numerator by de-numerator@@@B / A will give 2|||%@@@Modulus Operator and remainder of after an integer division@@@B % A will give 0&&&Operator@@@Description@@@Example|||==@@@Checks if the values of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||!=@@@Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||&&@@@Called Logical AND operator. If both the operands are non-zero, then condition becomes true.@@@(A && B) is false.|||||@@@Called Logical OR Operator. If any of the two operands is non-zero, then condition becomes true.@@@(A || B) is true.|||!@@@Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A && B) is true.&&&p@@@q@@@p & q@@@p | q@@@p ^ q|||0@@@0@@@0@@@0@@@0|||0@@@1@@@0@@@1@@@1|||1@@@1@@@1@@@1@@@0|||1@@@0@@@0@@@1@@@1&&&Operator@@@Description@@@Example|||&@@@Binary AND Operator copies a bit to the result if it exists in both operands.@@@(A & B) will give 12, which is 0000 1100||||@@@Binary OR Operator copies a bit if it exists in either operand.@@@(A | B) will give 61, which is 0011 1101|||^@@@Binary XOR Operator copies the bit if it is set in one operand but not both.@@@(A ^ B) will give 49, which is 0011 0001|||<<@@@Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.@@@A << 2 will give 240, which is 1111 0000|||>>@@@Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.@@@A >> 2 will give 15, which is 0000 1111&&&Operator@@@Description@@@Example|||? :@@@Ternary@@@If Condition is true? Then value X : Otherwise value Y&&&Category@@@Operator@@@Associativity|||Unary@@@+ -@@@Right to left|||Multiplicative@@@* / %@@@Left to right|||Additive@@@+ -@@@Left to right|||Shift@@@<< >>@@@Left to right|||Relational@@@< <= > >=@@@Left to right|||Bitwise AND@@@&@@@Left to right|||Bitwise XOR@@@^@@@Left to right|||Bitwise OR@@@|@@@Left to right|||Logical AND@@@&&@@@Left to right|||Logical OR@@@||@@@Left to right|||Ternary@@@?:@@@Right to left",
Learn Tcl/Tk,Tcl - Decisions,Tcl - Decisions|||The ? : Operator,"Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.|||Following is the general form of a typical decision making structure found in most of the programming languages −|||Tcl language uses the expr command internally and hence it’s not required for us to use expr statement explicitly.|||Tcl language provides following types of decision making statements −|||An 'if' statement consists of a Boolean expression followed by one or more statements.|||An 'if' statement can be followed by an optional 'else' statement, which executes when the Boolean expression is false.|||You can use one 'if' or 'else if' statement inside another 'if' or 'else if' statement(s).|||A switch statement allows a variable to be tested for equality against a list of values.|||You can use one switch statement inside another switch statement(s).|||We have covered conditional operator ? : in previous chapter, which can be used to replace if...else statements. It has the following general form −|||Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.|||The value of a '? expression' is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire '? expression.' If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. An example is shown below.|||When you compile and execute the above program, it produces the following result −",,,"Sr.No.@@@Statement & Description|||1@@@if statement
An 'if' statement consists of a Boolean expression followed by one or more statements.|||2@@@if...else statement
An 'if' statement can be followed by an optional 'else' statement, which executes when the Boolean expression is false.|||3@@@nested if statements
You can use one 'if' or 'else if' statement inside another 'if' or 'else if' statement(s).|||4@@@switch statement
A switch statement allows a variable to be tested for equality against a list of values.|||5@@@nested switch statements
You can use one switch statement inside another switch statement(s).","#!/usr/bin/tclshset a 10;set b [expr $a == 1 ? 20: 30]puts ""Value of b is $b\n""set b [expr $a == 10 ? 20: 30]puts ""Value of b is $b\n"" "
Learn Tcl/Tk,Tcl - Loops,Tcl - Loops|||Loop Control Statements@@@The Infinite Loop,"There may be a situation, where you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −|||Tcl language provides the following types of loops to handle looping requirements.|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||You can use one or more loop inside any another while, for or do..while loop.|||Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.|||Tcl supports the following control statements.|||Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.|||Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.|||A loop becomes infinite loop if a condition never becomes false. The while loop is traditionally used for this purpose. You can make an endless loop by leaving the conditional expression as 1.|||When the conditional expression is absent, it is assumed to be true. Tcl programmers more commonly use the while {1} construct to signify an infinite loop.|||NOTE − You can terminate an infinite loop by pressing Ctrl + C keys.",,,"Sr.No.@@@Loop Type & Description|||1@@@while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||2@@@for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||3@@@nested loops
You can use one or more loop inside any another while, for or do..while loop.&&&Sr.No.@@@Control Statement & Description|||1@@@break statement
Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.|||2@@@continue statement
Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.",
Learn Tcl/Tk,Tcl - Arrays,Tcl - Arrays|||Size of Array@@@Array Iteration@@@Associative Arrays@@@Indices of Array@@@Iteration of Associative Array,"An array is a systematic arrangement of a group of elements using indices. The syntax for the conventional array is shown below.|||An example for creating simple array is shown below.|||When the above code is executed, it produces the following result −|||The syntax for calculating size array is shown below.|||An example for printing the size is shown below.|||When the above code is executed, it produces the following result −|||Though, array indices can be non-continuous like values specified for index 1 then index 10 and so on. But, in case they are continuous, we can use array iteration to access elements of the array. A simple array iteration for printing elements of the array is shown below.|||When the above code is executed, it produces the following result −|||In Tcl, all arrays by nature are associative. Arrays are stored and retrieved without any specific order. Associative arrays have an index that is not necessarily a number, and can be sparsely populated. A simple example for associative array with non-number indices is shown below.|||When the above code is executed, it produces the following result −|||The syntax for retrieving indices of array is shown below.|||An example for printing the size is shown below.|||When the above code is executed, it produces the following result −|||You can use the indices of array to iterate through the associative array. An example is shown below.|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""puts $languages(0)puts $languages(1)|||#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""puts  [array size languages]|||#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""for { set index 0 }  { $index < [array size languages] }  { incr index } {   puts ""languages($index) : $languages($index)""}|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14puts  $personA(Name)puts  $personA(Age)|||[array names variablename]|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14puts [array names personA]|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14foreach index [array names personA] {   puts ""personA($index): $personA($index)""}"
Learn Tcl/Tk,Tcl - Strings,Tcl - Strings|||String Representations@@@String Escape Sequence@@@String Command|||String Comparison@@@Index of String@@@Length of String@@@Handling Cases@@@Trimming Characters@@@Matching Strings@@@Append Command@@@Format command@@@Scan command,"The primitive data-type of Tcl is string and often we can find quotes on Tcl as string only language. These strings can contain alphanumeric character, just numbers, Boolean, or even binary data. Tcl uses 16 bit unicode characters and alphanumeric characters can contain letters including non-Latin characters, number or punctuation.|||Boolean value can be represented as 1, yes or true for true and 0, no, or false for false.|||Unlike other languages, in Tcl, you need not include double quotes when it's only a single word. An example can be −|||When the above code is executed, it produces the following result −|||When we want to represent multiple strings, we can use either double quotes or curly braces. It is shown below −|||When the above code is executed, it produces the following result −|||A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0').|||There are certain characters in Tcl when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes −|||Following is the example to show a few escape sequence characters −|||When the above code is compiled and executed, it produces the following result −|||The list of subcommands for string command is listed in the following table −|||compare string1 string2|||Compares string1 and string2 lexographically. Returns 0 if equal, -1 if string1 comes before string2, else 1.|||first string1 string2|||Returns the index first occurrence of string1 in string2. If not found, returns -1.|||index string index|||Returns the character at index.|||last string1 string2|||Returns the index last occurrence of string1 in string2. If not found, returns -1.|||length string|||Returns the length of string.|||match pattern string|||Returns 1 if the string matches the pattern.|||range string index1 index2|||Return the range of characters in string from index1 to index2.|||tolower string|||Returns the lowercase string.|||toupper string|||Returns the uppercase string.|||trim string ?trimcharacters?|||Removes trimcharacters in both ends of string. The default trimcharacters is whitespace.|||trimleft string ?trimcharacters?|||Removes trimcharacters in left beginning of string. The default trimcharacters is whitespace.|||trimright string ?trimcharacters?|||Removes trimcharacters in left end of string. The default trimcharacters is whitespace.|||wordend findstring index|||Return the index in findstring of the character after the word containing the character at index.|||wordstart findstring index|||Return the index in findstring of the first character in the word containing the character at index.|||Examples of some commonly used Tcl string sub commands are given below.|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||The following table shows the list of format specifiers available in Tcl −|||Some simple examples are given below −|||When the above code is compiled and executed, it produces the following result −|||Scan command is used for parsing a string based to the format specifier. Some examples are shown below.|||When the above code is compiled and executed, it produces the following result −",,,"Escape sequence@@@Meaning|||\\@@@\ character|||\'@@@' character|||\""@@@"" character|||\?@@@? character|||\a@@@Alert or bell|||\b@@@Backspace|||\f@@@Form feed|||\n@@@Newline|||\r@@@Carriage return|||\t@@@Horizontal tab|||\v@@@Vertical tab&&&Sr.No.@@@Methods & Description|||1@@@compare string1 string2
Compares string1 and string2 lexographically. Returns 0 if equal, -1 if string1 comes before string2, else 1.|||2@@@first string1 string2
Returns the index first occurrence of string1 in string2. If not found, returns -1.|||3@@@index string index
Returns the character at index.|||4@@@last string1 string2
Returns the index last occurrence of string1 in string2. If not found, returns -1.|||5@@@length string
Returns the length of string.|||6@@@match pattern string
Returns 1 if the string matches the pattern.|||7@@@range string index1 index2
Return the range of characters in string from index1 to index2.|||8@@@tolower string
Returns the lowercase string.|||9@@@toupper string
Returns the uppercase string.|||10@@@trim string ?trimcharacters?
Removes trimcharacters in both ends of string. The default trimcharacters is whitespace.|||11@@@trimleft string ?trimcharacters?
Removes trimcharacters in left beginning of string. The default trimcharacters is whitespace.|||12@@@trimright string ?trimcharacters?
Removes trimcharacters in left end of string. The default trimcharacters is whitespace.|||13@@@wordend findstring index
Return the index in findstring of the character after the word containing the character at index.|||14@@@wordstart findstring index
Return the index in findstring of the first character in the word containing the character at index.&&&Specifier@@@Use|||%s@@@String representation|||%d@@@Integer representation|||%f@@@Floating point representation|||%e@@@Floating point representation with mantissa-exponent form|||%x@@@Hexa decimal representation","#!/usr/bin/tclshset myVariable helloputs $myVariable|||#!/usr/bin/tclshset myVariable ""hello world""puts $myVariableset myVariable {hello world}puts $myVariable|||#!/usr/bin/tclshputs ""Hello\tWorld\n\nTutorialspoint"";|||#!/usr/bin/tclshset s1 ""Hello""set s2 ""World""set s3 ""World""puts [string compare $s1 $s2]if {[string compare $s2 $s3] == 0} {   puts ""String \'s1\' and \'s2\' are same."";}if {[string compare $s1 $s2] == -1} {   puts ""String \'s1\' comes before \'s2\'."";}if {[string compare $s2 $s1] == 1} {   puts ""String \'s2\' comes after \'s1\'."";}|||#!/usr/bin/tclshset s1 ""Hello World""set s2 ""o""puts ""First occurrence of $s2 in s1""puts [string first $s2 $s1]puts ""Character at index 0 in s1""puts [string index $s1 0]puts ""Last occurrence of $s2 in s1""puts [string last $s2 $s1]puts ""Word end index in s1""puts [string wordend $s1 20]puts ""Word start index in s1""puts [string wordstart $s1 20]|||#!/usr/bin/tclshset s1 ""Hello World""puts ""Length of string s1""puts [string length $s1]|||#!/usr/bin/tclshset s1 ""Hello World""puts ""Uppercase string of s1""puts [string toupper $s1]puts ""Lowercase string of s1""puts [string tolower $s1]|||#!/usr/bin/tclshset s1 ""Hello World""set s2 ""World""puts ""Trim right $s2 in $s1""puts [string trimright $s1 $s2]set s2 ""Hello""puts ""Trim left $s2 in $s1""puts [string trimleft $s1 $s2]set s1 "" Hello World ""set s2 "" ""puts ""Trim characters s1 on both sides of s2""puts [string trim $s1 $s2]|||#!/usr/bin/tclshset s1 ""test@test.com"" set s2 ""*@*.com""puts ""Matching pattern s2 in s1""puts [string match ""*@*.com"" $s1 ]puts ""Matching pattern tcl in s1""puts [string match {tcl} $s1]|||#!/usr/bin/tclshset s1 ""Hello"" append s1 "" World""puts $s1|||#!/usr/bin/tclshputs [format ""%f"" 43.5]puts [format ""%e"" 43.5]puts [format ""%d %s"" 4 tuts]puts [format ""%s"" ""Tcl Language""]puts [format ""%x"" 40]|||#!/usr/bin/tclshputs [scan ""90"" {%[0-9]} m]puts [scan ""abc"" {%[a-z]} m]puts [scan ""abc"" {%[A-Z]} m]puts [scan ""ABC"" {%[A-Z]} m]"
Learn Tcl/Tk,Tcl - Lists,Tcl - Lists|||Creating a List@@@Appending Item to a List@@@Length of List@@@List Item at Index@@@Insert Item at Index@@@Replace Items at Indices@@@Set Item at Index@@@Transform List to Variables@@@Sorting a List,"List is one of the basic data-type available in Tcl. It is used for representing an ordered collection of items. It can include different types of items in the same list. Further, a list can contain another list.|||An important thing that needs to be noted is that these lists are represented as strings completely and processed to form individual items when required. So, avoid large lists and in such cases; use array.|||The general syntax for list is given below −|||Some examples are given below −|||When the above code is executed, it produces the following result −|||The syntax for appending item to a list is given below −|||Some examples are given below −|||When the above code is executed, it produces the following result −|||The syntax for length of list is given below −|||Example for length of list is given below −|||When the above code is executed, it produces the following result −|||The syntax for selecting list item at specific index is given below −|||Example for list item at index is given below −|||When the above code is executed, it produces the following result −|||The syntax for inserting list items at specific index is given below.|||Example for inserting list item at specific index is given below.|||When the above code is executed, it produces the following result −|||The syntax for replacing list items at specific indices is given below −|||Example for replacing list items at specific indices is given below.|||When the above code is executed, it produces the following result −|||The syntax for setting list item at specific index is given below −|||Example for setting list item at specific index is given below −|||When the above code is executed, it produces the following result −|||The syntax for copying values to variables is given below −|||Example for transforming list into variables is given below −|||When the above code is executed, it produces the following result −|||The syntax for sorting a list is given below −|||An example for sorting a list is given below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshset colorList1 {red green blue}set colorList2 [list red green blue]set colorList3 [split ""red_green_blue"" _]puts $colorList1puts $colorList2puts $colorList3|||#!/usr/bin/tclshset var orangeappend var "" "" ""blue""lappend var ""red"" lappend var ""green"" puts $var|||#!/usr/bin/tclshset var {orange blue red green}puts [llength $var] |||#!/usr/bin/tclshset var {orange blue red green}puts [lindex $var  1]|||#!/usr/bin/tclshset var {orange blue red green}set var [linsert  $var 3 black white]puts $var|||#!/usr/bin/tclshset var {orange blue red green}set var [lreplace $var 2 3 black white]puts $var|||#!/usr/bin/tclshset var {orange blue red green}lset var 0 black puts $var|||#!/usr/bin/tclshset var {orange blue red green}lassign $var colour1 colour2puts $colour1puts $colour2|||#!/usr/bin/tclshset var {orange blue red green}set var [lsort $var]puts $var"
Learn Tcl/Tk,Tcl - Dictionary,Tcl - Dictionary|||Size of Dict@@@Dictionary Iteration@@@Value for Key in Dict@@@All Keys in Dict@@@All Values in Dict@@@Key Exists in Dict,"A dictionary is an arrangement for mapping values to keys. The syntax for the conventional dictionary is shown below −|||Some examples for creating a dictionary are shown below −|||When the above code is executed, it produces the following result −|||The syntax for getting size of dict is shown below −|||An example for printing the size is shown below −|||When the above code is executed, it produces the following result −|||A simple dictionary iteration for printing keys and valued of the dictionary is shown below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving value for key in dict is shown below −|||An example for retrieving value for key is given below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving all keys in dict is shown below −|||An example for printing all keys is shown below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving all values in dict is shown below −|||An example for printing all values is shown below −|||When the above code is executed, it produces the following result −|||The syntax for checking if a key exists in dict is shown below −|||An example for checking if a key exists in dict is shown below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshdict set colours  colour1 red puts $coloursdict set colours  colour2 greenputs $coloursset colours [dict create colour1 ""black"" colour2 ""white""]puts $colours|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]puts [dict size $colours]|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]foreach item [dict keys $colours] {   set value [dict get $colours $item]   puts $value}|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set value [dict get $colours colour1]puts $value|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set keys [dict keys $colours]puts $keys|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set values [dict values $colours]puts $values|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set result [dict exists $colours colour1]puts $result"
Learn Tcl/Tk,Tcl - Procedures,Tcl - Procedures|||Procedures with Multiple Arguments@@@Procedures with Variable Arguments@@@Procedures with Default Arguments@@@Recursive Procedures,"Procedures are nothing but code blocks with series of commands that provide a specific reusable functionality. It is used to avoid same code being repeated in multiple locations. Procedures are equivalent to the functions used in many programming languages and are made available in Tcl with the help of proc command.|||The syntax of creating a simple procedure is shown below −|||A simple example for procedure is given below −|||When the above code is executed, it produces the following result −|||An example for procedure with arguments is shown below −|||When the above code is executed, it produces the following result −|||An example for procedure with arguments is shown below −|||When the above code is executed, it produces the following result −|||Default arguments are used to provide default values that can be used if no value is provided. An example for procedure with default arguments, which is sometimes referred as implicit arguments is shown below −|||When the above code is executed, it produces the following result −|||An example for recursive procedures is shown below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshproc helloWorld {} {   puts ""Hello, World!""}helloWorld|||#!/usr/bin/tclshproc add {a b} {   return [expr $a+$b]}puts [add 10 30]|||#!/usr/bin/tclshproc avg {numbers} {   set sum 0   foreach number $numbers {      set sum  [expr $sum + $number]   }   set average [expr $sum/[llength $numbers]]   return $average}puts [avg {70 80 50 60}]puts [avg {70 80 50 }]|||#!/usr/bin/tclshproc add {a {b 100} } {   return [expr $a+$b]}puts [add 10 30]puts [add 10]|||#!/usr/bin/tclshproc factorial {number} {   if {$number <= 1} {      return 1   }    return [expr $number * [factorial [expr $number - 1]]]}puts [factorial 3]puts [factorial 5]"
Learn Tcl/Tk,Tcl - Packages,Tcl - Packages|||Creating Package|||STEP 1 : Creating Code@@@STEP 2 : Creating Package Index@@@STEP 3 : Adding Directory to Autopath@@@STEP 4 : Adding Package@@@STEP 5 : Invoking Procedure,"Packages are used for creating reusable units of code. A package consists of a collection of files that provide specific functionality. This collection of files is identified by a package name and can have multiple versions of same files. The package can be a collection of Tcl scripts, binary library, or a combination of both.|||Package uses the concept of namespace to avoid collision of variable names and procedure names. Check out more in our next 'namespace' tutorial.|||A package can be created with the help of minimum two files. One file contains the package code. Other file contains the index package file for declaring your package.|||The list of steps for creating and using package is given below.|||Create code for package inside a folder say HelloWorld. Let the file be named HelloWorld.tcl with the code as shown below −|||Open tclsh. Switch to HelloWorld directory and use the pkg_mkIndex command to create the index file as shown below −|||Use the lappend command to add the package to the global list as shown below −|||Next add package to program using package require statement as shown below −|||Now, everything being setup, we can invoke our procedure as shown below −|||You will get the following result −|||First two steps create the package. Once package is created, you can use it in any Tcl file by adding the last three statements as shown below −|||You will get the following result −",,,,"# /Users/rajkumar/Desktop/helloworld/HelloWorld.tcl # Create the namespacenamespace eval ::HelloWorld {   # Export MyProcedure  namespace export MyProcedure   # My Variables   set version 1.0   set MyDescription ""HelloWorld""   # Variable for the path of the script   variable home [file join [pwd] [file dirname [info script]]] } # Definition of the procedure MyProcedureproc ::HelloWorld::MyProcedure {} {   puts $HelloWorld::MyDescription}package provide HelloWorld $HelloWorld::versionpackage require Tcl 8.0"
Learn Tcl/Tk,Tcl - Namespaces,Tcl - Namespaces|||Creating Namespace@@@Nested Namespaces@@@Importing and Exporting Namespace@@@Forget Namespace,"Namespace is a container for set of identifiers that is used to group variables and procedures. Namespaces are available from Tcl version 8.0. Before the introduction of the namespaces, there was single global scope. Now with namespaces, we have additional partitions of global scope.|||Namespaces are created using the namespace command. A simple example for creating namespace is shown below −|||When the above code is executed, it produces the following result −|||In the above program, you can see there is a namespace with a variable myResult and a procedure Add. This makes it possible to create variables and procedures with the same names under different namespaces.|||Tcl allows nesting of namespaces. A simple example for nesting namespaces is given below −|||When the above code is executed, it produces the following result −|||You can see in the previous namespace examples, we use a lot of scope resolution operator and it's more complex to use. We can avoid this by importing and exporting namespaces. An example is given below −|||When the above code is executed, it produces the following result −|||You can remove an imported namespace by using forget subcommand. A simple example is shown below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshnamespace eval MyMath {  # Create a variable inside the namespace  variable myResult}# Create procedures inside the namespaceproc MyMath::Add {a b } {    set ::MyMath::myResult [expr $a + $b]}MyMath::Add 10 23puts $::MyMath::myResult|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult}namespace eval extendedMath {   # Create a variable inside the namespace   namespace eval MyMath {      # Create a variable inside the namespace      variable myResult   }}set ::MyMath::myResult ""test1""puts $::MyMath::myResultset ::extendedMath::MyMath::myResult ""test2""puts $::extendedMath::MyMath::myResult|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult   namespace export Add}# Create procedures inside the namespaceproc MyMath::Add {a b } {     return [expr $a + $b]}namespace import MyMath::*puts [Add 10 30]|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult   namespace export Add}# Create procedures inside the namespaceproc MyMath::Add {a b } {     return [expr $a + $b]}namespace import MyMath::*puts [Add 10 30]namespace forget MyMath::*"
Learn Tcl/Tk,Tcl - File I/O,Tcl - File I/O|||Opening Files@@@Closing a File@@@Writing a File@@@Reading a File,"Tcl supports file handling with the help of the built in commands open, read, puts, gets, and close.|||A file represents a sequence of bytes, does not matter if it is a text file or binary file.|||Tcl uses the open command to open files in Tcl. The syntax for opening a file is as follows −|||Here, filename is string literal, which you will use to name your file and accessMode can have one of the following values −|||r|||Opens an existing text file for reading purpose and the file must exist. This is the default mode used when no accessMode is specified.|||w|||Opens a text file for writing, if it does not exist, then a new file is created else existing file is truncated.|||a|||Opens a text file for writing in appending mode and file must exist. Here, your program will start appending content in the existing file content.|||r+|||Opens a text file for reading and writing both. File must exist already.|||w+|||Opens a text file for reading and writing both. It first truncate the file to zero length if it exists otherwise create the file if it does not exist.|||a+|||Opens a text file for reading and writing both. It creates the file if it does not exist. The reading will start from the beginning, but writing can only be appended.|||To close a file, use the close command. The syntax for close is as follows −|||Any file that has been opened by a program must be closed when the program finishes using that file. In most cases, the files need not be closed explicitly; they are closed automatically when File objects are terminated automatically.|||Puts command is used to write to an open file.|||A simple example for writing to a file is shown below.|||When the above code is compiled and executed, it creates a new file input.txt in the directory that it has been started under (in the program's working directory).|||Following is the simple command to read from a file −|||A complete example of read and write is shown below −|||When the above code is compiled and executed, it reads the file created in previous section and produces the following result −|||Here is another example for reading file till end of file line by line −|||When the above code is compiled and executed, it reads the file created in previous section and produces the following result −",,,"Sr.No.@@@Mode & Description|||1@@@r
Opens an existing text file for reading purpose and the file must exist. This is the default mode used when no accessMode is specified.|||2@@@w
Opens a text file for writing, if it does not exist, then a new file is created else existing file is truncated.|||3@@@a
Opens a text file for writing in appending mode and file must exist. Here, your program will start appending content in the existing file content.|||4@@@r+
Opens a text file for reading and writing both. File must exist already.|||5@@@w+
Opens a text file for reading and writing both. It first truncate the file to zero length if it exists otherwise create the file if it does not exist.|||6@@@a+
Opens a text file for reading and writing both. It creates the file if it does not exist. The reading will start from the beginning, but writing can only be appended.","#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test""close $fp|||#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test""close $fpset fp [open ""input.txt"" r]set file_data [read $fp]puts $file_dataclose $fp|||#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test\ntest""close $fpset fp [open ""input.txt"" r]while { [gets $fp data] >= 0 } {   puts $data}close $fp"
Learn Tcl/Tk,Tcl - Error Handling,Tcl - Error Handling|||Error syntax@@@Catch Syntax,"Error handling in Tcl is provided with the help of error and catch commands. The syntax for each of these commands is shown below.|||In the above error command syntax, message is the error message, info is set in the global variable errorInfo and code is set in the global variable errorCode.|||In the above catch command syntax, script is the code to be executed, resultVarName is variable that holds the error or the result. The catch command returns 0 if there is no error, and 1 if there is an error.|||An example for simple error handling is shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above example, we can create our own custom error messages. Similarly, it is possible to catch the error generated by Tcl. An example is shown below −|||When the above code is executed, it produces the following result −",,,,"#!/usr/bin/tclshproc Div {a b} {   if {$b == 0} {      error ""Error generated by error"" ""Info String for error"" 401   } else {      return [expr $a/$b]   }}if {[catch {puts ""Result = [Div 10 0]""} errmsg]} {   puts ""ErrorMsg: $errmsg""   puts ""ErrorCode: $errorCode""   puts ""ErrorInfo:\n$errorInfo\n""}if {[catch {puts ""Result = [Div 10 2]""} errmsg]} {   puts ""ErrorMsg: $errmsg""   puts ""ErrorCode: $errorCode""   puts ""ErrorInfo:\n$errorInfo\n""}|||#!/usr/bin/tclshcatch {set file [open myNonexistingfile.txt]} resultputs ""ErrorMsg: $result""puts ""ErrorCode: $errorCode""puts ""ErrorInfo:\n$errorInfo\n"""
Learn Tcl/Tk,Tcl - Built-in Functions,Tcl - Built-in Functions|||Math Functions@@@System Functions,"Tcl provides a number of built-in functions (procedures) for various operations. This includes −|||Functions for list handling.|||Functions for string handling.|||Functions for array handling.|||Functions for dictionary handling.|||Functions for File I/O handling.|||Functions for creating namespaces and packages.|||Functions for Math operations.|||Functions for System operations.|||Each of the above except for math and system functions are covered in earlier chapters. Math and system built-in functions are explained below.|||The math functions available in Tcl are listed in the following table −|||abs arg|||Calculates the absolute value of arg.|||acos arg|||Calculates the arccosine of arg.|||asin arg|||Calculates the arcsine of arg.|||atan arg|||Calculates the arctangent of arg.|||atan2 y x|||Calculates the arctangent of the quotient of its arguments(y/x).|||ceil arg|||Calculates the smallest integer greater than or equal to a number.|||cos arg|||Calculates the cosine of arg.|||cosh arg|||Calculates the hyperbolic cosine of arg.|||double arg|||Calculates if arg is a floating-point value, returns arg, otherwise converts arg to floating-point and returns the converted value.|||exp arg|||Calculates an exponential function (e raised to the power of arg).|||floor arg|||Calculates the largest integer less than or equal to arg.|||fmod x y|||Calculates the floating-point remainder of the division of x by y. If y is 0, an error is returned.|||hypot x y|||Calculates the length of the hypotenuse of a right-angled triangle sqrt(x*x+y*y).|||int arg|||Calculates if arg is an integer value of the same width as the machine word, returns arg, otherwise converts arg to an integer.|||log arg|||Calculates the natural logarithm of arg.|||log10 arg|||Calculates the base 10 logarithm of arg.|||pow x y|||Calculates the value of x raised to the power y. If x is negative, y must be an integer value.|||rand|||Calculates a pseudo-random number between 0 and 1.|||round arg|||Calculates the value of arg rounded to the nearest integer.|||sin arg|||Calculates the sine of arg.|||sinh arg|||Calculates the hyperbolic sine of arg.|||sqrt arg|||Calculates the square root of arg. arg must be positive.|||srand arg|||Calculates a pseudo-random number between 0 and 1. The arg, which must be an integer, is used to reset the seed for the random number generator of rand.|||tan arg|||Calculates the tangent of arg.|||tanh arg|||Calculates the hyperbolic tangent of arg.|||wide arg|||Calculates integer value at least 64-bits wide (by sign-extension if arg is a 32-bit number) for arg if it is not one already.|||Some examples using math functions are given below −|||When the above code is executed, it produces the following result −|||The important system functions in Tcl includes,|||clock − seconds function, which returns current time in seconds.|||clock − format function, which formats the seconds into date and time.|||clock − scan function, which scans the input string and converts it into seconds.|||open − function, which is used to open a file.|||exec − function, which is used to execute a system command.|||close − function, which is used to close a file.|||Some examples for the above functions are listed below −|||When the above code is executed, it produces the following result −|||The following table provides the list strings that can be used to format the date and time.|||%a|||Day in short form, eg:Sun.|||%A|||Day in full form eg:Sunday.|||%b|||Month in short form.|||%B|||Month in full form.|||%d|||Day of month.|||%j|||Julian day of year.|||%m|||Month in number.|||%y|||Year in two digits.|||%Y|||Year in four digits.|||%H|||Hour in 24 hour clock.|||%I|||Hour in 12 hour clock.|||%M|||Minutes.|||%S|||Seconds.|||%p|||AM or PM.|||%D|||Date in number, mm /dd/yy.|||%r|||Time in 12 hour clock.|||%R |||Time in 24 hour clock without seconds.|||%T|||Time in 24 hour clock with seconds.|||%Z|||Time Zone Name like GMT, IST, EST and so on.","Functions for list handling.@@@Functions for string handling.@@@Functions for array handling.@@@Functions for dictionary handling.@@@Functions for File I/O handling.@@@Functions for creating namespaces and packages.@@@Functions for Math operations.@@@Functions for System operations.|||clock − seconds function, which returns current time in seconds.@@@clock − format function, which formats the seconds into date and time.@@@clock − scan function, which scans the input string and converts it into seconds.@@@open − function, which is used to open a file.@@@exec − function, which is used to execute a system command.@@@close − function, which is used to close a file.",,"Sr.No.@@@Method & Description|||1@@@abs arg
Calculates the absolute value of arg.|||2@@@acos arg
Calculates the arccosine of arg.|||3@@@asin arg
Calculates the arcsine of arg.|||4@@@atan arg
Calculates the arctangent of arg.|||5@@@atan2 y x
Calculates the arctangent of the quotient of its arguments(y/x).|||6@@@ceil arg
Calculates the smallest integer greater than or equal to a number.|||7@@@cos arg
Calculates the cosine of arg.|||8@@@cosh arg
Calculates the hyperbolic cosine of arg.|||9@@@double arg
Calculates if arg is a floating-point value, returns arg, otherwise converts arg to floating-point and returns the converted value.|||10@@@exp arg
Calculates an exponential function (e raised to the power of arg).|||11@@@floor arg
Calculates the largest integer less than or equal to arg.|||12@@@fmod x y
Calculates the floating-point remainder of the division of x by y. If y is 0, an error is returned.|||13@@@hypot x y
Calculates the length of the hypotenuse of a right-angled triangle sqrt(x*x+y*y).|||14@@@int arg
Calculates if arg is an integer value of the same width as the machine word, returns arg, otherwise converts arg to an integer.|||15@@@log arg
Calculates the natural logarithm of arg.|||16@@@log10 arg
Calculates the base 10 logarithm of arg.|||17@@@pow x y
Calculates the value of x raised to the power y. If x is negative, y must be an integer value.|||18@@@rand
Calculates a pseudo-random number between 0 and 1.|||19@@@round arg
Calculates the value of arg rounded to the nearest integer.|||20@@@sin arg
Calculates the sine of arg.|||21@@@sinh arg
Calculates the hyperbolic sine of arg.|||22@@@sqrt arg
Calculates the square root of arg. arg must be positive.|||23@@@srand arg
Calculates a pseudo-random number between 0 and 1. The arg, which must be an integer, is used to reset the seed for the random number generator of rand.|||24@@@tan arg
Calculates the tangent of arg.|||25@@@tanh arg
Calculates the hyperbolic tangent of arg.|||26@@@wide arg
Calculates integer value at least 64-bits wide (by sign-extension if arg is a 32-bit number) for arg if it is not one already.&&&Sr.No.@@@Format & Description|||1@@@%a
Day in short form, eg:Sun.|||2@@@%A
Day in full form eg:Sunday.|||3@@@%b
Month in short form.|||4@@@%B
Month in full form.|||5@@@%d
Day of month.|||6@@@%j
Julian day of year.|||7@@@%m
Month in number.|||8@@@%y
Year in two digits.|||9@@@%Y
Year in four digits.|||10@@@%H
Hour in 24 hour clock.|||11@@@%I
Hour in 12 hour clock.|||12@@@%M
Minutes.|||13@@@%S
Seconds.|||14@@@%p
AM or PM.|||15@@@%D
Date in number, mm /dd/yy.|||16@@@%r
Time in 12 hour clock.|||17@@@%R 
Time in 24 hour clock without seconds.|||18@@@%T
Time in 24 hour clock with seconds.|||19@@@%Z
Time Zone Name like GMT, IST, EST and so on.","#!/usr/bin/tclshnamespace import ::tcl::mathfunc::*puts [tan 10]puts [pow 10 2]puts [ceil 10.34]puts [hypot 10 20]puts [srand 45]puts [log 10]puts [srand 45]|||#!/usr/bin/tclsh#get secondsset currentTime [clock seconds]puts $currentTime#get format puts ""The time is: [clock format $currentTime -format %H:%M:%S]""puts ""The date is: [clock format $currentTime -format %D]""set date ""Jun 15, 2014""puts [clock scan $date -format {%b %d, %Y}]puts [exec ls]puts [exec dir]set a  [open input.txt]puts [read $a];puts $aclose $a"
Learn Tcl/Tk,Tcl - Regular Expressions,Tcl - Regular Expressions|||Syntax@@@Multiple Patterns@@@Switches for Regex Command,"The ""regexp"" command is used to match a regular expression in Tcl. A regular expression is a sequence of characters that contains a search pattern. It consists of multiple rules and the following table explains these rules and corresponding use.|||x|||Exact match.|||[a-z]|||Any lowercase letter from a-z.|||.|||Any character.|||^|||Beginning string should match.|||$|||Ending string should match.|||\^|||Backlash sequence to match special character ^.Similarly you can use for other characters.|||()|||Add the above sequences inside parenthesis to make a regular expression.|||x*|||Should match 0 or more occurrences of the preceding x.|||x+|||Should match 1 or more occurrences of the preceding x.|||[a-z]?|||Should match 0 or 1 occurrence of the preceding x.|||{digit}|||Matches exactly digit occurrences of previous regex expression. Digit that contains 0-9.|||{digit,}|||Matches 3 or more digit occurrences of previous regex expression. Digit that contains 0-9.|||{digit1,digit2}|||Occurrences matches the range between digit1 and digit2 occurrences of previous regex expression.|||The syntax for regex is given below −|||Here, regex is the command. We will see about optional switches later. Patterns are the rules as mentioned earlier. Search string is the actual string on which the regex is performed. Full match is any variable to hold the result of matched regex result. Submatch1 to SubMatchn are optional subMatch variable that holds the result of sub match patterns.|||Let's look at some simple examples before diving into complex ones. A simple example for a string with any alphabets. When any other character is encountered the regex, search will be stopped and returned.|||When the above code is executed, it produces the following result −|||The following example shows how to search for multiple patterns. This is example pattern for any alphabets followed by any character followed by any alphabets.|||When the above code is executed, it produces the following result −|||A modified version of the above code to show that a sub pattern can contain multiple patterns is shown below −|||When the above code is executed, it produces the following result −|||The list of switches available in Tcl are,|||nocase − Used to ignore case.|||indices − Store location of matched sub patterns instead of matched characters.|||line − New line sensitive matching. Ignores the characters after newline.|||start index − Sets the offset of start of search pattern.|||Marks the end of switches|||In the above examples, I have deliberately used [A-Z, a-z] for all alphabets, you can easily use -nocase instead of as shown below −|||When the above code is executed, it produces the following result −|||Another example using switches is shown below −|||When the above code is executed, it produces the following result −",nocase − Used to ignore case.@@@indices − Store location of matched sub patterns instead of matched characters.@@@line − New line sensitive matching. Ignores the characters after newline.@@@start index − Sets the offset of start of search pattern.@@@Marks the end of switches,,"Sr.No.@@@Rule & Description|||1@@@x
Exact match.|||2@@@[a-z]
Any lowercase letter from a-z.|||3@@@.
Any character.|||4@@@^
Beginning string should match.|||5@@@$
Ending string should match.|||6@@@\^
Backlash sequence to match special character ^.Similarly you can use for other characters.|||7@@@()
Add the above sequences inside parenthesis to make a regular expression.|||8@@@x*
Should match 0 or more occurrences of the preceding x.|||9@@@x+
Should match 1 or more occurrences of the preceding x.|||10@@@[a-z]?
Should match 0 or 1 occurrence of the preceding x.|||11@@@{digit}
Matches exactly digit occurrences of previous regex expression. Digit that contains 0-9.|||12@@@{digit,}
Matches 3 or more digit occurrences of previous regex expression. Digit that contains 0-9.|||13@@@{digit1,digit2}
Occurrences matches the range between digit1 and digit2 occurrences of previous regex expression.","#!/usr/bin/tclshregexp {([A-Za-z]*)} ""Tcl Tutorial"" a b puts ""Full Match: $a""puts ""Sub Match1: $b""|||#!/usr/bin/tclshregexp {([A-Za-z]*).([A-Za-z]*)} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp {([A-Za-z]*.([A-Za-z]*))} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp -nocase {([A-Z]*.([A-Z]*))} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp -nocase -line -- {([A-Z]*.([A-Z]*))} ""Tcl \nTutorial"" a b puts ""Full Match: $a""puts ""Sub Match1: $b""regexp -nocase -start 4 -line -- {([A-Z]*.([A-Z]*))} ""Tcl \nTutorial"" a b  puts ""Full Match: $a""puts ""Sub Match1: $b"""
Learn Tcl/Tk,Tk - Overview,Tk - Overview|||Features of Tk@@@Applications Built in Tk,"Tk refers to Toolkit and it provides cross platform GUI widgets, which helps you in building a Graphical User Interface. It was developed as an extension to Tcl scripting language by John Ousterhout. Tk remained in development independently from Tcl with version being different to each other, before, it was made in sync with Tcl in v8.0.|||It is cross platform with support for Linux, Mac OS, Unix, and Microsoft Windows operating systems.|||Large successful applications have been built in Tcl/Tk.",It is an open source.@@@It provides high level of extendibility.@@@It is customizable.@@@It is configurable.@@@It provides a large number of widgets.@@@It can be used with other dynamic languages and not just Tcl.@@@GUI looks identical across platforms.|||Dashboard Soft User Interface@@@Forms GUI for Relational DB@@@Ad Hoc GUI for Relational DB@@@Software/Hardware System Design@@@Xtask - Task Management@@@Musicology with Tcl and Tk@@@Calender app@@@Tk mail@@@Tk Debugger,,,
Learn Tcl/Tk,Tk - Environment,Tk - Environment|||The Tk Interpreter@@@Installation on Windows@@@Installation on Linux@@@Installation on Debian Based Systems@@@Installation on Mac OS X@@@Installation from Source Files,"Generally, all Mac and Linux mac come with Tk pre-installed. In case, it's not available or you need the latest version, then you may need to install it. Windows don't come with Tcl/Tk and you may need to use its specific binary to install it.|||It is just a small program that enables you to type Tk commands and have them executed line by line. It stops execution of a tcl file in case, it encounters an error unlike a compiler that executes fully.|||Let's have a helloWorld.tcl file as follows. We will use this as first program, we run on the platform you choose.|||The following section explains only how to install Tcl/Tk on each of the available platforms.|||Download the latest version for windows  installer from the list of Active Tcl/Tk binaries available. Active Tcl/Tk community edition is free for personal use.|||Run the downloaded executable to install the Tcl and Tk, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd and then using the following step −|||Press enter and we will see an output as shown below −|||Most Linux operating systems comes with Tk inbuilt and you can get started right away in those systems. In case, it's not available, you can use the following command to download and install Tcl-Tk.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following step −|||Press enter and we will see an output similar to the following −|||In case, it's not available prebuilt in your OS, you can use the following command to download and install Tcl-Tk −|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following steps −|||Press enter and we will see an output similar to the following −|||Download the latest version for Mac OS X  package from the list of Active Tcl/Tk binaries available. Active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Active Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following step −|||Press enter and we will see an output as shown below −|||You can use the option of installing from source files when a binary package is not available. It is generally preferred to use Tk binaries for Windows and Mac OS X, so only compilation of sources on unix based system is shown below −|||Download the source files.|||Now, use the following commands to extract, compile and build after switching to the downloaded folder.|||Note − Make sure, you change the file name to the version you downloaded on commands 1 and 2 in the above.","Download the source files.@@@Now, use the following commands to extract, compile and build after switching to the downloaded folder.",,,"#!/usr/bin/wishgrid [ttk::button .mybutton -text ""Hello World""] |||$ tar zxf tk8.6.1-src.tar.gz$ cd tcl8.6.1$ cd unix$ ./configure —with-tcl=../../tcl8.6.1/unix —prefix=/opt —enable-gcc$ make$ sudo make install"
Learn Tcl/Tk,Tk - Special Variables,Tk - Special Variables|||Examples for using Tk special variables|||TK VERSION@@@TK LIBRARY PATH@@@TK PATCH LEVEL@@@TK STRICTMOTIF,"In Tk, we classify some of the variables as special variables and they have a predefined usage/functionality. The list of special variables is listed below.|||tk_library|||Used for setting the location of standard Tk libraries.|||tk_patchLevel|||Refers to the current patch level of the Tk interpreter.|||tk_strictMotif|||When non-zero, Tk tries to adhere to Motif look-and-feel as closely as possible.|||tk_version|||Displays the Tk version.|||The above special variables have their special meanings for the Tk interpreter.|||Lets see the examples for special variables.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.",,,"Sr.No.@@@Special Variable & Description|||1@@@tk_library
Used for setting the location of standard Tk libraries.|||2@@@tk_patchLevel
Refers to the current patch level of the Tk interpreter.|||3@@@tk_strictMotif
When non-zero, Tk tries to adhere to Motif look-and-feel as closely as possible.|||4@@@tk_version
Displays the Tk version.",#!/usr/bin/wishputs $tk_version|||#!/usr/bin/wishputs $tk_library|||#!/usr/bin/wishputs $tk_patchLevel|||#!/usr/bin/wishputs $tk_strictMotif
Learn Tcl/Tk,Tk - Widgets Overview,Tk - Widgets Overview|||Creating a Widget@@@Widget Naming Convention@@@Color Naming Convention@@@Dimension Convention@@@Common Options@@@Basic widgets@@@Layout Widgets@@@Selection Widgets@@@Mega Widgets@@@Other Widgets,"The basic component of a Tk-based application is called a widget. A component is also sometimes called a window, since, in Tk, ""window"" and ""widget"" are often used interchangeably. Tk is a package that provides a rich set of graphical components for creating graphical applications with Tcl.|||Tk provides a range of widgets ranging from basic GUI widgets like buttons and menus to data display widgets. The widgets are very configurable as they have default configurations making them easy to use.|||Tk applications follow a widget hierarchy where any number of widgets may be placed within another widget, and those widgets within another widget. The main widget in a Tk program is referred to as the root widget and can be created by making a new instance of the TkRoot class.|||The syntax for creating a widget is given below.|||The type here refers to the widget type like button, label, and so on. Arguments can be optional and required based on individual syntax of each widget. The options range from size to formatting of each component.|||Widget uses a structure similar to naming packages. In Tk, the root window is named with a period (.) and an element in window, for example button is named .myButton1. The variable name should start with a lowercase letter, digit, or punctuation mark (except a period). After the first character, other characters may be uppercase or lowercase letters, numbers, or punctuation marks (except periods). It is recommended to use a lowercase letter to start the label.|||The colors can be declared using name like red, green, and so on. It can also use hexadecimal representing with #. The number of hexadecimal digits can be 3, 6, 9, or 12.|||The default unit is pixels and it is used when we specify no dimension. The other dimensions are i for inches, m for millimeters, c for centimeters and p for points.|||There are so many common options available to all widgets and they are listed below in the following table −|||-background color|||Used to set background color for widget.|||-borderwidth width|||Used to draw with border in 3D effects.|||-font fontDescriptor|||Used to set font for widget.|||-foreground color|||Used to set foreground color for widget.|||-height number|||Used to set height for widget.|||-highlightbackground color|||Used to set the color rectangle to draw around a widget when the widget does not have input focus.|||-highlightcolor color|||Used to set the color rectangle to draw around a widget when the widget has input focus.|||-padx number|||Sets the padx for the widget.|||-pady number|||Sets the pady for the widget.|||-relief condition|||Sets the 3D relief for this widget. The condition may be raised, sunken, flat, ridge, solid, or groove.|||-text text|||Sets the text for the widget.|||-textvariable varName|||Variable associated with the widget. When the text of widget changes, the variable is set with text of widget.|||-width number|||Sets the width for widget.|||A simple example for options is shown below.|||When we run the above program, we will get the following output.|||The list of available widgets are categorized below −|||Label|||Widget for displaying single line of text.|||Button|||Widget that is clickable and triggers an action.|||Entry|||Widget used to accept a single line of text as input.|||Message|||Widget for displaying multiple lines of text.|||Text|||Widget for displaying and optionally edit multiple lines of text.|||Toplevel|||Window with all borders and decorations provided by the Window manager.|||Frame|||Container widget to hold other widgets.|||Place|||Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||Pack|||Simple widget to organize widgets in blocks before placing them in the parent widget.|||Grid|||Widget to nest widgets packing in different directions.|||Radiobutton|||Widget that has a set of on/off buttons and labels, one of which may be selected.|||Checkbutton|||Widget that has a set of on/off buttons and labels, many of which may be selected..|||Menu|||Widget that acts as holder for menu items.|||Listbox|||Widget that displays a list of cells, one or more of which may be selected.|||Dialog|||Widget for displaying dialog boxes.|||Spinbox|||Widget that allows users to choose numbers.|||Combobox|||Widget that combines an entry with a list of choices available to the use.|||Notebook|||Tabbed widget that helps to switch between one of several pages, using an index tab.|||Progressbar|||Widget to provide visual feedback to the  progress of a long operation like file upload.|||Treeview|||Widget to display and allow browsing through a hierarchy of items more in form of tree.|||Scrollbar|||Scrolling widgets without a text or canvas widgets.|||Scale|||Scale widget to choose a numeric value through sliders.|||Canvas|||Drawing widget for displaying graphics and images..|||We will cover each of these widgets in the upcoming chapters.",,,"Sr.No.@@@Syntax & Description|||1@@@-background color
Used to set background color for widget.|||2@@@-borderwidth width
Used to draw with border in 3D effects.|||3@@@-font fontDescriptor
Used to set font for widget.|||4@@@-foreground color
Used to set foreground color for widget.|||5@@@-height number
Used to set height for widget.|||6@@@-highlightbackground color
Used to set the color rectangle to draw around a widget when the widget does not have input focus.|||7@@@-highlightcolor color
Used to set the color rectangle to draw around a widget when the widget has input focus.|||8@@@-padx number
Sets the padx for the widget.|||9@@@-pady number
Sets the pady for the widget.|||10@@@-relief condition
Sets the 3D relief for this widget. The condition may be raised, sunken, flat, ridge, solid, or groove.|||11@@@-text text
Sets the text for the widget.|||12@@@-textvariable varName
Variable associated with the widget. When the text of widget changes, the variable is set with text of widget.|||13@@@-width number
Sets the width for widget.&&&Sr.No.@@@Widget & Description|||1@@@Label
Widget for displaying single line of text.|||2@@@Button
Widget that is clickable and triggers an action.|||3@@@Entry
Widget used to accept a single line of text as input.|||4@@@Message
Widget for displaying multiple lines of text.|||5@@@Text
Widget for displaying and optionally edit multiple lines of text.|||6@@@Toplevel
Window with all borders and decorations provided by the Window manager.&&&Sr.No.@@@Widget & Description|||1@@@Frame
Container widget to hold other widgets.|||2@@@Place
Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||3@@@Pack
Simple widget to organize widgets in blocks before placing them in the parent widget.|||4@@@Grid
Widget to nest widgets packing in different directions.&&&Sr.No.@@@Widget & Description|||1@@@Radiobutton
Widget that has a set of on/off buttons and labels, one of which may be selected.|||2@@@Checkbutton
Widget that has a set of on/off buttons and labels, many of which may be selected..|||3@@@Menu
Widget that acts as holder for menu items.|||4@@@Listbox
Widget that displays a list of cells, one or more of which may be selected.&&&Sr.No.@@@Widget & Description|||1@@@Dialog
Widget for displaying dialog boxes.|||2@@@Spinbox
Widget that allows users to choose numbers.|||3@@@Combobox
Widget that combines an entry with a list of choices available to the use.|||4@@@Notebook
Tabbed widget that helps to switch between one of several pages, using an index tab.|||5@@@Progressbar
Widget to provide visual feedback to the  progress of a long operation like file upload.|||6@@@Treeview
Widget to display and allow browsing through a hierarchy of items more in form of tree.|||7@@@Scrollbar
Scrolling widgets without a text or canvas widgets.|||8@@@Scale
Scale widget to choose a numeric value through sliders.&&&Sr.No.@@@Widget & Description|||1@@@Canvas
Drawing widget for displaying graphics and images..","type variableName arguments options|||#!/usr/bin/wishgrid [label .myLabel -background red -text ""Hello World"" -relief ridge -borderwidth 3]   -padx 100 -pady 100"
Learn Tcl/Tk,Tk - Basic Widgets,Tk - Basic Widgets,"Basic widgets are common widgets available in almost all Tk applications. The list of available basic widgets is given below −|||Widget for displaying single line of text.|||Widget that is clickable and triggers an action.|||Widget used to accept a single line of text as input.|||Widget for displaying multiple lines of text.|||Widget for displaying and optionally edit multiple lines of text.|||Widget used to create a frame that is a new top level window.|||A simple Tk example is shown below using basic widgets −|||When we run the above program, we will get the following output −",,,"Sr.No.@@@Widgets & Description|||1@@@Label
Widget for displaying single line of text.|||2@@@Button
Widget that is clickable and triggers an action.|||3@@@Entry
Widget used to accept a single line of text as input.|||4@@@Message
Widget for displaying multiple lines of text.|||5@@@Text
Widget for displaying and optionally edit multiple lines of text.|||6@@@Toplevel
Widget used to create a frame that is a new top level window.","#!/usr/bin/wishgrid [label .myLabel -text ""Label Widget"" -textvariable labelText] grid [text .myText -width 20 -height 5].myText insert 1.0 ""Text\nWidget\n""grid [entry .myEntry -text ""Entry Widget""]grid [message .myMessage -background red -foreground white -text ""Message\nWidget""]grid [button .myButton1  -text ""Button"" -command ""set labelText clicked""]"
Learn Tcl/Tk,Tk - Layout Widgets,Tk - Layout Widgets,"Layout widgets are used to handle layouts for the Tk application. Frame widget is used group other widgets and place, pack, and grid are layout manager to give you total control over your adding to windows. The list of available layout widgets are as shown below −|||Container widget to hold other widgets.|||Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||Simple widget to organize widgets in blocks before placing them in the parent widget.|||Widget to nest widgets packing in different directions.|||A simple Tk example is shown below for layout widgets −|||When we run the above program, we will get the following output −",,,"Sr.No.@@@Widgets & Description|||1@@@Frame
Container widget to hold other widgets.|||2@@@Place
Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||3@@@Pack
Simple widget to organize widgets in blocks before placing them in the parent widget.|||4@@@Grid
Widget to nest widgets packing in different directions.",#!/usr/bin/wishframe .myFrame1 -background red  -relief ridge -borderwidth 8 -padx 10 -pady 10   -height 100 -width 100frame .myFrame2 -background blue  -relief ridge -borderwidth 8 -padx 10 -pady 10   -height 100 -width 50pack .myFrame1 pack .myFrame2
Learn Tcl/Tk,Tk - Selection Widgets,Tk - Selection Widgets,"Selection widgets are used to select different options in a Tk application. The list of available selection widgets are as shown below.|||Widget that has a set of on/off buttons and labels, one of which may be selected.|||Widget that has a set of on/off buttons and labels, many of which may be selected.|||Widget that acts as holder for menu items.|||Widget that displays a list of cells, one or more of which may be selected.|||A simple Tk example is shown below using selection widgets −|||When we run the above program, we will get the following output −",,,"Sr.No.@@@Widgets & Description|||1@@@Radiobutton
Widget that has a set of on/off buttons and labels, one of which may be selected.|||2@@@Checkbutton
Widget that has a set of on/off buttons and labels, many of which may be selected.|||3@@@Menu
Widget that acts as holder for menu items.|||4@@@Listbox
Widget that displays a list of cells, one or more of which may be selected.","#!/usr/bin/wishgrid [frame .gender ]grid [label .label1  -text ""Male"" -textvariable myLabel1 ] grid [radiobutton .gender.maleBtn -text ""Male""   -variable gender -value ""Male""   -command ""set  myLabel1 Male""] -row 1 -column 2grid [radiobutton .gender.femaleBtn -text ""Female"" -variable gender -value ""Female""   -command ""set  myLabel1 Female""] -row 1 -column 3.gender.maleBtn selectgrid [label .myLabel2  -text ""Range 1 not selected"" -textvariable myLabelValue2 ] grid [checkbutton .chk1 -text ""Range 1"" -variable occupied1 -command {if {$occupied1 } {   set myLabelValue2 {Range 1 selected}} else {   set myLabelValue2 {Range 1 not selected}} }]proc setLabel {text} {   .label configure -text $text }"
Learn Tcl/Tk,Tk - Canvas Widgets,Tk - Canvas Widgets|||Options@@@Widgets for Drawing in Canvas,"Canvas is used for providing drawing areas. The syntax for canvas widget is shown below −|||The options available for the canvas widget are listed below in the following table −|||-background color|||Used to set background color for widget.|||-closeenough distance|||Sets the closeness of mouse cursor to a displayable item. The default is 1.0 pixel. This value may be a fraction and must be positive.|||-scrollregion boundingBox|||The bounding box for the total area of this canvas.|||-height number|||Used to set height for widget.|||-width number|||Sets the width for widget.|||-xscrollincrement size|||The amount to scroll horizontally  when scrolling is requested.|||-yscrollincrement size|||The amount to scroll vertically when scrolling is requested.|||A simple example for canvas widget is shown below −|||When we run the above program, we will get the following output −|||The list of the available widgets for drawing in canvas is listed below −|||Draws a line.|||Draws an arc.|||Draws a rectangle.|||Draws an oval.|||Draws a polygon.|||Draws a text.|||Draws a bitmap.|||Draws an image.|||An example using different canvas widgets is shown below −|||When we run the above program, we will get the following output −",,,"Sr.No.@@@Syntax & Description|||1@@@-background color
Used to set background color for widget.|||2@@@-closeenough distance
Sets the closeness of mouse cursor to a displayable item. The default is 1.0 pixel. This value may be a fraction and must be positive.|||3@@@-scrollregion boundingBox
The bounding box for the total area of this canvas.|||4@@@-height number
Used to set height for widget.|||5@@@-width number
Sets the width for widget.|||6@@@-xscrollincrement size
The amount to scroll horizontally  when scrolling is requested.|||7@@@-yscrollincrement size
The amount to scroll vertically when scrolling is requested.&&&Sr.No.@@@Widget & Description|||1@@@Line
Draws a line.|||2@@@Arc
Draws an arc.|||3@@@Rectangle
Draws a rectangle.|||4@@@Oval
Draws an oval.|||5@@@Polygon
Draws a polygon.|||6@@@Text
Draws a text.|||7@@@Bitmap
Draws a bitmap.|||8@@@Image
Draws an image.","#!/usr/bin/wishcanvas .myCanvas -background red -width 100 -height 100 pack .myCanvas|||#!/usr/bin/wishcanvas .myCanvas -background red -width 200 -height 200 pack .myCanvas.myCanvas create arc 10 10 50 50 -fill yellow.myCanvas create line 10 30 50 50 100 10 -arrow both -fill yellow -smooth true   -splinesteps 2.myCanvas create oval 50 50 100 80 -fill yellow.myCanvas create polygon 50 150 100 80 120 120 100 190 -fill yellow -outline green.myCanvas create rectangle 150 150 170 170  -fill yellow.myCanvas create text 170 20 -fill yellow -text ""Hello"" -font {Helvetica -18 bold}.myCanvas create bitmap 180 50 -bitmap info"
Learn Tcl/Tk,Tk - Mega Widgets,Tk - Mega Widgets,"Mega widgets include many complex widgets which is often required in some large scale Tk applications. The list of available mega widgets are as shown below −|||Widget for displaying dialog boxes.|||Widget that allows users to choose numbers.|||Widget that combines an entry with a list of choices available to the use.|||Tabbed widget that helps to switch between one of several pages, using an index tab.|||Widget to provide visual feedback to the  progress of a long operation like file upload.|||Widget to display and allow browsing through a hierarchy of items more in form of tree.|||Scrolling widgets without a text or canvas widgets.|||Scale widget to choose a numeric value through sliders.|||A simple Tk example is shown below using some mega widgets.|||When we run the above program, we will get the following output −",,,"Sr.No.@@@Widget & Description|||1@@@Dialog
Widget for displaying dialog boxes.|||2@@@Spinbox
Widget that allows users to choose numbers.|||3@@@Combobox
Widget that combines an entry with a list of choices available to the use.|||4@@@Notebook
Tabbed widget that helps to switch between one of several pages, using an index tab.|||5@@@Progressbar
Widget to provide visual feedback to the  progress of a long operation like file upload.|||6@@@Treeview
Widget to display and allow browsing through a hierarchy of items more in form of tree.|||7@@@Scrollbar
Scrolling widgets without a text or canvas widgets.|||8@@@Scale
Scale widget to choose a numeric value through sliders.","#!/usr/bin/wishttk::treeview .tree -columns ""Creator Year"" -displaycolumns ""Year Creator"" .tree heading Creator -text ""Creator"" -anchor center.tree heading Year -text ""Year"" -anchor centerpack .tree.tree insert {} end -id Languages -text ""Languages"".tree insert Languages end -text C -values [list ""Dennis Ritchie"" ""1990""]proc scaleMe {mywidget scaleValue} {   $mywidget configure -length $scaleValue} pack [scale .s2  -from 100.0 -to 200.0 -length 100 -background yellow -borderwidth 5   -font{Helvetica -18 bold} -foreground red -width 40 -relief ridge -orien horizontal   -variable a -command ""scaleMe .s2"" ]pack [ttk::progressbar .p1 -orient horizontal -length 200 -mode indeterminate -value 90]pack [ttk::progressbar .p2 -orient horizontal -length 200 -mode determinate -variable a   -maximum 75 -value 20]"
Learn Tcl/Tk,Tk - Fonts,Tk - Fonts|||Options,"There are a number of widgets that supports displaying text. Most of these provides the option of font attribute. The syntax for creating a font is shown below −|||The options available for the font create are listed below in the following table −|||-family familyName|||The name of font family.|||-size number|||The size of font.|||-weight level|||The weight for font.|||A simple example for a font creation is shown below −|||When we run the above program, we will get the following output −|||To get all the fonts available, we can use the following command −|||When we run the above command, we will get the following output −",,,"Sr.No.@@@Syntax & Description|||1@@@-family familyName
The name of font family.|||2@@@-size number
The size of font.|||3@@@-weight level
The weight for font.","#!/usr/bin/wishfont create myFont -family Helvetica -size 18 -weight bold pack [label .myLabel -font myFont -text ""Hello World""]|||#!/usr/bin/wishputs [font families]"
Learn Tcl/Tk,Tk - Images,Tk - Images|||Options,"The image widget is used to create and manipulate images. The syntax for creating image is as follows −|||In the above syntax type is photo or bitmap and name is the image identifier.|||The options available for image create are listed below in the following table −|||-file fileName|||The name of the image file name.|||-height number|||Used to set height for widget.|||-width number|||Sets the width for widget.|||-data string|||Image in base 64 encoded string.|||A simple example for image widget is shown below −|||When we run the above program, we will get the following output −|||The available function for image are listed below in the following table −|||image delete imageName|||Deletes the image from memory and related widgets visually.|||image height imageName|||Returns the height for image.|||image width imageName|||Returns the width for image.|||image type imageName|||Returns the type for image.|||image names|||Returns the list of images live in memory.|||A simple example for using the above image widget commands is shown below −|||The image will be deleted visually and from memory once ""image delete imgobj"" command executes. In console, the output will be like the following −",,,"Sr.No.@@@Syntax & Description|||1@@@-file fileName
The name of the image file name.|||2@@@-height number
Used to set height for widget.|||3@@@-width number
Sets the width for widget.|||4@@@-data string
Image in base 64 encoded string.&&&Sr.No.@@@Syntax & Description|||1@@@image delete imageName
Deletes the image from memory and related widgets visually.|||2@@@image height imageName
Returns the height for image.|||3@@@image width imageName
Returns the width for image.|||4@@@image type imageName
Returns the type for image.|||5@@@image names
Returns the list of images live in memory.","#!/usr/bin/wishimage create photo imgobj -file ""/Users/rajkumar/Desktop/F Drive/pictur/vb/Forests/   680049.png"" -width 400 -height 400 pack [label .myLabel].myLabel configure -image imgobj |||#!/usr/bin/wishimage create photo imgobj -file ""/Users/rajkumar/images/680049.png""   -width 400 -height 400 pack [label .myLabel].myLabel configure -image imgobjputs [image height imgobj]puts [image width imgobj]puts [image type imgobj]puts [image names]image delete imgobj"
Learn Tcl/Tk,Tk - Events,Tk - Events|||Event Binding|||Event after delay@@@Keyboard Events Example@@@Mouse Events Example@@@Linking Events with Button Example,"Events in its simplest form is handled with the help of commands. A simple example for event handling is event handling with button and is shown below −|||When we run the above program, we will get the following output −|||A simple program to show delay text animation event is shown below −|||When we run the program, we will get the following output in animated way −|||The syntax for event after delay is shown below −|||A simple program to show after delay event is shown below −|||When we run the program, we will get the following output after one second −|||You can cancel an event using the after cancel command as shown below −|||The syntax for event binding is as shown below −|||When we run the program and press a letter X, we will get the following output −|||When we run the program and press the left mouse button, we will get an output similar to the following −|||When we run the program and press enter, we will get the following output −",,,,"#!/usr/bin/wishproc myEvent { } {   puts ""Event triggered""}pack [button .myButton1  -text ""Button 1""   -command myEvent]|||#!/usr/bin/wishproc delay {} {   for {set j 0} {$j < 100000} {incr j} {} }label .myLabel -text ""Hello................"" -width 25pack .myLabelset str ""Hello................""for {set i [string length $str]} {$i > -2} {set i [expr $i-1]} {   .myLabel configure -text [string range $str 0 $i]   update   delay}|||#!/usr/bin/wishproc addText {} {   label .myLabel -text ""Hello................"" -width 25   pack .myLabel}after 1000 addText|||#!/usr/bin/wishproc addText {} {   label .myLabel -text ""Hello................"" -width 25   pack .myLabel}after 1000 addTextafter cancel addText|||#!/usr/bin/wishbind .  {puts ""Key Pressed: %K ""}|||#!/usr/bin/wishbind .  {puts ""Button %b Pressed : %x %y ""}|||#!/usr/bin/wishproc myEvent { } {   puts ""Event triggered""}pack [button .myButton1  -text ""Button 1""   -command myEvent]bind .  "".myButton1 invoke"""
Learn Tcl/Tk,Tk - Windows Manager,Tk - Windows Manager|||Creating Window@@@Destroying Window,"Window manager is used to handle the top level window. It helps in controlling the size, position, and other attributes of the window. In Tk, . is used to refer the main window. The syntax for window command is shown below −|||The list of options available for Tk wm command is shown in the following table −|||aspect windowName a b c d|||Tries to maintain the ratio of width/height to be between a/b and c/d.|||geometry windowName geometryParams|||Use to set geometry for window.|||grid windowName w h dx dy|||Sets the grid size.|||group windowName leaderName|||leaderName gives the leader of a group of related windows.|||deiconify windowName|||Brings the screen to normal if minimized.|||iconify windowName|||Minimizes the window.|||state windowName|||Returns the current state of window.|||withdraw windowName|||Unmaps the window and removes its details in memory.|||iconbitmap windowName image|||Sets or returns the icon bitmap.|||iconPhoto windowName image|||Sets or returns the icon photo.|||command windowName commandString|||Records the startup command in the WM_COMMAND property.|||protocol windowName arguments|||Register a command to handle the protocol request name, which can be WM_DELETE_WINDOW,|||WM_SAVE_YOURSELF,|||WM_TAKE_FOCUS. Eg: wm protocol.|||WM_DELETE_WINDOW Quit.|||minsize windowName size|||Determines the minimum window size.|||maxsize windowName size|||Determines the maximum window size.|||title windowName titleText|||Determines the title for window.|||attributes subOptions|||There are lots of attributes available like alpha, full screen and so on.|||Some of the above commands are used in the following example −|||When we run the above program, we will get the following output −|||As you can see alpha is one of the attributes available. The list of commonly used subcommands are listed below −|||-alpha number|||Sets the alpha for window.|||-fullscreen number|||Number can be 0 for normal screen or 1 for full screen.|||-topmost number|||Sets or returns whether window is topmost.Value can be 0 or 1.|||We can use toplevel command to create window and an example is shown below −|||When we run the above program, we will get the following output −|||We can use destroy command to destroy window and an example is shown below −|||The above command will destroy window named .t.",,,"Sr.No.@@@Syntax & Description|||1@@@aspect windowName a b c d
Tries to maintain the ratio of width/height to be between a/b and c/d.|||2@@@geometry windowName geometryParams
Use to set geometry for window.|||3@@@grid windowName w h dx dy
Sets the grid size.|||4@@@group windowName leaderName
leaderName gives the leader of a group of related windows.|||5@@@deiconify windowName
Brings the screen to normal if minimized.|||6@@@iconify windowName
Minimizes the window.|||7@@@state windowName
Returns the current state of window.|||8@@@withdraw windowName
Unmaps the window and removes its details in memory.|||9@@@iconbitmap windowName image
Sets or returns the icon bitmap.|||10@@@iconPhoto windowName image
Sets or returns the icon photo.|||11@@@command windowName commandString
Records the startup command in the WM_COMMAND property.|||12@@@protocol windowName arguments
Register a command to handle the protocol request name, which can be WM_DELETE_WINDOW,
WM_SAVE_YOURSELF,
WM_TAKE_FOCUS. Eg: wm protocol.
WM_DELETE_WINDOW Quit.|||13@@@minsize windowName size
Determines the minimum window size.|||14@@@maxsize windowName size
Determines the maximum window size.|||15@@@title windowName titleText
Determines the title for window.|||16@@@attributes subOptions
There are lots of attributes available like alpha, full screen and so on.&&&Sr.No.@@@Syntax & Description|||1@@@-alpha number
Sets the alpha for window.|||2@@@-fullscreen number
Number can be 0 for normal screen or 1 for full screen.|||3@@@-topmost number
Sets or returns whether window is topmost.Value can be 0 or 1.","#!/usr/bin/wishwm maxsize . 800 800wm minsize . 300 300wm title . ""Hello""wm attributes . -alpha "".90"" wm geometry . 300x200+100+100|||#!/usr/bin/wishtoplevel .t|||#!/usr/bin/wishdestroy .t"
Learn Tcl/Tk,Tk - Geometry Manager,Tk - Geometry Manager|||Positioning and sizing@@@Grid Geometry,"The geometry manager is used to manage the geometry of the window and other frames. We can use it to handle the position and size of the window and frames. The layout widgets are used for this purpose.|||The syntax for positioning and sizing window is shown below −|||Here, w refers to width and h refers to height. It is followed by a '+' or '-' sign with number next referring to the x position on screen. Similarly the following '+' or '-' sign with number refers to the y position on screen|||A simple example is shown below for the above Statement −.|||When we run the above program, we will get the following output −|||The syntax for grid geometry is shown below −|||The column, row, columnspan, or rowspan helps in providing the grid geometry.|||A simple example is shown below for the above statement −|||When we run the above program, we will get the following output −",,,,#!/usr/bin/wishwm geometry . 300x200+100+100|||#!/usr/bin/wishframe .myFrame1 -background red  -height 100 -width 100frame .myFrame2 -background blue -height 100 -width 50grid .myFrame1 -columnspan 10 -rowspan 10 -sticky wgrid .myFrame2 -column 10 -row 2
Learn Tcl/Tk,Tcl-Tk - Quick Guide,Tcl-Tk - Quick Guide@@@Tcl - Overview@@@Tcl - Environment Setup@@@Tcl - Special Variables@@@Tcl - Basic Syntax@@@Tcl - Commands@@@Tcl - Data Types@@@Tcl - Variables@@@Tcl - Operators@@@Tcl - Decisions@@@Tcl - Loops@@@Tcl - Arrays@@@Tcl - Strings@@@Tcl - Lists@@@Tcl - Dictionary@@@Tcl - Procedures@@@Tcl - Packages@@@Tcl - Namespaces@@@Tcl - File I/O@@@Tcl - Error Handling@@@Tcl - Built-in Functions@@@Tcl - Regular Expressions@@@Tk - Overview@@@Tk - Environment@@@Tk - Special Variables@@@Tk - Widgets Overview@@@Tk - Basic Widgets@@@Tk - Layout Widgets@@@Tk - Selection Widgets@@@Tk - Canvas Widgets@@@Tk - Mega Widgets@@@Tk - Fonts@@@Tk - Images@@@Tk - Events@@@Tk - Windows Manager@@@Tk - Geometry Manager|||Features of Tcl@@@Applications@@@Local Environment Setup@@@Text Editor@@@The Tcl Interpreter@@@Installation on Windows@@@Installation on Linux@@@Installation on Debian based Systems@@@Installation on Mac OS X@@@Installation from Source Files@@@Examples for using Tcl special variables@@@First Tcl Program@@@Comments@@@Identifiers@@@Whitespace in Tcl@@@Command Substitution@@@Variable Substitution@@@Backslash Substitution@@@Simple Tcl Objects@@@String Representations@@@List@@@Associative Array@@@Handles@@@Variable Naming@@@Dynamic Typing@@@Mathematical Expressions@@@Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Ternary Operator@@@Operators Precedence in Tcl@@@The ? : Operator@@@Loop Control Statements@@@The Infinite Loop@@@Size of Array@@@Array Iteration@@@Associative Arrays@@@Indices of Array@@@Iteration of Associative Array@@@String Representations@@@String Escape Sequence@@@String Command@@@Creating a List@@@Appending Item to a List@@@Length of List@@@List Item at Index@@@Insert Item at Index@@@Replace Items at Indices@@@Set Item at Index@@@Transform List to Variables@@@Sorting a List@@@Size of Dict@@@Dictionary Iteration@@@Value for Key in Dict@@@All Keys in Dict@@@All Values in Dict@@@Key Exists in Dict@@@Procedures with Multiple Arguments@@@Procedures with Variable Arguments@@@Procedures with Default Arguments@@@Recursive Procedures@@@Creating Package@@@Creating Namespace@@@Nested Namespaces@@@Importing and Exporting Namespace@@@Forget Namespace@@@Opening Files@@@Closing a File@@@Writing a File@@@Reading a File@@@Error syntax@@@Catch Syntax@@@Math Functions@@@System Functions@@@Syntax@@@Multiple Patterns@@@Switches for Regex Command@@@Features of Tk@@@Applications Built in Tk@@@The Tk Interpreter@@@Installation on Windows@@@Installation on Linux@@@Installation on Debian Based Systems@@@Installation on Mac OS X@@@Installation from Source Files@@@Examples for using Tk special variables@@@Creating a Widget@@@Widget Naming Convention@@@Color Naming Convention@@@Dimension Convention@@@Common Options@@@Basic widgets@@@Layout Widgets@@@Selection Widgets@@@Mega Widgets@@@Other Widgets@@@Options@@@Widgets for Drawing in Canvas@@@Options@@@Options@@@Event Binding@@@Creating Window@@@Destroying Window@@@Positioning and sizing@@@Grid Geometry|||Tcl version@@@Tcl Environment Path@@@Tcl Package Path@@@Tcl Library@@@Tcl Patch Level@@@Tcl Precision@@@Tcl Startup File@@@String Comparison@@@Index of String@@@Length of String@@@Handling Cases@@@Trimming Characters@@@Matching Strings@@@Append Command@@@Format command@@@Scan command@@@STEP 1 : Creating Code@@@STEP 2 : Creating Package Index@@@STEP 3 : Adding Directory to Autopath@@@STEP 4 : Adding Package@@@STEP 5 : Invoking Procedure@@@TK VERSION@@@TK LIBRARY PATH@@@TK PATCH LEVEL@@@TK STRICTMOTIF@@@Event after delay@@@Keyboard Events Example@@@Mouse Events Example@@@Linking Events with Button Example,"Tcl is shortened form of Tool Command Language. John Ousterhout of the University of California, Berkeley, designed it. It is a combination of a scripting language and its own interpreter that gets embedded to the application, we develop with it.|||Tcl was developed initially for Unix. It was then ported to Windows, DOS, OS/2, and Mac OSX. Tcl is much similar to other unix shell languages like Bourne Shell (Sh), the C Shell (csh), the Korn Shell (sh), and Perl.|||It aims at providing ability for programs to interact with other programs and also for acting as an embeddable interpreter. Even though, the original aim was to enable programs to interact, you can find full-fledged applications written in Tcl/Tk.|||The features of Tcl are as follows −|||Reduced development time.|||Powerful and simple user interface kit with integration of TK.|||Write once, run anywhere. It runs on Windows, Mac OS X, and almost on every Unix platform.|||Quite easy to get started for experienced programmers; since, the language is so simple that they can learn Tcl in a few hours or days.|||You can easily extend existing applications with Tcl. Also, it is possible to include Tcl in C, C++, or Java to Tcl or vice versa.|||Have a powerful set of networking functions.|||Finally, it's an open source, free, and can be used for commercial applications without any limit.|||Tcl is a general-purpose language and you can find Tcl everywhere. It includes,|||If you are willing to set up your environment for Tcl, you need the following two software applications available on your computer −|||This will be used to type your program. Examples of a few text editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of a text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.|||The files you create with your text editor are called source files and contain program source code. The source files for Tcl programs are named with the extension "".tcl"".|||Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, build it, and finally execute it.|||It is just a small program that enables you to type Tcl commands and have them executed line by line. It stops execution of a tcl file, in case, it encounters an error unlike a compiler that executes fully.|||Let's have a helloWorld.tcl file as follows. We will use this as a first program, we run on a platform you choose.|||Download the latest version for windows installer from the list of Active Tcl binaries available. The active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps|||We can see the following output.|||C:\Tcl is the folder, I am using to save my samples. You can change it to the folder in which you have saved Tcl programs.|||Most of the Linux operating systems come with Tcl inbuilt and you can get started right away in those systems. In case, it's not available, you can use the following command to download and install Tcl-Tk.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps −|||We can see the following output −|||In case, it's not available in your OS, you can use the following command to download and install Tcl-Tk −|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' command and then execute the program using the following steps −|||We can see the following output −|||Download the latest version for Mac OS X package from the list of Active Tcl binaries available. The active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Active Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using 'cd' and then execute the program using the following steps −|||We can see the following output −|||You can use the option of installing from source files when a binary package is not available. It is generally preferred to use Tcl binaries for Windows and Mac OS X, so only compilation of sources on unix based system is shown below.|||Download the source files.|||Now, use the following commands to extract, compile, and build after switching to the downloaded folder.|||Note − Make sure, you change the file name to the version you downloaded on commands 1 and 2 given above.|||In Tcl, we classify some of the variables as special variables and they have a predefined usage/functionality. The list of specials variables is listed below.|||argc|||Refers to a number of command-line arguments.|||argv|||Refers to the list containing the command-line arguments.|||argv0|||Refers to the file name of the file being interpreted or the name by which we invoke the script.|||env|||Used for representing the array of elements that are environmental variables.|||errorCode|||Provides the error code for last Tcl error.|||errorInfo|||Provides the stack trace for last Tcl error.|||tcl_interactive|||Used to switch between interactive and non-interactive modes by setting this to 1 and 0 respectively.|||tcl_library|||Used for setting the location of standard Tcl libraries.|||tcl_pkgPath|||Provides the list of directories where packages are generally installed.|||tcl_patchLevel|||Refers to the current patch level of the Tcl interpreter.|||tcl_platform|||Used for representing the array of elements with objects including byteOrder, machine, osVersion, platform, and os.|||tcl_precision|||Refers to the precision i.e. number of digits to retain when converting to floating-point numbers to strings. The default value is 12.|||tcl_prompt1|||Refers to the primary prompt.|||tcl_prompt2|||Refers to the secondary prompt with invalid commands.|||tcl_rcFileName|||Provides the user specific startup file.|||tcl_traceCompile|||Used for controlling the tracing of bytecode compilation. Use 0 for no output, 1 for summary, and 2 for detailed.|||tcl_traceExec|||Used for controlling the tracing of bytecode execution. Use 0 for no output, 1 for summary, and 2 for detailed.|||tcl_version|||Returns the current version of the Tcl interpreter.|||The above special variables have their special meanings for the Tcl interpreter.|||Let's see some examples for special variables.|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||When you run the program, you will get a similar output as shown below −|||Tcl is quite simple to learn and let's start creating our first Tcl program!|||Let us write a simple Tcl program. All Tcl files will have an extension, i.e., .tcl. So, put the following source code in a test.tcl file.|||Assuming, Tcl environment is setup correctly; let's run the program after switching to file's directory and then execute the program using −|||We will get the following output −|||Let us now see the basic structure of Tcl program, so that it will be easy for you to understand basic building blocks of the Tcl language. In Tcl, we use new line or semicolon to terminate the previous line of code. But semicolon is not necessary, if you are using newline for each command.|||Comments are like helping text in your Tcl program and the interpreter ignores them. Comments can be written using a hash_(#) sign in the beginning.|||When the above code is executed, it produces the following result −|||Multiline or block comment is written using 'if' with condition '0'. An example is shown below.|||When the above code is executed, it produces the following result −|||Inline comments use ;#. An example is given below.|||When the above code is executed, it produces the following result −|||A Tcl identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter A to Z or a to z or an underscore (_) followed by zero or more letters, underscores, dollars ($) , and digits (0 to 9).|||Tcl does not allow punctuation characters such as @, and % within identifiers. Tcl is a case sensitive_ language. Thus Manpower and manpower are two different identifiers in Tcl. Here are some of the examples of acceptable identifiers −|||A line containing only whitespace, possibly with a comment, is known as a blank line, and a Tcl interpreter totally ignores it.|||Whitespace is the term used in Tcl to describe blanks, tabs, newline characters, and comments. Whitespace separates one part of a statement from another and enables the interpreter to identify where one element in a statement, such as puts, ends and the next element begins. Therefore, in the following statement −|||There must be at least one whitespace character (usually a space) between “puts” and ""Hello World!"" for the interpreter to be able to distinguish them. On the other hand, in the following statement −|||When the above code is executed, it produces the following result −|||No whitespace characters are necessary between 3 and +, or between + and 2; although, you are free to include some if you wish for the readability purpose.|||As you know, Tcl is a Tool command language, commands are the most vital part of the language. Tcl commands are built in-to the language with each having its own predefined function. These commands form the reserved words of the language and cannot be used for other variable naming. The advantage with these Tcl commands is that, you can define your own implementation for any of these commands to replace the original built-in functionality.|||Each of the Tcl commands validates the input and it reduces the work of the interpreter.|||Tcl command is actually a list of words, with the first word representing the command to be executed. The next words represent the arguments. In order to group the words into a single argument, we enclose multiple words with """" or {}.|||The syntax of Tcl command is as follows −|||Let's see a simple example of Tcl command −|||When the above code is executed, it produces the following result −|||In the above code, ‘puts’ is the Tcl command and ""Hello World"" is the argument1. As said before, we have used """" to group two words.|||Let's see another example of Tcl command with two arguments −|||When the above code is executed, it produces the following result −|||In the above code, ‘puts’ is the Tcl command, ‘stdout’ is argument1, and ""Hello World"" is argument2. Here, stdout makes the program to print in the standard output device.|||In command substitutions, square brackets are used to evaluate the scripts inside the square brackets. A simple example to add two numbers is shown below −|||When the above code is executed, it produces following result −|||In variable substitutions, $ is used before the variable name and this returns the contents of the variable. A simple example to set a value to a variable and print it is shown below.|||When the above code is executed, it produces the following result −|||These are commonly called escape sequences; with each backslash, followed by a letter having its own meaning. A simple example for newline substitution is shown below −|||When the above code is executed, it produces the following result −|||The primitive data-type of Tcl is string and often we can find quotes on Tcl as string only language. These primitive data-types in turn create composite data-types for list and associative array. In Tcl, data-types can represent not only the simple Tcl objects, but also can represent complex objects such as handles, graphic objects (mostly widgets), and I/O channels. Let's look into the details about each of the above.|||In Tcl, whether it is an integer number, boolean, floating point number, or a string. When you want to use a variable, you can directly assign a value to it, there is no step of declaration in Tcl. There can be internal representations for these different types of objects. It can transform one data-type to another when required. The syntax for assigning value to variable is as follows −|||When the above code is executed, it produces the following result −|||The above statement will create a variable name myVariable and stores it as a string even though, we have not used double quotations. Now, if we try to make an arithmetic on the variable, it is automatically turned to an integer. A simple example is shown below −|||When the above code is executed, it produces the following result −|||One important thing to note is that, these variables don't have any default values and must be assigned value before they are used.|||If we try to print using puts, the number is transformed into proper string. Having two representations, internal and external, help Tcl to create complex data structures easily compared to other languages. Also, Tcl is more efficient due to its dynamic object nature.|||Unlike other languages, in Tcl, you need not include double quotes when it's only a single word. An example can be −|||When the above code is executed, it produces the following result −|||When we want to represent multiple strings, we can use either double quotes or curly braces. It is shown below −|||When the above code is executed, it produces the following result −|||List is nothing but a group of elements. A group of words either using double quotes or curly braces can be used to represent a simple list. A simple list is shown below −|||When the above code is executed, it produces the following result −|||Associative arrays have an index (key) that is not necessarily an integer. It is generally a string that acts like key value pairs. A simple example is shown below −|||When the above code is executed, it produces the following result −|||Tcl handles are commonly used to represent files and graphics objects. These can include handles to network requests and also other channels like serial port communication, sockets, or I/O devices. The following is an example where a file handle is created.|||You will see more detail on files in the Tcl file I/O chapter.|||In Tcl, there is no concept of variable declaration. Once, a new variable name is encountered, Tcl will define a new variable.|||The name of variables can contain any characters and length. You can even have white spaces by enclosing the variable in curly braces, but it is not preferred.|||The set command is used for assigning value to a variable. The syntax for set command is,|||A few examples of variables are shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above program, the $variableName is used to get the value of the variable.|||Tcl is a dynamically typed language. The value of the variable can be dynamically converted to the required type when required. For example, a number 5 that is stored as string will be converted to number when doing an arithmetic operation. It is shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above example, expr is used for representing mathematical expression. The default precision of Tcl is 12 digits. In order to get floating point results, we should add at least a single decimal digit. A simple example explains the above.|||When the above code is executed, it produces the following result −|||In the above example, you can see three cases. In the first case, the dividend and the divisor are whole numbers and we get a whole number as result. In the second case, the divisor alone is a decimal number and in the third case, the dividend is a decimal number. In both second and third cases, we get a decimal number as result.|||In the above code, you can change the precision by using tcl_precision special variable. It is shown below −|||When the above code is executed, it produces the following result −|||An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Tcl language is rich in built-in operators and provides the following types of operators −|||This chapter will explain the arithmetic, relational, logical, bitwise, and ternary operators one by one.|||Following table shows all the arithmetic operators supported by Tcl language. Assume variable ‘A’ holds 10 and variable ‘B’ holds 20, then −|||Show Examples|||Following table shows all the relational operators supported by Tcl language. Assume variable A holds 10 and variable B holds 20, then −|||Show Examples|||Following table shows all the logical operators supported by Tcl language. Assume variable A holds 1 and variable B holds 0, then −|||Show Examples|||Bitwise operator works on bits and perform bit-by-bit operation. The truth tables for &, |, and ^ are as follows −|||Assume if A = 60; and B = 13; now in binary format they will be as follows −|||A = 0011 1100|||B = 0000 1101|||----------------------|||A&B = 0000 1100|||A|B = 0011 1101|||A^B = 0011 0001|||The Bitwise operators supported by Tcl language are listed in the following table. Assume variable A holds 60 and variable B holds 13, then −|||Show Examples|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.|||For example : x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3 * 2 and then adds into 7.|||Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.|||Show Examples|||Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.|||Following is the general form of a typical decision making structure found in most of the programming languages −|||Tcl language uses the expr command internally and hence it’s not required for us to use expr statement explicitly.|||Tcl language provides following types of decision making statements −|||An 'if' statement consists of a Boolean expression followed by one or more statements.|||An 'if' statement can be followed by an optional 'else' statement, which executes when the Boolean expression is false.|||You can use one 'if' or 'else if' statement inside another 'if' or 'else if' statement(s).|||A switch statement allows a variable to be tested for equality against a list of values.|||You can use one switch statement inside another switch statement(s).|||We have covered conditional operator ? : in previous chapter, which can be used to replace if...else statements. It has the following general form −|||Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.|||The value of a '? expression' is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire '? expression.' If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. An example is shown below.|||When you compile and execute the above program, it produces the following result −|||There may be a situation, where you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −|||Tcl language provides the following types of loops to handle looping requirements.|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||You can use one or more loop inside any another while, for or do..while loop.|||Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.|||Tcl supports the following control statements.|||Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.|||Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.|||A loop becomes infinite loop if a condition never becomes false. The while loop is traditionally used for this purpose. You can make an endless loop by leaving the conditional expression as 1.|||When the conditional expression is absent, it is assumed to be true. Tcl programmers more commonly use the while {1} construct to signify an infinite loop.|||NOTE − You can terminate an infinite loop by pressing Ctrl + C keys.|||An array is a systematic arrangement of a group of elements using indices. The syntax for the conventional array is shown below.|||An example for creating simple array is shown below.|||When the above code is executed, it produces the following result −|||The syntax for calculating size array is shown below.|||An example for printing the size is shown below.|||When the above code is executed, it produces the following result −|||Though, array indices can be non-continuous like values specified for index 1 then index 10 and so on. But, in case they are continuous, we can use array iteration to access elements of the array. A simple array iteration for printing elements of the array is shown below.|||When the above code is executed, it produces the following result −|||In Tcl, all arrays by nature are associative. Arrays are stored and retrieved without any specific order. Associative arrays have an index that is not necessarily a number, and can be sparsely populated. A simple example for associative array with non-number indices is shown below.|||When the above code is executed, it produces the following result −|||The syntax for retrieving indices of array is shown below.|||An example for printing the size is shown below.|||When the above code is executed, it produces the following result −|||You can use the indices of array to iterate through the associative array. An example is shown below.|||When the above code is executed, it produces the following result −|||The primitive data-type of Tcl is string and often we can find quotes on Tcl as string only language. These strings can contain alphanumeric character, just numbers, Boolean, or even binary data. Tcl uses 16 bit unicode characters and alphanumeric characters can contain letters including non-Latin characters, number or punctuation.|||Boolean value can be represented as 1, yes or true for true and 0, no, or false for false.|||Unlike other languages, in Tcl, you need not include double quotes when it's only a single word. An example can be −|||When the above code is executed, it produces the following result −|||When we want to represent multiple strings, we can use either double quotes or curly braces. It is shown below −|||When the above code is executed, it produces the following result −|||A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0').|||There are certain characters in Tcl when they are preceded by a backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here, you have a list of some of such escape sequence codes −|||Following is the example to show a few escape sequence characters −|||When the above code is compiled and executed, it produces the following result −|||The list of subcommands for string command is listed in the following table −|||compare string1 string2|||Compares string1 and string2 lexographically. Returns 0 if equal, -1 if string1 comes before string2, else 1.|||first string1 string2|||Returns the index first occurrence of string1 in string2. If not found, returns -1.|||index string index|||Returns the character at index.|||last string1 string2|||Returns the index last occurrence of string1 in string2. If not found, returns -1.|||length string|||Returns the length of string.|||match pattern string|||Returns 1 if the string matches the pattern.|||range string index1 index2|||Return the range of characters in string from index1 to index2.|||tolower string|||Returns the lowercase string.|||toupper string|||Returns the uppercase string.|||trim string ?trimcharacters?|||Removes trimcharacters in both ends of string. The default trimcharacters is whitespace.|||trimleft string ?trimcharacters?|||Removes trimcharacters in left beginning of string. The default trimcharacters is whitespace.|||trimright string ?trimcharacters?|||Removes trimcharacters in left end of string. The default trimcharacters is whitespace.|||wordend findstring index|||Return the index in findstring of the character after the word containing the character at index.|||wordstart findstring index|||Return the index in findstring of the first character in the word containing the character at index.|||Examples of some commonly used Tcl string sub commands are given below.|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||When the above code is compiled and executed, it produces the following result −|||The following table shows the list of format specifiers available in Tcl −|||Some simple examples are given below −|||When the above code is compiled and executed, it produces the following result −|||Scan command is used for parsing a string based to the format specifier. Some examples are shown below.|||When the above code is compiled and executed, it produces the following result −|||List is one of the basic data-type available in Tcl. It is used for representing an ordered collection of items. It can include different types of items in the same list. Further, a list can contain another list.|||An important thing that needs to be noted is that these lists are represented as strings completely and processed to form individual items when required. So, avoid large lists and in such cases; use array.|||The general syntax for list is given below −|||Some examples are given below −|||When the above code is executed, it produces the following result −|||The syntax for appending item to a list is given below −|||Some examples are given below −|||When the above code is executed, it produces the following result −|||The syntax for length of list is given below −|||Example for length of list is given below −|||When the above code is executed, it produces the following result −|||The syntax for selecting list item at specific index is given below −|||Example for list item at index is given below −|||When the above code is executed, it produces the following result −|||The syntax for inserting list items at specific index is given below.|||Example for inserting list item at specific index is given below.|||When the above code is executed, it produces the following result −|||The syntax for replacing list items at specific indices is given below −|||Example for replacing list items at specific indices is given below.|||When the above code is executed, it produces the following result −|||The syntax for setting list item at specific index is given below −|||Example for setting list item at specific index is given below −|||When the above code is executed, it produces the following result −|||The syntax for copying values to variables is given below −|||Example for transforming list into variables is given below −|||When the above code is executed, it produces the following result −|||The syntax for sorting a list is given below −|||An example for sorting a list is given below −|||When the above code is executed, it produces the following result −|||A dictionary is an arrangement for mapping values to keys. The syntax for the conventional dictionary is shown below −|||Some examples for creating a dictionary are shown below −|||When the above code is executed, it produces the following result −|||The syntax for getting size of dict is shown below −|||An example for printing the size is shown below −|||When the above code is executed, it produces the following result −|||A simple dictionary iteration for printing keys and valued of the dictionary is shown below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving value for key in dict is shown below −|||An example for retrieving value for key is given below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving all keys in dict is shown below −|||An example for printing all keys is shown below −|||When the above code is executed, it produces the following result −|||The syntax for retrieving all values in dict is shown below −|||An example for printing all values is shown below −|||When the above code is executed, it produces the following result −|||The syntax for checking if a key exists in dict is shown below −|||An example for checking if a key exists in dict is shown below −|||When the above code is executed, it produces the following result −|||Procedures are nothing but code blocks with series of commands that provide a specific reusable functionality. It is used to avoid same code being repeated in multiple locations. Procedures are equivalent to the functions used in many programming languages and are made available in Tcl with the help of proc command.|||The syntax of creating a simple procedure is shown below −|||A simple example for procedure is given below −|||When the above code is executed, it produces the following result −|||An example for procedure with arguments is shown below −|||When the above code is executed, it produces the following result −|||An example for procedure with arguments is shown below −|||When the above code is executed, it produces the following result −|||Default arguments are used to provide default values that can be used if no value is provided. An example for procedure with default arguments, which is sometimes referred as implicit arguments is shown below −|||When the above code is executed, it produces the following result −|||An example for recursive procedures is shown below −|||When the above code is executed, it produces the following result −|||Packages are used for creating reusable units of code. A package consists of a collection of files that provide specific functionality. This collection of files is identified by a package name and can have multiple versions of same files. The package can be a collection of Tcl scripts, binary library, or a combination of both.|||Package uses the concept of namespace to avoid collision of variable names and procedure names. Check out more in our next 'namespace' tutorial.|||A package can be created with the help of minimum two files. One file contains the package code. Other file contains the index package file for declaring your package.|||The list of steps for creating and using package is given below.|||Create code for package inside a folder say HelloWorld. Let the file be named HelloWorld.tcl with the code as shown below −|||Open tclsh. Switch to HelloWorld directory and use the pkg_mkIndex command to create the index file as shown below −|||Use the lappend command to add the package to the global list as shown below −|||Next add package to program using package require statement as shown below −|||Now, everything being setup, we can invoke our procedure as shown below −|||You will get the following result −|||First two steps create the package. Once package is created, you can use it in any Tcl file by adding the last three statements as shown below −|||You will get the following result −|||Namespace is a container for set of identifiers that is used to group variables and procedures. Namespaces are available from Tcl version 8.0. Before the introduction of the namespaces, there was single global scope. Now with namespaces, we have additional partitions of global scope.|||Namespaces are created using the namespace command. A simple example for creating namespace is shown below −|||When the above code is executed, it produces the following result −|||In the above program, you can see there is a namespace with a variable myResult and a procedure Add. This makes it possible to create variables and procedures with the same names under different namespaces.|||Tcl allows nesting of namespaces. A simple example for nesting namespaces is given below −|||When the above code is executed, it produces the following result −|||You can see in the previous namespace examples, we use a lot of scope resolution operator and it's more complex to use. We can avoid this by importing and exporting namespaces. An example is given below −|||When the above code is executed, it produces the following result −|||You can remove an imported namespace by using forget subcommand. A simple example is shown below −|||When the above code is executed, it produces the following result −|||Tcl supports file handling with the help of the built in commands open, read, puts, gets, and close.|||A file represents a sequence of bytes, does not matter if it is a text file or binary file.|||Tcl uses the open command to open files in Tcl. The syntax for opening a file is as follows −|||Here, filename is string literal, which you will use to name your file and accessMode can have one of the following values −|||r|||Opens an existing text file for reading purpose and the file must exist. This is the default mode used when no accessMode is specified.|||w|||Opens a text file for writing, if it does not exist, then a new file is created else existing file is truncated.|||a|||Opens a text file for writing in appending mode and file must exist. Here, your program will start appending content in the existing file content.|||r+|||Opens a text file for reading and writing both. File must exist already.|||w+|||Opens a text file for reading and writing both. It first truncate the file to zero length if it exists otherwise create the file if it does not exist.|||a+|||Opens a text file for reading and writing both. It creates the file if it does not exist. The reading will start from the beginning, but writing can only be appended.|||To close a file, use the close command. The syntax for close is as follows −|||Any file that has been opened by a program must be closed when the program finishes using that file. In most cases, the files need not be closed explicitly; they are closed automatically when File objects are terminated automatically.|||Puts command is used to write to an open file.|||A simple example for writing to a file is shown below.|||When the above code is compiled and executed, it creates a new file input.txt in the directory that it has been started under (in the program's working directory).|||Following is the simple command to read from a file −|||A complete example of read and write is shown below −|||When the above code is compiled and executed, it reads the file created in previous section and produces the following result −|||Here is another example for reading file till end of file line by line −|||When the above code is compiled and executed, it reads the file created in previous section and produces the following result −|||Error handling in Tcl is provided with the help of error and catch commands. The syntax for each of these commands is shown below.|||In the above error command syntax, message is the error message, info is set in the global variable errorInfo and code is set in the global variable errorCode.|||In the above catch command syntax, script is the code to be executed, resultVarName is variable that holds the error or the result. The catch command returns 0 if there is no error, and 1 if there is an error.|||An example for simple error handling is shown below −|||When the above code is executed, it produces the following result −|||As you can see in the above example, we can create our own custom error messages. Similarly, it is possible to catch the error generated by Tcl. An example is shown below −|||When the above code is executed, it produces the following result −|||Tcl provides a number of built-in functions (procedures) for various operations. This includes −|||Functions for list handling.|||Functions for string handling.|||Functions for array handling.|||Functions for dictionary handling.|||Functions for File I/O handling.|||Functions for creating namespaces and packages.|||Functions for Math operations.|||Functions for System operations.|||Each of the above except for math and system functions are covered in earlier chapters. Math and system built-in functions are explained below.|||The math functions available in Tcl are listed in the following table −|||abs arg|||Calculates the absolute value of arg.|||acos arg|||Calculates the arccosine of arg.|||asin arg|||Calculates the arcsine of arg.|||atan arg|||Calculates the arctangent of arg.|||atan2 y x|||Calculates the arctangent of the quotient of its arguments(y/x).|||ceil arg|||Calculates the smallest integer greater than or equal to a number.|||cos arg|||Calculates the cosine of arg.|||cosh arg|||Calculates the hyperbolic cosine of arg.|||double arg|||Calculates if arg is a floating-point value, returns arg, otherwise converts arg to floating-point and returns the converted value.|||exp arg|||Calculates an exponential function (e raised to the power of arg).|||floor arg|||Calculates the largest integer less than or equal to arg.|||fmod x y|||Calculates the floating-point remainder of the division of x by y. If y is 0, an error is returned.|||hypot x y|||Calculates the length of the hypotenuse of a right-angled triangle sqrt(x*x+y*y).|||int arg|||Calculates if arg is an integer value of the same width as the machine word, returns arg, otherwise converts arg to an integer.|||log arg|||Calculates the natural logarithm of arg.|||log10 arg|||Calculates the base 10 logarithm of arg.|||pow x y|||Calculates the value of x raised to the power y. If x is negative, y must be an integer value.|||rand|||Calculates a pseudo-random number between 0 and 1.|||round arg|||Calculates the value of arg rounded to the nearest integer.|||sin arg|||Calculates the sine of arg.|||sinh arg|||Calculates the hyperbolic sine of arg.|||sqrt arg|||Calculates the square root of arg. arg must be positive.|||srand arg|||Calculates a pseudo-random number between 0 and 1. The arg, which must be an integer, is used to reset the seed for the random number generator of rand.|||tan arg|||Calculates the tangent of arg.|||tanh arg|||Calculates the hyperbolic tangent of arg.|||wide arg|||Calculates integer value at least 64-bits wide (by sign-extension if arg is a 32-bit number) for arg if it is not one already.|||Some examples using math functions are given below −|||When the above code is executed, it produces the following result −|||The important system functions in Tcl includes,|||clock − seconds function, which returns current time in seconds.|||clock − format function, which formats the seconds into date and time.|||clock − scan function, which scans the input string and converts it into seconds.|||open − function, which is used to open a file.|||exec − function, which is used to execute a system command.|||close − function, which is used to close a file.|||Some examples for the above functions are listed below −|||When the above code is executed, it produces the following result −|||The following table provides the list strings that can be used to format the date and time.|||%a|||Day in short form, eg:Sun.|||%A|||Day in full form eg:Sunday.|||%b|||Month in short form.|||%B|||Month in full form.|||%d|||Day of month.|||%j|||Julian day of year.|||%m|||Month in number.|||%y|||Year in two digits.|||%Y|||Year in four digits.|||%H|||Hour in 24 hour clock.|||%I|||Hour in 12 hour clock.|||%M|||Minutes.|||%S|||Seconds.|||%p|||AM or PM.|||%D|||Date in number, mm /dd/yy.|||%r|||Time in 12 hour clock.|||%R |||Time in 24 hour clock without seconds.|||%T|||Time in 24 hour clock with seconds.|||%Z|||Time Zone Name like GMT, IST, EST and so on.|||The ""regexp"" command is used to match a regular expression in Tcl. A regular expression is a sequence of characters that contains a search pattern. It consists of multiple rules and the following table explains these rules and corresponding use.|||x|||Exact match.|||[a-z]|||Any lowercase letter from a-z.|||.|||Any character.|||^|||Beginning string should match.|||$|||Ending string should match.|||\^|||Backlash sequence to match special character ^.Similarly you can use for other characters.|||()|||Add the above sequences inside parenthesis to make a regular expression.|||x*|||Should match 0 or more occurrences of the preceding x.|||x+|||Should match 1 or more occurrences of the preceding x.|||[a-z]?|||Should match 0 or 1 occurrence of the preceding x.|||{digit}|||Matches exactly digit occurrences of previous regex expression. Digit that contains 0-9.|||{digit,}|||Matches 3 or more digit occurrences of previous regex expression. Digit that contains 0-9.|||{digit1,digit2}|||Occurrences matches the range between digit1 and digit2 occurrences of previous regex expression.|||The syntax for regex is given below −|||Here, regex is the command. We will see about optional switches later. Patterns are the rules as mentioned earlier. Search string is the actual string on which the regex is performed. Full match is any variable to hold the result of matched regex result. Submatch1 to SubMatchn are optional subMatch variable that holds the result of sub match patterns.|||Let's look at some simple examples before diving into complex ones. A simple example for a string with any alphabets. When any other character is encountered the regex, search will be stopped and returned.|||When the above code is executed, it produces the following result −|||The following example shows how to search for multiple patterns. This is example pattern for any alphabets followed by any character followed by any alphabets.|||When the above code is executed, it produces the following result −|||A modified version of the above code to show that a sub pattern can contain multiple patterns is shown below −|||When the above code is executed, it produces the following result −|||The list of switches available in Tcl are,|||nocase − Used to ignore case.|||indices − Store location of matched sub patterns instead of matched characters.|||line − New line sensitive matching. Ignores the characters after newline.|||start index − Sets the offset of start of search pattern.|||Marks the end of switches|||In the above examples, I have deliberately used [A-Z, a-z] for all alphabets, you can easily use -nocase instead of as shown below −|||When the above code is executed, it produces the following result −|||Another example using switches is shown below −|||When the above code is executed, it produces the following result −|||Tk refers to Toolkit and it provides cross platform GUI widgets, which helps you in building a Graphical User Interface. It was developed as an extension to Tcl scripting language by John Ousterhout. Tk remained in development independently from Tcl with version being different to each other, before, it was made in sync with Tcl in v8.0.|||It is cross platform with support for Linux, Mac OS, Unix, and Microsoft Windows operating systems.|||Large successful applications have been built in Tcl/Tk.|||Generally, all Mac and Linux mac come with Tk pre-installed. In case, it's not available or you need the latest version, then you may need to install it. Windows don't come with Tcl/Tk and you may need to use its specific binary to install it.|||It is just a small program that enables you to type Tk commands and have them executed line by line. It stops execution of a tcl file in case, it encounters an error unlike a compiler that executes fully.|||Let's have a helloWorld.tcl file as follows. We will use this as first program, we run on the platform you choose.|||The following section explains only how to install Tcl/Tk on each of the available platforms.|||Download the latest version for windows  installer from the list of Active Tcl/Tk binaries available. Active Tcl/Tk community edition is free for personal use.|||Run the downloaded executable to install the Tcl and Tk, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd and then using the following step −|||Press enter and we will see an output as shown below −|||Most Linux operating systems comes with Tk inbuilt and you can get started right away in those systems. In case, it's not available, you can use the following command to download and install Tcl-Tk.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following step −|||Press enter and we will see an output similar to the following −|||In case, it's not available prebuilt in your OS, you can use the following command to download and install Tcl-Tk −|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following steps −|||Press enter and we will see an output similar to the following −|||Download the latest version for Mac OS X  package from the list of Active Tcl/Tk binaries available. Active Tcl community edition is free for personal use.|||Run the downloaded executable to install the Active Tcl, which can be done by following the on screen instructions.|||Now, we can build and run a Tcl file say helloWorld.tcl by switching to folder containing the file using cd command and then using the following step −|||Press enter and we will see an output as shown below −|||You can use the option of installing from source files when a binary package is not available. It is generally preferred to use Tk binaries for Windows and Mac OS X, so only compilation of sources on unix based system is shown below −|||Download the source files.|||Now, use the following commands to extract, compile and build after switching to the downloaded folder.|||Note − Make sure, you change the file name to the version you downloaded on commands 1 and 2 in the above.|||In Tk, we classify some of the variables as special variables and they have a predefined usage/functionality. The list of special variables is listed below.|||tk_library|||Used for setting the location of standard Tk libraries.|||tk_patchLevel|||Refers to the current patch level of the Tk interpreter.|||tk_strictMotif|||When non-zero, Tk tries to adhere to Motif look-and-feel as closely as possible.|||tk_version|||Displays the Tk version.|||The above special variables have their special meanings for the Tk interpreter.|||Lets see the examples for special variables.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.|||When you run the program, you will get a similar output as shown below.|||The basic component of a Tk-based application is called a widget. A component is also sometimes called a window, since, in Tk, ""window"" and ""widget"" are often used interchangeably. Tk is a package that provides a rich set of graphical components for creating graphical applications with Tcl.|||Tk provides a range of widgets ranging from basic GUI widgets like buttons and menus to data display widgets. The widgets are very configurable as they have default configurations making them easy to use.|||Tk applications follow a widget hierarchy where any number of widgets may be placed within another widget, and those widgets within another widget. The main widget in a Tk program is referred to as the root widget and can be created by making a new instance of the TkRoot class.|||The syntax for creating a widget is given below.|||The type here refers to the widget type like button, label, and so on. Arguments can be optional and required based on individual syntax of each widget. The options range from size to formatting of each component.|||Widget uses a structure similar to naming packages. In Tk, the root window is named with a period (.) and an element in window, for example button is named .myButton1. The variable name should start with a lowercase letter, digit, or punctuation mark (except a period). After the first character, other characters may be uppercase or lowercase letters, numbers, or punctuation marks (except periods). It is recommended to use a lowercase letter to start the label.|||The colors can be declared using name like red, green, and so on. It can also use hexadecimal representing with #. The number of hexadecimal digits can be 3, 6, 9, or 12.|||The default unit is pixels and it is used when we specify no dimension. The other dimensions are i for inches, m for millimeters, c for centimeters and p for points.|||There are so many common options available to all widgets and they are listed below in the following table −|||-background color|||Used to set background color for widget.|||-borderwidth width|||Used to draw with border in 3D effects.|||-font fontDescriptor|||Used to set font for widget.|||-foreground color|||Used to set foreground color for widget.|||-height number|||Used to set height for widget.|||-highlightbackground color|||Used to set the color rectangle to draw around a widget when the widget does not have input focus.|||-highlightcolor color|||Used to set the color rectangle to draw around a widget when the widget has input focus.|||-padx number|||Sets the padx for the widget.|||-pady number|||Sets the pady for the widget.|||-relief condition|||Sets the 3D relief for this widget. The condition may be raised, sunken, flat, ridge, solid, or groove.|||-text text|||Sets the text for the widget.|||-textvariable varName|||Variable associated with the widget. When the text of widget changes, the variable is set with text of widget.|||-width number|||Sets the width for widget.|||A simple example for options is shown below.|||When we run the above program, we will get the following output.|||The list of available widgets are categorized below −|||Label|||Widget for displaying single line of text.|||Button|||Widget that is clickable and triggers an action.|||Entry|||Widget used to accept a single line of text as input.|||Message|||Widget for displaying multiple lines of text.|||Text|||Widget for displaying and optionally edit multiple lines of text.|||Toplevel|||Window with all borders and decorations provided by the Window manager.|||Frame|||Container widget to hold other widgets.|||Place|||Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||Pack|||Simple widget to organize widgets in blocks before placing them in the parent widget.|||Grid|||Widget to nest widgets packing in different directions.|||Radiobutton|||Widget that has a set of on/off buttons and labels, one of which may be selected.|||Checkbutton|||Widget that has a set of on/off buttons and labels, many of which may be selected..|||Menu|||Widget that acts as holder for menu items.|||Listbox|||Widget that displays a list of cells, one or more of which may be selected.|||Dialog|||Widget for displaying dialog boxes.|||Spinbox|||Widget that allows users to choose numbers.|||Combobox|||Widget that combines an entry with a list of choices available to the use.|||Notebook|||Tabbed widget that helps to switch between one of several pages, using an index tab.|||Progressbar|||Widget to provide visual feedback to the  progress of a long operation like file upload.|||Treeview|||Widget to display and allow browsing through a hierarchy of items more in form of tree.|||Scrollbar|||Scrolling widgets without a text or canvas widgets.|||Scale|||Scale widget to choose a numeric value through sliders.|||Canvas|||Drawing widget for displaying graphics and images..|||We will cover each of these widgets in the upcoming chapters.|||Basic widgets are common widgets available in almost all Tk applications. The list of available basic widgets is given below −|||Widget for displaying single line of text.|||Widget that is clickable and triggers an action.|||Widget used to accept a single line of text as input.|||Widget for displaying multiple lines of text.|||Widget for displaying and optionally edit multiple lines of text.|||Widget used to create a frame that is a new top level window.|||A simple Tk example is shown below using basic widgets −|||When we run the above program, we will get the following output −|||Layout widgets are used to handle layouts for the Tk application. Frame widget is used group other widgets and place, pack, and grid are layout manager to give you total control over your adding to windows. The list of available layout widgets are as shown below −|||Container widget to hold other widgets.|||Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||Simple widget to organize widgets in blocks before placing them in the parent widget.|||Widget to nest widgets packing in different directions.|||A simple Tk example is shown below for layout widgets −|||When we run the above program, we will get the following output −|||Selection widgets are used to select different options in a Tk application. The list of available selection widgets are as shown below.|||Widget that has a set of on/off buttons and labels, one of which may be selected.|||Widget that has a set of on/off buttons and labels, many of which may be selected.|||Widget that acts as holder for menu items.|||Widget that displays a list of cells, one or more of which may be selected.|||A simple Tk example is shown below using selection widgets −|||When we run the above program, we will get the following output −|||Canvas is used for providing drawing areas. The syntax for canvas widget is shown below −|||The options available for the canvas widget are listed below in the following table −|||-background color|||Used to set background color for widget.|||-closeenough distance|||Sets the closeness of mouse cursor to a displayable item. The default is 1.0 pixel. This value may be a fraction and must be positive.|||-scrollregion boundingBox|||The bounding box for the total area of this canvas.|||-height number|||Used to set height for widget.|||-width number|||Sets the width for widget.|||-xscrollincrement size|||The amount to scroll horizontally  when scrolling is requested.|||-yscrollincrement size|||The amount to scroll vertically when scrolling is requested.|||A simple example for canvas widget is shown below −|||When we run the above program, we will get the following output −|||The list of the available widgets for drawing in canvas is listed below −|||Draws a line.|||Draws an arc.|||Draws a rectangle.|||Draws an oval.|||Draws a polygon.|||Draws a text.|||Draws a bitmap.|||Draws an image.|||An example using different canvas widgets is shown below −|||When we run the above program, we will get the following output −|||Mega widgets include many complex widgets which is often required in some large scale Tk applications. The list of available mega widgets are as shown below −|||Widget for displaying dialog boxes.|||Widget that allows users to choose numbers.|||Widget that combines an entry with a list of choices available to the use.|||Tabbed widget that helps to switch between one of several pages, using an index tab.|||Widget to provide visual feedback to the  progress of a long operation like file upload.|||Widget to display and allow browsing through a hierarchy of items more in form of tree.|||Scrolling widgets without a text or canvas widgets.|||Scale widget to choose a numeric value through sliders.|||A simple Tk example is shown below using some mega widgets.|||When we run the above program, we will get the following output −|||There are a number of widgets that supports displaying text. Most of these provides the option of font attribute. The syntax for creating a font is shown below −|||The options available for the font create are listed below in the following table −|||-family familyName|||The name of font family.|||-size number|||The size of font.|||-weight level|||The weight for font.|||A simple example for a font creation is shown below −|||When we run the above program, we will get the following output −|||To get all the fonts available, we can use the following command −|||When we run the above command, we will get the following output −|||The image widget is used to create and manipulate images. The syntax for creating image is as follows −|||In the above syntax type is photo or bitmap and name is the image identifier.|||The options available for image create are listed below in the following table −|||-file fileName|||The name of the image file name.|||-height number|||Used to set height for widget.|||-width number|||Sets the width for widget.|||-data string|||Image in base 64 encoded string.|||A simple example for image widget is shown below −|||When we run the above program, we will get the following output −|||The available function for image are listed below in the following table −|||image delete imageName|||Deletes the image from memory and related widgets visually.|||image height imageName|||Returns the height for image.|||image width imageName|||Returns the width for image.|||image type imageName|||Returns the type for image.|||image names|||Returns the list of images live in memory.|||A simple example for using the above image widget commands is shown below −|||The image will be deleted visually and from memory once ""image delete imgobj"" command executes. In console, the output will be like the following −|||Events in its simplest form is handled with the help of commands. A simple example for event handling is event handling with button and is shown below −|||When we run the above program, we will get the following output −|||A simple program to show delay text animation event is shown below −|||When we run the program, we will get the following output in animated way −|||The syntax for event after delay is shown below −|||A simple program to show after delay event is shown below −|||When we run the program, we will get the following output after one second −|||You can cancel an event using the after cancel command as shown below −|||The syntax for event binding is as shown below −|||When we run the program and press a letter X, we will get the following output −|||When we run the program and press the left mouse button, we will get an output similar to the following −|||When we run the program and press enter, we will get the following output −|||Window manager is used to handle the top level window. It helps in controlling the size, position, and other attributes of the window. In Tk, . is used to refer the main window. The syntax for window command is shown below −|||The list of options available for Tk wm command is shown in the following table −|||aspect windowName a b c d|||Tries to maintain the ratio of width/height to be between a/b and c/d.|||geometry windowName geometryParams|||Use to set geometry for window.|||grid windowName w h dx dy|||Sets the grid size.|||group windowName leaderName|||leaderName gives the leader of a group of related windows.|||deiconify windowName|||Brings the screen to normal if minimized.|||iconify windowName|||Minimizes the window.|||state windowName|||Returns the current state of window.|||withdraw windowName|||Unmaps the window and removes its details in memory.|||iconbitmap windowName image|||Sets or returns the icon bitmap.|||iconPhoto windowName image|||Sets or returns the icon photo.|||command windowName commandString|||Records the startup command in the WM_COMMAND property.|||protocol windowName arguments|||Register a command to handle the protocol request name, which can be WM_DELETE_WINDOW,|||WM_SAVE_YOURSELF,|||WM_TAKE_FOCUS. Eg: wm protocol.|||WM_DELETE_WINDOW Quit.|||minsize windowName size|||Determines the minimum window size.|||maxsize windowName size|||Determines the maximum window size.|||title windowName titleText|||Determines the title for window.|||attributes subOptions|||There are lots of attributes available like alpha, full screen and so on.|||Some of the above commands are used in the following example −|||When we run the above program, we will get the following output −|||As you can see alpha is one of the attributes available. The list of commonly used subcommands are listed below −|||-alpha number|||Sets the alpha for window.|||-fullscreen number|||Number can be 0 for normal screen or 1 for full screen.|||-topmost number|||Sets or returns whether window is topmost.Value can be 0 or 1.|||We can use toplevel command to create window and an example is shown below −|||When we run the above program, we will get the following output −|||We can use destroy command to destroy window and an example is shown below −|||The above command will destroy window named .t.|||The geometry manager is used to manage the geometry of the window and other frames. We can use it to handle the position and size of the window and frames. The layout widgets are used for this purpose.|||The syntax for positioning and sizing window is shown below −|||Here, w refers to width and h refers to height. It is followed by a '+' or '-' sign with number next referring to the x position on screen. Similarly the following '+' or '-' sign with number refers to the y position on screen|||A simple example is shown below for the above Statement −.|||When we run the above program, we will get the following output −|||The syntax for grid geometry is shown below −|||The column, row, columnspan, or rowspan helps in providing the grid geometry.|||A simple example is shown below for the above statement −|||When we run the above program, we will get the following output −","Reduced development time.@@@Powerful and simple user interface kit with integration of TK.@@@Write once, run anywhere. It runs on Windows, Mac OS X, and almost on every Unix platform.@@@Quite easy to get started for experienced programmers; since, the language is so simple that they can learn Tcl in a few hours or days.@@@You can easily extend existing applications with Tcl. Also, it is possible to include Tcl in C, C++, or Java to Tcl or vice versa.@@@Have a powerful set of networking functions.@@@Finally, it's an open source, free, and can be used for commercial applications without any limit.|||Scalable websites that are often backed by databases.@@@High performance web servers build with TclHttpd.@@@Tcl with CGI based websites.@@@Desktop GUI applications.@@@Embedded applications.|||Text Editor@@@Tcl Interpreter.|||Download the source files.@@@Now, use the following commands to extract, compile, and build after switching to the downloaded folder.|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Bitwise Operators@@@Ternary Operator|||Functions for list handling.@@@Functions for string handling.@@@Functions for array handling.@@@Functions for dictionary handling.@@@Functions for File I/O handling.@@@Functions for creating namespaces and packages.@@@Functions for Math operations.@@@Functions for System operations.|||clock − seconds function, which returns current time in seconds.@@@clock − format function, which formats the seconds into date and time.@@@clock − scan function, which scans the input string and converts it into seconds.@@@open − function, which is used to open a file.@@@exec − function, which is used to execute a system command.@@@close − function, which is used to close a file.|||nocase − Used to ignore case.@@@indices − Store location of matched sub patterns instead of matched characters.@@@line − New line sensitive matching. Ignores the characters after newline.@@@start index − Sets the offset of start of search pattern.@@@Marks the end of switches|||It is an open source.@@@It provides high level of extendibility.@@@It is customizable.@@@It is configurable.@@@It provides a large number of widgets.@@@It can be used with other dynamic languages and not just Tcl.@@@GUI looks identical across platforms.|||Dashboard Soft User Interface@@@Forms GUI for Relational DB@@@Ad Hoc GUI for Relational DB@@@Software/Hardware System Design@@@Xtask - Task Management@@@Musicology with Tcl and Tk@@@Calender app@@@Tk mail@@@Tk Debugger|||Download the source files.@@@Now, use the following commands to extract, compile and build after switching to the downloaded folder.",,"Sr.No.@@@Special Variable & Description|||1@@@argc
Refers to a number of command-line arguments.|||2@@@argv
Refers to the list containing the command-line arguments.|||3@@@argv0
Refers to the file name of the file being interpreted or the name by which we invoke the script.|||4@@@env
Used for representing the array of elements that are environmental variables.|||5@@@errorCode
Provides the error code for last Tcl error.|||6@@@errorInfo
Provides the stack trace for last Tcl error.|||7@@@tcl_interactive
Used to switch between interactive and non-interactive modes by setting this to 1 and 0 respectively.|||8@@@tcl_library
Used for setting the location of standard Tcl libraries.|||9@@@tcl_pkgPath
Provides the list of directories where packages are generally installed.|||10@@@tcl_patchLevel
Refers to the current patch level of the Tcl interpreter.|||11@@@tcl_platform
Used for representing the array of elements with objects including byteOrder, machine, osVersion, platform, and os.|||12@@@tcl_precision
Refers to the precision i.e. number of digits to retain when converting to floating-point numbers to strings. The default value is 12.|||13@@@tcl_prompt1
Refers to the primary prompt.|||14@@@tcl_prompt2
Refers to the secondary prompt with invalid commands.|||15@@@tcl_rcFileName
Provides the user specific startup file.|||16@@@tcl_traceCompile
Used for controlling the tracing of bytecode compilation. Use 0 for no output, 1 for summary, and 2 for detailed.|||17@@@tcl_traceExec
Used for controlling the tracing of bytecode execution. Use 0 for no output, 1 for summary, and 2 for detailed.|||18@@@tcl_version
Returns the current version of the Tcl interpreter.&&&Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiplies both operands@@@A * B will give 200|||/@@@Divides numerator by de-numerator@@@B / A will give 2|||%@@@Modulus Operator and remainder of after an integer division@@@B % A will give 0&&&Operator@@@Description@@@Example|||==@@@Checks if the values of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||!=@@@Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||&&@@@Called Logical AND operator. If both the operands are non-zero, then condition becomes true.@@@(A && B) is false.|||||@@@Called Logical OR Operator. If any of the two operands is non-zero, then condition becomes true.@@@(A || B) is true.|||!@@@Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A && B) is true.&&&p@@@q@@@p & q@@@p | q@@@p ^ q|||0@@@0@@@0@@@0@@@0|||0@@@1@@@0@@@1@@@1|||1@@@1@@@1@@@1@@@0|||1@@@0@@@0@@@1@@@1&&&Operator@@@Description@@@Example|||&@@@Binary AND Operator copies a bit to the result if it exists in both operands.@@@(A & B) will give 12, which is 0000 1100||||@@@Binary OR Operator copies a bit if it exists in either operand.@@@(A | B) will give 61, which is 0011 1101|||^@@@Binary XOR Operator copies the bit if it is set in one operand but not both.@@@(A ^ B) will give 49, which is 0011 0001|||<<@@@Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.@@@A << 2 will give 240, which is 1111 0000|||>>@@@Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.@@@A >> 2 will give 15, which is 0000 1111&&&Operator@@@Description@@@Example|||? :@@@Ternary@@@If Condition is true? Then value X : Otherwise value Y&&&Category@@@Operator@@@Associativity|||Unary@@@+ -@@@Right to left|||Multiplicative@@@* / %@@@Left to right|||Additive@@@+ -@@@Left to right|||Shift@@@<< >>@@@Left to right|||Relational@@@< <= > >=@@@Left to right|||Bitwise AND@@@&@@@Left to right|||Bitwise XOR@@@^@@@Left to right|||Bitwise OR@@@|@@@Left to right|||Logical AND@@@&&@@@Left to right|||Logical OR@@@||@@@Left to right|||Ternary@@@?:@@@Right to left&&&Sr.No.@@@Statement & Description|||1@@@if statement
An 'if' statement consists of a Boolean expression followed by one or more statements.|||2@@@if...else statement
An 'if' statement can be followed by an optional 'else' statement, which executes when the Boolean expression is false.|||3@@@nested if statements
You can use one 'if' or 'else if' statement inside another 'if' or 'else if' statement(s).|||4@@@switch statement
A switch statement allows a variable to be tested for equality against a list of values.|||5@@@nested switch statements
You can use one switch statement inside another switch statement(s).&&&Sr.No.@@@Loop Type & Description|||1@@@while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||2@@@for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||3@@@nested loops
You can use one or more loop inside any another while, for or do..while loop.&&&Sr.No.@@@Control Statement & Description|||1@@@break statement
Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.|||2@@@continue statement
Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.&&&Escape sequence@@@Meaning|||\\@@@\ character|||\'@@@' character|||\""@@@"" character|||\?@@@? character|||\a@@@Alert or bell|||\b@@@Backspace|||\f@@@Form feed|||\n@@@Newline|||\r@@@Carriage return|||\t@@@Horizontal tab|||\v@@@Vertical tab&&&Sr.No.@@@Methods & Description|||1@@@compare string1 string2
Compares string1 and string2 lexographically. Returns 0 if equal, -1 if string1 comes before string2, else 1.|||2@@@first string1 string2
Returns the index first occurrence of string1 in string2. If not found, returns -1.|||3@@@index string index
Returns the character at index.|||4@@@last string1 string2
Returns the index last occurrence of string1 in string2. If not found, returns -1.|||5@@@length string
Returns the length of string.|||6@@@match pattern string
Returns 1 if the string matches the pattern.|||7@@@range string index1 index2
Return the range of characters in string from index1 to index2.|||8@@@tolower string
Returns the lowercase string.|||9@@@toupper string
Returns the uppercase string.|||10@@@trim string ?trimcharacters?
Removes trimcharacters in both ends of string. The default trimcharacters is whitespace.|||11@@@trimleft string ?trimcharacters?
Removes trimcharacters in left beginning of string. The default trimcharacters is whitespace.|||12@@@trimright string ?trimcharacters?
Removes trimcharacters in left end of string. The default trimcharacters is whitespace.|||13@@@wordend findstring index
Return the index in findstring of the character after the word containing the character at index.|||14@@@wordstart findstring index
Return the index in findstring of the first character in the word containing the character at index.&&&Specifier@@@Use|||%s@@@String representation|||%d@@@Integer representation|||%f@@@Floating point representation|||%e@@@Floating point representation with mantissa-exponent form|||%x@@@Hexa decimal representation&&&Sr.No.@@@Mode & Description|||1@@@r
Opens an existing text file for reading purpose and the file must exist. This is the default mode used when no accessMode is specified.|||2@@@w
Opens a text file for writing, if it does not exist, then a new file is created else existing file is truncated.|||3@@@a
Opens a text file for writing in appending mode and file must exist. Here, your program will start appending content in the existing file content.|||4@@@r+
Opens a text file for reading and writing both. File must exist already.|||5@@@w+
Opens a text file for reading and writing both. It first truncate the file to zero length if it exists otherwise create the file if it does not exist.|||6@@@a+
Opens a text file for reading and writing both. It creates the file if it does not exist. The reading will start from the beginning, but writing can only be appended.&&&Sr.No.@@@Method & Description|||1@@@abs arg
Calculates the absolute value of arg.|||2@@@acos arg
Calculates the arccosine of arg.|||3@@@asin arg
Calculates the arcsine of arg.|||4@@@atan arg
Calculates the arctangent of arg.|||5@@@atan2 y x
Calculates the arctangent of the quotient of its arguments(y/x).|||6@@@ceil arg
Calculates the smallest integer greater than or equal to a number.|||7@@@cos arg
Calculates the cosine of arg.|||8@@@cosh arg
Calculates the hyperbolic cosine of arg.|||9@@@double arg
Calculates if arg is a floating-point value, returns arg, otherwise converts arg to floating-point and returns the converted value.|||10@@@exp arg
Calculates an exponential function (e raised to the power of arg).|||11@@@floor arg
Calculates the largest integer less than or equal to arg.|||12@@@fmod x y
Calculates the floating-point remainder of the division of x by y. If y is 0, an error is returned.|||13@@@hypot x y
Calculates the length of the hypotenuse of a right-angled triangle sqrt(x*x+y*y).|||14@@@int arg
Calculates if arg is an integer value of the same width as the machine word, returns arg, otherwise converts arg to an integer.|||15@@@log arg
Calculates the natural logarithm of arg.|||16@@@log10 arg
Calculates the base 10 logarithm of arg.|||17@@@pow x y
Calculates the value of x raised to the power y. If x is negative, y must be an integer value.|||18@@@rand
Calculates a pseudo-random number between 0 and 1.|||19@@@round arg
Calculates the value of arg rounded to the nearest integer.|||20@@@sin arg
Calculates the sine of arg.|||21@@@sinh arg
Calculates the hyperbolic sine of arg.|||22@@@sqrt arg
Calculates the square root of arg. arg must be positive.|||23@@@srand arg
Calculates a pseudo-random number between 0 and 1. The arg, which must be an integer, is used to reset the seed for the random number generator of rand.|||24@@@tan arg
Calculates the tangent of arg.|||25@@@tanh arg
Calculates the hyperbolic tangent of arg.|||26@@@wide arg
Calculates integer value at least 64-bits wide (by sign-extension if arg is a 32-bit number) for arg if it is not one already.&&&Sr.No.@@@Format & Description|||1@@@%a
Day in short form, eg:Sun.|||2@@@%A
Day in full form eg:Sunday.|||3@@@%b
Month in short form.|||4@@@%B
Month in full form.|||5@@@%d
Day of month.|||6@@@%j
Julian day of year.|||7@@@%m
Month in number.|||8@@@%y
Year in two digits.|||9@@@%Y
Year in four digits.|||10@@@%H
Hour in 24 hour clock.|||11@@@%I
Hour in 12 hour clock.|||12@@@%M
Minutes.|||13@@@%S
Seconds.|||14@@@%p
AM or PM.|||15@@@%D
Date in number, mm /dd/yy.|||16@@@%r
Time in 12 hour clock.|||17@@@%R 
Time in 24 hour clock without seconds.|||18@@@%T
Time in 24 hour clock with seconds.|||19@@@%Z
Time Zone Name like GMT, IST, EST and so on.&&&Sr.No.@@@Rule & Description|||1@@@x
Exact match.|||2@@@[a-z]
Any lowercase letter from a-z.|||3@@@.
Any character.|||4@@@^
Beginning string should match.|||5@@@$
Ending string should match.|||6@@@\^
Backlash sequence to match special character ^.Similarly you can use for other characters.|||7@@@()
Add the above sequences inside parenthesis to make a regular expression.|||8@@@x*
Should match 0 or more occurrences of the preceding x.|||9@@@x+
Should match 1 or more occurrences of the preceding x.|||10@@@[a-z]?
Should match 0 or 1 occurrence of the preceding x.|||11@@@{digit}
Matches exactly digit occurrences of previous regex expression. Digit that contains 0-9.|||12@@@{digit,}
Matches 3 or more digit occurrences of previous regex expression. Digit that contains 0-9.|||13@@@{digit1,digit2}
Occurrences matches the range between digit1 and digit2 occurrences of previous regex expression.&&&Sr.No.@@@Special Variable & Description|||1@@@tk_library
Used for setting the location of standard Tk libraries.|||2@@@tk_patchLevel
Refers to the current patch level of the Tk interpreter.|||3@@@tk_strictMotif
When non-zero, Tk tries to adhere to Motif look-and-feel as closely as possible.|||4@@@tk_version
Displays the Tk version.&&&Sr.No.@@@Syntax & Description|||1@@@-background color
Used to set background color for widget.|||2@@@-borderwidth width
Used to draw with border in 3D effects.|||3@@@-font fontDescriptor
Used to set font for widget.|||4@@@-foreground color
Used to set foreground color for widget.|||5@@@-height number
Used to set height for widget.|||6@@@-highlightbackground color
Used to set the color rectangle to draw around a widget when the widget does not have input focus.|||7@@@-highlightcolor color
Used to set the color rectangle to draw around a widget when the widget has input focus.|||8@@@-padx number
Sets the padx for the widget.|||9@@@-pady number
Sets the pady for the widget.|||10@@@-relief condition
Sets the 3D relief for this widget. The condition may be raised, sunken, flat, ridge, solid, or groove.|||11@@@-text text
Sets the text for the widget.|||12@@@-textvariable varName
Variable associated with the widget. When the text of widget changes, the variable is set with text of widget.|||13@@@-width number
Sets the width for widget.&&&Sr.No.@@@Widget & Description|||1@@@Label
Widget for displaying single line of text.|||2@@@Button
Widget that is clickable and triggers an action.|||3@@@Entry
Widget used to accept a single line of text as input.|||4@@@Message
Widget for displaying multiple lines of text.|||5@@@Text
Widget for displaying and optionally edit multiple lines of text.|||6@@@Toplevel
Window with all borders and decorations provided by the Window manager.&&&Sr.No.@@@Widget & Description|||1@@@Frame
Container widget to hold other widgets.|||2@@@Place
Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||3@@@Pack
Simple widget to organize widgets in blocks before placing them in the parent widget.|||4@@@Grid
Widget to nest widgets packing in different directions.&&&Sr.No.@@@Widget & Description|||1@@@Radiobutton
Widget that has a set of on/off buttons and labels, one of which may be selected.|||2@@@Checkbutton
Widget that has a set of on/off buttons and labels, many of which may be selected..|||3@@@Menu
Widget that acts as holder for menu items.|||4@@@Listbox
Widget that displays a list of cells, one or more of which may be selected.&&&Sr.No.@@@Widget & Description|||1@@@Dialog
Widget for displaying dialog boxes.|||2@@@Spinbox
Widget that allows users to choose numbers.|||3@@@Combobox
Widget that combines an entry with a list of choices available to the use.|||4@@@Notebook
Tabbed widget that helps to switch between one of several pages, using an index tab.|||5@@@Progressbar
Widget to provide visual feedback to the  progress of a long operation like file upload.|||6@@@Treeview
Widget to display and allow browsing through a hierarchy of items more in form of tree.|||7@@@Scrollbar
Scrolling widgets without a text or canvas widgets.|||8@@@Scale
Scale widget to choose a numeric value through sliders.&&&Sr.No.@@@Widget & Description|||1@@@Canvas
Drawing widget for displaying graphics and images..&&&Sr.No.@@@Widgets & Description|||1@@@Label
Widget for displaying single line of text.|||2@@@Button
Widget that is clickable and triggers an action.|||3@@@Entry
Widget used to accept a single line of text as input.|||4@@@Message
Widget for displaying multiple lines of text.|||5@@@Text
Widget for displaying and optionally edit multiple lines of text.|||6@@@Toplevel
Widget used to create a frame that is a new top level window.&&&Sr.No.@@@Widgets & Description|||1@@@Frame
Container widget to hold other widgets.|||2@@@Place
Widget to hold other widgets in specific place with coordinates of its origin and an exact size.|||3@@@Pack
Simple widget to organize widgets in blocks before placing them in the parent widget.|||4@@@Grid
Widget to nest widgets packing in different directions.&&&Sr.No.@@@Widgets & Description|||1@@@Radiobutton
Widget that has a set of on/off buttons and labels, one of which may be selected.|||2@@@Checkbutton
Widget that has a set of on/off buttons and labels, many of which may be selected.|||3@@@Menu
Widget that acts as holder for menu items.|||4@@@Listbox
Widget that displays a list of cells, one or more of which may be selected.&&&Sr.No.@@@Syntax & Description|||1@@@-background color
Used to set background color for widget.|||2@@@-closeenough distance
Sets the closeness of mouse cursor to a displayable item. The default is 1.0 pixel. This value may be a fraction and must be positive.|||3@@@-scrollregion boundingBox
The bounding box for the total area of this canvas.|||4@@@-height number
Used to set height for widget.|||5@@@-width number
Sets the width for widget.|||6@@@-xscrollincrement size
The amount to scroll horizontally  when scrolling is requested.|||7@@@-yscrollincrement size
The amount to scroll vertically when scrolling is requested.&&&Sr.No.@@@Widget & Description|||1@@@Line
Draws a line.|||2@@@Arc
Draws an arc.|||3@@@Rectangle
Draws a rectangle.|||4@@@Oval
Draws an oval.|||5@@@Polygon
Draws a polygon.|||6@@@Text
Draws a text.|||7@@@Bitmap
Draws a bitmap.|||8@@@Image
Draws an image.&&&Sr.No.@@@Widget & Description|||1@@@Dialog
Widget for displaying dialog boxes.|||2@@@Spinbox
Widget that allows users to choose numbers.|||3@@@Combobox
Widget that combines an entry with a list of choices available to the use.|||4@@@Notebook
Tabbed widget that helps to switch between one of several pages, using an index tab.|||5@@@Progressbar
Widget to provide visual feedback to the  progress of a long operation like file upload.|||6@@@Treeview
Widget to display and allow browsing through a hierarchy of items more in form of tree.|||7@@@Scrollbar
Scrolling widgets without a text or canvas widgets.|||8@@@Scale
Scale widget to choose a numeric value through sliders.&&&Sr.No.@@@Syntax & Description|||1@@@-family familyName
The name of font family.|||2@@@-size number
The size of font.|||3@@@-weight level
The weight for font.&&&Sr.No.@@@Syntax & Description|||1@@@-file fileName
The name of the image file name.|||2@@@-height number
Used to set height for widget.|||3@@@-width number
Sets the width for widget.|||4@@@-data string
Image in base 64 encoded string.&&&Sr.No.@@@Syntax & Description|||1@@@image delete imageName
Deletes the image from memory and related widgets visually.|||2@@@image height imageName
Returns the height for image.|||3@@@image width imageName
Returns the width for image.|||4@@@image type imageName
Returns the type for image.|||5@@@image names
Returns the list of images live in memory.&&&Sr.No.@@@Syntax & Description|||1@@@aspect windowName a b c d
Tries to maintain the ratio of width/height to be between a/b and c/d.|||2@@@geometry windowName geometryParams
Use to set geometry for window.|||3@@@grid windowName w h dx dy
Sets the grid size.|||4@@@group windowName leaderName
leaderName gives the leader of a group of related windows.|||5@@@deiconify windowName
Brings the screen to normal if minimized.|||6@@@iconify windowName
Minimizes the window.|||7@@@state windowName
Returns the current state of window.|||8@@@withdraw windowName
Unmaps the window and removes its details in memory.|||9@@@iconbitmap windowName image
Sets or returns the icon bitmap.|||10@@@iconPhoto windowName image
Sets or returns the icon photo.|||11@@@command windowName commandString
Records the startup command in the WM_COMMAND property.|||12@@@protocol windowName arguments
Register a command to handle the protocol request name, which can be WM_DELETE_WINDOW,
WM_SAVE_YOURSELF,
WM_TAKE_FOCUS. Eg: wm protocol.
WM_DELETE_WINDOW Quit.|||13@@@minsize windowName size
Determines the minimum window size.|||14@@@maxsize windowName size
Determines the maximum window size.|||15@@@title windowName titleText
Determines the title for window.|||16@@@attributes subOptions
There are lots of attributes available like alpha, full screen and so on.&&&Sr.No.@@@Syntax & Description|||1@@@-alpha number
Sets the alpha for window.|||2@@@-fullscreen number
Number can be 0 for normal screen or 1 for full screen.|||3@@@-topmost number
Sets or returns whether window is topmost.Value can be 0 or 1.","#!/usr/bin/tclshputs ""Hello World!"" |||$ tclsh helloWorld.tcl|||#!/usr/bin/tclshputs $tcl_version|||#!/usr/bin/tclshputs $env(PATH)|||#!/usr/bin/tclshputs $tcl_pkgPath|||#!/usr/bin/tclshputs $tcl_library|||#!/usr/bin/tclshputs $tcl_patchLevel|||#!/usr/bin/tclshputs $tcl_precision|||#!/usr/bin/tclshputs $tcl_rcFileName|||#!/usr/bin/tclshputs ""Hello, World!"" |||#!/usr/bin/tclsh# my first program in Tclputs ""Hello World!"" |||#!/usr/bin/tclshif 0 {   my first program in Tcl program   Its very simple}puts ""Hello World!"" |||#!/usr/bin/tclshputs ""Hello World!"" ;# my first print in Tcl program|||#!/usr/bin/tclshputs ""Hello World!"" |||#!/usr/bin/tclshputs [expr 3 + 2] ;# print sum of the 3 and 2|||commandName argument1 argument2 ... argumentN|||#!/usr/bin/tclshputs ""Hello, world!""|||#!/usr/bin/tclshputs stdout ""Hello, world!""|||#!/usr/bin/tclshputs [expr 1 + 6 + 9]|||#!/usr/bin/tclshset a 3puts $a|||#!/usr/bin/tclshputs ""Hello\nWorld""|||#!/usr/bin/tclshset myVariable 18puts $myVariable|||#!/usr/bin/tclshset myVariable 18puts [expr $myVariable + 6 + 9]|||#!/usr/bin/tclshset myVariable helloputs $myVariable|||#!/usr/bin/tclshset myVariable ""hello world""puts $myVariableset myVariable {hello world}puts $myVariable|||#!/usr/bin/tclshset myVariable {red green blue}puts [lindex $myVariable 2]set myVariable ""red green blue""puts [lindex $myVariable 1]|||#!/usr/bin/tclshset  marks(english) 80puts $marks(english)set  marks(mathematics) 90puts $marks(mathematics)|||#!/usr/bin/tclshset variableA 10set {variable B} testputs $variableAputs ${variable B}|||#!/usr/bin/tclshset variableA ""10""puts $variableAset sum [expr $variableA +20];puts $sum|||#!/usr/bin/tclshset variableA ""10""set result [expr $variableA / 9];puts $resultset result [expr $variableA / 9.0];puts $resultset variableA ""10.0""set result [expr $variableA / 9];puts $result|||#!/usr/bin/tclshset variableA ""10""set tcl_precision 5set result [expr $variableA / 9.0];puts $result|||#!/usr/bin/tclshset a 10;set b [expr $a == 1 ? 20: 30]puts ""Value of b is $b\n""set b [expr $a == 10 ? 20: 30]puts ""Value of b is $b\n"" |||#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""puts $languages(0)puts $languages(1)|||#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""puts  [array size languages]|||#!/usr/bin/tclshset languages(0) Tclset languages(1) ""C Language""for { set index 0 }  { $index < [array size languages] }  { incr index } {   puts ""languages($index) : $languages($index)""}|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14puts  $personA(Name)puts  $personA(Age)|||[array names variablename]|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14puts [array names personA]|||#!/usr/bin/tclshset personA(Name) ""Dave""set personA(Age) 14foreach index [array names personA] {   puts ""personA($index): $personA($index)""}|||#!/usr/bin/tclshset myVariable helloputs $myVariable|||#!/usr/bin/tclshset myVariable ""hello world""puts $myVariableset myVariable {hello world}puts $myVariable|||#!/usr/bin/tclshputs ""Hello\tWorld\n\nTutorialspoint"";|||#!/usr/bin/tclshset s1 ""Hello""set s2 ""World""set s3 ""World""puts [string compare $s1 $s2]if {[string compare $s2 $s3] == 0} {   puts ""String \'s1\' and \'s2\' are same."";}if {[string compare $s1 $s2] == -1} {   puts ""String \'s1\' comes before \'s2\'."";}if {[string compare $s2 $s1] == 1} {   puts ""String \'s2\' comes after \'s1\'."";}|||#!/usr/bin/tclshset s1 ""Hello World""set s2 ""o""puts ""First occurrence of $s2 in s1""puts [string first $s2 $s1]puts ""Character at index 0 in s1""puts [string index $s1 0]puts ""Last occurrence of $s2 in s1""puts [string last $s2 $s1]puts ""Word end index in s1""puts [string wordend $s1 20]puts ""Word start index in s1""puts [string wordstart $s1 20]|||#!/usr/bin/tclshset s1 ""Hello World""puts ""Length of string s1""puts [string length $s1]|||#!/usr/bin/tclshset s1 ""Hello World""puts ""Uppercase string of s1""puts [string toupper $s1]puts ""Lowercase string of s1""puts [string tolower $s1]|||#!/usr/bin/tclshset s1 ""Hello World""set s2 ""World""puts ""Trim right $s2 in $s1""puts [string trimright $s1 $s2]set s2 ""Hello""puts ""Trim left $s2 in $s1""puts [string trimleft $s1 $s2]set s1 "" Hello World ""set s2 "" ""puts ""Trim characters s1 on both sides of s2""puts [string trim $s1 $s2]|||#!/usr/bin/tclshset s1 ""test@test.com"" set s2 ""*@*.com""puts ""Matching pattern s2 in s1""puts [string match ""*@*.com"" $s1 ]puts ""Matching pattern tcl in s1""puts [string match {tcl} $s1]|||#!/usr/bin/tclshset s1 ""Hello"" append s1 "" World""puts $s1|||#!/usr/bin/tclshputs [format ""%f"" 43.5]puts [format ""%e"" 43.5]puts [format ""%d %s"" 4 tuts]puts [format ""%s"" ""Tcl Language""]puts [format ""%x"" 40]|||#!/usr/bin/tclshputs [scan ""90"" {%[0-9]} m]puts [scan ""abc"" {%[a-z]} m]puts [scan ""abc"" {%[A-Z]} m]puts [scan ""ABC"" {%[A-Z]} m]|||#!/usr/bin/tclshset colorList1 {red green blue}set colorList2 [list red green blue]set colorList3 [split ""red_green_blue"" _]puts $colorList1puts $colorList2puts $colorList3|||#!/usr/bin/tclshset var orangeappend var "" "" ""blue""lappend var ""red"" lappend var ""green"" puts $var|||#!/usr/bin/tclshset var {orange blue red green}puts [llength $var] |||#!/usr/bin/tclshset var {orange blue red green}puts [lindex $var  1]|||#!/usr/bin/tclshset var {orange blue red green}set var [linsert  $var 3 black white]puts $var|||#!/usr/bin/tclshset var {orange blue red green}set var [lreplace $var 2 3 black white]puts $var|||#!/usr/bin/tclshset var {orange blue red green}lset var 0 black puts $var|||#!/usr/bin/tclshset var {orange blue red green}lassign $var colour1 colour2puts $colour1puts $colour2|||#!/usr/bin/tclshset var {orange blue red green}set var [lsort $var]puts $var|||#!/usr/bin/tclshdict set colours  colour1 red puts $coloursdict set colours  colour2 greenputs $coloursset colours [dict create colour1 ""black"" colour2 ""white""]puts $colours|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]puts [dict size $colours]|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]foreach item [dict keys $colours] {   set value [dict get $colours $item]   puts $value}|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set value [dict get $colours colour1]puts $value|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set keys [dict keys $colours]puts $keys|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set values [dict values $colours]puts $values|||#!/usr/bin/tclshset colours [dict create colour1 ""black"" colour2 ""white""]set result [dict exists $colours colour1]puts $result|||#!/usr/bin/tclshproc helloWorld {} {   puts ""Hello, World!""}helloWorld|||#!/usr/bin/tclshproc add {a b} {   return [expr $a+$b]}puts [add 10 30]|||#!/usr/bin/tclshproc avg {numbers} {   set sum 0   foreach number $numbers {      set sum  [expr $sum + $number]   }   set average [expr $sum/[llength $numbers]]   return $average}puts [avg {70 80 50 60}]puts [avg {70 80 50 }]|||#!/usr/bin/tclshproc add {a {b 100} } {   return [expr $a+$b]}puts [add 10 30]puts [add 10]|||#!/usr/bin/tclshproc factorial {number} {   if {$number <= 1} {      return 1   }    return [expr $number * [factorial [expr $number - 1]]]}puts [factorial 3]puts [factorial 5]|||# /Users/rajkumar/Desktop/helloworld/HelloWorld.tcl # Create the namespacenamespace eval ::HelloWorld {   # Export MyProcedure  namespace export MyProcedure   # My Variables   set version 1.0   set MyDescription ""HelloWorld""   # Variable for the path of the script   variable home [file join [pwd] [file dirname [info script]]] } # Definition of the procedure MyProcedureproc ::HelloWorld::MyProcedure {} {   puts $HelloWorld::MyDescription}package provide HelloWorld $HelloWorld::versionpackage require Tcl 8.0|||#!/usr/bin/tclshnamespace eval MyMath {  # Create a variable inside the namespace  variable myResult}# Create procedures inside the namespaceproc MyMath::Add {a b } {    set ::MyMath::myResult [expr $a + $b]}MyMath::Add 10 23puts $::MyMath::myResult|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult}namespace eval extendedMath {   # Create a variable inside the namespace   namespace eval MyMath {      # Create a variable inside the namespace      variable myResult   }}set ::MyMath::myResult ""test1""puts $::MyMath::myResultset ::extendedMath::MyMath::myResult ""test2""puts $::extendedMath::MyMath::myResult|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult   namespace export Add}# Create procedures inside the namespaceproc MyMath::Add {a b } {     return [expr $a + $b]}namespace import MyMath::*puts [Add 10 30]|||#!/usr/bin/tclshnamespace eval MyMath {   # Create a variable inside the namespace   variable myResult   namespace export Add}# Create procedures inside the namespaceproc MyMath::Add {a b } {     return [expr $a + $b]}namespace import MyMath::*puts [Add 10 30]namespace forget MyMath::*|||#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test""close $fp|||#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test""close $fpset fp [open ""input.txt"" r]set file_data [read $fp]puts $file_dataclose $fp|||#!/usr/bin/tclshset fp [open ""input.txt"" w+]puts $fp ""test\ntest""close $fpset fp [open ""input.txt"" r]while { [gets $fp data] >= 0 } {   puts $data}close $fp|||#!/usr/bin/tclshproc Div {a b} {   if {$b == 0} {      error ""Error generated by error"" ""Info String for error"" 401   } else {      return [expr $a/$b]   }}if {[catch {puts ""Result = [Div 10 0]""} errmsg]} {   puts ""ErrorMsg: $errmsg""   puts ""ErrorCode: $errorCode""   puts ""ErrorInfo:\n$errorInfo\n""}if {[catch {puts ""Result = [Div 10 2]""} errmsg]} {   puts ""ErrorMsg: $errmsg""   puts ""ErrorCode: $errorCode""   puts ""ErrorInfo:\n$errorInfo\n""}|||#!/usr/bin/tclshcatch {set file [open myNonexistingfile.txt]} resultputs ""ErrorMsg: $result""puts ""ErrorCode: $errorCode""puts ""ErrorInfo:\n$errorInfo\n""|||#!/usr/bin/tclshnamespace import ::tcl::mathfunc::*puts [tan 10]puts [pow 10 2]puts [ceil 10.34]puts [hypot 10 20]puts [srand 45]puts [log 10]puts [srand 45]|||#!/usr/bin/tclsh#get secondsset currentTime [clock seconds]puts $currentTime#get format puts ""The time is: [clock format $currentTime -format %H:%M:%S]""puts ""The date is: [clock format $currentTime -format %D]""set date ""Jun 15, 2014""puts [clock scan $date -format {%b %d, %Y}]puts [exec ls]puts [exec dir]set a  [open input.txt]puts [read $a];puts $aclose $a|||#!/usr/bin/tclshregexp {([A-Za-z]*)} ""Tcl Tutorial"" a b puts ""Full Match: $a""puts ""Sub Match1: $b""|||#!/usr/bin/tclshregexp {([A-Za-z]*).([A-Za-z]*)} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp {([A-Za-z]*.([A-Za-z]*))} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp -nocase {([A-Z]*.([A-Z]*))} ""Tcl Tutorial"" a b c  puts ""Full Match: $a""puts ""Sub Match1: $b""puts ""Sub Match2: $c""|||#!/usr/bin/tclshregexp -nocase -line -- {([A-Z]*.([A-Z]*))} ""Tcl \nTutorial"" a b puts ""Full Match: $a""puts ""Sub Match1: $b""regexp -nocase -start 4 -line -- {([A-Z]*.([A-Z]*))} ""Tcl \nTutorial"" a b  puts ""Full Match: $a""puts ""Sub Match1: $b""|||#!/usr/bin/wishgrid [ttk::button .mybutton -text ""Hello World""] |||$ tar zxf tk8.6.1-src.tar.gz$ cd tcl8.6.1$ cd unix$ ./configure —with-tcl=../../tcl8.6.1/unix —prefix=/opt —enable-gcc$ make$ sudo make install|||#!/usr/bin/wishputs $tk_version|||#!/usr/bin/wishputs $tk_library|||#!/usr/bin/wishputs $tk_patchLevel|||#!/usr/bin/wishputs $tk_strictMotif|||type variableName arguments options|||#!/usr/bin/wishgrid [label .myLabel -background red -text ""Hello World"" -relief ridge -borderwidth 3]   -padx 100 -pady 100|||#!/usr/bin/wishgrid [label .myLabel -text ""Label Widget"" -textvariable labelText] grid [text .myText -width 20 -height 5].myText insert 1.0 ""Text\nWidget\n""grid [entry .myEntry -text ""Entry Widget""]grid [message .myMessage -background red -foreground white -text ""Message\nWidget""]grid [button .myButton1  -text ""Button"" -command ""set labelText clicked""]|||#!/usr/bin/wishframe .myFrame1 -background red  -relief ridge -borderwidth 8 -padx 10 -pady 10   -height 100 -width 100frame .myFrame2 -background blue  -relief ridge -borderwidth 8 -padx 10 -pady 10   -height 100 -width 50pack .myFrame1 pack .myFrame2|||#!/usr/bin/wishgrid [frame .gender ]grid [label .label1  -text ""Male"" -textvariable myLabel1 ] grid [radiobutton .gender.maleBtn -text ""Male""   -variable gender -value ""Male""   -command ""set  myLabel1 Male""] -row 1 -column 2grid [radiobutton .gender.femaleBtn -text ""Female"" -variable gender -value ""Female""   -command ""set  myLabel1 Female""] -row 1 -column 3.gender.maleBtn selectgrid [label .myLabel2  -text ""Range 1 not selected"" -textvariable myLabelValue2 ] grid [checkbutton .chk1 -text ""Range 1"" -variable occupied1 -command {if {$occupied1 } {   set myLabelValue2 {Range 1 selected}} else {   set myLabelValue2 {Range 1 not selected}} }]proc setLabel {text} {   .label configure -text $text }|||#!/usr/bin/wishcanvas .myCanvas -background red -width 100 -height 100 pack .myCanvas|||#!/usr/bin/wishcanvas .myCanvas -background red -width 200 -height 200 pack .myCanvas.myCanvas create arc 10 10 50 50 -fill yellow.myCanvas create line 10 30 50 50 100 10 -arrow both -fill yellow -smooth true   -splinesteps 2.myCanvas create oval 50 50 100 80 -fill yellow.myCanvas create polygon 50 150 100 80 120 120 100 190 -fill yellow -outline green.myCanvas create rectangle 150 150 170 170  -fill yellow.myCanvas create text 170 20 -fill yellow -text ""Hello"" -font {Helvetica -18 bold}.myCanvas create bitmap 180 50 -bitmap info|||#!/usr/bin/wishttk::treeview .tree -columns ""Creator Year"" -displaycolumns ""Year Creator"" .tree heading Creator -text ""Creator"" -anchor center.tree heading Year -text ""Year"" -anchor centerpack .tree.tree insert {} end -id Languages -text ""Languages"".tree insert Languages end -text C -values [list ""Dennis Ritchie"" ""1990""]proc scaleMe {mywidget scaleValue} {	$mywidget configure -length $scaleValue} pack [scale .s2  -from 100.0 -to 200.0 -length 100 -background yellow -borderwidth 5   -font{Helvetica -18 bold} -foreground red -width 40 -relief ridge -orien horizontal   -variable a -command ""scaleMe .s2"" ]pack [ttk::progressbar .p1 -orient horizontal -length 200 -mode indeterminate -value 90]pack [ttk::progressbar .p2 -orient horizontal -length 200 -mode determinate -variable a   -maximum 75 -value 20]|||#!/usr/bin/wishfont create myFont -family Helvetica -size 18 -weight bold pack [label .myLabel -font myFont -text ""Hello World""]|||#!/usr/bin/wishputs [font families]|||#!/usr/bin/wishimage create photo imgobj -file ""/Users/rajkumar/Desktop/F Drive/pictur/vb/Forests/   680049.png"" -width 400 -height 400 pack [label .myLabel].myLabel configure -image imgobj |||#!/usr/bin/wishimage create photo imgobj -file ""/Users/rajkumar/images/680049.png""   -width 400 -height 400 pack [label .myLabel].myLabel configure -image imgobjputs [image height imgobj]puts [image width imgobj]puts [image type imgobj]puts [image names]image delete imgobj|||#!/usr/bin/wishproc myEvent { } {   puts ""Event triggered""}pack [button .myButton1  -text ""Button 1""   -command myEvent]|||#!/usr/bin/wishproc delay {} {   for {set j 0} {$j < 100000} {incr j} {} }label .myLabel -text ""Hello................"" -width 25pack .myLabelset str ""Hello................""for {set i [string length $str]} {$i > -2} {set i [expr $i-1]} {   .myLabel configure -text [string range $str 0 $i]   update   delay}|||#!/usr/bin/wishproc addText {} {   label .myLabel -text ""Hello................"" -width 25   pack .myLabel}after 1000 addText|||#!/usr/bin/wishproc addText {} {   label .myLabel -text ""Hello................"" -width 25   pack .myLabel}after 1000 addTextafter cancel addText|||#!/usr/bin/wishbind .  {puts ""Key Pressed: %K ""}|||#!/usr/bin/wishbind .  {puts ""Button %b Pressed : %x %y ""}|||#!/usr/bin/wishproc myEvent { } {   puts ""Event triggered""}pack [button .myButton1  -text ""Button 1""   -command myEvent]bind .  "".myButton1 invoke""|||#!/usr/bin/wishwm maxsize . 800 800wm minsize . 300 300wm title . ""Hello""wm attributes . -alpha "".90"" wm geometry . 300x200+100+100|||#!/usr/bin/wishtoplevel .t|||#!/usr/bin/wishdestroy .t|||#!/usr/bin/wishwm geometry . 300x200+100+100|||#!/usr/bin/wishframe .myFrame1 -background red  -height 100 -width 100frame .myFrame2 -background blue -height 100 -width 50grid .myFrame1 -columnspan 10 -rowspan 10 -sticky wgrid .myFrame2 -column 10 -row 2"
Learn Tcl/Tk,Tcl-Tk - Useful Resources,Tcl-Tk - Useful Resources|||Useful Links on Tcl-Tk@@@Useful Books on Tcl-Tk,"The following resources contain additional information on Tcl-Tk. Please use them to get more in-depth knowledge on this topic.|||Official Site - Official Site for Tcl-Tk|||Details about Tcl-Tk − Wikipedia Reference for Tcl-Tk|||More Details - Know more details about Tcl-Tk|||To enlist your site on this page, please drop an email to contact@tutorialspoint.com",Official Site - Official Site for Tcl-Tk@@@Details about Tcl-Tk − Wikipedia Reference for Tcl-Tk@@@More Details - Know more details about Tcl-Tk,,,
Learn Tcl/Tk,Discuss Tcl-Tk,Discuss Tcl-Tk,"Tcl is a general purpose multi-paradigm system programming language. It is a scripting language that aims at providing the ability for applications to communicate with each other. On the other hand, Tk is a cross platform widget toolkit used for building GUI in many languages. This tutorial covers various topics ranging from the basics of the Tcl/Tk to its scope in various applications.",,,,
