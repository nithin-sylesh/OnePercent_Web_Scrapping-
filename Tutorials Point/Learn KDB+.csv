Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn KDB+,KDB+ Tutorial,KDB+ Tutorial@@@Audience@@@Prerequisites,"Kdb+ is a high-performance column-oriented database from Kx Systems Inc. kdb+ is designed to capture, analyze, compare, and store data − all at high speeds and on high volumes of data. The tutorial starts off with a basic introduction of Kdb+ followed by its architecture, installation, and a basic-to-advanced coverage of q programming language.|||Kx® and kdb+ are registered trademarks of Kx Systems, Inc|||This reference has been prepared for beginners to help them understand the KDB+ database and write smart queries in q languages for KDB+.|||As we are going to start from scratch, you can set off without any preparation. However, it would definitely help if you have a working knowledge of any database or a programming language.",,,,
Learn KDB+,KDB+ Overview,KDB+ Overview|||Background@@@Why and Where to Use KDB+@@@Getting Started|||Downloading & Installing KDB+@@@Directory Layout,"This is a complete quide to kdb+ from kx systems, aimed primarily at those learning independently. kdb+, introduced in 2003, is the new generation of the kdb database which is designed to capture, analyze, compare, and store data.|||A kdb+ system contains the following two components −|||KDB+ − the database (k database plus)|||Q − the programming language for working with kdb+|||Both kdb+ and q are written in k programming language (same as q but less readable).|||Kdb+/q originated as an obscure academic language but over the years, it has gradually improved its user friendliness.|||APL (1964, A Programming Language)|||A+ (1988, modified APL by Arthur Whitney)|||K (1993, crisp version of A+, developed by A. Whitney)|||Kdb (1998, in-memory column-based db)|||Kdb+/q (2003, q language – more readable version of k)|||Why? − If you need a single solution for real-time data with analytics, then you should consider kdb+. Kdb+ stores database as ordinary native files, so it does not have any special needs regarding hardware and storage architecture. It is worth pointing out that the database is just a set of files, so your administrative work won’t be difficult.|||Where to use KDB+? − It’s easy to count which investment banks are NOT using kdb+ as most of them are using currently or planning to switch from conventional databases to kdb+. As the volume of data is increasing day by day, we need a system that can handle huge volumes of data. KDB+ fulfills this requirement. KDB+ not only stores an enormous amount of data but also analyzes it in real time.|||With this much of background, let us now set forth and learn how to set up an environment for KDB+. We will start with how to download and install KDB+.|||You can get the free 32-bit version of KDB+, with all the functionality of the 64- bit version from http://kx.com/software-download.php|||Agree to the license agreement, select the operating system (available for all major operating system). For Windows operating system, the latest version is 3.2. Download the latest version. Once you unzip it, you will get the folder name “windows” and inside the windows folder, you will get another folder “q”. Copy the entire q folder onto your c:/ drive.|||Open the Run terminal, type the location where you store the q folder; it will be like “c:/q/w32/q.exe”. Once you hit Enter, you will get a new console as follows −|||On the first line, you can see the version number which is 3.2 and the release date as 2015.03.05|||The trial/free version is generally installed in directories,|||For linux/Mac −|||For Windows −|||Example Files −|||Once you download kdb+, the directory structure in the Windows platform would appear as follows −|||In the above directory structure, trade.q and sp.q are the example files which we can use as a reference point.","KDB+ − the database (k database plus)@@@Q − the programming language for working with kdb+|||APL (1964, A Programming Language)@@@A+ (1988, modified APL by Arthur Whitney)@@@K (1993, crisp version of A+, developed by A. Whitney)@@@Kdb (1998, in-memory column-based db)@@@Kdb+/q (2003, q language – more readable version of k)",,,
Learn KDB+,KDB+ Architecture,KDB+ Architecture|||Kdb+/ tick Architecture@@@Components of Kdb+ Tick Architecture|||Data Feeds@@@Feed Handler@@@Ticker Plant@@@Real-Time Database@@@Historical Database,"Kdb+ is a high-performance, high-volume database designed from the outset to handle tremendous volumes of data. It is fully 64-bit, and has built-in multi-core processing and multi-threading. The same architecture is used for real-time and historical data. The database incorporates its own powerful query language, q, so analytics can be run directly on the data.|||kdb+tick is an architecture which allows the capture, processing, and querying of real-time and historical data.|||The following illustration provides a generalized outline of a typical Kdb+/tick architecture, followed by a brief explanation of the various components and the through-flow of data.|||The Data Feeds are a time series data that are mostly provided by the data feed providers like Reuters, Bloomberg or directly from exchanges.|||To get the relevant data, the data from the data feed is parsed by the feed handler.|||Once the data is parsed by the feed handler, it goes to the ticker-plant.|||To recover data from any failure, the ticker-plant first updates/stores the new data to the log file and then updates its own tables.|||After updating the internal tables and the log files, the on-time loop data is continuously sent/published to the real-time database and all the chained subscribers who requested for data.|||At the end of a business day, the log file is deleted, a new one created and the real-time database is saved onto the historical database. Once all the data is saved onto the historical database, the real-time database purges its tables.|||Data Feeds can be any market or other time series data. Consider data feeds as the raw input to the feed-handler. Feeds can be directly from the exchange (live-streaming data), from the news/data providers like Thomson-Reuters, Bloomberg, or any other external agencies.|||A feed handler converts the data stream into a format suitable for writing to kdb+. It is connected to the data feed and it retrieves and converts the data from the feed-specific format into a Kdb+ message which is published to the ticker-plant process. Generally a feed handler is used to perform the following operations −|||Ticker Plant is the most important component of KDB+ architecture. It is the ticker plant with which the real-time database or directly subscribers (clients) are connected to access the financial data. It operates in publish and subscribe mechanism. Once you obtain a subscription (license), a tick (routinely) publication from the publisher (ticker plant) is defined. It performs the following operations −|||Receives the data from the feed handler.|||Immediately after the ticker plant receives the data, it stores a copy as a log file and updates it once the ticker plant gets any update so that in case of any failure, we should not have any data loss.|||The clients (real-time subscriber) can directly subscribe to the ticker-plant.|||At the end of each business day, i.e., once the real-time database receives the last message, it stores all of today’s data onto the historical database and pushes the same to all the subscribers who have subscribed for today’s data. Then it resets all its tables. The log file is also deleted once the data is stored in the historical database or other directly linked subscriber to real time database (rtdb).|||As a result, the ticker-plant, the real-time database, and the historical database are operational on a 24/7 basis.|||Since the ticker-plant is a Kdb+ application, its tables can be queried using q like any other Kdb+ database. All ticker-plant clients should only have access to the database as subscribers.|||A real-time database (rdb) stores today’s data. It is directly connected to the ticker plant. Typically it would be stored in memory during market hours (a day) and written out to the historical database (hdb) at the end of day. As the data (rdb data) is stored in memory, processing is extremely fast.|||As kdb+ recommends to have a RAM size that is four or more times the expected size of data per day, the query that runs on rdb is very fast and provides superior performance. Since a real-time database contains only today’s data, the date column (parameter) is not required.|||For example, we can have rdb queries like,|||If we have to calculate the estimates of a company, we need to have its historical data available. A historical database (hdb) holds data of transactions done in the past. Each new day’s record would be added to the hdb at the end of day. Large tables in the hdb are either stored splayed (each column is stored in its own file) or they are stored partitioned by temporal data. Also some very large databases may be further partitioned using par.txt (file).|||These storage strategies (splayed, partitioned, etc.) are efficient while searching or accessing the data from a large table.|||A historical database can also be used for internal and external reporting purposes, i.e., for analytics. For example, suppose we want to get the company trades of IBM for a particular day from the trade (or any) table name, we need to write a query as follows −|||Note − We will write all such queries once we get some overview of the q language.","The Data Feeds are a time series data that are mostly provided by the data feed providers like Reuters, Bloomberg or directly from exchanges.@@@To get the relevant data, the data from the data feed is parsed by the feed handler.@@@Once the data is parsed by the feed handler, it goes to the ticker-plant.@@@To recover data from any failure, the ticker-plant first updates/stores the new data to the log file and then updates its own tables.@@@After updating the internal tables and the log files, the on-time loop data is continuously sent/published to the real-time database and all the chained subscribers who requested for data.@@@At the end of a business day, the log file is deleted, a new one created and the real-time database is saved onto the historical database. Once all the data is saved onto the historical database, the real-time database purges its tables.|||Capture data according to a set of rules.@@@Translate (/enrich) that data from one format to another.@@@Catch the most recent values.|||Receives the data from the feed handler.@@@Immediately after the ticker plant receives the data, it stores a copy as a log file and updates it once the ticker plant gets any update so that in case of any failure, we should not have any data loss.@@@The clients (real-time subscriber) can directly subscribe to the ticker-plant.@@@At the end of each business day, i.e., once the real-time database receives the last message, it stores all of today’s data onto the historical database and pushes the same to all the subscribers who have subscribed for today’s data. Then it resets all its tables. The log file is also deleted once the data is stored in the historical database or other directly linked subscriber to real time database (rtdb).@@@As a result, the ticker-plant, the real-time database, and the historical database are operational on a 24/7 basis.",,,
Learn KDB+,Q Programming Language,Q Programming Language|||Starting the “q” Environment@@@Data Types@@@Atom and List Formation|||Example 1 – Atom and List Formation,"Kdb+ comes with its built-in programming language that is known as q. It incorporates a superset of standard SQL which is extended for time-series analysis and offers many advantages over the standard version. Anyone familiar with SQL can learn q in a matter of days and be able to quickly write her own ad-hoc queries.|||To start using kdb+, you need to start the q session. There are three ways to start a q session −|||Simply type “c:/q/w32/q.exe” on your run terminal.|||Start the MS-DOS command terminal and type q.|||Copy the q.exe file onto “C:\Windows\System32” and on the run terminal, just type “q”.|||Here we are assuming that you are working on a Windows platform.|||The following table provides a list of supported data types −|||Atoms are single entities, e.g., a single number, a character or a symbol. In the above table (of different data types), all supported data types are atoms. A list is a sequence of atoms or other types including lists.|||Passing an atom of any type to the monadic (i.e. single argument function) type function will return a negative value, i.e., –n, whereas passing a simple list of those atoms to the type function will return a positive value n.","Simply type “c:/q/w32/q.exe” on your run terminal.@@@Start the MS-DOS command terminal and type q.@@@Copy the q.exe file onto “C:\Windows\System32” and on the run terminal, just type “q”.",,"Name@@@Example@@@Char@@@Type@@@Size|||boolean@@@1b@@@b@@@1@@@1|||byte@@@0xff@@@x@@@4@@@1|||short@@@23h@@@h@@@5@@@2|||int@@@23i@@@i@@@6@@@4|||long@@@23j@@@j@@@7@@@8|||real@@@2.3e@@@e@@@8@@@4|||float@@@2.3f@@@f@@@9@@@8|||char@@@“a”@@@c@@@10@@@1|||varchar@@@`ab@@@s@@@11@@@*|||month@@@2003.03m@@@m@@@13@@@4|||date@@@2015.03.17T18:01:40.134@@@z@@@15@@@8|||minute@@@08:31@@@u@@@17@@@4|||second@@@08:31:53@@@v@@@18@@@4|||time@@@18:03:18.521@@@t@@@19@@@4|||enum@@@`u$`b, where u:`a`b@@@*@@@20@@@4",
Learn KDB+,Q Language - Type Casting,Q Language - Type Casting|||Casting Integers to Floats@@@Casting Strings to Symbols@@@Casting Strings to Non-Symbols,"It is often required to change the data type of some data from one type to another. The standard casting function is the “$” dyadic operator.|||Three approaches are used to cast from one type to another (except for string) −|||In the following example of casting integers to floats, all the three different ways of casting are equivalent −|||Check if all the three operations are equivalent,|||Casting string to symbols and vice versa works a bit differently. Let’s check it with an example −|||Attempting to cast strings to symbols using the keyed words `symbol or 11h will fail with the type error −|||Casting strings to a data type other than symbol is accomplished as follows −|||So to cast an entire string (the list of characters) to a single atom of data type x requires us to specify the upper case letter representing data type x as the first argument to the $ operator. If you specify the data type of x in any other way, it result in the cast being applied to each character of the string.",Specify desired data type by its symbol name@@@Specify desired data type by its character@@@Specify desired data type by it short value.,,,
Learn KDB+,Q Language - Temporal Data,Q Language - Temporal Data|||Date@@@Times@@@Datetimes,"The q language has many different ways of representing and manipulating temporal data such as times and dates.|||A date in kdb+ is internally stored as the integer number of days since our reference date is 01Jan2000. A date after this date is internally stored as a positive number and a date before that is referenced as a negative number.|||By default, a date is written in the format “YYYY.MM.DD”|||Arithmetic and logical operations can be performed directly on dates.|||The 1st of January 2000 fell on a Saturday. Therefore any Saturday throughout the history or in the future when divided by 7, would yield a remainder of 0, Sunday gives 1, Monday yield 2.|||A time is internally stored as the integer number of milliseconds since the stroke of midnight. A time is written in the format HH:MM:SS.MSS|||As in case of dates, arithmetic can be performed directly on times.|||A datetime is the combination of a date and a time, separated by ‘T’ as in the ISO standard format. A datetime value stores the fractional day count from midnight Jan 1, 2000.|||The underlying fractional day count can be obtained by casting to float.",,,,
Learn KDB+,Q Language - Lists,Q Language - Lists|||Types of List|||Count@@@Examples of simple List,"Lists are the basic building blocks of q language, so a thorough understanding of lists is very important. A list is simply an ordered collection of atoms (atomic elements) and other lists (group of one or more atoms).|||A general list encloses its items within matching parentheses and separates them with semicolons. For example −|||If a list comprises of atoms of same type, it is known as a uniform list. Else, it is known as a general list (mixed type).|||We can obtain the number of items in a list through its count.|||**Note − A simple list of char is called a string.|||A list contains atoms or lists. To create a single item list, we use −|||To distinguish between an atom and the equivalent singleton, examine the sign of their type.",,,,
Learn KDB+,Q Language - Indexing,Q Language - Indexing|||Index Notation@@@Indexed Assignment@@@Joining Lists@@@Nesting@@@Elided Indices|||Lists from Variables@@@Depth@@@Indexing at Depth,"A list is ordered from left to right by the position of its items. The offset of an item from the beginning of the list is called its index. Thus, the first item has an index 0, the second item (if there is one) has an index 1, etc. A list of count n has index domain from 0 to n–1.|||Given a list L, the item at index i is accessed by L[i]. Retrieving an item by its index is called item indexing. For example,|||Items in a list can also be assigned via item indexing. Thus,|||The most common operation on two lists is to join them together to form a larger list. More precisely, the join operator (,) appends its right operand to the end of the left operand and returns the result. It accepts an atom in either argument.|||Data complexity is built by using lists as items of lists.|||The number of levels of nesting for a list is called its depth. Atoms have a depth of 0 and simple lists have a depth of 1.|||Here is a list of depth 3 having two items −|||It is possible to index directly into the items of a nested list.|||Repeated Item Indexing|||Retrieving an item via a single index always retrieves an uppermost item from a nested list.|||Since the result L[1] is itself a list, we can retrieve its elements using a single index.|||We can repeat single indexing once more to retrieve an item from the innermost nested list.|||You can read this as,|||Get the item at index 1 from L, and from it retrieve the item at index 2, and from it retrieve the item at index 0.|||Notation for Indexing at Depth|||There is an alternate notation for repeated indexing into the constituents of a nested list. The last retrieval can also be written as,|||Assignment via index also works at depth.|||Eliding Indices for a General List|||Interpret L[;1;] as,|||Retrieve all items in the second position of each list at the top level.|||Interpret L[;;2] as,|||Retrieve the items in the third position for each list at the second level.",,,,
Learn KDB+,Q Language - Dictionaries,Q Language - Dictionaries|||Lookup@@@Operations on Dictionaries@@@Column Dictionaries@@@Flipping a Dictionary|||Lookup with Verb @@@@Amend and Upsert@@@Reverse Lookup with Find (?)@@@Removing Entries@@@Flip on a Column Dictionary@@@Flip of a Flipped Column Dictionary,"Dictionaries are an extension of lists which provide the foundation for creating tables. In mathematical terms, dictionary creates the|||“domain →  Range” |||or in general (short) creates|||“key → value”|||relationship between elements.|||A dictionary is an ordered collection of key-value pairs that is roughly equivalent to a hash table. A dictionary is a mapping defined by an explicit I/O association between a domain list and a range list via positional correspondence. The creation of a dictionary uses the ""xkey"" primitive (!)|||The most basic dictionary maps a simple list to a simple list.|||Finding the dictionary output value corresponding to an input value is called looking up the input.|||As with lists, the items of a dictionary can be modified via indexed assignment.|||Dictionaries can be extended via index assignment. |||The find (?) operator is used to perform reverse lookup by mapping a range of elements to its domain element.|||In case the elements of a list is not unique, the find returns the first item mapping to it from the domain list.|||To remove an entry from a dictionary, the delete ( _ ) function is used. The left operand of ( _ ) is the dictionary and the right operand is a key value.|||Whitespace is required to the left of _ if the first operand is a variable.|||Column dictionaries are the basics for creation of tables. Consider the following example −|||The net effect of flipping a column dictionary is simply reversing the order of the indices. This is logically equivalent to transposing the rows and columns.|||The transpose of a dictionary is obtained by applying the unary flip operator. Take a look at the following example −|||If you transpose a dictionary twice, you obtain the original dictionary,",,,Input (I)@@@Output (O)|||`Name@@@`John|||`Age@@@36|||`Sex@@@“M”|||Weight@@@60.3,
Learn KDB+,Q Language - Table,Q Language - Table|||Creating Tables@@@Getting Table Information@@@Primary Keys and Keyed Tables@@@Manipulating Tables|||Keyed Table@@@ForeignKeys@@@Select@@@Insert@@@Delete@@@Update,"Tables are at the heart of kdb+. A table is a collection of named columns implemented as a dictionary. q tables are column-oriented.|||Tables are created using the following syntax −|||In the above example, we have not specified the type of each column. This will be set by the first insert into the table.|||Another way, we can specify column type on initialization −|||Or we can also define non-empty tables −|||If there are no columns within the square brackets as in the examples above, the table is unkeyed.|||To create a keyed table, we insert the column(s) for the key in the square brackets.|||One can also define the column types by setting the values to be null lists of various types −|||Let’s create a trade table −|||A keyed table is a dictionary that maps each row in a table of unique keys to a corresponding row in a table of values. Let us take an example −|||Now create a simple keyed table containing eid as key,|||A foreign key defines a mapping from the rows of the table in which it is defined to the rows of the table with the corresponding primary key.|||Foreign keys provide referential integrity. In other words, an attempt to insert a foreign key value that is not in the primary key will fail.|||Consider the following examples. In the first example, we will define a foreign key explicitly on initialization. In the second example, we will use foreign key chasing which does not assume any prior relationship between the two tables.|||Example 1 − Define foreign key on initialization|||Example 2 − no pre-defined relationship between tables|||To use foreign key chasing, we must create a table to key into sector.|||General notation for a predefined foreign key −|||select a.b from c where a is the foreign key (sym), b is a|||field in the primary key table (ind), c is the|||foreign key table (trade)|||Let’s create one trade table and check the result of different table expression −|||Let us now take a look at the statements that are used to manipulate tables using q language.|||The syntax to use a Select statement is as follows −|||Let us now take an example to demonstrate how to use Select statement −|||The syntax to use an Insert statement is as follows −|||Let us now take an example to demonstrate how to use Insert statement −|||The syntax to use a Delete statement is as follows −|||Let us now take an example to demonstrate how to use Delete statement −|||The syntax to use an Update statement is as follows −|||Use the following syntax to update the format/datatype of a column using the cast function −|||Let us now take an example to demonstrate how to use Update statement −",,,,
Learn KDB+,Q Language - Verb & Adverbs,Q Language - Verb & Adverbs|||Each@@@Each-Left and Each-Right,"Kdb+ has nouns, verbs, and adverbs. All data objects and functions are nouns. Verbs enhance the readability by reducing the number of square brackets and parentheses in expressions. Adverbs modify dyadic (2 arguments) functions and verbs to produce new, related verbs. The functions produced by adverbs are called derived functions or derived verbs.|||The adverb each, denoted by ( ` ), modifies dyadic functions and verbs to apply to the items of lists instead of the lists themselves. Take a look at the following example −|||There is a form of Each for monadic functions that uses the keyword “each”. For example,|||There are two variants of Each for dyadic functions called Each-Left (\:) and Each-Right (/:). The following example explains how to use them.",,,,
Learn KDB+,Q Language - Joins,Q Language - Joins|||Simple Join@@@Asof Join (aj)@@@Left Join(lj)@@@Union Join (uj)|||General format@@@Example@@@General format@@@Example,"In q language, we have different kinds of joins based on the input tables supplied and the kind of joined tables we desire. A join combines data from two tables. Besides foreign key chasing, there are four other ways to join tables −|||Here, in this chapter, we will discuss each of these joins in detail.|||Simple join is the most basic type of join, performed with a comma ‘,’. In this case, the two tables have to be type conformant, i.e., both the tables have the same number of columns in the same order, and same key.|||We can use comma-each join for tables with same length to join sideways. One of the tables can be keyed here,|||It is the most powerful join which is used to get the value of a field in one table asof the time in another table. Generally it is used to get the prevailing bid and ask at the time of each trade.|||For example,|||It’s a special case of aj where the second argument is a keyed table and the first argument contains the columns of the right argument’s key.|||It allows to create a union of two tables with distinct schemas. It is basically an extension to the simple join ( , )|||If you are using uj on keyed tables, then the primary keys must match.",Simple join@@@Asof join@@@Left join@@@Union join,,,
Learn KDB+,Q Language - Functions,"Q Language - Functions|||Types of Functions@@@Frequently Used Functions@@@System Commands|||abs@@@all@@@Max (&), Min (|), and Not (!)@@@asc@@@avg@@@by@@@cols@@@count@@@port@@@cut@@@Delete@@@Distinct@@@enlist@@@Fill (^)@@@Fills@@@First@@@Flip@@@iasc@@@Idesc@@@in@@@insert@@@key@@@lower@@@Max and Min (i.e. | and &)@@@null@@@Peach@@@Prev@@@Random( ?)@@@Raze@@@read0@@@read1@@@reverse@@@set@@@ssr@@@string@@@SV@@@system@@@tables@@@Til@@@trim@@@vs@@@xasc@@@xcol@@@xcols@@@xdesc@@@xgroup@@@xkey@@@\a [ namespace] – List tables in the given namespace@@@\b – View dependencies@@@\B – Pending views / dependencies@@@\cd – Change directory@@@\d – sets current namespace@@@\l – load file or directory from db@@@\p – port number@@@\\ - Exit from q console","Functions can be classified in a number of ways. Here we have classified them based on the number and type of argument they take and the result type. Functions can be,|||Atomic − Where the arguments are atomic and produce atomic results|||Aggregate − atom from list|||Uniform (list from list) − Extended the concept of atom as they apply to lists. The count of the argument list equals the count of the result list.|||Other − if the function is not from the above category.|||Binary operations in mathematics are called dyadic functions in q; for example, “+”. Similarly unary operations are called monadic functions; for example, “abs” or “floor”.|||There are quite a few functions used frequently in q programming. Here, in this section, we will see the usage of some popular functions −|||System commands control the q environment. They are of the following form −|||Some of the popular system commands have been discussed below −",Atomic − Where the arguments are atomic and produce atomic results@@@Aggregate − atom from list@@@Uniform (list from list) − Extended the concept of atom as they apply to lists. The count of the argument list equals the count of the result list.@@@Other − if the function is not from the above category.,,,
Learn KDB+,Q Language - Built-in Functions,Q Language - Built-in Functions|||String Functions@@@Mathematical Functions@@@Aggregate Functions@@@Uniform Functions@@@Miscellaneous Functions|||Like − pattern matching@@@ltrim − removes leading blanks@@@rtrim − removes trailing blanks@@@ss − string search@@@trim − removes leading and trailing blanks@@@acos − inverse of cos@@@cor − gives correlation@@@cross − Cartesian product@@@var − variance@@@wavg@@@all − & operation@@@Any − | operation@@@prd − arithmetic product@@@Sum − arithmetic sum@@@Deltas − difference from its previous item.@@@fills − fills nulls value@@@maxs − cumulative maximum@@@Count − return number of element@@@Distinct − return distinct entities@@@Except − element not present in second arg.@@@fill − fill null with first argument,The q programming language has a set of rich and powerful built-in functions. A built-in function can be of the following types −|||String function − Takes a string as input and returns a string.|||Aggregate function − Takes a list as input and returns an atom.|||Uniform function − Takes a list and returns a list of the same count.|||Mathematical function − Takes numeric argument and returns a numeric argument.|||Miscellaneous function − All functions other than above mentioned.,String function − Takes a string as input and returns a string.@@@Aggregate function − Takes a list as input and returns an atom.@@@Uniform function − Takes a list and returns a list of the same count.@@@Mathematical function − Takes numeric argument and returns a numeric argument.@@@Miscellaneous function − All functions other than above mentioned.,,,
Learn KDB+,Q Language - Queries,Q Language - Queries|||Basics Queries@@@Queries with Constraints@@@Queries with Aggregations,"Queries in q are shorter and simpler and extend the capabilities of sql. The main query expression is the ‘select expression’, which in its simplest form extracts sub-tables but it can also create new columns.|||The general form of a Select expression is as follows −|||**Note − by & where phrases are optional, only the ‘from expression’ is mandatory.|||In general, the syntax will be −|||The syntax of q expressions look quite similar to SQL, but q expressions are simple and powerful. An equivalent sql expression for the above q expression would be as follows −|||All the clauses execute on the columns and therefore q can take advantage of order. As Sql queries are not based on order, they cannot take that advantage.|||q relational queries are generally much smaller in size as compared to their corresponding sql. Ordered and functional queries do things that are difficult in sql.|||In a historical database, the ordering of the where clause is very important because it affects the performance of the query. The partition variable (date/month/day) always comes first followed by the sorted and indexed column (generally the sym column).|||For example,|||is much faster than,|||Let’s write a query script in notepad (as below), save (as *.q), and then load it.|||* Denotes HDB query|||Select all IBM trades|||*Select all IBM trades on a certain day|||Select all IBM trades with a price > 100|||Select all IBM trades with a price less than or equal to 100|||*Select all IBM trades between 10.30 and 10.40, in the morning, on a certain date|||Select all IBM trades in ascending order of price|||*Select all IBM trades in descending order of price in a certain time frame|||Composite sort − sort ascending order by sym and then sort the result in descending order of price|||Select all IBM or MSFT trades|||*Calculate count of all symbols in ascending order within a certain time frame|||*Calculate count of all symbols in descending order within a certain time frame|||* What is the maximum price of IBM stock within a certain time frame, and when does this first happen?|||Select the last price for each sym in hourly buckets|||* Calculate vwap (Volume Weighted Average Price) of all symbols|||* Count the number of records (in millions) for a certain month|||* HLOC – Daily High, Low, Open and Close for CSCO in a certain month|||* Daily Vwap for CSCO in a certain month|||* Calculate the hourly mean, variance and standard deviation of the price for AIG|||Select the price range in hourly buckets|||* Daily Spread (average bid-ask) for CSCO in a certain month|||* Daily Traded Values for all syms in a certain month|||Extract a 5 minute vwap for CSCO|||* Extract 10 minute bars for CSCO|||* Find the times when the price exceeds 100 basis points (100e-4) over the last price for CSCO for a certain day|||* Full Day Price and Volume for MSFT in 1 Minute Intervals for the last date in the database",,,,
Learn KDB+,Q Language - Inter-Process Communication,Q Language - Inter-Process Communication|||Initialize Server@@@Communication Handle@@@Synchronous and Asynchronous Messages|||Example,"KDB+ allows one process to communicate with another process through interprocess communication. Kdb+ processes can connect to any other kdb+ on the same computer, the same network, or even remotely. We just need to specify the port and then the clients can talk to that port. Any q process can communicate with any other q process as long as it is accessible on the network and is listening for connections.|||a server process listens for connections and processes any requests|||a client process initiates the connection and sends commands to be executed|||Client and server can be on the same machine or on different machines. A process can be both a client and a server.|||A communication can be,|||Synchronous (wait for a result to be returned)|||Asynchronous (no wait and no result returned)|||A q server is initialized by specifying the port to listen on,|||A communication handle is a symbol that starts with “:” and has the form −|||To start the connection, we use the function “hopen” which returns an integer connection handle. This handle is used for all subsequent client requests. For example −|||Once we have a handle, we can send a message either synchronously or asynchronously.|||Synchronous Message − Once a message is sent, it waits on and returns the result. Its format is as follows −|||Asynchronous Message − After sending a message, start processing the next statement immediately without having to wait and return a result. Its format is as follows −|||Messages that require a response, for example function calls or select statements, will normally use the synchronous form; while messages that need not return an output, for example inserting updates to a table, will be asynchronous.",a server process listens for connections and processes any requests@@@a client process initiates the connection and sends commands to be executed|||Synchronous (wait for a result to be returned)@@@Asynchronous (no wait and no result returned),,,
Learn KDB+,Q Language - Message Handler,Q Language - Message Handler|||Predefined Message Handlers|||.z.pg @@@.z.ps@@@.z.po[]@@@.z.pc[]@@@.z.pi[]@@@.z.pw,"When a q process connects to another q process via inter-process communication, it is processed by message handlers. These message handlers have a default behavior. For example, in case of synchronous message handling, the handler returns the value of the query. The synchronous handler in this case is .z.pg, which we could override as per requirement.|||Kdb+ processes have several pre-defined message handlers. Message handlers are important for configuring the database. Some of the usages include −|||Logging − Log incoming messages (helpful in case of any fatal error),|||Security − Allow/disallow access to the database, certain function calls, etc., based on username / ip address. It helps in providing access to authorized subscribers only.|||Handle connections/disconnections from other processes.|||Some of the predefined message handlers are discussed below.|||It is a synchronous message handler (process get). This function gets called automatically whenever a sync message is received on a kdb+ instance.|||Parameter is the string/function call to be executed, i.e., the message passed. By default, it is defined as follows −|||It is an asynchronous message handler (process set). It is the equivalent handler for asynchronous messages. Parameter is the string/function call to be executed. By default, it is defined as,|||Following is the customized message handler for asynchronous messages, where we have used the protected execution,|||Here errhandler is a function used in case of any unexpected error.|||It is a connection open handler (process-open). It is executed when a remote process opens a connection. To see the handle when a connection to a process is opened, we can define the .z.po as,|||It is a close connection handler (process-close). It is called when a connection is closed. We can create our own close handler which can reset the global connection handle to 0 and issue a command to set the timer to fire (execute) every 3 seconds (3000 milliseconds).|||The timer handler (.z.ts) attempts to re-open the connection. On success, it turns the timer off.|||PI stands for process input. It is called for any sort of input. It can be used to handle console input or remote client input. Using .z.pi[], one can validate the console input or replace the default display. In addition, it can be used for any sort of logging operations.|||It is a validation connection handler (user authentication). It adds an extra callback when a connection is being opened to a kdb+ session. It is called after the –u/-U checks and before the .z.po (port open).|||Inputs are userid (symbol) and password (text).","Logging − Log incoming messages (helpful in case of any fatal error),@@@Security − Allow/disallow access to the database, certain function calls, etc., based on username / ip address. It helps in providing access to authorized subscribers only.@@@Handle connections/disconnections from other processes.",,,
Learn KDB+,Q Language - Attributes,Q Language - Attributes|||Types of Attributes|||Sorted (`s#)@@@Parted (`p#)@@@Grouped (`g#)@@@Unique (`#u)@@@Removing Attributes@@@Applying Attributes,"Lists, dictionaries, or columns of a table can have attributes applied to them. Attributes impose certain properties on the list. Some attributes might disappear on modification.|||`s# means the list is sorted in an ascending order. If a list is explicitly sorted by asc (or xasc), the list will automatically have the sorted attribute set.|||A list which is known to be sorted can also have the attribute explicitly set. Q will check if the list is sorted, and if is not, an s-fail error will be thrown.|||The sorted attribute will be lost upon an unsorted append.|||`p# means the list is parted and identical items are stored contiguously.|||The range is an int or temporal type having an underlying int value, such as years, months, days, etc. You can also partition over a symbol provided it is enumerated.|||Applying the parted attribute creates an index dictionary that maps each unique output value to the position of its first occurrence. When a list is parted, lookup is much faster, since linear search is replaced by hashtable lookup.|||Note −|||The parted attribute is not preserved under an operation on the list, even if
the operation preserves the partitioning.|||The parted attribute should be considered when the number of entities reaches a billion and most of the partitions are of substantial size, i.e., there is significant repetition.|||`g# means the list is grouped. An internal dictionary is built and maintained which maps each unique item to each of its indices, requiring considerable storage space. For a list of length L containing u unique items of size s, this will be (L × 4) + (u × s) bytes.|||Grouping can be applied to a list when no other assumptions about its structure can be made.|||The attribute can be applied to any typed lists. It is maintained on appends, but lost on deletes.|||Applying the unique attribute (`u#) to a list indicates that the items of the list are distinct. Knowing that the elements of a list are unique dramatically speeds up distinct and allows q to execute some comparisons early.|||When a list is flagged as unique, an internal hash map is created to each item in the list. Operations on the list must preserve uniqueness or the attribute is lost.|||Note −|||`u# is preserved on concatenations which preserve the uniqueness. It is lost on deletions and non-unique concatenations.|||Searches on `u# lists are done via a hash function.|||Attributes can be removed by applying `#.|||Three formats for applying attributes are −|||L: `s# 14 2 3 3 9/ Specify during list creation|||@[ `.; `L ; `s#]/ Functional apply, i.e. to the variable list L|||/ in the default namespace (i.e. `.) apply|||/ the sorted `s# attribute|||Update `s#time from `tab|||/ Update the table (tab) to apply the|||/ attribute.|||Let’s apply the above three different formats with examples.","The parted attribute is not preserved under an operation on the list, even if
the operation preserves the partitioning.@@@The parted attribute should be considered when the number of entities reaches a billion and most of the partitions are of substantial size, i.e., there is significant repetition.|||`u# is preserved on concatenations which preserve the uniqueness. It is lost on deletions and non-unique concatenations.@@@Searches on `u# lists are done via a hash function.|||L: `s# 14 2 3 3 9/ Specify during list creation@@@@[ `.; `L ; `s#]/ Functional apply, i.e. to the variable list L
/ in the default namespace (i.e. `.) apply
/ the sorted `s# attribute@@@Update `s#time from `tab
/ Update the table (tab) to apply the
/ attribute.",,,
Learn KDB+,Q Language - Functional Queries,Q Language - Functional Queries|||Note −@@@Functional select@@@Functional Exec@@@Functional Update@@@Functional delete|||Example 1@@@Example 2@@@Example 3,"Functional (Dynamic) queries allow specifying column names as symbols to typical q-sql select/exec/delete columns. It comes very handy when we want to specify column names dynamically.|||The functional forms are −|||where|||t is a table;|||a is a dictionary of aggregates;|||b the by-phrase; and|||c is a list of constraints.|||All q entities in a, b, and c must be referenced by name, meaning as symbols containing the entity names.|||The syntactic forms of select and update are parsed into their equivalent functional forms by the q interpreter, so there is no performance difference between the two forms.|||The following code block shows how to use functional select −|||Let’s start with the easiest case, the functional version of “select from t” will look like −|||In the following example, we use the enlist function to create singletons to ensure that appropriate entities are lists.|||The functional form of exec is a simplified form of select.|||The functional form of update is completely analogous to that of select. In the following example, the use of enlist is to create singletons, to ensure that input entities are lists.|||Functional delete is a simplified form of functional update. Its syntax is as follows −|||Let us now take an example to show how functional delete work −","t is a table;@@@a is a dictionary of aggregates;@@@b the by-phrase; and@@@c is a list of constraints.|||All q entities in a, b, and c must be referenced by name, meaning as symbols containing the entity names.@@@The syntactic forms of select and update are parsed into their equivalent functional forms by the q interpreter, so there is no performance difference between the two forms.",,,
Learn KDB+,Q Language - Table Arithmetic,Q Language - Table Arithmetic,"In this chapter, we will learn how to operate on dictionaries and then tables. Let’s start with dictionaries −|||If one needs to amend the dictionary values, then the amend formulation can be −",,,,
Learn KDB+,Q Language - Tables on Disk,Q Language - Tables on Disk|||Flat file@@@Splayed Tables@@@Partitioned Tables|||Sym file@@@par.txt file (optional),"Data on your hard disk (also called historical database) can be saved in three different formats − Flat Files, Splayed Tables, and Partitioned Tables. Here we will learn how to use these three formats to save data.|||Flat files are fully loaded into memory which is why their size (memory footprint) should be small. Tables are saved on disk entirely in one file (so size matters).|||The functions used to manipulate these tables are set/get −|||Let’s take an example to demonstrate how it works −|||In Windows environment, flat files are saved at the location − C:\q\w32|||Get the flat file from your disk (historical db) and use the get command as follows −|||A new table is created tab2 with its contents stored in tab1_test file.|||If there are too many columns in a table, then we store such tables in splayed format, i.e., we save them on disk in a directory. Inside the directory, each column is saved in a separate file under the same name as the column name. Each column is saved as a list of corresponding type in a kdb+ binary file.|||Saving a table in splayed format is very useful when we have to access only a few columns frequently out of its many columns. A splayed table directory contains .d binary file which contains the order of the columns.|||Much like a flat file, a table can be saved as splayed by using the set command. To save a table as splayed, the file path should end with a backlash −|||For reading a splayed table, we can use the get function −|||Note − For a table to be saved as splayed, it should be un-keyed and enumerated.|||In Windows environment, your file structure will appear as follows −|||Partitioned tables provide an efficient means to manage huge tables containing significant volumes of data. Partitioned tables are splayed tables spread across more partitions (directories).|||Inside each partition, a table will have its own directory, with the structure of a splayed table. The tables could be split on a day/month/year basis in order to provide optimized access to its content.|||To get the content of a partitioned table, use the following code block −|||Let’s try to get the contents of a trade table −|||Note − The partitioned mode is suitable for tables with millions of records per day (i.e. time series data)|||The sym file is a kdb+ binary file containing the list of symbols from all splayed and partitioned tables. It can be read with,|||This is a configuration file, used when partitions are spread on several directories/disk drives, and contain the paths to the disk partitions.",,,,
Learn KDB+,Q Language - Maintenance Functions,Q Language - Maintenance Functions|||.Q.en@@@.Q.dpft@@@.Q.chk,".Q.en is a dyadic function which help in splaying a table by enumerating a symbol column. It is especially useful when we are dealing with historical db (splayed, partition tables etc.).  −|||where directory is the home directory of the historical database where sym file is located and table is the table to be enumerated.|||Manual enumeration of tables is not required to save them as splayed tables, as this will be done by −|||The .Q.dpft function helps in creating partitioned and segmented tables. It is advanced form of .Q.en, as it not only splays the table but also creates a partition table.|||There are four arguments used in .Q.dpft −|||symbolic file handle of the database where we want to create a partition,|||q data value with which we are going to partition the table, |||name of the field with which parted (`p#) attribute is going to be applied (usually `sym), and|||the table name.|||Let’s take an example to see how it works −|||We have deleted the table tab from the memory. Let us now load it from the db|||.Q.chk is a monadic function whose single parameter is the symbolic file handle of the root directory. It creates empty tables in a partition, wherever necessary, by examining each partition subdirectories in the root.|||where directory is the home directory of the historical database.","symbolic file handle of the database where we want to create a partition,@@@q data value with which we are going to partition the table, @@@name of the field with which parted (`p#) attribute is going to be applied (usually `sym), and@@@the table name.",,,
Learn KDB+,KDB+ - Quick Guide,"KDB+ - Quick Guide@@@KDB+ - Overview@@@KDB+ - Architecture@@@Q Programming Language@@@Q Language - Type Casting@@@Q Language - Temporal Data@@@Q Language - Lists@@@Q Language - Indexing@@@Q Language - Dictionaries@@@Q Language - Table@@@Q Language - Verb & Adverbs@@@Q Language - Joins@@@Q Language - Functions@@@Q Language - Built-in Functions@@@Q Language - Queries@@@Q Language - Inter-Process Communication@@@Q Language - Message Handler@@@Q Language - Attributes@@@Q Language - Functional Queries@@@Q Language - Table Arithmetic@@@Q Language - Tables on Disk@@@Q Language - Maintenance Functions|||Background@@@Why and Where to Use KDB+@@@Getting Started@@@Kdb+/ tick Architecture@@@Components of Kdb+ Tick Architecture@@@Starting the “q” Environment@@@Data Types@@@Atom and List Formation@@@Casting Integers to Floats@@@Casting Strings to Symbols@@@Casting Strings to Non-Symbols@@@Date@@@Times@@@Datetimes@@@Types of List@@@Index Notation@@@Indexed Assignment@@@Joining Lists@@@Nesting@@@Elided Indices@@@Lookup@@@Operations on Dictionaries@@@Column Dictionaries@@@Flipping a Dictionary@@@Creating Tables@@@Getting Table Information@@@Primary Keys and Keyed Tables@@@Manipulating Tables@@@Each@@@Each-Left and Each-Right@@@Simple Join@@@Asof Join (aj)@@@Left Join(lj)@@@Union Join (uj)@@@Types of Functions@@@Frequently Used Functions@@@System Commands@@@String Functions@@@Mathematical Functions@@@Aggregate Functions@@@Uniform Functions@@@Miscellaneous Functions@@@Basics Queries@@@Queries with Constraints@@@Queries with Aggregations@@@Initialize Server@@@Communication Handle@@@Synchronous and Asynchronous Messages@@@Predefined Message Handlers@@@Types of Attributes@@@Note −@@@Functional select@@@Functional Exec@@@Functional Update@@@Functional delete@@@Flat file@@@Splayed Tables@@@Partitioned Tables@@@.Q.en@@@.Q.dpft@@@.Q.chk|||Downloading & Installing KDB+@@@Directory Layout@@@Data Feeds@@@Feed Handler@@@Ticker Plant@@@Real-Time Database@@@Historical Database@@@Example 1 – Atom and List Formation@@@Count@@@Examples of simple List@@@Lists from Variables@@@Depth@@@Indexing at Depth@@@Lookup with Verb @@@@Amend and Upsert@@@Reverse Lookup with Find (?)@@@Removing Entries@@@Flip on a Column Dictionary@@@Flip of a Flipped Column Dictionary@@@Keyed Table@@@ForeignKeys@@@Select@@@Insert@@@Delete@@@Update@@@General format@@@Example@@@General format@@@Example@@@abs@@@all@@@Max (&), Min (|), and Not (!)@@@asc@@@avg@@@by@@@cols@@@count@@@port@@@cut@@@Delete@@@Distinct@@@enlist@@@Fill (^)@@@Fills@@@First@@@Flip@@@iasc@@@Idesc@@@in@@@insert@@@key@@@lower@@@Max and Min (i.e. | and &)@@@null@@@Peach@@@Prev@@@Random( ?)@@@Raze@@@read0@@@read1@@@reverse@@@set@@@ssr@@@string@@@SV@@@system@@@tables@@@Til@@@trim@@@vs@@@xasc@@@xcol@@@xcols@@@xdesc@@@xgroup@@@xkey@@@\a [ namespace] – List tables in the given namespace@@@\b – View dependencies@@@\B – Pending views / dependencies@@@\cd – Change directory@@@\d – sets current namespace@@@\l – load file or directory from db@@@\p – port number@@@\\ - Exit from q console@@@Like − pattern matching@@@ltrim − removes leading blanks@@@rtrim − removes trailing blanks@@@ss − string search@@@trim − removes leading and trailing blanks@@@acos − inverse of cos@@@cor − gives correlation@@@cross − Cartesian product@@@var − variance@@@wavg@@@all − & operation@@@Any − | operation@@@prd − arithmetic product@@@Sum − arithmetic sum@@@Deltas − difference from its previous item.@@@fills − fills nulls value@@@maxs − cumulative maximum@@@Count − return number of element@@@Distinct − return distinct entities@@@Except − element not present in second arg.@@@fill − fill null with first argument@@@Example@@@.z.pg @@@.z.ps@@@.z.po[]@@@.z.pc[]@@@.z.pi[]@@@.z.pw@@@Sorted (`s#)@@@Parted (`p#)@@@Grouped (`g#)@@@Unique (`#u)@@@Removing Attributes@@@Applying Attributes@@@Example 1@@@Example 2@@@Example 3@@@Sym file@@@par.txt file (optional)","This is a complete quide to kdb+ from kx systems, aimed primarily at those learning independently. kdb+, introduced in 2003, is the new generation of the kdb database which is designed to capture, analyze, compare, and store data.|||A kdb+ system contains the following two components −|||KDB+ − the database (k database plus)|||Q − the programming language for working with kdb+|||Both kdb+ and q are written in k programming language (same as q but less readable).|||Kdb+/q originated as an obscure academic language but over the years, it has gradually improved its user friendliness.|||APL (1964, A Programming Language)|||A+ (1988, modified APL by Arthur Whitney)|||K (1993, crisp version of A+, developed by A. Whitney)|||Kdb (1998, in-memory column-based db)|||Kdb+/q (2003, q language – more readable version of k)|||Why? − If you need a single solution for real-time data with analytics, then you should consider kdb+. Kdb+ stores database as ordinary native files, so it does not have any special needs regarding hardware and storage architecture. It is worth pointing out that the database is just a set of files, so your administrative work won’t be difficult.|||Where to use KDB+? − It’s easy to count which investment banks are NOT using kdb+ as most of them are using currently or planning to switch from conventional databases to kdb+. As the volume of data is increasing day by day, we need a system that can handle huge volumes of data. KDB+ fulfills this requirement. KDB+ not only stores an enormous amount of data but also analyzes it in real time.|||With this much of background, let us now set forth and learn how to set up an environment for KDB+. We will start with how to download and install KDB+.|||You can get the free 32-bit version of KDB+, with all the functionality of the 64- bit version from http://kx.com/software-download.php|||Agree to the license agreement, select the operating system (available for all major operating system). For Windows operating system, the latest version is 3.2. Download the latest version. Once you unzip it, you will get the folder name “windows” and inside the windows folder, you will get another folder “q”. Copy the entire q folder onto your c:/ drive.|||Open the Run terminal, type the location where you store the q folder; it will be like “c:/q/w32/q.exe”. Once you hit Enter, you will get a new console as follows −|||On the first line, you can see the version number which is 3.2 and the release date as 2015.03.05|||The trial/free version is generally installed in directories,|||For linux/Mac −|||For Windows −|||Example Files −|||Once you download kdb+, the directory structure in the Windows platform would appear as follows −|||In the above directory structure, trade.q and sp.q are the example files which we can use as a reference point.|||Kdb+ is a high-performance, high-volume database designed from the outset to handle tremendous volumes of data. It is fully 64-bit, and has built-in multi-core processing and multi-threading. The same architecture is used for real-time and historical data. The database incorporates its own powerful query language, q, so analytics can be run directly on the data.|||kdb+tick is an architecture which allows the capture, processing, and querying of real-time and historical data.|||The following illustration provides a generalized outline of a typical Kdb+/tick architecture, followed by a brief explanation of the various components and the through-flow of data.|||The Data Feeds are a time series data that are mostly provided by the data feed providers like Reuters, Bloomberg or directly from exchanges.|||To get the relevant data, the data from the data feed is parsed by the feed handler.|||Once the data is parsed by the feed handler, it goes to the ticker-plant.|||To recover data from any failure, the ticker-plant first updates/stores the new data to the log file and then updates its own tables.|||After updating the internal tables and the log files, the on-time loop data is continuously sent/published to the real-time database and all the chained subscribers who requested for data.|||At the end of a business day, the log file is deleted, a new one created and the real-time database is saved onto the historical database. Once all the data is saved onto the historical database, the real-time database purges its tables.|||Data Feeds can be any market or other time series data. Consider data feeds as the raw input to the feed-handler. Feeds can be directly from the exchange (live-streaming data), from the news/data providers like Thomson-Reuters, Bloomberg, or any other external agencies.|||A feed handler converts the data stream into a format suitable for writing to kdb+. It is connected to the data feed and it retrieves and converts the data from the feed-specific format into a Kdb+ message which is published to the ticker-plant process. Generally a feed handler is used to perform the following operations −|||Ticker Plant is the most important component of KDB+ architecture. It is the ticker plant with which the real-time database or directly subscribers (clients) are connected to access the financial data. It operates in publish and subscribe mechanism. Once you obtain a subscription (license), a tick (routinely) publication from the publisher (ticker plant) is defined. It performs the following operations −|||Receives the data from the feed handler.|||Immediately after the ticker plant receives the data, it stores a copy as a log file and updates it once the ticker plant gets any update so that in case of any failure, we should not have any data loss.|||The clients (real-time subscriber) can directly subscribe to the ticker-plant.|||At the end of each business day, i.e., once the real-time database receives the last message, it stores all of today’s data onto the historical database and pushes the same to all the subscribers who have subscribed for today’s data. Then it resets all its tables. The log file is also deleted once the data is stored in the historical database or other directly linked subscriber to real time database (rtdb).|||As a result, the ticker-plant, the real-time database, and the historical database are operational on a 24/7 basis.|||Since the ticker-plant is a Kdb+ application, its tables can be queried using q like any other Kdb+ database. All ticker-plant clients should only have access to the database as subscribers.|||A real-time database (rdb) stores today’s data. It is directly connected to the ticker plant. Typically it would be stored in memory during market hours (a day) and written out to the historical database (hdb) at the end of day. As the data (rdb data) is stored in memory, processing is extremely fast.|||As kdb+ recommends to have a RAM size that is four or more times the expected size of data per day, the query that runs on rdb is very fast and provides superior performance. Since a real-time database contains only today’s data, the date column (parameter) is not required.|||For example, we can have rdb queries like,|||If we have to calculate the estimates of a company, we need to have its historical data available. A historical database (hdb) holds data of transactions done in the past. Each new day’s record would be added to the hdb at the end of day. Large tables in the hdb are either stored splayed (each column is stored in its own file) or they are stored partitioned by temporal data. Also some very large databases may be further partitioned using par.txt (file).|||These storage strategies (splayed, partitioned, etc.) are efficient while searching or accessing the data from a large table.|||A historical database can also be used for internal and external reporting purposes, i.e., for analytics. For example, suppose we want to get the company trades of IBM for a particular day from the trade (or any) table name, we need to write a query as follows −|||Note − We will write all such queries once we get some overview of the q language.|||Kdb+ comes with its built-in programming language that is known as q. It incorporates a superset of standard SQL which is extended for time-series analysis and offers many advantages over the standard version. Anyone familiar with SQL can learn q in a matter of days and be able to quickly write her own ad-hoc queries.|||To start using kdb+, you need to start the q session. There are three ways to start a q session −|||Simply type “c:/q/w32/q.exe” on your run terminal.|||Start the MS-DOS command terminal and type q.|||Copy the q.exe file onto “C:\Windows\System32” and on the run terminal, just type “q”.|||Here we are assuming that you are working on a Windows platform.|||The following table provides a list of supported data types −|||Atoms are single entities, e.g., a single number, a character or a symbol. In the above table (of different data types), all supported data types are atoms. A list is a sequence of atoms or other types including lists.|||Passing an atom of any type to the monadic (i.e. single argument function) type function will return a negative value, i.e., –n, whereas passing a simple list of those atoms to the type function will return a positive value n.|||It is often required to change the data type of some data from one type to another. The standard casting function is the “$” dyadic operator.|||Three approaches are used to cast from one type to another (except for string) −|||In the following example of casting integers to floats, all the three different ways of casting are equivalent −|||Check if all the three operations are equivalent,|||Casting string to symbols and vice versa works a bit differently. Let’s check it with an example −|||Attempting to cast strings to symbols using the keyed words `symbol or 11h will fail with the type error −|||Casting strings to a data type other than symbol is accomplished as follows −|||So to cast an entire string (the list of characters) to a single atom of data type x requires us to specify the upper case letter representing data type x as the first argument to the $ operator. If you specify the data type of x in any other way, it result in the cast being applied to each character of the string.|||The q language has many different ways of representing and manipulating temporal data such as times and dates.|||A date in kdb+ is internally stored as the integer number of days since our reference date is 01Jan2000. A date after this date is internally stored as a positive number and a date before that is referenced as a negative number.|||By default, a date is written in the format “YYYY.MM.DD”|||Arithmetic and logical operations can be performed directly on dates.|||The 1st of January 2000 fell on a Saturday. Therefore any Saturday throughout the history or in the future when divided by 7, would yield a remainder of 0, Sunday gives 1, Monday yield 2.|||A time is internally stored as the integer number of milliseconds since the stroke of midnight. A time is written in the format HH:MM:SS.MSS|||As in case of dates, arithmetic can be performed directly on times.|||A datetime is the combination of a date and a time, separated by ‘T’ as in the ISO standard format. A datetime value stores the fractional day count from midnight Jan 1, 2000.|||The underlying fractional day count can be obtained by casting to float.|||Lists are the basic building blocks of q language, so a thorough understanding of lists is very important. A list is simply an ordered collection of atoms (atomic elements) and other lists (group of one or more atoms).|||A general list encloses its items within matching parentheses and separates them with semicolons. For example −|||If a list comprises of atoms of same type, it is known as a uniform list. Else, it is known as a general list (mixed type).|||We can obtain the number of items in a list through its count.|||**Note − A simple list of char is called a string.|||A list contains atoms or lists. To create a single item list, we use −|||To distinguish between an atom and the equivalent singleton, examine the sign of their type.|||A list is ordered from left to right by the position of its items. The offset of an item from the beginning of the list is called its index. Thus, the first item has an index 0, the second item (if there is one) has an index 1, etc. A list of count n has index domain from 0 to n–1.|||Given a list L, the item at index i is accessed by L[i]. Retrieving an item by its index is called item indexing. For example,|||Items in a list can also be assigned via item indexing. Thus,|||The most common operation on two lists is to join them together to form a larger list. More precisely, the join operator (,) appends its right operand to the end of the left operand and returns the result. It accepts an atom in either argument.|||Data complexity is built by using lists as items of lists.|||The number of levels of nesting for a list is called its depth. Atoms have a depth of 0 and simple lists have a depth of 1.|||Here is a list of depth 3 having two items −|||It is possible to index directly into the items of a nested list.|||Repeated Item Indexing|||Retrieving an item via a single index always retrieves an uppermost item from a nested list.|||Since the result L[1] is itself a list, we can retrieve its elements using a single index.|||We can repeat single indexing once more to retrieve an item from the innermost nested list.|||You can read this as,|||Get the item at index 1 from L, and from it retrieve the item at index 2, and from it retrieve the item at index 0.|||Notation for Indexing at Depth|||There is an alternate notation for repeated indexing into the constituents of a nested list. The last retrieval can also be written as,|||Assignment via index also works at depth.|||Eliding Indices for a General List|||Interpret L[;1;] as,|||Retrieve all items in the second position of each list at the top level.|||Interpret L[;;2] as,|||Retrieve the items in the third position for each list at the second level.|||Dictionaries are an extension of lists which provide the foundation for creating tables. In mathematical terms, dictionary creates the|||“domain →  Range” |||or in general (short) creates|||“key → value”|||relationship between elements.|||A dictionary is an ordered collection of key-value pairs that is roughly equivalent to a hash table. A dictionary is a mapping defined by an explicit I/O association between a domain list and a range list via positional correspondence. The creation of a dictionary uses the ""xkey"" primitive (!)|||The most basic dictionary maps a simple list to a simple list.|||Finding the dictionary output value corresponding to an input value is called looking up the input.|||As with lists, the items of a dictionary can be modified via indexed assignment.|||Dictionaries can be extended via index assignment. |||The find (?) operator is used to perform reverse lookup by mapping a range of elements to its domain element.|||In case the elements of a list is not unique, the find returns the first item mapping to it from the domain list.|||To remove an entry from a dictionary, the delete ( _ ) function is used. The left operand of ( _ ) is the dictionary and the right operand is a key value.|||Whitespace is required to the left of _ if the first operand is a variable.|||Column dictionaries are the basics for creation of tables. Consider the following example −|||The net effect of flipping a column dictionary is simply reversing the order of the indices. This is logically equivalent to transposing the rows and columns.|||The transpose of a dictionary is obtained by applying the unary flip operator. Take a look at the following example −|||If you transpose a dictionary twice, you obtain the original dictionary,|||Tables are at the heart of kdb+. A table is a collection of named columns implemented as a dictionary. q tables are column-oriented.|||Tables are created using the following syntax −|||In the above example, we have not specified the type of each column. This will be set by the first insert into the table.|||Another way, we can specify column type on initialization −|||Or we can also define non-empty tables −|||If there are no columns within the square brackets as in the examples above, the table is unkeyed.|||To create a keyed table, we insert the column(s) for the key in the square brackets.|||One can also define the column types by setting the values to be null lists of various types −|||Let’s create a trade table −|||A keyed table is a dictionary that maps each row in a table of unique keys to a corresponding row in a table of values. Let us take an example −|||Now create a simple keyed table containing eid as key,|||A foreign key defines a mapping from the rows of the table in which it is defined to the rows of the table with the corresponding primary key.|||Foreign keys provide referential integrity. In other words, an attempt to insert a foreign key value that is not in the primary key will fail.|||Consider the following examples. In the first example, we will define a foreign key explicitly on initialization. In the second example, we will use foreign key chasing which does not assume any prior relationship between the two tables.|||Example 1 − Define foreign key on initialization|||Example 2 − no pre-defined relationship between tables|||To use foreign key chasing, we must create a table to key into sector.|||General notation for a predefined foreign key −|||select a.b from c where a is the foreign key (sym), b is a|||field in the primary key table (ind), c is the|||foreign key table (trade)|||Let’s create one trade table and check the result of different table expression −|||Let us now take a look at the statements that are used to manipulate tables using q language.|||The syntax to use a Select statement is as follows −|||Let us now take an example to demonstrate how to use Select statement −|||The syntax to use an Insert statement is as follows −|||Let us now take an example to demonstrate how to use Insert statement −|||The syntax to use a Delete statement is as follows −|||Let us now take an example to demonstrate how to use Delete statement −|||The syntax to use an Update statement is as follows −|||Use the following syntax to update the format/datatype of a column using the cast function −|||Let us now take an example to demonstrate how to use Update statement −|||Kdb+ has nouns, verbs, and adverbs. All data objects and functions are nouns. Verbs enhance the readability by reducing the number of square brackets and parentheses in expressions. Adverbs modify dyadic (2 arguments) functions and verbs to produce new, related verbs. The functions produced by adverbs are called derived functions or derived verbs.|||The adverb each, denoted by ( ` ), modifies dyadic functions and verbs to apply to the items of lists instead of the lists themselves. Take a look at the following example −|||There is a form of Each for monadic functions that uses the keyword “each”. For example,|||There are two variants of Each for dyadic functions called Each-Left (\:) and Each-Right (/:). The following example explains how to use them.|||In q language, we have different kinds of joins based on the input tables supplied and the kind of joined tables we desire. A join combines data from two tables. Besides foreign key chasing, there are four other ways to join tables −|||Here, in this chapter, we will discuss each of these joins in detail.|||Simple join is the most basic type of join, performed with a comma ‘,’. In this case, the two tables have to be type conformant, i.e., both the tables have the same number of columns in the same order, and same key.|||We can use comma-each join for tables with same length to join sideways. One of the tables can be keyed here,|||It is the most powerful join which is used to get the value of a field in one table asof the time in another table. Generally it is used to get the prevailing bid and ask at the time of each trade.|||For example,|||It’s a special case of aj where the second argument is a keyed table and the first argument contains the columns of the right argument’s key.|||It allows to create a union of two tables with distinct schemas. It is basically an extension to the simple join ( , )|||If you are using uj on keyed tables, then the primary keys must match.|||Functions can be classified in a number of ways. Here we have classified them based on the number and type of argument they take and the result type. Functions can be,|||Atomic − Where the arguments are atomic and produce atomic results|||Aggregate − atom from list|||Uniform (list from list) − Extended the concept of atom as they apply to lists. The count of the argument list equals the count of the result list.|||Other − if the function is not from the above category.|||Binary operations in mathematics are called dyadic functions in q; for example, “+”. Similarly unary operations are called monadic functions; for example, “abs” or “floor”.|||There are quite a few functions used frequently in q programming. Here, in this section, we will see the usage of some popular functions −|||System commands control the q environment. They are of the following form −|||Some of the popular system commands have been discussed below −|||The q programming language has a set of rich and powerful built-in functions. A built-in function can be of the following types −|||String function − Takes a string as input and returns a string.|||Aggregate function − Takes a list as input and returns an atom.|||Uniform function − Takes a list and returns a list of the same count.|||Mathematical function − Takes numeric argument and returns a numeric argument.|||Miscellaneous function − All functions other than above mentioned.|||Queries in q are shorter and simpler and extend the capabilities of sql. The main query expression is the ‘select expression’, which in its simplest form extracts sub-tables but it can also create new columns.|||The general form of a Select expression is as follows −|||**Note − by & where phrases are optional, only the ‘from expression’ is mandatory.|||In general, the syntax will be −|||The syntax of q expressions look quite similar to SQL, but q expressions are simple and powerful. An equivalent sql expression for the above q expression would be as follows −|||All the clauses execute on the columns and therefore q can take advantage of order. As Sql queries are not based on order, they cannot take that advantage.|||q relational queries are generally much smaller in size as compared to their corresponding sql. Ordered and functional queries do things that are difficult in sql.|||In a historical database, the ordering of the where clause is very important because it affects the performance of the query. The partition variable (date/month/day) always comes first followed by the sorted and indexed column (generally the sym column).|||For example,|||is much faster than,|||Let’s write a query script in notepad (as below), save (as *.q), and then load it.|||* Denotes HDB query|||Select all IBM trades|||*Select all IBM trades on a certain day|||Select all IBM trades with a price > 100|||Select all IBM trades with a price less than or equal to 100|||*Select all IBM trades between 10.30 and 10.40, in the morning, on a certain date|||Select all IBM trades in ascending order of price|||*Select all IBM trades in descending order of price in a certain time frame|||Composite sort − sort ascending order by sym and then sort the result in descending order of price|||Select all IBM or MSFT trades|||*Calculate count of all symbols in ascending order within a certain time frame|||*Calculate count of all symbols in descending order within a certain time frame|||* What is the maximum price of IBM stock within a certain time frame, and when does this first happen?|||Select the last price for each sym in hourly buckets|||* Calculate vwap (Volume Weighted Average Price) of all symbols|||* Count the number of records (in millions) for a certain month|||* HLOC – Daily High, Low, Open and Close for CSCO in a certain month|||* Daily Vwap for CSCO in a certain month|||* Calculate the hourly mean, variance and standard deviation of the price for AIG|||Select the price range in hourly buckets|||* Daily Spread (average bid-ask) for CSCO in a certain month|||* Daily Traded Values for all syms in a certain month|||Extract a 5 minute vwap for CSCO|||* Extract 10 minute bars for CSCO|||* Find the times when the price exceeds 100 basis points (100e-4) over the last price for CSCO for a certain day|||* Full Day Price and Volume for MSFT in 1 Minute Intervals for the last date in the database|||KDB+ allows one process to communicate with another process through interprocess communication. Kdb+ processes can connect to any other kdb+ on the same computer, the same network, or even remotely. We just need to specify the port and then the clients can talk to that port. Any q process can communicate with any other q process as long as it is accessible on the network and is listening for connections.|||a server process listens for connections and processes any requests|||a client process initiates the connection and sends commands to be executed|||Client and server can be on the same machine or on different machines. A process can be both a client and a server.|||A communication can be,|||Synchronous (wait for a result to be returned)|||Asynchronous (no wait and no result returned)|||A q server is initialized by specifying the port to listen on,|||A communication handle is a symbol that starts with “:” and has the form −|||To start the connection, we use the function “hopen” which returns an integer connection handle. This handle is used for all subsequent client requests. For example −|||Once we have a handle, we can send a message either synchronously or asynchronously.|||Synchronous Message − Once a message is sent, it waits on and returns the result. Its format is as follows −|||Asynchronous Message − After sending a message, start processing the next statement immediately without having to wait and return a result. Its format is as follows −|||Messages that require a response, for example function calls or select statements, will normally use the synchronous form; while messages that need not return an output, for example inserting updates to a table, will be asynchronous.|||When a q process connects to another q process via inter-process communication, it is processed by message handlers. These message handlers have a default behavior. For example, in case of synchronous message handling, the handler returns the value of the query. The synchronous handler in this case is .z.pg, which we could override as per requirement.|||Kdb+ processes have several pre-defined message handlers. Message handlers are important for configuring the database. Some of the usages include −|||Logging − Log incoming messages (helpful in case of any fatal error),|||Security − Allow/disallow access to the database, certain function calls, etc., based on username / ip address. It helps in providing access to authorized subscribers only.|||Handle connections/disconnections from other processes.|||Some of the predefined message handlers are discussed below.|||It is a synchronous message handler (process get). This function gets called automatically whenever a sync message is received on a kdb+ instance.|||Parameter is the string/function call to be executed, i.e., the message passed. By default, it is defined as follows −|||It is an asynchronous message handler (process set). It is the equivalent handler for asynchronous messages. Parameter is the string/function call to be executed. By default, it is defined as,|||Following is the customized message handler for asynchronous messages, where we have used the protected execution,|||Here errhandler is a function used in case of any unexpected error.|||It is a connection open handler (process-open). It is executed when a remote process opens a connection. To see the handle when a connection to a process is opened, we can define the .z.po as,|||It is a close connection handler (process-close). It is called when a connection is closed. We can create our own close handler which can reset the global connection handle to 0 and issue a command to set the timer to fire (execute) every 3 seconds (3000 milliseconds).|||The timer handler (.z.ts) attempts to re-open the connection. On success, it turns the timer off.|||PI stands for process input. It is called for any sort of input. It can be used to handle console input or remote client input. Using .z.pi[], one can validate the console input or replace the default display. In addition, it can be used for any sort of logging operations.|||It is a validation connection handler (user authentication). It adds an extra callback when a connection is being opened to a kdb+ session. It is called after the –u/-U checks and before the .z.po (port open).|||Inputs are userid (symbol) and password (text).|||Lists, dictionaries, or columns of a table can have attributes applied to them. Attributes impose certain properties on the list. Some attributes might disappear on modification.|||`s# means the list is sorted in an ascending order. If a list is explicitly sorted by asc (or xasc), the list will automatically have the sorted attribute set.|||A list which is known to be sorted can also have the attribute explicitly set. Q will check if the list is sorted, and if is not, an s-fail error will be thrown.|||The sorted attribute will be lost upon an unsorted append.|||`p# means the list is parted and identical items are stored contiguously.|||The range is an int or temporal type having an underlying int value, such as years, months, days, etc. You can also partition over a symbol provided it is enumerated.|||Applying the parted attribute creates an index dictionary that maps each unique output value to the position of its first occurrence. When a list is parted, lookup is much faster, since linear search is replaced by hashtable lookup.|||Note −|||The parted attribute is not preserved under an operation on the list, even if
the operation preserves the partitioning.|||The parted attribute should be considered when the number of entities reaches a billion and most of the partitions are of substantial size, i.e., there is significant repetition.|||`g# means the list is grouped. An internal dictionary is built and maintained which maps each unique item to each of its indices, requiring considerable storage space. For a list of length L containing u unique items of size s, this will be (L × 4) + (u × s) bytes.|||Grouping can be applied to a list when no other assumptions about its structure can be made.|||The attribute can be applied to any typed lists. It is maintained on appends, but lost on deletes.|||Applying the unique attribute (`u#) to a list indicates that the items of the list are distinct. Knowing that the elements of a list are unique dramatically speeds up distinct and allows q to execute some comparisons early.|||When a list is flagged as unique, an internal hash map is created to each item in the list. Operations on the list must preserve uniqueness or the attribute is lost.|||Note −|||`u# is preserved on concatenations which preserve the uniqueness. It is lost on deletions and non-unique concatenations.|||Searches on `u# lists are done via a hash function.|||Attributes can be removed by applying `#.|||Three formats for applying attributes are −|||L: `s# 14 2 3 3 9/ Specify during list creation|||@[ `.; `L ; `s#]/ Functional apply, i.e. to the variable list L|||/ in the default namespace (i.e. `.) apply|||/ the sorted `s# attribute|||Update `s#time from `tab|||/ Update the table (tab) to apply the|||/ attribute.|||Let’s apply the above three different formats with examples.|||Functional (Dynamic) queries allow specifying column names as symbols to typical q-sql select/exec/delete columns. It comes very handy when we want to specify column names dynamically.|||The functional forms are −|||where|||t is a table;|||a is a dictionary of aggregates;|||b the by-phrase; and|||c is a list of constraints.|||All q entities in a, b, and c must be referenced by name, meaning as symbols containing the entity names.|||The syntactic forms of select and update are parsed into their equivalent functional forms by the q interpreter, so there is no performance difference between the two forms.|||The following code block shows how to use functional select −|||Let’s start with the easiest case, the functional version of “select from t” will look like −|||In the following example, we use the enlist function to create singletons to ensure that appropriate entities are lists.|||The functional form of exec is a simplified form of select.|||The functional form of update is completely analogous to that of select. In the following example, the use of enlist is to create singletons, to ensure that input entities are lists.|||Functional delete is a simplified form of functional update. Its syntax is as follows −|||Let us now take an example to show how functional delete work −|||In this chapter, we will learn how to operate on dictionaries and then tables. Let’s start with dictionaries −|||If one needs to amend the dictionary values, then the amend formulation can be −|||Data on your hard disk (also called historical database) can be saved in three different formats − Flat Files, Splayed Tables, and Partitioned Tables. Here we will learn how to use these three formats to save data.|||Flat files are fully loaded into memory which is why their size (memory footprint) should be small. Tables are saved on disk entirely in one file (so size matters).|||The functions used to manipulate these tables are set/get −|||Let’s take an example to demonstrate how it works −|||In Windows environment, flat files are saved at the location − C:\q\w32|||Get the flat file from your disk (historical db) and use the get command as follows −|||A new table is created tab2 with its contents stored in tab1_test file.|||If there are too many columns in a table, then we store such tables in splayed format, i.e., we save them on disk in a directory. Inside the directory, each column is saved in a separate file under the same name as the column name. Each column is saved as a list of corresponding type in a kdb+ binary file.|||Saving a table in splayed format is very useful when we have to access only a few columns frequently out of its many columns. A splayed table directory contains .d binary file which contains the order of the columns.|||Much like a flat file, a table can be saved as splayed by using the set command. To save a table as splayed, the file path should end with a backlash −|||For reading a splayed table, we can use the get function −|||Note − For a table to be saved as splayed, it should be un-keyed and enumerated.|||In Windows environment, your file structure will appear as follows −|||Partitioned tables provide an efficient means to manage huge tables containing significant volumes of data. Partitioned tables are splayed tables spread across more partitions (directories).|||Inside each partition, a table will have its own directory, with the structure of a splayed table. The tables could be split on a day/month/year basis in order to provide optimized access to its content.|||To get the content of a partitioned table, use the following code block −|||Let’s try to get the contents of a trade table −|||Note − The partitioned mode is suitable for tables with millions of records per day (i.e. time series data)|||The sym file is a kdb+ binary file containing the list of symbols from all splayed and partitioned tables. It can be read with,|||This is a configuration file, used when partitions are spread on several directories/disk drives, and contain the paths to the disk partitions.|||.Q.en is a dyadic function which help in splaying a table by enumerating a symbol column. It is especially useful when we are dealing with historical db (splayed, partition tables etc.).  −|||where directory is the home directory of the historical database where sym file is located and table is the table to be enumerated.|||Manual enumeration of tables is not required to save them as splayed tables, as this will be done by −|||The .Q.dpft function helps in creating partitioned and segmented tables. It is advanced form of .Q.en, as it not only splays the table but also creates a partition table.|||There are four arguments used in .Q.dpft −|||symbolic file handle of the database where we want to create a partition,|||q data value with which we are going to partition the table, |||name of the field with which parted (`p#) attribute is going to be applied (usually `sym), and|||the table name.|||Let’s take an example to see how it works −|||We have deleted the table tab from the memory. Let us now load it from the db|||.Q.chk is a monadic function whose single parameter is the symbolic file handle of the root directory. It creates empty tables in a partition, wherever necessary, by examining each partition subdirectories in the root.|||where directory is the home directory of the historical database.","KDB+ − the database (k database plus)@@@Q − the programming language for working with kdb+|||APL (1964, A Programming Language)@@@A+ (1988, modified APL by Arthur Whitney)@@@K (1993, crisp version of A+, developed by A. Whitney)@@@Kdb (1998, in-memory column-based db)@@@Kdb+/q (2003, q language – more readable version of k)|||The Data Feeds are a time series data that are mostly provided by the data feed providers like Reuters, Bloomberg or directly from exchanges.@@@To get the relevant data, the data from the data feed is parsed by the feed handler.@@@Once the data is parsed by the feed handler, it goes to the ticker-plant.@@@To recover data from any failure, the ticker-plant first updates/stores the new data to the log file and then updates its own tables.@@@After updating the internal tables and the log files, the on-time loop data is continuously sent/published to the real-time database and all the chained subscribers who requested for data.@@@At the end of a business day, the log file is deleted, a new one created and the real-time database is saved onto the historical database. Once all the data is saved onto the historical database, the real-time database purges its tables.|||Capture data according to a set of rules.@@@Translate (/enrich) that data from one format to another.@@@Catch the most recent values.|||Receives the data from the feed handler.@@@Immediately after the ticker plant receives the data, it stores a copy as a log file and updates it once the ticker plant gets any update so that in case of any failure, we should not have any data loss.@@@The clients (real-time subscriber) can directly subscribe to the ticker-plant.@@@At the end of each business day, i.e., once the real-time database receives the last message, it stores all of today’s data onto the historical database and pushes the same to all the subscribers who have subscribed for today’s data. Then it resets all its tables. The log file is also deleted once the data is stored in the historical database or other directly linked subscriber to real time database (rtdb).@@@As a result, the ticker-plant, the real-time database, and the historical database are operational on a 24/7 basis.|||Simply type “c:/q/w32/q.exe” on your run terminal.@@@Start the MS-DOS command terminal and type q.@@@Copy the q.exe file onto “C:\Windows\System32” and on the run terminal, just type “q”.|||Specify desired data type by its symbol name@@@Specify desired data type by its character@@@Specify desired data type by it short value.|||Simple join@@@Asof join@@@Left join@@@Union join|||Atomic − Where the arguments are atomic and produce atomic results@@@Aggregate − atom from list@@@Uniform (list from list) − Extended the concept of atom as they apply to lists. The count of the argument list equals the count of the result list.@@@Other − if the function is not from the above category.|||String function − Takes a string as input and returns a string.@@@Aggregate function − Takes a list as input and returns an atom.@@@Uniform function − Takes a list and returns a list of the same count.@@@Mathematical function − Takes numeric argument and returns a numeric argument.@@@Miscellaneous function − All functions other than above mentioned.|||a server process listens for connections and processes any requests@@@a client process initiates the connection and sends commands to be executed|||Synchronous (wait for a result to be returned)@@@Asynchronous (no wait and no result returned)|||Logging − Log incoming messages (helpful in case of any fatal error),@@@Security − Allow/disallow access to the database, certain function calls, etc., based on username / ip address. It helps in providing access to authorized subscribers only.@@@Handle connections/disconnections from other processes.|||The parted attribute is not preserved under an operation on the list, even if
the operation preserves the partitioning.@@@The parted attribute should be considered when the number of entities reaches a billion and most of the partitions are of substantial size, i.e., there is significant repetition.|||`u# is preserved on concatenations which preserve the uniqueness. It is lost on deletions and non-unique concatenations.@@@Searches on `u# lists are done via a hash function.|||L: `s# 14 2 3 3 9/ Specify during list creation@@@@[ `.; `L ; `s#]/ Functional apply, i.e. to the variable list L
/ in the default namespace (i.e. `.) apply
/ the sorted `s# attribute@@@Update `s#time from `tab
/ Update the table (tab) to apply the
/ attribute.|||t is a table;@@@a is a dictionary of aggregates;@@@b the by-phrase; and@@@c is a list of constraints.|||All q entities in a, b, and c must be referenced by name, meaning as symbols containing the entity names.@@@The syntactic forms of select and update are parsed into their equivalent functional forms by the q interpreter, so there is no performance difference between the two forms.|||symbolic file handle of the database where we want to create a partition,@@@q data value with which we are going to partition the table, @@@name of the field with which parted (`p#) attribute is going to be applied (usually `sym), and@@@the table name.",,"Name@@@Example@@@Char@@@Type@@@Size|||boolean@@@1b@@@b@@@1@@@1|||byte@@@0xff@@@x@@@4@@@1|||short@@@23h@@@h@@@5@@@2|||int@@@23i@@@i@@@6@@@4|||long@@@23j@@@j@@@7@@@8|||real@@@2.3e@@@e@@@8@@@4|||float@@@2.3f@@@f@@@9@@@8|||char@@@“a”@@@c@@@10@@@1|||varchar@@@`ab@@@s@@@11@@@*|||month@@@2003.03m@@@m@@@13@@@4|||date@@@2015.03.17T18:01:40.134@@@z@@@15@@@8|||minute@@@08:31@@@u@@@17@@@4|||second@@@08:31:53@@@v@@@18@@@4|||time@@@18:03:18.521@@@t@@@19@@@4|||enum@@@`u$`b, where u:`a`b@@@*@@@20@@@4&&&Input (I)@@@Output (O)|||`Name@@@`John|||`Age@@@36|||`Sex@@@“M”|||Weight@@@60.3",
Learn KDB+,KDB+ - Useful Resources,KDB+ - Useful Resources|||Useful Links on KDB+@@@Useful Books on KDB+,"The following resources contain additional information on KDB+. Please use them to get more in-depth knowledge on this.|||KDB+ -  Official Site of KDB+.|||Q Programming Language Wiki -  Wikipedia reference for Q Programming Language.|||To enlist your site on this page, please drop an email to contact@tutorialspoint.com",KDB+ -  Official Site of KDB+.@@@Q Programming Language Wiki -  Wikipedia reference for Q Programming Language.,,,
Learn KDB+,Discuss KDB+,Discuss KDB+,"Kdb+ is a high-performance column-oriented database from Kx Systems Inc. kdb+ is designed to capture, analyze, compare, and store data − all at high speeds and on high volumes of data. The tutorial starts off with a basic introduction of Kdb+ followed by its architecture, installation, and a basic-to-advanced coverage of q programming language.",,,,
