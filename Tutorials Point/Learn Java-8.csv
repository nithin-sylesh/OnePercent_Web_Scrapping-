Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Java-8,Java8 Tutorial,Java8 Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Java 8 is the most awaited and is a major feature release of Java programming language. This is an introductory tutorial that explains the basic-to-advanced features of Java 8 and their usage in a simple and intuitive way.|||This tutorial will be useful for most Java developers, starting from beginners to experts. After completing this tutorial, you will find yourself at a moderate level of expertise in Java 8, from where you can take yourself to next levels.|||Knowledge of basic Java programming language is the only prerequisite for learning the concepts explained in this tutorial.",,,,
Learn Java-8,Java 8 - Overview,Java 8 - Overview|||New Features@@@Useful Video Courses|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"JAVA 8 is a major feature release of JAVA programming language development. Its initial version was released on 18 March 2014. With the Java 8 release, Java provided supports for functional programming, new JavaScript engine, new APIs for date time manipulation, new streaming API, etc.|||Lambda expression − Adds functional processing capability to Java.|||Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.|||Default method − Interface to have default method implementation.|||New tools − New compiler tools and utilities are added like ‘jdeps’ to figure out dependencies.|||Stream API − New stream API to facilitate pipeline processing.|||Date Time API − Improved date time API.|||Optional − Emphasis on best practices to handle null values properly.|||Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.|||Consider the following code snippet.|||Run the program to get the following result.|||Here the sortUsingJava8() method uses sort function with a lambda expression as parameter to get the sorting criteria.","Lambda expression − Adds functional processing capability to Java.@@@Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.@@@Default method − Interface to have default method implementation.@@@New tools − New compiler tools and utilities are added like ‘jdeps’ to figure out dependencies.@@@Stream API − New stream API to facilitate pipeline processing.@@@Date Time API − Improved date time API.@@@Optional − Emphasis on best practices to handle null values properly.@@@Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.",,,"import java.util.Collections;import java.util.List;import java.util.ArrayList;import java.util.Comparator;public class Java8Tester {   public static void main(String args[]) {         List<String> names1 = new ArrayList<String>();      names1.add(""Mahesh "");      names1.add(""Suresh "");      names1.add(""Ramesh "");      names1.add(""Naresh "");      names1.add(""Kalpesh "");		      List<String> names2 = new ArrayList<String>();      names2.add(""Mahesh "");      names2.add(""Suresh "");      names2.add(""Ramesh "");      names2.add(""Naresh "");      names2.add(""Kalpesh "");		      Java8Tester tester = new Java8Tester();      System.out.println(""Sort using Java 7 syntax: "");		      tester.sortUsingJava7(names1);      System.out.println(names1);      System.out.println(""Sort using Java 8 syntax: "");		      tester.sortUsingJava8(names2);      System.out.println(names2);   }      //sort using java 7   private void sortUsingJava7(List<String> names) {         Collections.sort(names, new Comparator<String>() {         @Override         public int compare(String s1, String s2) {            return s1.compareTo(s2);         }      });   }      //sort using java 8   private void sortUsingJava8(List<String> names) {      Collections.sort(names, (s1, s2) -> s1.compareTo(s2));   }}"
Learn Java-8,Java 8 - Environment Setup,"Java 8 - Environment Setup|||Local Environment Setup@@@Popular Java Editors@@@Useful Video Courses|||Setting Up the Path for Windows 2000/XP@@@Setting Up the Path for Windows 95/98/ME@@@Setting Up the Path for Linux, UNIX, Solaris, FreeBSD|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training","If you want to set up your own environment for Java programming language, then this section guides you through the whole process. Please follow the steps given below to set up your Java environment.|||Java SE can be downloaded for free from the following link −|||https://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html|||You download a version based on your operating system.|||Follow the instructions to download Java, and run the .exe to install Java on your machine. Once you have installed Java on your machine, you would need to set environment variables to point to correct installation directories.|||Assuming you have installed Java in c:\Program Files\java\jdk directory −|||Right-click on 'My Computer' and select 'Properties'.|||Click on the 'Environment variables' button under the 'Advanced' tab.|||Now, alter the 'Path' variable so that it also contains the path to the Java executable. For example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then change your path to read 'C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin'.|||Assuming you have installed Java in c:\Program Files\java\jdk directory −|||Edit the 'C:\autoexec.bat' file and add the following line at the end −|||SET PATH=%PATH%;C:\Program Files\java\jdk\bin|||Environment variable PATH should be set to point to where the Java binaries have been installed. Refer to your shell documentation if you have trouble doing this.|||For example, if you use bash as your shell, then you would add the following line at the end of your '.bashrc: export PATH=/path/to/java:$PATH'|||To write Java programs, you need a text editor. There are even more sophisticated IDEs available in the market. But for now, you can consider one of the following −|||Notepad − On Windows machine, you can use any simple text editor like Notepad (recommended for this tutorial) or TextPad.|||Netbeans − It is a Java IDE that is open-source and free. It can be downloaded from https://netbeans.org/index.html.|||Eclipse − It is also a Java IDE developed by the Eclipse open-source community and can be downloaded from https://www.eclipse.org/.","Right-click on 'My Computer' and select 'Properties'.@@@Click on the 'Environment variables' button under the 'Advanced' tab.@@@Now, alter the 'Path' variable so that it also contains the path to the Java executable. For example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then change your path to read 'C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin'.|||Edit the 'C:\autoexec.bat' file and add the following line at the end −
SET PATH=%PATH%;C:\Program Files\java\jdk\bin|||Notepad − On Windows machine, you can use any simple text editor like Notepad (recommended for this tutorial) or TextPad.@@@Netbeans − It is a Java IDE that is open-source and free. It can be downloaded from https://netbeans.org/index.html.@@@Eclipse − It is also a Java IDE developed by the Eclipse open-source community and can be downloaded from https://www.eclipse.org/.",,,
Learn Java-8,Java 8 - Lambda Expressions,Java 8 - Lambda Expressions|||Syntax@@@Lambda Expressions Example@@@Scope@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result@@@Scope Example@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Lambda expressions are introduced in Java 8 and are touted to be the biggest feature of Java 8. Lambda expression facilitates functional programming, and simplifies the development a lot.|||A lambda expression is characterized by the following syntax.|||Following are the important characteristics of a lambda expression.|||Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.|||Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.|||Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.|||Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Following are the important points to be considered in the above example.|||Lambda expressions are used primarily to define inline implementation of a functional interface, i.e., an interface with a single method only. In the above example, we've used various types of lambda expressions to define the operation method of MathOperation interface. Then we have defined the implementation of sayMessage of GreetingService.|||Lambda expression eliminates the need of anonymous class and gives a very simple yet powerful functional programming capability to Java.|||Using lambda expression, you can refer to any final variable or effectively final variable (which is assigned only once). Lambda expression throws a compilation error, if a variable is assigned a value the second time.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Java8Tester.java|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −","Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.@@@Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.@@@Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.@@@Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.|||Lambda expressions are used primarily to define inline implementation of a functional interface, i.e., an interface with a single method only. In the above example, we've used various types of lambda expressions to define the operation method of MathOperation interface. Then we have defined the implementation of sayMessage of GreetingService.@@@Lambda expression eliminates the need of anonymous class and gives a very simple yet powerful functional programming capability to Java.",,,"public class Java8Tester {   public static void main(String args[]) {      Java8Tester tester = new Java8Tester();		      //with type declaration      MathOperation addition = (int a, int b) -> a + b;		      //with out type declaration      MathOperation subtraction = (a, b) -> a - b;		      //with return statement along with curly braces      MathOperation multiplication = (int a, int b) -> { return a * b; };		      //without return statement and without curly braces      MathOperation division = (int a, int b) -> a / b;		      System.out.println(""10 + 5 = "" + tester.operate(10, 5, addition));      System.out.println(""10 - 5 = "" + tester.operate(10, 5, subtraction));      System.out.println(""10 x 5 = "" + tester.operate(10, 5, multiplication));      System.out.println(""10 / 5 = "" + tester.operate(10, 5, division));		      //without parenthesis      GreetingService greetService1 = message ->      System.out.println(""Hello "" + message);		      //with parenthesis      GreetingService greetService2 = (message) ->      System.out.println(""Hello "" + message);		      greetService1.sayMessage(""Mahesh"");      greetService2.sayMessage(""Suresh"");   }	   interface MathOperation {      int operation(int a, int b);   }	   interface GreetingService {      void sayMessage(String message);   }	   private int operate(int a, int b, MathOperation mathOperation) {      return mathOperation.operation(a, b);   }}|||public class Java8Tester {   final static String salutation = ""Hello! "";      public static void main(String args[]) {      GreetingService greetService1 = message ->       System.out.println(salutation + message);      greetService1.sayMessage(""Mahesh"");   }	   interface GreetingService {      void sayMessage(String message);   }}"
Learn Java-8,Java 8 - Method References,Java 8 - Method References|||Method Reference Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Method references help to point to methods by their names. A method reference is described using ""::"" symbol. A method reference can be used to point the following types of methods −|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Here we have passed System.out::println method as a static method reference.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −",Static methods@@@Instance methods@@@Constructors using new operator (TreeSet::new),,,"import java.util.List;import java.util.ArrayList;public class Java8Tester {   public static void main(String args[]) {      List names = new ArrayList();		      names.add(""Mahesh"");      names.add(""Suresh"");      names.add(""Ramesh"");      names.add(""Naresh"");      names.add(""Kalpesh"");		      names.forEach(System.out::println);   }}"
Learn Java-8,Java 8 - Functional Interfaces,Java 8 - Functional Interfaces|||Functional Interface Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Functional interfaces have a single functionality to exhibit. For example, a Comparable interface with a single method ‘compareTo’ is used for comparison purpose. Java 8 has defined a lot of functional interfaces to be used extensively in lambda expressions. Following is the list of functional interfaces defined in java.util.Function package.|||BiConsumer<T,U>|||Represents an operation that accepts two input arguments, and returns no result.|||BiFunction<T,U,R>|||Represents a function that accepts two arguments and produces a result.|||BinaryOperator<T>|||Represents an operation upon two operands of the same type, producing a result of the same type as the operands.|||BiPredicate<T,U>|||Represents a predicate (Boolean-valued function) of two arguments.|||BooleanSupplier|||Represents a supplier of Boolean-valued results.|||Consumer<T>|||Represents an operation that accepts a single input argument and returns no result.|||DoubleBinaryOperator|||Represents an operation upon two double-valued operands and producing a double-valued result.|||DoubleConsumer|||Represents an operation that accepts a single double-valued argument and returns no result.|||DoubleFunction<R>|||Represents a function that accepts a double-valued argument and produces a result.|||DoublePredicate|||Represents a predicate (Boolean-valued function) of one double-valued argument.|||DoubleSupplier|||Represents a supplier of double-valued results.|||DoubleToIntFunction|||Represents a function that accepts a double-valued argument and produces an int-valued result.|||DoubleToLongFunction|||Represents a function that accepts a double-valued argument and produces a long-valued result.|||DoubleUnaryOperator|||Represents an operation on a single double-valued operand that produces a double-valued result.|||Function<T,R>|||Represents a function that accepts one argument and produces a result.|||IntBinaryOperator|||Represents an operation upon two int-valued operands and produces an int-valued result.|||IntConsumer|||Represents an operation that accepts a single int-valued argument and returns no result.|||IntFunction<R>|||Represents a function that accepts an int-valued argument and produces a result.|||IntPredicate|||Represents a predicate (Boolean-valued function) of one int-valued argument.|||IntSupplier|||Represents a supplier of int-valued results.|||IntToDoubleFunction|||Represents a function that accepts an int-valued argument and produces a double-valued result.|||IntToLongFunction|||Represents a function that accepts an int-valued argument and produces a long-valued result.|||IntUnaryOperator|||Represents an operation on a single int-valued operand that produces an int-valued result.|||LongBinaryOperator|||Represents an operation upon two long-valued operands and produces a long-valued result.|||LongConsumer|||Represents an operation that accepts a single long-valued argument and returns no result.|||LongFunction<R>|||Represents a function that accepts a long-valued argument and produces a result.|||LongPredicate|||Represents a predicate (Boolean-valued function) of one long-valued argument.|||LongSupplier|||Represents a supplier of long-valued results.|||LongToDoubleFunction|||Represents a function that accepts a long-valued argument and produces a double-valued result.|||LongToIntFunction|||Represents a function that accepts a long-valued argument and produces an int-valued result.|||LongUnaryOperator|||Represents an operation on a single long-valued operand that produces a long-valued result.|||ObjDoubleConsumer<T>|||Represents an operation that accepts an object-valued and a double-valued argument, and returns no result.|||ObjIntConsumer<T>|||Represents an operation that accepts an object-valued and an int-valued argument, and returns no result.|||ObjLongConsumer<T>|||Represents an operation that accepts an object-valued and a long-valued argument, and returns no result.|||Predicate<T>|||Represents a predicate (Boolean-valued function) of one argument.|||Supplier<T>|||Represents a supplier of results.|||ToDoubleBiFunction<T,U>|||Represents a function that accepts two arguments and produces a double-valued result.|||ToDoubleFunction<T>|||Represents a function that produces a double-valued result.|||ToIntBiFunction<T,U>|||Represents a function that accepts two arguments and produces an int-valued result.|||ToIntFunction<T>|||Represents a function that produces an int-valued result.|||ToLongBiFunction<T,U>|||Represents a function that accepts two arguments and produces a long-valued result.|||ToLongFunction<T>|||Represents a function that produces a long-valued result.|||UnaryOperator<T>|||Represents an operation on a single operand that produces a result of the same type as its operand.|||Predicate <T> interface is a functional interface with a method test(Object) to return a Boolean value. This interface signifies that an object is tested to be true or false.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Here we've passed Predicate interface, which takes a single input and returns Boolean.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −",,,"Sr.No.@@@Interface & Description|||1@@@BiConsumer<T,U>
Represents an operation that accepts two input arguments, and returns no result.
|||2@@@BiFunction<T,U,R>
Represents a function that accepts two arguments and produces a result.
|||3@@@BinaryOperator<T>
Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
|||4@@@BiPredicate<T,U>
Represents a predicate (Boolean-valued function) of two arguments.
|||5@@@BooleanSupplier
Represents a supplier of Boolean-valued results.
|||6@@@Consumer<T>
Represents an operation that accepts a single input argument and returns no result.
|||7@@@DoubleBinaryOperator
Represents an operation upon two double-valued operands and producing a double-valued result.
|||8@@@DoubleConsumer
Represents an operation that accepts a single double-valued argument and returns no result.
|||9@@@DoubleFunction<R>
Represents a function that accepts a double-valued argument and produces a result.
|||10@@@DoublePredicate
Represents a predicate (Boolean-valued function) of one double-valued argument.
|||11@@@DoubleSupplier
Represents a supplier of double-valued results.
|||12@@@DoubleToIntFunction
Represents a function that accepts a double-valued argument and produces an int-valued result.
|||13@@@DoubleToLongFunction
Represents a function that accepts a double-valued argument and produces a long-valued result.
|||14@@@DoubleUnaryOperator
Represents an operation on a single double-valued operand that produces a double-valued result.
|||15@@@Function<T,R>
Represents a function that accepts one argument and produces a result.
|||16@@@IntBinaryOperator
Represents an operation upon two int-valued operands and produces an int-valued result.
|||17@@@IntConsumer
Represents an operation that accepts a single int-valued argument and returns no result.
|||18@@@IntFunction<R>
Represents a function that accepts an int-valued argument and produces a result.
|||19@@@IntPredicate
Represents a predicate (Boolean-valued function) of one int-valued argument.
|||20@@@IntSupplier
Represents a supplier of int-valued results.
|||21@@@IntToDoubleFunction
Represents a function that accepts an int-valued argument and produces a double-valued result.
|||22@@@IntToLongFunction
Represents a function that accepts an int-valued argument and produces a long-valued result.
|||23@@@IntUnaryOperator
Represents an operation on a single int-valued operand that produces an int-valued result.
|||24@@@LongBinaryOperator
Represents an operation upon two long-valued operands and produces a long-valued result.
|||25@@@LongConsumer
Represents an operation that accepts a single long-valued argument and returns no result.
|||26@@@LongFunction<R>
Represents a function that accepts a long-valued argument and produces a result.
|||27@@@LongPredicate
Represents a predicate (Boolean-valued function) of one long-valued argument.
|||28@@@LongSupplier
Represents a supplier of long-valued results.
|||29@@@LongToDoubleFunction
Represents a function that accepts a long-valued argument and produces a double-valued result.
|||30@@@LongToIntFunction
Represents a function that accepts a long-valued argument and produces an int-valued result.
|||31@@@LongUnaryOperator
Represents an operation on a single long-valued operand that produces a long-valued result.
|||32@@@ObjDoubleConsumer<T>
Represents an operation that accepts an object-valued and a double-valued argument, and returns no result.
|||33@@@ObjIntConsumer<T>
Represents an operation that accepts an object-valued and an int-valued argument, and returns no result.
|||34@@@ObjLongConsumer<T>
Represents an operation that accepts an object-valued and a long-valued argument, and returns no result.
|||35@@@Predicate<T>
Represents a predicate (Boolean-valued function) of one argument.
|||36@@@Supplier<T>
Represents a supplier of results.
|||37@@@ToDoubleBiFunction<T,U>
Represents a function that accepts two arguments and produces a double-valued result.
|||38@@@ToDoubleFunction<T>
Represents a function that produces a double-valued result.
|||39@@@ToIntBiFunction<T,U>
Represents a function that accepts two arguments and produces an int-valued result.
|||40@@@ToIntFunction<T>
Represents a function that produces an int-valued result.
|||41@@@ToLongBiFunction<T,U>
Represents a function that accepts two arguments and produces a long-valued result.
|||42@@@ToLongFunction<T>
Represents a function that produces a long-valued result.
|||43@@@UnaryOperator<T>
Represents an operation on a single operand that produces a result of the same type as its operand.
","import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class Java8Tester {   public static void main(String args[]) {      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);		      // Predicate<Integer> predicate = n -> true      // n is passed as parameter to test method of Predicate interface      // test method will always return true no matter what value n has.		      System.out.println(""Print all numbers:"");		      //pass n as parameter      eval(list, n->true);		      // Predicate<Integer> predicate1 = n -> n%2 == 0      // n is passed as parameter to test method of Predicate interface      // test method will return true if n%2 comes to be zero		      System.out.println(""Print even numbers:"");      eval(list, n-> n%2 == 0 );		      // Predicate<Integer> predicate2 = n -> n > 3      // n is passed as parameter to test method of Predicate interface      // test method will return true if n is greater than 3.		      System.out.println(""Print numbers greater than 3:"");      eval(list, n-> n > 3 );   }	   public static void eval(List<Integer> list, Predicate<Integer> predicate) {      for(Integer n: list) {         if(predicate.test(n)) {            System.out.println(n + "" "");         }      }   }}"
Learn Java-8,Java 8 - Default Methods,Java 8 - Default Methods|||Syntax@@@Multiple Defaults@@@Static Default Methods@@@Default Method Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Java 8 introduces a new concept of default method implementation in interfaces. This capability is added for backward compatibility so that old interfaces can be used to leverage the lambda expression capability of Java 8.|||For example, ‘List’ or ‘Collection’ interfaces do not have ‘forEach’ method declaration. Thus, adding such method will simply break the collection framework implementations. Java 8 introduces default method so that List/Collection interface can have a default implementation of forEach method, and the class implementing these interfaces need not implement the same.|||With default functions in interfaces, there is a possibility that a class is implementing two interfaces with same default methods. The following code explains how this ambiguity can be resolved.|||First solution is to create an own method that overrides the default implementation.|||Second solution is to call the default method of the specified interface using super.|||An interface can also have static helper methods from Java 8 onwards.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows -|||Now run the Java8Tester as follows -|||It should produce the following output -",,,,"public interface vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }}public interface fourWheeler {   default void print() {      System.out.println(""I am a four wheeler!"");   }}|||public class car implements vehicle, fourWheeler {   public void print() {      System.out.println(""I am a four wheeler car vehicle!"");   }}|||public class car implements vehicle, fourWheeler {   public void print() {      vehicle.super.print();   }}|||public interface vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }	   static void blowHorn() {      System.out.println(""Blowing horn!!!"");   }}|||public class Java8Tester {   public static void main(String args[]) {      Vehicle vehicle = new Car();      vehicle.print();   }}interface Vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }	   static void blowHorn() {      System.out.println(""Blowing horn!!!"");   }}interface FourWheeler {   default void print() {      System.out.println(""I am a four wheeler!"");   }}class Car implements Vehicle, FourWheeler {   public void print() {      Vehicle.super.print();      FourWheeler.super.print();      Vehicle.blowHorn();      System.out.println(""I am a car!"");   }}"
Learn Java-8,Java 8 - Streams,Java 8 - Streams|||What is Stream?@@@Generating Streams@@@forEach@@@map@@@filter@@@limit@@@sorted@@@Parallel Processing@@@Collectors@@@Statistics@@@Stream Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Stream is a new abstract layer introduced in Java 8. Using stream, you can process data in a declarative way similar to SQL statements. For example, consider the following SQL statement.|||The above SQL expression automatically returns the maximum salaried employee's details, without doing any computation on the developer's end. Using collections framework in Java, a developer has to use loops and make repeated checks. Another concern is efficiency; as multi-core processors are available at ease, a Java developer has to write parallel code processing that can be pretty error-prone.|||To resolve such issues, Java 8 introduced the concept of stream that lets the developer to process data declaratively and leverage multicore architecture without the need to write any specific code for it.|||Stream represents a sequence of objects from a source, which supports aggregate operations. Following are the characteristics of a Stream −|||Sequence of elements − A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. It never stores the elements.|||Source − Stream takes Collections, Arrays, or I/O resources as input source.|||Aggregate operations − Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.|||Pipelining − Most of the stream operations return stream itself so that their result can be pipelined. These operations are called intermediate operations and their function is to take input, process them, and return output to the target. collect() method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.|||Automatic iterations − Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.|||With Java 8, Collection interface has two methods to generate a Stream.|||stream() − Returns a sequential stream considering collection as its source.|||parallelStream() − Returns a parallel Stream considering collection as its source.|||Stream has provided a new method ‘forEach’ to iterate each element of the stream. The following code segment shows how to print 10 random numbers using forEach.|||The ‘map’ method is used to map each element to its corresponding result. The following code segment prints unique squares of numbers using map.|||The ‘filter’ method is used to eliminate elements based on a criteria. The following code segment prints a count of empty strings using filter.|||The ‘limit’ method is used to reduce the size of the stream. The following code segment shows how to print 10 random numbers using limit.|||The ‘sorted’ method is used to sort the stream. The following code segment shows how to print 10 random numbers in a sorted order.|||parallelStream is the alternative of stream for parallel processing. Take a look at the following code segment that prints a count of empty strings using parallelStream.|||It is very easy to switch between sequential and parallel streams.|||Collectors are used to combine the result of processing on the elements of a stream. Collectors can be used to return a list or a string.|||With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −","Sequence of elements − A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. It never stores the elements.@@@Source − Stream takes Collections, Arrays, or I/O resources as input source.@@@Aggregate operations − Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.@@@Pipelining − Most of the stream operations return stream itself so that their result can be pipelined. These operations are called intermediate operations and their function is to take input, process them, and return output to the target. collect() method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.@@@Automatic iterations − Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.|||stream() − Returns a sequential stream considering collection as its source.@@@parallelStream() − Returns a parallel Stream considering collection as its source.",,,"SELECT max(salary), employee_id, employee_name FROM Employee|||List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());|||Random random = new Random();random.ints().limit(10).forEach(System.out::println);|||List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);//get list of unique squaresList<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());|||List<String>strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");//get count of empty stringint count = strings.stream().filter(string -> string.isEmpty()).count();|||Random random = new Random();random.ints().limit(10).forEach(System.out::println);|||Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println);|||List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");//get count of empty stringlong count = strings.parallelStream().filter(string -> string.isEmpty()).count();|||List<String>strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());System.out.println(""Filtered List: "" + filtered);String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining("", ""));System.out.println(""Merged String: "" + mergedString);|||List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();System.out.println(""Highest number in List : "" + stats.getMax());System.out.println(""Lowest number in List : "" + stats.getMin());System.out.println(""Sum of all numbers : "" + stats.getSum());System.out.println(""Average of all numbers : "" + stats.getAverage());|||import java.util.ArrayList;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.Map;public class Java8Tester {   public static void main(String args[]) {      System.out.println(""Using Java 7: "");		      // Count empty strings      List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");      System.out.println(""List: "" +strings);      long count = getCountEmptyStringUsingJava7(strings);		      System.out.println(""Empty Strings: "" + count);      count = getCountLength3UsingJava7(strings);		      System.out.println(""Strings of length 3: "" + count);		      //Eliminate empty string      List<String> filtered = deleteEmptyStringsUsingJava7(strings);      System.out.println(""Filtered List: "" + filtered);		      //Eliminate empty string and join using comma.      String mergedString = getMergedStringUsingJava7(strings,"", "");      System.out.println(""Merged String: "" + mergedString);      List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);		      //get list of square of distinct numbers      List<Integer> squaresList = getSquares(numbers);      System.out.println(""Squares List: "" + squaresList);      List<Integer> integers = Arrays.asList(1,2,13,4,15,6,17,8,19);		      System.out.println(""List: "" +integers);      System.out.println(""Highest number in List : "" + getMax(integers));      System.out.println(""Lowest number in List : "" + getMin(integers));      System.out.println(""Sum of all numbers : "" + getSum(integers));      System.out.println(""Average of all numbers : "" + getAverage(integers));      System.out.println(""Random Numbers: "");		      //print ten random numbers      Random random = new Random();		      for(int i = 0; i < 10; i++) {         System.out.println(random.nextInt());      }		      System.out.println(""Using Java 8: "");      System.out.println(""List: "" +strings);		      count = strings.stream().filter(string->string.isEmpty()).count();      System.out.println(""Empty Strings: "" + count);		      count = strings.stream().filter(string -> string.length() == 3).count();      System.out.println(""Strings of length 3: "" + count);		      filtered = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.toList());      System.out.println(""Filtered List: "" + filtered);		      mergedString = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.joining("", ""));      System.out.println(""Merged String: "" + mergedString);		      squaresList = numbers.stream().map( i ->i*i).distinct().collect(Collectors.toList());      System.out.println(""Squares List: "" + squaresList);      System.out.println(""List: "" +integers);		      IntSummaryStatistics stats = integers.stream().mapToInt((x) ->x).summaryStatistics();		      System.out.println(""Highest number in List : "" + stats.getMax());      System.out.println(""Lowest number in List : "" + stats.getMin());      System.out.println(""Sum of all numbers : "" + stats.getSum());      System.out.println(""Average of all numbers : "" + stats.getAverage());      System.out.println(""Random Numbers: "");		      random.ints().limit(10).sorted().forEach(System.out::println);		      //parallel processing      count = strings.parallelStream().filter(string -> string.isEmpty()).count();      System.out.println(""Empty Strings: "" + count);   }	   private static int getCountEmptyStringUsingJava7(List<String> strings) {      int count = 0;      for(String string: strings) {		         if(string.isEmpty()) {            count++;         }      }      return count;   }	   private static int getCountLength3UsingJava7(List<String> strings) {      int count = 0;		      for(String string: strings) {		         if(string.length() == 3) {            count++;         }      }      return count;   }	   private static List<String> deleteEmptyStringsUsingJava7(List<String> strings) {      List<String> filteredList = new ArrayList<String>();		      for(String string: strings) {		         if(!string.isEmpty()) {             filteredList.add(string);         }      }      return filteredList;   }	   private static String getMergedStringUsingJava7(List<String> strings, String separator) {      StringBuilder stringBuilder = new StringBuilder();		      for(String string: strings) {		         if(!string.isEmpty()) {            stringBuilder.append(string);            stringBuilder.append(separator);         }      }      String mergedString = stringBuilder.toString();      return mergedString.substring(0, mergedString.length()-2);   }	   private static List<Integer> getSquares(List<Integer> numbers) {      List<Integer> squaresList = new ArrayList<Integer>();		      for(Integer number: numbers) {         Integer square = new Integer(number.intValue() * number.intValue());			         if(!squaresList.contains(square)) {            squaresList.add(square);         }      }      return squaresList;   }	   private static int getMax(List<Integer> numbers) {      int max = numbers.get(0);		      for(int i = 1;i < numbers.size();i++) {		         Integer number = numbers.get(i);			         if(number.intValue() > max) {            max = number.intValue();         }      }      return max;   }	   private static int getMin(List<Integer> numbers) {      int min = numbers.get(0);		      for(int i= 1;i < numbers.size();i++) {         Integer number = numbers.get(i);		         if(number.intValue() < min) {            min = number.intValue();         }      }      return min;   }	   private static int getSum(List numbers) {      int sum = (int)(numbers.get(0));		      for(int i = 1;i < numbers.size();i++) {         sum += (int)numbers.get(i);      }      return sum;   }	   private static int getAverage(List<Integer> numbers) {      return getSum(numbers) / numbers.size();   }}"
Learn Java-8,Java 8 - Optional Class,Java 8 - Optional Class|||Class Declaration@@@Class Method@@@Optional Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value. This class has various utility methods to facilitate code to handle values as ‘available’ or ‘not available’ instead of checking null values. It is introduced in Java 8 and is similar to what Optional is in Guava.|||Following is the declaration for java.util.Optional<T> class −|||static <T> Optional<T> empty()|||Returns an empty Optional instance.|||boolean equals(Object obj)|||Indicates whether some other object is ""equal to"" this Optional.|||Optional<T> filter(Predicate<? super <T> predicate)|||If a value is present and the value matches a given predicate, it returns an Optional describing the value, otherwise returns an empty Optional.|||<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)|||If a value is present, it applies the provided Optional-bearing mapping function to it, returns that result, otherwise returns an empty Optional.|||T get()|||If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.|||int hashCode()|||Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.|||void ifPresent(Consumer<? super T> consumer)|||If a value is present, it invokes the specified consumer with the value, otherwise does nothing.|||boolean isPresent()|||Returns true if there is a value present, otherwise false.|||<U>Optional<U> map(Function<? super T,? extends U> mapper)|||If a value is present, applies the provided mapping function to it, and if the result is non-null, returns an Optional describing the result.|||static <T> Optional<T> of(T value)|||Returns an Optional with the specified present non-null value.|||static <T> Optional<T> ofNullable(T value)|||Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.|||T orElse(T other)|||Returns the value if present, otherwise returns other.|||T orElseGet(Supplier<? extends T> other)|||Returns the value if present, otherwise invokes other and returns the result of that invocation.|||<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)|||Returns the contained value, if present, otherwise throws an exception to be created by the provided supplier.|||String toString()|||Returns a non-empty string representation of this Optional suitable for debugging.|||This class inherits methods from the following class −|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −",java.lang.Object,,"Sr.No.@@@Method & Description|||1@@@static <T> Optional<T> empty()
Returns an empty Optional instance.|||2@@@boolean equals(Object obj)
Indicates whether some other object is ""equal to"" this Optional.|||3@@@Optional<T> filter(Predicate<? super <T> predicate)
If a value is present and the value matches a given predicate, it returns an Optional describing the value, otherwise returns an empty Optional.|||4@@@<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)
If a value is present, it applies the provided Optional-bearing mapping function to it, returns that result, otherwise returns an empty Optional.|||5@@@T get()
If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.|||6@@@int hashCode()
Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.|||7@@@void ifPresent(Consumer<? super T> consumer)
If a value is present, it invokes the specified consumer with the value, otherwise does nothing.|||8@@@boolean isPresent()
Returns true if there is a value present, otherwise false.|||9@@@<U>Optional<U> map(Function<? super T,? extends U> mapper)
If a value is present, applies the provided mapping function to it, and if the result is non-null, returns an Optional describing the result.|||10@@@static <T> Optional<T> of(T value)
Returns an Optional with the specified present non-null value.|||11@@@static <T> Optional<T> ofNullable(T value)
Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.|||12@@@T orElse(T other)
Returns the value if present, otherwise returns other.|||13@@@T orElseGet(Supplier<? extends T> other)
Returns the value if present, otherwise invokes other and returns the result of that invocation.|||14@@@<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)
Returns the contained value, if present, otherwise throws an exception to be created by the provided supplier.|||15@@@String toString()
Returns a non-empty string representation of this Optional suitable for debugging.","import java.util.Optional;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8Tester = new Java8Tester();      Integer value1 = null;      Integer value2 = new Integer(10);		      //Optional.ofNullable - allows passed parameter to be null.      Optional<Integer> a = Optional.ofNullable(value1);		      //Optional.of - throws NullPointerException if passed parameter is null      Optional<Integer> b = Optional.of(value2);      System.out.println(java8Tester.sum(a,b));   }	   public Integer sum(Optional<Integer> a, Optional<Integer> b) {      //Optional.isPresent - checks the value is present or not		      System.out.println(""First parameter is present: "" + a.isPresent());      System.out.println(""Second parameter is present: "" + b.isPresent());		      //Optional.orElse - returns the value if present otherwise returns      //the default value passed.      Integer value1 = a.orElse(new Integer(0));		      //Optional.get - gets the value, value should be present      Integer value2 = b.get();      return value1 + value2;   }}"
Learn Java-8,Java 8 - Nashorn JavaScript,Java 8 - Nashorn JavaScript|||jjs@@@Calling JavaScript from Java@@@Calling Java from JavaScript@@@Useful Video Courses|||Interpreting js File@@@sample.js@@@jjs in Interactive Mode@@@Pass Arguments@@@Example@@@Java8Tester.java@@@Verify the Result@@@sample.js|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"With Java 8, Nashorn, a much improved javascript engine is introduced, to replace the existing Rhino. Nashorn provides 2 to 10 times better performance, as it directly compiles the code in memory and passes the bytecode to JVM. Nashorn uses invoke dynamics feature, introduced in Java 7 to improve performance.|||For Nashorn engine, JAVA 8 introduces a new command line tool, jjs, to execute javascript codes at console.|||Create and save the file sample.js in c:\> JAVA folder.|||Open console and use the following command.|||It will produce the following output:|||Open the console and use the following command.|||Open the console and use the following command.|||Using ScriptEngineManager, JavaScript code can be called and interpreted in Java.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||The following example explains how to import and use Java classes in java script.|||Create and save sample.js in c:\> JAVA folder.|||Open the console and use the following command.|||It should produce the following output −",,,,"print('Hello World!');|||import javax.script.ScriptEngineManager;import javax.script.ScriptEngine;import javax.script.ScriptException;public class Java8Tester {   public static void main(String args[]) {      ScriptEngineManager scriptEngineManager = new ScriptEngineManager();      ScriptEngine nashorn = scriptEngineManager.getEngineByName(""nashorn"");		      String name = ""Mahesh"";      Integer result = null;            try {         nashorn.eval(""print('"" + name + ""')"");         result = (Integer) nashorn.eval(""10 + 2"");               } catch(ScriptException e) {         System.out.println(""Error executing script: ""+ e.getMessage());      }      System.out.println(result.toString());   }}|||var BigDecimal = Java.type('java.math.BigDecimal');function calculate(amount, percentage) {   var result = new BigDecimal(amount).multiply(new BigDecimal(percentage)).divide(      new BigDecimal(""100""), 2, BigDecimal.ROUND_HALF_EVEN);      return result.toPlainString();}var result = calculate(568000000000000000023,13.9);print(result);"
Learn Java-8,Java 8 - New Date/Time API,Java 8 - New Date/Time API|||Local Date-Time API@@@Zoned Date-Time API@@@Chrono Units Enum@@@Period and Duration@@@Temporal Adjusters@@@Backward Compatibility@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"With Java 8, a new Date-Time API is introduced to cover the following drawbacks of old date-time API.|||Not thread safe − java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. The new date-time API is immutable and does not have setter methods.|||Poor design − Default Date starts from 1900, month starts from 1, and day starts from 0, so no uniformity. The old API had less direct methods for date operations. The new API provides numerous utility methods for such operations.|||Difficult time zone handling − Developers had to write a lot of code to deal with timezone issues. The new API has been developed keeping domain-specific design in mind.|||Java 8 introduces a new date-time API under the package java.time. Following are some of the important classes introduced in java.time package.|||Local − Simplified date-time API with no complexity of timezone handling.|||Zoned − Specialized date-time API to deal with various timezones.|||LocalDate/LocalTime and LocalDateTime classes simplify the development where timezones are not required. Let's see them in action.|||Create the following java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Zoned date-time API is to be used when time zone is to be considered. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||java.time.temporal.ChronoUnit enum is added in Java 8 to replace the integer values used in old API to represent day, month, etc. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||With Java 8, two specialized classes are introduced to deal with the time differences.|||Period − It deals with date based amount of time.|||Duration − It deals with time based amount of time.|||Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||TemporalAdjuster is used to perform the date mathematics. For example, get the ""Second Saturday of the Month"" or ""Next Tuesday"". Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||A toInstant() method is added to the original Date and Calendar objects, which can be used to convert them to the new Date-Time API. Use an ofInstant(Insant,ZoneId) method to get a LocalDateTime or ZonedDateTime object. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −","Not thread safe − java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. The new date-time API is immutable and does not have setter methods.@@@Poor design − Default Date starts from 1900, month starts from 1, and day starts from 0, so no uniformity. The old API had less direct methods for date operations. The new API provides numerous utility methods for such operations.@@@Difficult time zone handling − Developers had to write a lot of code to deal with timezone issues. The new API has been developed keeping domain-specific design in mind.|||Local − Simplified date-time API with no complexity of timezone handling.@@@Zoned − Specialized date-time API to deal with various timezones.|||Period − It deals with date based amount of time.@@@Duration − It deals with time based amount of time.",,,"import java.time.LocalDate;import java.time.LocalTime;import java.time.LocalDateTime;import java.time.Month;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testLocalDateTime();   }	   public void testLocalDateTime() {      // Get the current date and time      LocalDateTime currentTime = LocalDateTime.now();      System.out.println(""Current DateTime: "" + currentTime);		      LocalDate date1 = currentTime.toLocalDate();      System.out.println(""date1: "" + date1);		      Month month = currentTime.getMonth();      int day = currentTime.getDayOfMonth();      int seconds = currentTime.getSecond();		      System.out.println(""Month: "" + month +""day: "" + day +""seconds: "" + seconds);		      LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);      System.out.println(""date2: "" + date2);		      //12 december 2014      LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);      System.out.println(""date3: "" + date3);		      //22 hour 15 minutes      LocalTime date4 = LocalTime.of(22, 15);      System.out.println(""date4: "" + date4);		      //parse a string      LocalTime date5 = LocalTime.parse(""20:15:30"");      System.out.println(""date5: "" + date5);   }}|||import java.time.ZonedDateTime;import java.time.ZoneId;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testZonedDateTime();   }	   public void testZonedDateTime() {      // Get the current date and time      ZonedDateTime date1 = ZonedDateTime.parse(""2007-12-03T10:15:30+05:30[Asia/Karachi]"");      System.out.println(""date1: "" + date1);		      ZoneId id = ZoneId.of(""Europe/Paris"");      System.out.println(""ZoneId: "" + id);		      ZoneId currentZone = ZoneId.systemDefault();      System.out.println(""CurrentZone: "" + currentZone);   }}|||import java.time.LocalDate;import java.time.temporal.ChronoUnit;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testChromoUnits();   }	   public void testChromoUnits() {      //Get the current date      LocalDate today = LocalDate.now();      System.out.println(""Current date: "" + today);		      //add 1 week to the current date      LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);      System.out.println(""Next week: "" + nextWeek);		      //add 1 month to the current date      LocalDate nextMonth = today.plus(1, ChronoUnit.MONTHS);      System.out.println(""Next month: "" + nextMonth);		      //add 1 year to the current date      LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);      System.out.println(""Next year: "" + nextYear);		      //add 10 years to the current date      LocalDate nextDecade = today.plus(1, ChronoUnit.DECADES);      System.out.println(""Date after ten year: "" + nextDecade);   }}|||import java.time.temporal.ChronoUnit;import java.time.LocalDate;import java.time.LocalTime;import java.time.Duration;import java.time.Period;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testPeriod();      java8tester.testDuration();   }	   public void testPeriod() {      //Get the current date      LocalDate date1 = LocalDate.now();      System.out.println(""Current date: "" + date1);		      //add 1 month to the current date      LocalDate date2 = date1.plus(1, ChronoUnit.MONTHS);      System.out.println(""Next month: "" + date2);            Period period = Period.between(date2, date1);      System.out.println(""Period: "" + period);   }	   public void testDuration() {      LocalTime time1 = LocalTime.now();      Duration twoHours = Duration.ofHours(2);		      LocalTime time2 = time1.plus(twoHours);      Duration duration = Duration.between(time1, time2);		      System.out.println(""Duration: "" + duration);   }}|||import java.time.LocalDate;import java.time.temporal.TemporalAdjusters;import java.time.DayOfWeek;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testAdjusters();   }	   public void testAdjusters() {      //Get the current date      LocalDate date1 = LocalDate.now();      System.out.println(""Current date: "" + date1);		      //get the next tuesday      LocalDate nextTuesday = date1.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));      System.out.println(""Next Tuesday on : "" + nextTuesday);		      //get the second saturday of next month      LocalDate firstInYear = LocalDate.of(date1.getYear(),date1.getMonth(), 1);      LocalDate secondSaturday = firstInYear.with(TemporalAdjusters.nextOrSame(         DayOfWeek.SATURDAY)).with(TemporalAdjusters.next(DayOfWeek.SATURDAY));      System.out.println(""Second Saturday on : "" + secondSaturday);   }}|||import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.util.Date;import java.time.Instant;import java.time.ZoneId;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testBackwardCompatability();   }	   public void testBackwardCompatability() {      //Get the current date      Date currentDate = new Date();      System.out.println(""Current date: "" + currentDate);		      //Get the instant of current date in terms of milliseconds      Instant now = currentDate.toInstant();      ZoneId currentZone = ZoneId.systemDefault();		      LocalDateTime localDateTime = LocalDateTime.ofInstant(now, currentZone);      System.out.println(""Local date: "" + localDateTime);		      ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(now, currentZone);      System.out.println(""Zoned date: "" + zonedDateTime);   }}"
Learn Java-8,Java 8 - Base64,Java 8 - Base64|||Nested Classes@@@Methods@@@Methods Inherited@@@Base64 Example@@@Useful Video Courses|||Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"With Java 8, Base64 has finally got its due. Java 8 now has inbuilt encoder and decoder for Base64 encoding. In Java 8, we can use three types of Base64 encoding.|||Simple − Output is mapped to a set of characters lying in A-Za-z0-9+/. The encoder does not add any line feed in output, and the decoder rejects any character other than A-Za-z0-9+/.|||URL − Output is mapped to set of characters lying in A-Za-z0-9+_. Output is URL and filename safe.|||MIME − Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, and uses a carriage return '\r' followed by a linefeed '\n' as the line separator. No line separator is present to the end of the encoded output.|||static class Base64.Decoder|||This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||static class Base64.Encoder|||This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||static Base64.Decoder getDecoder()|||Returns a Base64.Decoder that decodes using the Basic type base64 encoding scheme.|||static Base64.Encoder getEncoder()|||Returns a Base64.Encoder that encodes using the Basic type base64 encoding scheme.|||static Base64.Decoder getMimeDecoder()|||Returns a Base64.Decoder that decodes using the MIME type base64 decoding scheme.|||static Base64.Encoder getMimeEncoder()|||Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme.|||static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)|||Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators.|||static Base64.Decoder getUrlDecoder()|||Returns a Base64.Decoder that decodes using the URL and Filename safe type base64 encoding scheme.|||static Base64.Encoder getUrlEncoder()|||Returns a Base64.Encoder that encodes using the URL and Filename safe type base64 encoding scheme.|||This class inherits methods from the following class −|||Create the following Java program using any editor of your choice in say C:/> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −","Simple − Output is mapped to a set of characters lying in A-Za-z0-9+/. The encoder does not add any line feed in output, and the decoder rejects any character other than A-Za-z0-9+/.@@@URL − Output is mapped to set of characters lying in A-Za-z0-9+_. Output is URL and filename safe.@@@MIME − Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, and uses a carriage return '\r' followed by a linefeed '\n' as the line separator. No line separator is present to the end of the encoded output.|||java.lang.Object",,"Sr.No.@@@Nested class & Description|||1@@@static class Base64.Decoder
This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||2@@@static class Base64.Encoder
This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.&&&Sr.No.@@@Method Name & Description|||1@@@static Base64.Decoder getDecoder()
Returns a Base64.Decoder that decodes using the Basic type base64 encoding scheme.|||2@@@static Base64.Encoder getEncoder()
Returns a Base64.Encoder that encodes using the Basic type base64 encoding scheme.|||3@@@static Base64.Decoder getMimeDecoder()
Returns a Base64.Decoder that decodes using the MIME type base64 decoding scheme.|||4@@@static Base64.Encoder getMimeEncoder()
Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme.|||5@@@static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)
Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators.|||6@@@static Base64.Decoder getUrlDecoder()
Returns a Base64.Decoder that decodes using the URL and Filename safe type base64 encoding scheme.|||7@@@static Base64.Encoder getUrlEncoder()
Returns a Base64.Encoder that encodes using the URL and Filename safe type base64 encoding scheme.","import java.util.Base64;import java.util.UUID;import java.io.UnsupportedEncodingException;public class HelloWorld {   public static void main(String args[]) {      try {		         // Encode using basic encoder         String base64encodedString = Base64.getEncoder().encodeToString(            ""TutorialsPoint?java8"".getBytes(""utf-8""));         System.out.println(""Base64 Encoded String (Basic) :"" + base64encodedString);		         // Decode         byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);		         System.out.println(""Original String: "" + new String(base64decodedBytes, ""utf-8""));         base64encodedString = Base64.getUrlEncoder().encodeToString(            ""TutorialsPoint?java8"".getBytes(""utf-8""));         System.out.println(""Base64 Encoded String (URL) :"" + base64encodedString);		         StringBuilder stringBuilder = new StringBuilder();		         for (int i = 0; i < 10; ++i) {            stringBuilder.append(UUID.randomUUID().toString());         }		         byte[] mimeBytes = stringBuilder.toString().getBytes(""utf-8"");         String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);         System.out.println(""Base64 Encoded String (MIME) :"" + mimeEncodedString);      } catch(UnsupportedEncodingException e) {         System.out.println(""Error :"" + e.getMessage());      }   }}"
Learn Java-8,Java 8 Questions and Answers,Java 8 Questions and Answers|||Useful Video Courses|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,"Java 8 Questions and Answers has been designed with a special intention of helping students and professionals preparing for various Certification Exams and Job Interviews. This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.|||This section provides a huge collection of Java 8 Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.|||This section provides a great collection of Java 8 Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.|||If you are preparing to appear for a Java and Java 8 related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.|||This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.",,,"SN@@@Question/Answers Type|||1@@@Java 8 Interview Questions
This section provides a huge collection of Java 8 Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.
|||2@@@Java 8 Online Quiz
This section provides a great collection of Java 8 Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.
|||3@@@Java 8 Online Test
If you are preparing to appear for a Java and Java 8 related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.
|||4@@@Java 8 Mock Test
This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.
",
Learn Java-8,Java 8 - Quick Guide,"Java 8 - Quick Guide@@@Java 8 - Overview@@@Java 8 - Environment Setup@@@Java 8 - Lambda Expressions@@@Java 8 - Method References@@@Java 8 - Functional Interfaces@@@Java 8 - Default Methods@@@Java 8 - Streams@@@Java 8 - Optional Class@@@Java 8 - Nashorn JavaScript@@@Java 8 - New Date/Time API@@@Java 8 - Base64|||New Features@@@Local Environment Setup@@@Popular Java Editors@@@Syntax@@@Lambda Expressions Example@@@Scope@@@Method Reference Example@@@Functional Interface Example@@@Syntax@@@Multiple Defaults@@@Static Default Methods@@@Default Method Example@@@What is Stream?@@@Generating Streams@@@forEach@@@map@@@filter@@@limit@@@sorted@@@Parallel Processing@@@Collectors@@@Statistics@@@Stream Example@@@Class Declaration@@@Class Method@@@Optional Example@@@jjs@@@Calling JavaScript from Java@@@Calling Java from JavaScript@@@Local Date-Time API@@@Zoned Date-Time API@@@Chrono Units Enum@@@Period and Duration@@@Temporal Adjusters@@@Backward Compatibility@@@Nested Classes@@@Methods@@@Methods Inherited@@@Base64 Example@@@Useful Video Courses|||Setting Up the Path for Windows 2000/XP@@@Setting Up the Path for Windows 95/98/ME@@@Setting Up the Path for Linux, UNIX, Solaris, FreeBSD@@@Java8Tester.java@@@Verify the Result@@@Scope Example@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Interpreting js File@@@sample.js@@@jjs in Interactive Mode@@@Pass Arguments@@@Example@@@Java8Tester.java@@@Verify the Result@@@sample.js@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result@@@Java8Tester.java@@@Verify the Result|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training","JAVA 8 is a major feature release of JAVA programming language development. Its initial version was released on 18 March 2014. With the Java 8 release, Java provided supports for functional programming, new JavaScript engine, new APIs for date time manipulation, new streaming API, etc.|||Lambda expression − Adds functional processing capability to Java.|||Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.|||Default method − Interface to have default method implementation.|||New tools − New compiler tools and utilities are added like ‘jdeps’ to figure out dependencies.|||Stream API − New stream API to facilitate pipeline processing.|||Date Time API − Improved date time API.|||Optional − Emphasis on best practices to handle null values properly.|||Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.|||Consider the following code snippet.|||Run the program to get the following result.|||Here the sortUsingJava8() method uses sort function with a lambda expression as parameter to get the sorting criteria.|||If you want to set up your own environment for Java programming language, then this section guides you through the whole process. Please follow the steps given below to set up your Java environment.|||Java SE can be downloaded for free from the following link −|||https://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html|||You download a version based on your operating system.|||Follow the instructions to download Java, and run the .exe to install Java on your machine. Once you have installed Java on your machine, you would need to set environment variables to point to correct installation directories.|||Assuming you have installed Java in c:\Program Files\java\jdk directory −|||Right-click on 'My Computer' and select 'Properties'.|||Click on the 'Environment variables' button under the 'Advanced' tab.|||Now, alter the 'Path' variable so that it also contains the path to the Java executable. For example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then change your path to read 'C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin'.|||Assuming you have installed Java in c:\Program Files\java\jdk directory −|||Edit the 'C:\autoexec.bat' file and add the following line at the end −|||SET PATH=%PATH%;C:\Program Files\java\jdk\bin|||Environment variable PATH should be set to point to where the Java binaries have been installed. Refer to your shell documentation if you have trouble doing this.|||For example, if you use bash as your shell, then you would add the following line at the end of your '.bashrc: export PATH=/path/to/java:$PATH'|||To write Java programs, you need a text editor. There are even more sophisticated IDEs available in the market. But for now, you can consider one of the following −|||Notepad − On Windows machine, you can use any simple text editor like Notepad (recommended for this tutorial) or TextPad.|||Netbeans − It is a Java IDE that is open-source and free. It can be downloaded from https://netbeans.org/index.html.|||Eclipse − It is also a Java IDE developed by the Eclipse open-source community and can be downloaded from https://www.eclipse.org/.|||Lambda expressions are introduced in Java 8 and are touted to be the biggest feature of Java 8. Lambda expression facilitates functional programming, and simplifies the development a lot.|||A lambda expression is characterized by the following syntax.|||Following are the important characteristics of a lambda expression.|||Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.|||Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.|||Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.|||Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Following are the important points to be considered in the above example.|||Lambda expressions are used primarily to define inline implementation of a functional interface, i.e., an interface with a single method only. In the above example, we've used various types of lambda expressions to define the operation method of MathOperation interface. Then we have defined the implementation of sayMessage of GreetingService.|||Lambda expression eliminates the need of anonymous class and gives a very simple yet powerful functional programming capability to Java.|||Using lambda expression, you can refer to any final variable or effectively final variable (which is assigned only once). Lambda expression throws a compilation error, if a variable is assigned a value the second time.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Java8Tester.java|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Method references help to point to methods by their names. A method reference is described using ""::"" symbol. A method reference can be used to point the following types of methods −|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Here we have passed System.out::println method as a static method reference.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Functional interfaces have a single functionality to exhibit. For example, a Comparable interface with a single method ‘compareTo’ is used for comparison purpose. Java 8 has defined a lot of functional interfaces to be used extensively in lambda expressions. Following is the list of functional interfaces defined in java.util.Function package.|||BiConsumer<T,U>|||Represents an operation that accepts two input arguments, and returns no result.|||BiFunction<T,U,R>|||Represents a function that accepts two arguments and produces a result.|||BinaryOperator<T>|||Represents an operation upon two operands of the same type, producing a result of the same type as the operands.|||BiPredicate<T,U>|||Represents a predicate (Boolean-valued function) of two arguments.|||BooleanSupplier|||Represents a supplier of Boolean-valued results.|||Consumer<T>|||Represents an operation that accepts a single input argument and returns no result.|||DoubleBinaryOperator|||Represents an operation upon two double-valued operands and producing a double-valued result.|||DoubleConsumer|||Represents an operation that accepts a single double-valued argument and returns no result.|||DoubleFunction<R>|||Represents a function that accepts a double-valued argument and produces a result.|||DoublePredicate|||Represents a predicate (Boolean-valued function) of one double-valued argument.|||DoubleSupplier|||Represents a supplier of double-valued results.|||DoubleToIntFunction|||Represents a function that accepts a double-valued argument and produces an int-valued result.|||DoubleToLongFunction|||Represents a function that accepts a double-valued argument and produces a long-valued result.|||DoubleUnaryOperator|||Represents an operation on a single double-valued operand that produces a double-valued result.|||Function<T,R>|||Represents a function that accepts one argument and produces a result.|||IntBinaryOperator|||Represents an operation upon two int-valued operands and produces an int-valued result.|||IntConsumer|||Represents an operation that accepts a single int-valued argument and returns no result.|||IntFunction<R>|||Represents a function that accepts an int-valued argument and produces a result.|||IntPredicate|||Represents a predicate (Boolean-valued function) of one int-valued argument.|||IntSupplier|||Represents a supplier of int-valued results.|||IntToDoubleFunction|||Represents a function that accepts an int-valued argument and produces a double-valued result.|||IntToLongFunction|||Represents a function that accepts an int-valued argument and produces a long-valued result.|||IntUnaryOperator|||Represents an operation on a single int-valued operand that produces an int-valued result.|||LongBinaryOperator|||Represents an operation upon two long-valued operands and produces a long-valued result.|||LongConsumer|||Represents an operation that accepts a single long-valued argument and returns no result.|||LongFunction<R>|||Represents a function that accepts a long-valued argument and produces a result.|||LongPredicate|||Represents a predicate (Boolean-valued function) of one long-valued argument.|||LongSupplier|||Represents a supplier of long-valued results.|||LongToDoubleFunction|||Represents a function that accepts a long-valued argument and produces a double-valued result.|||LongToIntFunction|||Represents a function that accepts a long-valued argument and produces an int-valued result.|||LongUnaryOperator|||Represents an operation on a single long-valued operand that produces a long-valued result.|||ObjDoubleConsumer<T>|||Represents an operation that accepts an object-valued and a double-valued argument, and returns no result.|||ObjIntConsumer<T>|||Represents an operation that accepts an object-valued and an int-valued argument, and returns no result.|||ObjLongConsumer<T>|||Represents an operation that accepts an object-valued and a long-valued argument, and returns no result.|||Predicate<T>|||Represents a predicate (Boolean-valued function) of one argument.|||Supplier<T>|||Represents a supplier of results.|||ToDoubleBiFunction<T,U>|||Represents a function that accepts two arguments and produces a double-valued result.|||ToDoubleFunction<T>|||Represents a function that produces a double-valued result.|||ToIntBiFunction<T,U>|||Represents a function that accepts two arguments and produces an int-valued result.|||ToIntFunction<T>|||Represents a function that produces an int-valued result.|||ToLongBiFunction<T,U>|||Represents a function that accepts two arguments and produces a long-valued result.|||ToLongFunction<T>|||Represents a function that produces a long-valued result.|||UnaryOperator<T>|||Represents an operation on a single operand that produces a result of the same type as its operand.|||Predicate <T> interface is a functional interface with a method test(Object) to return a Boolean value. This interface signifies that an object is tested to be true or false.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Here we've passed Predicate interface, which takes a single input and returns Boolean.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Java 8 introduces a new concept of default method implementation in interfaces. This capability is added for backward compatibility so that old interfaces can be used to leverage the lambda expression capability of Java 8.|||For example, ‘List’ or ‘Collection’ interfaces do not have ‘forEach’ method declaration. Thus, adding such method will simply break the collection framework implementations. Java 8 introduces default method so that List/Collection interface can have a default implementation of forEach method, and the class implementing these interfaces need not implement the same.|||With default functions in interfaces, there is a possibility that a class is implementing two interfaces with same default methods. The following code explains how this ambiguity can be resolved.|||First solution is to create an own method that overrides the default implementation.|||Second solution is to call the default method of the specified interface using super.|||An interface can also have static helper methods from Java 8 onwards.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Stream is a new abstract layer introduced in Java 8. Using stream, you can process data in a declarative way similar to SQL statements. For example, consider the following SQL statement.|||The above SQL expression automatically returns the maximum salaried employee's details, without doing any computation on the developer's end. Using collections framework in Java, a developer has to use loops and make repeated checks. Another concern is efficiency; as multi-core processors are available at ease, a Java developer has to write parallel code processing that can be pretty error-prone.|||To resolve such issues, Java 8 introduced the concept of stream that lets the developer to process data declaratively and leverage multicore architecture without the need to write any specific code for it.|||Stream represents a sequence of objects from a source, which supports aggregate operations. Following are the characteristics of a Stream −|||Sequence of elements − A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. It never stores the elements.|||Source − Stream takes Collections, Arrays, or I/O resources as input source.|||Aggregate operations − Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.|||Pipelining − Most of the stream operations return stream itself so that their result can be pipelined. These operations are called intermediate operations and their function is to take input, process them, and return output to the target. collect() method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.|||Automatic iterations − Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.|||With Java 8, Collection interface has two methods to generate a Stream.|||stream() − Returns a sequential stream considering collection as its source.|||parallelStream() − Returns a parallel Stream considering collection as its source.|||Stream has provided a new method ‘forEach’ to iterate each element of the stream. The following code segment shows how to print 10 random numbers using forEach.|||The ‘map’ method is used to map each element to its corresponding result. The following code segment prints unique squares of numbers using map.|||The ‘filter’ method is used to eliminate elements based on a criteria. The following code segment prints a count of empty strings using filter.|||The ‘limit’ method is used to reduce the size of the stream. The following code segment shows how to print 10 random numbers using limit.|||The ‘sorted’ method is used to sort the stream. The following code segment shows how to print 10 random numbers in a sorted order.|||parallelStream is the alternative of stream for parallel processing. Take a look at the following code segment that prints a count of empty strings using parallelStream.|||It is very easy to switch between sequential and parallel streams.|||Collectors are used to combine the result of processing on the elements of a stream. Collectors can be used to return a list or a string.|||With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||Optional is a container object used to contain not-null objects. Optional object is used to represent null with absent value. This class has various utility methods to facilitate code to handle values as ‘available’ or ‘not available’ instead of checking null values. It is introduced in Java 8 and is similar to what Optional is in Guava.|||Following is the declaration for java.util.Optional<T> class −|||static <T> Optional<T> empty()|||Returns an empty Optional instance.|||boolean equals(Object obj)|||Indicates whether some other object is ""equal to"" this Optional.|||Optional<T> filter(Predicate<? super <T> predicate)|||If a value is present and the value matches a given predicate, it returns an Optional describing the value, otherwise returns an empty Optional.|||<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)|||If a value is present, it applies the provided Optional-bearing mapping function to it, returns that result, otherwise returns an empty Optional.|||T get()|||If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.|||int hashCode()|||Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.|||void ifPresent(Consumer<? super T> consumer)|||If a value is present, it invokes the specified consumer with the value, otherwise does nothing.|||boolean isPresent()|||Returns true if there is a value present, otherwise false.|||<U>Optional<U> map(Function<? super T,? extends U> mapper)|||If a value is present, applies the provided mapping function to it, and if the result is non-null, returns an Optional describing the result.|||static <T> Optional<T> of(T value)|||Returns an Optional with the specified present non-null value.|||static <T> Optional<T> ofNullable(T value)|||Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.|||T orElse(T other)|||Returns the value if present, otherwise returns other.|||T orElseGet(Supplier<? extends T> other)|||Returns the value if present, otherwise invokes other and returns the result of that invocation.|||<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)|||Returns the contained value, if present, otherwise throws an exception to be created by the provided supplier.|||String toString()|||Returns a non-empty string representation of this Optional suitable for debugging.|||This class inherits methods from the following class −|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||With Java 8, Nashorn, a much improved javascript engine is introduced, to replace the existing Rhino. Nashorn provides 2 to 10 times better performance, as it directly compiles the code in memory and passes the bytecode to JVM. Nashorn uses invoke dynamics feature, introduced in Java 7 to improve performance.|||For Nashorn engine, JAVA 8 introduces a new command line tool, jjs, to execute javascript codes at console.|||Create and save the file sample.js in c:\> JAVA folder.|||Open console and use the following command.|||It will produce the following output:|||Open the console and use the following command.|||Open the console and use the following command.|||Using ScriptEngineManager, JavaScript code can be called and interpreted in Java.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||The following example explains how to import and use Java classes in java script.|||Create and save sample.js in c:\> JAVA folder.|||Open the console and use the following command.|||It should produce the following output −|||With Java 8, a new Date-Time API is introduced to cover the following drawbacks of old date-time API.|||Not thread safe − java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. The new date-time API is immutable and does not have setter methods.|||Poor design − Default Date starts from 1900, month starts from 1, and day starts from 0, so no uniformity. The old API had less direct methods for date operations. The new API provides numerous utility methods for such operations.|||Difficult time zone handling − Developers had to write a lot of code to deal with timezone issues. The new API has been developed keeping domain-specific design in mind.|||Java 8 introduces a new date-time API under the package java.time. Following are some of the important classes introduced in java.time package.|||Local − Simplified date-time API with no complexity of timezone handling.|||Zoned − Specialized date-time API to deal with various timezones.|||LocalDate/LocalTime and LocalDateTime classes simplify the development where timezones are not required. Let's see them in action.|||Create the following java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||Zoned date-time API is to be used when time zone is to be considered. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||java.time.temporal.ChronoUnit enum is added in Java 8 to replace the integer values used in old API to represent day, month, etc. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||With Java 8, two specialized classes are introduced to deal with the time differences.|||Period − It deals with date based amount of time.|||Duration − It deals with time based amount of time.|||Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||TemporalAdjuster is used to perform the date mathematics. For example, get the ""Second Saturday of the Month"" or ""Next Tuesday"". Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following result −|||A toInstant() method is added to the original Date and Calendar objects, which can be used to convert them to the new Date-Time API. Use an ofInstant(Insant,ZoneId) method to get a LocalDateTime or ZonedDateTime object. Let us see them in action.|||Create the following Java program using any editor of your choice in, say, C:\> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −|||With Java 8, Base64 has finally got its due. Java 8 now has inbuilt encoder and decoder for Base64 encoding. In Java 8, we can use three types of Base64 encoding.|||Simple − Output is mapped to a set of characters lying in A-Za-z0-9+/. The encoder does not add any line feed in output, and the decoder rejects any character other than A-Za-z0-9+/.|||URL − Output is mapped to set of characters lying in A-Za-z0-9+_. Output is URL and filename safe.|||MIME − Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, and uses a carriage return '\r' followed by a linefeed '\n' as the line separator. No line separator is present to the end of the encoded output.|||static class Base64.Decoder|||This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||static class Base64.Encoder|||This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||static Base64.Decoder getDecoder()|||Returns a Base64.Decoder that decodes using the Basic type base64 encoding scheme.|||static Base64.Encoder getEncoder()|||Returns a Base64.Encoder that encodes using the Basic type base64 encoding scheme.|||static Base64.Decoder getMimeDecoder()|||Returns a Base64.Decoder that decodes using the MIME type base64 decoding scheme.|||static Base64.Encoder getMimeEncoder()|||Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme.|||static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)|||Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators.|||static Base64.Decoder getUrlDecoder()|||Returns a Base64.Decoder that decodes using the URL and Filename safe type base64 encoding scheme.|||static Base64.Encoder getUrlEncoder()|||Returns a Base64.Encoder that encodes using the URL and Filename safe type base64 encoding scheme.|||This class inherits methods from the following class −|||Create the following Java program using any editor of your choice in say C:/> JAVA.|||Compile the class using javac compiler as follows −|||Now run the Java8Tester as follows −|||It should produce the following output −","Lambda expression − Adds functional processing capability to Java.@@@Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.@@@Default method − Interface to have default method implementation.@@@New tools − New compiler tools and utilities are added like ‘jdeps’ to figure out dependencies.@@@Stream API − New stream API to facilitate pipeline processing.@@@Date Time API − Improved date time API.@@@Optional − Emphasis on best practices to handle null values properly.@@@Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.|||Right-click on 'My Computer' and select 'Properties'.@@@Click on the 'Environment variables' button under the 'Advanced' tab.@@@Now, alter the 'Path' variable so that it also contains the path to the Java executable. For example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then change your path to read 'C:\WINDOWS\SYSTEM32;c:\Program Files\java\jdk\bin'.|||Edit the 'C:\autoexec.bat' file and add the following line at the end −
SET PATH=%PATH%;C:\Program Files\java\jdk\bin|||Notepad − On Windows machine, you can use any simple text editor like Notepad (recommended for this tutorial) or TextPad.@@@Netbeans − It is a Java IDE that is open-source and free. It can be downloaded from https://netbeans.org/index.html.@@@Eclipse − It is also a Java IDE developed by the Eclipse open-source community and can be downloaded from https://www.eclipse.org/.|||Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.@@@Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.@@@Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.@@@Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.|||Lambda expressions are used primarily to define inline implementation of a functional interface, i.e., an interface with a single method only. In the above example, we've used various types of lambda expressions to define the operation method of MathOperation interface. Then we have defined the implementation of sayMessage of GreetingService.@@@Lambda expression eliminates the need of anonymous class and gives a very simple yet powerful functional programming capability to Java.|||Static methods@@@Instance methods@@@Constructors using new operator (TreeSet::new)|||Sequence of elements − A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. It never stores the elements.@@@Source − Stream takes Collections, Arrays, or I/O resources as input source.@@@Aggregate operations − Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.@@@Pipelining − Most of the stream operations return stream itself so that their result can be pipelined. These operations are called intermediate operations and their function is to take input, process them, and return output to the target. collect() method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.@@@Automatic iterations − Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.|||stream() − Returns a sequential stream considering collection as its source.@@@parallelStream() − Returns a parallel Stream considering collection as its source.|||java.lang.Object|||Not thread safe − java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. The new date-time API is immutable and does not have setter methods.@@@Poor design − Default Date starts from 1900, month starts from 1, and day starts from 0, so no uniformity. The old API had less direct methods for date operations. The new API provides numerous utility methods for such operations.@@@Difficult time zone handling − Developers had to write a lot of code to deal with timezone issues. The new API has been developed keeping domain-specific design in mind.|||Local − Simplified date-time API with no complexity of timezone handling.@@@Zoned − Specialized date-time API to deal with various timezones.|||Period − It deals with date based amount of time.@@@Duration − It deals with time based amount of time.|||Simple − Output is mapped to a set of characters lying in A-Za-z0-9+/. The encoder does not add any line feed in output, and the decoder rejects any character other than A-Za-z0-9+/.@@@URL − Output is mapped to set of characters lying in A-Za-z0-9+_. Output is URL and filename safe.@@@MIME − Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, and uses a carriage return '\r' followed by a linefeed '\n' as the line separator. No line separator is present to the end of the encoded output.|||java.lang.Object",,"Sr.No.@@@Interface & Description|||1@@@BiConsumer<T,U>
Represents an operation that accepts two input arguments, and returns no result.
|||2@@@BiFunction<T,U,R>
Represents a function that accepts two arguments and produces a result.
|||3@@@BinaryOperator<T>
Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
|||4@@@BiPredicate<T,U>
Represents a predicate (Boolean-valued function) of two arguments.
|||5@@@BooleanSupplier
Represents a supplier of Boolean-valued results.
|||6@@@Consumer<T>
Represents an operation that accepts a single input argument and returns no result.
|||7@@@DoubleBinaryOperator
Represents an operation upon two double-valued operands and producing a double-valued result.
|||8@@@DoubleConsumer
Represents an operation that accepts a single double-valued argument and returns no result.
|||9@@@DoubleFunction<R>
Represents a function that accepts a double-valued argument and produces a result.
|||10@@@DoublePredicate
Represents a predicate (Boolean-valued function) of one double-valued argument.
|||11@@@DoubleSupplier
Represents a supplier of double-valued results.
|||12@@@DoubleToIntFunction
Represents a function that accepts a double-valued argument and produces an int-valued result.
|||13@@@DoubleToLongFunction
Represents a function that accepts a double-valued argument and produces a long-valued result.
|||14@@@DoubleUnaryOperator
Represents an operation on a single double-valued operand that produces a double-valued result.
|||15@@@Function<T,R>
Represents a function that accepts one argument and produces a result.
|||16@@@IntBinaryOperator
Represents an operation upon two int-valued operands and produces an int-valued result.
|||17@@@IntConsumer
Represents an operation that accepts a single int-valued argument and returns no result.
|||18@@@IntFunction<R>
Represents a function that accepts an int-valued argument and produces a result.
|||19@@@IntPredicate
Represents a predicate (Boolean-valued function) of one int-valued argument.
|||20@@@IntSupplier
Represents a supplier of int-valued results.
|||21@@@IntToDoubleFunction
Represents a function that accepts an int-valued argument and produces a double-valued result.
|||22@@@IntToLongFunction
Represents a function that accepts an int-valued argument and produces a long-valued result.
|||23@@@IntUnaryOperator
Represents an operation on a single int-valued operand that produces an int-valued result.
|||24@@@LongBinaryOperator
Represents an operation upon two long-valued operands and produces a long-valued result.
|||25@@@LongConsumer
Represents an operation that accepts a single long-valued argument and returns no result.
|||26@@@LongFunction<R>
Represents a function that accepts a long-valued argument and produces a result.
|||27@@@LongPredicate
Represents a predicate (Boolean-valued function) of one long-valued argument.
|||28@@@LongSupplier
Represents a supplier of long-valued results.
|||29@@@LongToDoubleFunction
Represents a function that accepts a long-valued argument and produces a double-valued result.
|||30@@@LongToIntFunction
Represents a function that accepts a long-valued argument and produces an int-valued result.
|||31@@@LongUnaryOperator
Represents an operation on a single long-valued operand that produces a long-valued result.
|||32@@@ObjDoubleConsumer<T>
Represents an operation that accepts an object-valued and a double-valued argument, and returns no result.
|||33@@@ObjIntConsumer<T>
Represents an operation that accepts an object-valued and an int-valued argument, and returns no result.
|||34@@@ObjLongConsumer<T>
Represents an operation that accepts an object-valued and a long-valued argument, and returns no result.
|||35@@@Predicate<T>
Represents a predicate (Boolean-valued function) of one argument.
|||36@@@Supplier<T>
Represents a supplier of results.
|||37@@@ToDoubleBiFunction<T,U>
Represents a function that accepts two arguments and produces a double-valued result.
|||38@@@ToDoubleFunction<T>
Represents a function that produces a double-valued result.
|||39@@@ToIntBiFunction<T,U>
Represents a function that accepts two arguments and produces an int-valued result.
|||40@@@ToIntFunction<T>
Represents a function that produces an int-valued result.
|||41@@@ToLongBiFunction<T,U>
Represents a function that accepts two arguments and produces a long-valued result.
|||42@@@ToLongFunction<T>
Represents a function that produces a long-valued result.
|||43@@@UnaryOperator<T>
Represents an operation on a single operand that produces a result of the same type as its operand.
&&&Sr.No.@@@Method & Description|||1@@@static <T> Optional<T> empty()
Returns an empty Optional instance.|||2@@@boolean equals(Object obj)
Indicates whether some other object is ""equal to"" this Optional.|||3@@@Optional<T> filter(Predicate<? super <T> predicate)
If a value is present and the value matches a given predicate, it returns an Optional describing the value, otherwise returns an empty Optional.|||4@@@<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)
If a value is present, it applies the provided Optional-bearing mapping function to it, returns that result, otherwise returns an empty Optional.|||5@@@T get()
If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.|||6@@@int hashCode()
Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.|||7@@@void ifPresent(Consumer<? super T> consumer)
If a value is present, it invokes the specified consumer with the value, otherwise does nothing.|||8@@@boolean isPresent()
Returns true if there is a value present, otherwise false.|||9@@@<U>Optional<U> map(Function<? super T,? extends U> mapper)
If a value is present, applies the provided mapping function to it, and if the result is non-null, returns an Optional describing the result.|||10@@@static <T> Optional<T> of(T value)
Returns an Optional with the specified present non-null value.|||11@@@static <T> Optional<T> ofNullable(T value)
Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.|||12@@@T orElse(T other)
Returns the value if present, otherwise returns other.|||13@@@T orElseGet(Supplier<? extends T> other)
Returns the value if present, otherwise invokes other and returns the result of that invocation.|||14@@@<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)
Returns the contained value, if present, otherwise throws an exception to be created by the provided supplier.|||15@@@String toString()
Returns a non-empty string representation of this Optional suitable for debugging.&&&Sr.No.@@@Nested class & Description|||1@@@static class Base64.Decoder
This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.|||2@@@static class Base64.Encoder
This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.&&&Sr.No.@@@Method Name & Description|||1@@@static Base64.Decoder getDecoder()
Returns a Base64.Decoder that decodes using the Basic type base64 encoding scheme.|||2@@@static Base64.Encoder getEncoder()
Returns a Base64.Encoder that encodes using the Basic type base64 encoding scheme.|||3@@@static Base64.Decoder getMimeDecoder()
Returns a Base64.Decoder that decodes using the MIME type base64 decoding scheme.|||4@@@static Base64.Encoder getMimeEncoder()
Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme.|||5@@@static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)
Returns a Base64.Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators.|||6@@@static Base64.Decoder getUrlDecoder()
Returns a Base64.Decoder that decodes using the URL and Filename safe type base64 encoding scheme.|||7@@@static Base64.Encoder getUrlEncoder()
Returns a Base64.Encoder that encodes using the URL and Filename safe type base64 encoding scheme.","import java.util.Collections;import java.util.List;import java.util.ArrayList;import java.util.Comparator;public class Java8Tester {   public static void main(String args[]) {         List<String> names1 = new ArrayList<String>();      names1.add(""Mahesh "");      names1.add(""Suresh "");      names1.add(""Ramesh "");      names1.add(""Naresh "");      names1.add(""Kalpesh "");		      List<String> names2 = new ArrayList<String>();      names2.add(""Mahesh "");      names2.add(""Suresh "");      names2.add(""Ramesh "");      names2.add(""Naresh "");      names2.add(""Kalpesh "");		      Java8Tester tester = new Java8Tester();      System.out.println(""Sort using Java 7 syntax: "");		      tester.sortUsingJava7(names1);      System.out.println(names1);      System.out.println(""Sort using Java 8 syntax: "");		      tester.sortUsingJava8(names2);      System.out.println(names2);   }      //sort using java 7   private void sortUsingJava7(List<String> names) {         Collections.sort(names, new Comparator<String>() {         @Override         public int compare(String s1, String s2) {            return s1.compareTo(s2);         }      });   }      //sort using java 8   private void sortUsingJava8(List<String> names) {      Collections.sort(names, (s1, s2) -> s1.compareTo(s2));   }}|||public class Java8Tester {   public static void main(String args[]) {      Java8Tester tester = new Java8Tester();		      //with type declaration      MathOperation addition = (int a, int b) -> a + b;		      //with out type declaration      MathOperation subtraction = (a, b) -> a - b;		      //with return statement along with curly braces      MathOperation multiplication = (int a, int b) -> { return a * b; };		      //without return statement and without curly braces      MathOperation division = (int a, int b) -> a / b;		      System.out.println(""10 + 5 = "" + tester.operate(10, 5, addition));      System.out.println(""10 - 5 = "" + tester.operate(10, 5, subtraction));      System.out.println(""10 x 5 = "" + tester.operate(10, 5, multiplication));      System.out.println(""10 / 5 = "" + tester.operate(10, 5, division));		      //without parenthesis      GreetingService greetService1 = message ->      System.out.println(""Hello "" + message);		      //with parenthesis      GreetingService greetService2 = (message) ->      System.out.println(""Hello "" + message);		      greetService1.sayMessage(""Mahesh"");      greetService2.sayMessage(""Suresh"");   }	   interface MathOperation {      int operation(int a, int b);   }	   interface GreetingService {      void sayMessage(String message);   }	   private int operate(int a, int b, MathOperation mathOperation) {      return mathOperation.operation(a, b);   }}|||public class Java8Tester {   final static String salutation = ""Hello! "";      public static void main(String args[]) {      GreetingService greetService1 = message ->       System.out.println(salutation + message);      greetService1.sayMessage(""Mahesh"");   }	   interface GreetingService {      void sayMessage(String message);   }}|||import java.util.List;import java.util.ArrayList;public class Java8Tester {   public static void main(String args[]) {      List names = new ArrayList();		      names.add(""Mahesh"");      names.add(""Suresh"");      names.add(""Ramesh"");      names.add(""Naresh"");      names.add(""Kalpesh"");		      names.forEach(System.out::println);   }}|||import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class Java8Tester {   public static void main(String args[]) {      List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);		      // Predicate<Integer> predicate = n -> true      // n is passed as parameter to test method of Predicate interface      // test method will always return true no matter what value n has.		      System.out.println(""Print all numbers:"");		      //pass n as parameter      eval(list, n->true);		      // Predicate<Integer> predicate1 = n -> n%2 == 0      // n is passed as parameter to test method of Predicate interface      // test method will return true if n%2 comes to be zero		      System.out.println(""Print even numbers:"");      eval(list, n-> n%2 == 0 );		      // Predicate<Integer> predicate2 = n -> n > 3      // n is passed as parameter to test method of Predicate interface      // test method will return true if n is greater than 3.		      System.out.println(""Print numbers greater than 3:"");      eval(list, n-> n > 3 );   }	   public static void eval(List<Integer> list, Predicate<Integer> predicate) {      for(Integer n: list) {         if(predicate.test(n)) {            System.out.println(n + "" "");         }      }   }}|||public interface vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }}public interface fourWheeler {   default void print() {      System.out.println(""I am a four wheeler!"");   }}|||public class car implements vehicle, fourWheeler {   public void print() {      System.out.println(""I am a four wheeler car vehicle!"");   }}|||public class car implements vehicle, fourWheeler {   public void print() {      vehicle.super.print();   }}|||public interface vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }	   static void blowHorn() {      System.out.println(""Blowing horn!!!"");   }}|||public class Java8Tester {   public static void main(String args[]) {      Vehicle vehicle = new Car();      vehicle.print();   }}interface Vehicle {   default void print() {      System.out.println(""I am a vehicle!"");   }	   static void blowHorn() {      System.out.println(""Blowing horn!!!"");   }}interface FourWheeler {   default void print() {      System.out.println(""I am a four wheeler!"");   }}class Car implements Vehicle, FourWheeler {   public void print() {      Vehicle.super.print();      FourWheeler.super.print();      Vehicle.blowHorn();      System.out.println(""I am a car!"");   }}|||SELECT max(salary), employee_id, employee_name FROM Employee|||List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());|||Random random = new Random();random.ints().limit(10).forEach(System.out::println);|||List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);//get list of unique squaresList<Integer> squaresList = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());|||List<String>strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");//get count of empty stringint count = strings.stream().filter(string -> string.isEmpty()).count();|||Random random = new Random();random.ints().limit(10).forEach(System.out::println);|||Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println);|||List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");//get count of empty stringlong count = strings.parallelStream().filter(string -> string.isEmpty()).count();|||List<String>strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");List<String> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());System.out.println(""Filtered List: "" + filtered);String mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining("", ""));System.out.println(""Merged String: "" + mergedString);|||List numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);IntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();System.out.println(""Highest number in List : "" + stats.getMax());System.out.println(""Lowest number in List : "" + stats.getMin());System.out.println(""Sum of all numbers : "" + stats.getSum());System.out.println(""Average of all numbers : "" + stats.getAverage());|||import java.util.ArrayList;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.Map;public class Java8Tester {   public static void main(String args[]) {      System.out.println(""Using Java 7: "");		      // Count empty strings      List<String> strings = Arrays.asList(""abc"", """", ""bc"", ""efg"", ""abcd"","""", ""jkl"");      System.out.println(""List: "" +strings);      long count = getCountEmptyStringUsingJava7(strings);		      System.out.println(""Empty Strings: "" + count);      count = getCountLength3UsingJava7(strings);		      System.out.println(""Strings of length 3: "" + count);		      //Eliminate empty string      List<String> filtered = deleteEmptyStringsUsingJava7(strings);      System.out.println(""Filtered List: "" + filtered);		      //Eliminate empty string and join using comma.      String mergedString = getMergedStringUsingJava7(strings,"", "");      System.out.println(""Merged String: "" + mergedString);      List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);		      //get list of square of distinct numbers      List<Integer> squaresList = getSquares(numbers);      System.out.println(""Squares List: "" + squaresList);      List<Integer> integers = Arrays.asList(1,2,13,4,15,6,17,8,19);		      System.out.println(""List: "" +integers);      System.out.println(""Highest number in List : "" + getMax(integers));      System.out.println(""Lowest number in List : "" + getMin(integers));      System.out.println(""Sum of all numbers : "" + getSum(integers));      System.out.println(""Average of all numbers : "" + getAverage(integers));      System.out.println(""Random Numbers: "");		      //print ten random numbers      Random random = new Random();		      for(int i = 0; i < 10; i++) {         System.out.println(random.nextInt());      }		      System.out.println(""Using Java 8: "");      System.out.println(""List: "" +strings);		      count = strings.stream().filter(string->string.isEmpty()).count();      System.out.println(""Empty Strings: "" + count);		      count = strings.stream().filter(string -> string.length() == 3).count();      System.out.println(""Strings of length 3: "" + count);		      filtered = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.toList());      System.out.println(""Filtered List: "" + filtered);		      mergedString = strings.stream().filter(string ->!string.isEmpty()).collect(Collectors.joining("", ""));      System.out.println(""Merged String: "" + mergedString);		      squaresList = numbers.stream().map( i ->i*i).distinct().collect(Collectors.toList());      System.out.println(""Squares List: "" + squaresList);      System.out.println(""List: "" +integers);		      IntSummaryStatistics stats = integers.stream().mapToInt((x) ->x).summaryStatistics();		      System.out.println(""Highest number in List : "" + stats.getMax());      System.out.println(""Lowest number in List : "" + stats.getMin());      System.out.println(""Sum of all numbers : "" + stats.getSum());      System.out.println(""Average of all numbers : "" + stats.getAverage());      System.out.println(""Random Numbers: "");		      random.ints().limit(10).sorted().forEach(System.out::println);		      //parallel processing      count = strings.parallelStream().filter(string -> string.isEmpty()).count();      System.out.println(""Empty Strings: "" + count);   }	   private static int getCountEmptyStringUsingJava7(List<String> strings) {      int count = 0;      for(String string: strings) {		         if(string.isEmpty()) {            count++;         }      }      return count;   }	   private static int getCountLength3UsingJava7(List<String> strings) {      int count = 0;		      for(String string: strings) {		         if(string.length() == 3) {            count++;         }      }      return count;   }	   private static List<String> deleteEmptyStringsUsingJava7(List<String> strings) {      List<String> filteredList = new ArrayList<String>();		      for(String string: strings) {		         if(!string.isEmpty()) {             filteredList.add(string);         }      }      return filteredList;   }	   private static String getMergedStringUsingJava7(List<String> strings, String separator) {      StringBuilder stringBuilder = new StringBuilder();		      for(String string: strings) {		         if(!string.isEmpty()) {            stringBuilder.append(string);            stringBuilder.append(separator);         }      }      String mergedString = stringBuilder.toString();      return mergedString.substring(0, mergedString.length()-2);   }	   private static List<Integer> getSquares(List<Integer> numbers) {      List<Integer> squaresList = new ArrayList<Integer>();		      for(Integer number: numbers) {         Integer square = new Integer(number.intValue() * number.intValue());			         if(!squaresList.contains(square)) {            squaresList.add(square);         }      }      return squaresList;   }	   private static int getMax(List<Integer> numbers) {      int max = numbers.get(0);		      for(int i = 1;i < numbers.size();i++) {		         Integer number = numbers.get(i);			         if(number.intValue() > max) {            max = number.intValue();         }      }      return max;   }	   private static int getMin(List<Integer> numbers) {      int min = numbers.get(0);		      for(int i= 1;i < numbers.size();i++) {         Integer number = numbers.get(i);		         if(number.intValue() < min) {            min = number.intValue();         }      }      return min;   }	   private static int getSum(List numbers) {      int sum = (int)(numbers.get(0));		      for(int i = 1;i < numbers.size();i++) {         sum += (int)numbers.get(i);      }      return sum;   }	   private static int getAverage(List<Integer> numbers) {      return getSum(numbers) / numbers.size();   }}|||import java.util.Optional;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8Tester = new Java8Tester();      Integer value1 = null;      Integer value2 = new Integer(10);		      //Optional.ofNullable - allows passed parameter to be null.      Optional<Integer> a = Optional.ofNullable(value1);		      //Optional.of - throws NullPointerException if passed parameter is null      Optional<Integer> b = Optional.of(value2);      System.out.println(java8Tester.sum(a,b));   }	   public Integer sum(Optional<Integer> a, Optional<Integer> b) {      //Optional.isPresent - checks the value is present or not		      System.out.println(""First parameter is present: "" + a.isPresent());      System.out.println(""Second parameter is present: "" + b.isPresent());		      //Optional.orElse - returns the value if present otherwise returns      //the default value passed.      Integer value1 = a.orElse(new Integer(0));		      //Optional.get - gets the value, value should be present      Integer value2 = b.get();      return value1 + value2;   }}|||print('Hello World!');|||import javax.script.ScriptEngineManager;import javax.script.ScriptEngine;import javax.script.ScriptException;public class Java8Tester {   public static void main(String args[]) {      ScriptEngineManager scriptEngineManager = new ScriptEngineManager();      ScriptEngine nashorn = scriptEngineManager.getEngineByName(""nashorn"");		      String name = ""Mahesh"";      Integer result = null;            try {         nashorn.eval(""print('"" + name + ""')"");         result = (Integer) nashorn.eval(""10 + 2"");               } catch(ScriptException e) {         System.out.println(""Error executing script: ""+ e.getMessage());      }      System.out.println(result.toString());   }}|||var BigDecimal = Java.type('java.math.BigDecimal');function calculate(amount, percentage) {   var result = new BigDecimal(amount).multiply(new BigDecimal(percentage)).divide(      new BigDecimal(""100""), 2, BigDecimal.ROUND_HALF_EVEN);      return result.toPlainString();}var result = calculate(568000000000000000023,13.9);print(result);|||import java.time.LocalDate;import java.time.LocalTime;import java.time.LocalDateTime;import java.time.Month;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testLocalDateTime();   }	   public void testLocalDateTime() {      // Get the current date and time      LocalDateTime currentTime = LocalDateTime.now();      System.out.println(""Current DateTime: "" + currentTime);		      LocalDate date1 = currentTime.toLocalDate();      System.out.println(""date1: "" + date1);		      Month month = currentTime.getMonth();      int day = currentTime.getDayOfMonth();      int seconds = currentTime.getSecond();		      System.out.println(""Month: "" + month +""day: "" + day +""seconds: "" + seconds);		      LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);      System.out.println(""date2: "" + date2);		      //12 december 2014      LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);      System.out.println(""date3: "" + date3);		      //22 hour 15 minutes      LocalTime date4 = LocalTime.of(22, 15);      System.out.println(""date4: "" + date4);		      //parse a string      LocalTime date5 = LocalTime.parse(""20:15:30"");      System.out.println(""date5: "" + date5);   }}|||import java.time.ZonedDateTime;import java.time.ZoneId;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testZonedDateTime();   }	   public void testZonedDateTime() {      // Get the current date and time      ZonedDateTime date1 = ZonedDateTime.parse(""2007-12-03T10:15:30+05:30[Asia/Karachi]"");      System.out.println(""date1: "" + date1);		      ZoneId id = ZoneId.of(""Europe/Paris"");      System.out.println(""ZoneId: "" + id);		      ZoneId currentZone = ZoneId.systemDefault();      System.out.println(""CurrentZone: "" + currentZone);   }}|||import java.time.LocalDate;import java.time.temporal.ChronoUnit;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testChromoUnits();   }	   public void testChromoUnits() {      //Get the current date      LocalDate today = LocalDate.now();      System.out.println(""Current date: "" + today);		      //add 1 week to the current date      LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);      System.out.println(""Next week: "" + nextWeek);		      //add 1 month to the current date      LocalDate nextMonth = today.plus(1, ChronoUnit.MONTHS);      System.out.println(""Next month: "" + nextMonth);		      //add 1 year to the current date      LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);      System.out.println(""Next year: "" + nextYear);		      //add 10 years to the current date      LocalDate nextDecade = today.plus(1, ChronoUnit.DECADES);      System.out.println(""Date after ten year: "" + nextDecade);   }}|||import java.time.temporal.ChronoUnit;import java.time.LocalDate;import java.time.LocalTime;import java.time.Duration;import java.time.Period;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testPeriod();      java8tester.testDuration();   }	   public void testPeriod() {      //Get the current date      LocalDate date1 = LocalDate.now();      System.out.println(""Current date: "" + date1);		      //add 1 month to the current date      LocalDate date2 = date1.plus(1, ChronoUnit.MONTHS);      System.out.println(""Next month: "" + date2);            Period period = Period.between(date2, date1);      System.out.println(""Period: "" + period);   }	   public void testDuration() {      LocalTime time1 = LocalTime.now();      Duration twoHours = Duration.ofHours(2);		      LocalTime time2 = time1.plus(twoHours);      Duration duration = Duration.between(time1, time2);		      System.out.println(""Duration: "" + duration);   }}|||import java.time.LocalDate;import java.time.temporal.TemporalAdjusters;import java.time.DayOfWeek;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testAdjusters();   }	   public void testAdjusters() {      //Get the current date      LocalDate date1 = LocalDate.now();      System.out.println(""Current date: "" + date1);		      //get the next tuesday      LocalDate nextTuesday = date1.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));      System.out.println(""Next Tuesday on : "" + nextTuesday);		      //get the second saturday of next month      LocalDate firstInYear = LocalDate.of(date1.getYear(),date1.getMonth(), 1);      LocalDate secondSaturday = firstInYear.with(TemporalAdjusters.nextOrSame(         DayOfWeek.SATURDAY)).with(TemporalAdjusters.next(DayOfWeek.SATURDAY));      System.out.println(""Second Saturday on : "" + secondSaturday);   }}|||import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.util.Date;import java.time.Instant;import java.time.ZoneId;public class Java8Tester {   public static void main(String args[]) {      Java8Tester java8tester = new Java8Tester();      java8tester.testBackwardCompatability();   }	   public void testBackwardCompatability() {      //Get the current date      Date currentDate = new Date();      System.out.println(""Current date: "" + currentDate);		      //Get the instant of current date in terms of milliseconds      Instant now = currentDate.toInstant();      ZoneId currentZone = ZoneId.systemDefault();		      LocalDateTime localDateTime = LocalDateTime.ofInstant(now, currentZone);      System.out.println(""Local date: "" + localDateTime);		      ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(now, currentZone);      System.out.println(""Zoned date: "" + zonedDateTime);   }}|||import java.util.Base64;import java.util.UUID;import java.io.UnsupportedEncodingException;public class HelloWorld {   public static void main(String args[]) {      try {		         // Encode using basic encoder         String base64encodedString = Base64.getEncoder().encodeToString(            ""TutorialsPoint?java8"".getBytes(""utf-8""));         System.out.println(""Base64 Encoded String (Basic) :"" + base64encodedString);		         // Decode         byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);		         System.out.println(""Original String: "" + new String(base64decodedBytes, ""utf-8""));         base64encodedString = Base64.getUrlEncoder().encodeToString(            ""TutorialsPoint?java8"".getBytes(""utf-8""));         System.out.println(""Base64 Encoded String (URL) :"" + base64encodedString);		         StringBuilder stringBuilder = new StringBuilder();		         for (int i = 0; i < 10; ++i) {            stringBuilder.append(UUID.randomUUID().toString());         }		         byte[] mimeBytes = stringBuilder.toString().getBytes(""utf-8"");         String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);         System.out.println(""Base64 Encoded String (MIME) :"" + mimeEncodedString);      } catch(UnsupportedEncodingException e) {         System.out.println(""Error :"" + e.getMessage());      }   }}"
Learn Java-8,Java 8 - Useful Resources,Java 8 - Useful Resources|||Useful Video Courses@@@Useful eBooks|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training@@@Java Tutorial@@@JAVA8 Tutorial@@@Javascript Tutorial@@@Java RMI Tutorial@@@Java XML Tutorial@@@JavaFX Tutorial,The following resources contain additional information on Java 8. Please use them to get more in-depth knowledge on this topic.,,,,
Learn Java-8,Discuss Java 8,Discuss Java 8|||Useful Video Courses|||Java Date and Time Online Training@@@Java Servlet Online Training@@@JavaScript Online Training@@@Java Online Training@@@Java Essential Training@@@Java Essentials Online Training,Java 8 is the most awaited and is a major feature release of Java programming language. This is an introductory tutorial that explains the basic-to-advanced features of Java 8 and their usage in a simple and intuitive way.,,,,
