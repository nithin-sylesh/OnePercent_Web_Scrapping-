Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn COBOL,COBOL Tutorial,COBOL Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||COBOL Online Training,"COBOL stands for Common Business Oriented Language.The US Department of Defense, in a conference, formed CODASYL (Conference on Data Systems Language) to develop a language for business data processing needs which is now known as COBOL.|||COBOL is used for writing application programs and we cannot use it to write system software. The applications like those in defense domain, insurance domain, etc. which require huge data processing make extensive use of COBOL.|||This tutorial is designed for software programmers who would like  to learn the basics of COBOL. It provides enough understanding on COBOL programming language from where you can take yourself to a higher level of expertise.|||Before proceeding with this tutorial, you should have a basic understanding of computer programming terminologies and JCL. A basic understanding of any of the programming languages will help you understand the concepts of COBOL programming and move fast on the learning track.",,,,
Learn COBOL,COBOL - Overview,COBOL - Overview|||Introduction to COBOL@@@Evolution of COBOL@@@Importance of COBOL@@@Features of COBOL@@@Useful Video Courses|||Standard Language@@@Business Oriented@@@Robust Language@@@Structured Language|||COBOL Online Training,"COBOL is a high-level language. One must understand the way COBOL works. Computers only understand machine code, a binary stream of 0s and 1s. COBOL code must be converted into machine code  using a compiler. Run the program source through a compiler. The compiler first checks for any syntax errors and then converts it into machine language. The compiler creates an output file which is known as load module. This output file contains executable code in the form of 0s and 1s.|||During 1950s, when the businesses were growing in the western part of the world, there was a need to automate various processes for ease of operation and this gave birth to a high-level programming language meant for business data processing.|||In 1959, COBOL was developed by CODASYL (Conference on Data Systems Language).|||The next version, COBOL-61, was released in 1961 with some revisions.|||In 1968, COBOL was approved by ANSI as a standard language for commercial use (COBOL-68).|||It was again revised in 1974 and 1985 to develop subsequent versions named COBOL-74 and COBOL-85 respectively.|||In 2002, Object-Oriented COBOL was released, which could use encapsulated objects as a normal part of COBOL programming.|||COBOL was the first widely used high-level programming language. It is an English-like language which is user friendly. All the instructions can be coded in simple English words.|||COBOL is also used as a self-documenting language.|||COBOL can handle huge data processing.|||COBOL is compatible with its previous versions.|||COBOL has effective error messages and so, resolution of bugs is easier.|||COBOL is a standard language that can be compiled and executed on machines such as IBM AS/400, personal computers, etc.|||COBOL was designed for business-oriented applications related to financial domain, defense domain, etc. It can handle huge volumes of data because of its advanced file handling capabilities.|||COBOL is a robust language as its numerous debugging and testing tools are available for almost all computer platforms.|||Logical control structures are available in COBOL which makes it easier to read and modify. COBOL has different divisions, so it is easy to debug.","In 1959, COBOL was developed by CODASYL (Conference on Data Systems Language).@@@The next version, COBOL-61, was released in 1961 with some revisions.@@@In 1968, COBOL was approved by ANSI as a standard language for commercial use (COBOL-68).@@@It was again revised in 1974 and 1985 to develop subsequent versions named COBOL-74 and COBOL-85 respectively.@@@In 2002, Object-Oriented COBOL was released, which could use encapsulated objects as a normal part of COBOL programming.|||COBOL was the first widely used high-level programming language. It is an English-like language which is user friendly. All the instructions can be coded in simple English words.@@@COBOL is also used as a self-documenting language.@@@COBOL can handle huge data processing.@@@COBOL is compatible with its previous versions.@@@COBOL has effective error messages and so, resolution of bugs is easier.",,,
Learn COBOL,COBOL - Environment Setup,COBOL - Environment Setup|||Installing COBOL on Windows/Linux@@@Compiling COBOL Programs@@@Executing COBOL Programs@@@Executing COBOL-DB2 programs@@@Useful Video Courses|||COBOL Online Training,"We have set up the COBOL Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.|||For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.|||There are many Free Mainframe Emulators available for Windows which can be used to write and learn simple COBOL programs.|||One such emulator is Hercules, which can be easily installed on Windows by following a few simple steps as given below −|||Download and install the Hercules emulator, which is available from the Hercules' home site: www.hercules-390.eu|||Once you have installed the package on Windows machine, it will create a folder like C:/hercules/mvs/cobol.|||Run the Command Prompt (CMD) and reach the directory C:/hercules/mvs/cobol on CMD.|||The complete guide on various commands to write and execute a JCL and COBOL programs can be found at:|||www.jaymoseley.com/hercules/installmvs/instmvs2.htm|||Hercules is an open-source software implementation of the mainframe System/370 and ESA/390 architectures, in addition to the latest 64-bit z/Architecture. Hercules runs under Linux, Windows, Solaris, FreeBSD, and Mac OS X.|||A user can connect to a mainframe server in a number of ways such as thin client, dummy terminal, Virtual Client System (VCS), or Virtual Desktop System (VDS). Every valid user is given a login id to enter into the Z/OS interface (TSO/E or ISPF).|||In order to execute a COBOL program in batch mode using JCL, the program needs to be compiled, and a load module is created with all the sub-programs. The JCL uses the load module and not the actual program at the time of execution. The load libraries are concatenated and given to the JCL at the time of execution using JCLLIB or STEPLIB.|||There are many mainframe compiler utilities available to compile a COBOL program. Some corporate companies use Change Management tools like Endevor, which compiles and stores every version of the program. This is useful in tracking the changes made to the program.|||IGYCRCTL is an IBM COBOL compiler utility. The compiler options are passed using the PARM parameter. In the above example, RMODE instructs the compiler to use relative addressing mode in the program. The COBOL program is passed using the SYSIN parameter. Copybook is the library used by the program in SYSLIB.|||Given below is a JCL example where the program MYPROG is executed using the input file MYDATA.URMI.INPUT and produces two output files written to the spool.|||The load module of MYPROG is located in MYDATA.URMI.LOADLIB. This is important to note that the above JCL can be used for a non-DB2 COBOL module only.|||For running a COBOL-DB2 program, a specialized IBM utility is used in the JCL and the program; DB2 region and required parameters are passed as input to the utility.|||The steps followed in running a COBOL-DB2 program are as follows −|||When a COBOL-DB2 program is compiled, a DBRM (Database Request Module) is created along with the load module. The DBRM contains the SQL statements of the COBOL programs with its syntax checked to be correct.|||The DBRM is bound to the DB2 region (environment) in which the COBOL will run. This can be done using the IKJEFT01 utility in a JCL.|||After the bind step, the COBOL-DB2 program is run using IKJEFT01 (again) with the load library and the DBRM library as the input to the JCL.|||In the above example, MYCOBB is the COBOL-DB2 program run using IKJEFT01. Please note that the program name, DB2 Sub-System Id (SSID), and DB2 Plan name are passed within the SYSTSIN DD statement. The DBRM library is specified in the STEPLIB.","Download and install the Hercules emulator, which is available from the Hercules' home site: www.hercules-390.eu@@@Once you have installed the package on Windows machine, it will create a folder like C:/hercules/mvs/cobol.@@@Run the Command Prompt (CMD) and reach the directory C:/hercules/mvs/cobol on CMD.@@@The complete guide on various commands to write and execute a JCL and COBOL programs can be found at:
www.jaymoseley.com/hercules/installmvs/instmvs2.htm|||When a COBOL-DB2 program is compiled, a DBRM (Database Request Module) is created along with the load module. The DBRM contains the SQL statements of the COBOL programs with its syntax checked to be correct.@@@The DBRM is bound to the DB2 region (environment) in which the COBOL will run. This can be done using the IKJEFT01 utility in a JCL.@@@After the bind step, the COBOL-DB2 program is run using IKJEFT01 (again) with the load library and the DBRM library as the input to the JCL.",,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   DISPLAY 'Hello World'.STOP RUN.|||//COMPILE   JOB ,CLASS=6,MSGCLASS=X,NOTIFY=&SYSUID             //*            //STEP1     EXEC IGYCRCTL,PARM=RMODE,DYNAM,SSRANGE//SYSIN     DD DSN=MYDATA.URMI.SOURCES(MYCOBB),DISP=SHR//SYSLIB    DD DSN=MYDATA.URMI.COPYBOOK(MYCOPY),DISP=SHR//SYSLMOD   DD DSN=MYDATA.URMI.LOAD(MYCOBB),DISP=SHR//SYSPRINT  DD SYSOUT=*//*|||//COBBSTEP  JOB CLASS=6,NOTIFY=&SYSUID////STEP10    EXEC PGM=MYPROG,PARM=ACCT5000//STEPLIB   DD DSN=MYDATA.URMI.LOADLIB,DISP=SHR//INPUT1    DD DSN=MYDATA.URMI.INPUT,DISP=SHR//OUT1      DD SYSOUT=*//OUT2      DD SYSOUT=*//SYSIN     DD *//CUST1     1000//CUST2     1001/*|||//STEP001  EXEC PGM=IKJEFT01//*//STEPLIB  DD DSN=MYDATA.URMI.DBRMLIB,DISP=SHR//*//input files//output files//SYSPRINT DD SYSOUT=*//SYSABOUT DD SYSOUT=*//SYSDBOUT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//DISPLAY  DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSPRT DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(MYCOBB) PLAN(PLANNAME) PARM(parameters to cobol program) -   LIB('MYDATA.URMI.LOADLIB')   END/*"
Learn COBOL,COBOL - Program Structure,COBOL - Program Structure|||Divisions@@@Useful Video Courses|||Identification Division@@@Environment Division@@@Data Division@@@Procedure Division|||COBOL Online Training,"A COBOL program structure consists of divisions as shown in the following image −|||A brief introduction of these divisions is given below −|||Sections are the logical subdivision of program logic. A section is a collection of paragraphs.|||Paragraphs are the subdivision of a section or division. It is either a user-defined or a predefined name followed by a period, and consists of zero or more sentences/entries.|||Sentences are the combination of one or more statements. Sentences appear only in the Procedure division. A sentence must end with a period.|||Statements are meaningful COBOL statements that perform some processing.|||Characters are the lowest in the hierarchy and cannot be divisible.|||You can co-relate the above-mentioned terms with the COBOL program in the following example −|||A COBOL program consists of four divisions.|||It is the first and only mandatory division of every COBOL program. The programmer and the compiler use this division to identify the program. In this division, PROGRAM-ID is the only mandatory paragraph. PROGRAM-ID specifies the program name that can consist 1 to 30 characters.|||Try the following example using the Live Demo option online.|||Given below is the JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Environment division is used to specify input and output files to the program. It consists of two sections −|||Configuration section provides information about the system on which the program is written and executed. It consists of two paragraphs −|||Source computer − System used to compile the program.|||Object computer − System used to execute the program.|||Input-Output section provides information about the files to be used in the program. It consists of two paragraphs −|||File control − Provides information of external data sets used in the program.|||I-O control − Provides information of files used in the program.|||Data division is used to define the variables used in the program. It consists of four sections −|||File section is used to define the record structure of the file.|||Working-Storage section is used to declare temporary variables and file structures which are used in the program.|||Local-Storage section is similar to Working-Storage section. The only difference is that the variables will be allocated and initialized every time a program starts execution.|||Linkage section is used to describe the data names that are received from an external program.|||COBOL Program|||The JCL to execute the above COBOL program is as follows −|||When you compile and execute the above program, it produces the following result −|||Procedure division is used to include the logic of the program. It consists of executable statements using variables defined in the data division. In this division, paragraph and section names are user-defined.|||There must be at least one statement in the procedure division. The last statement to end the execution in this division is either STOP RUN which is used in the calling programs or EXIT PROGRAM which is used in the called programs.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −","Sections are the logical subdivision of program logic. A section is a collection of paragraphs.@@@Paragraphs are the subdivision of a section or division. It is either a user-defined or a predefined name followed by a period, and consists of zero or more sentences/entries.@@@Sentences are the combination of one or more statements. Sentences appear only in the Procedure division. A sentence must end with a period.@@@Statements are meaningful COBOL statements that perform some processing.@@@Characters are the lowest in the hierarchy and cannot be divisible.|||Configuration section provides information about the system on which the program is written and executed. It consists of two paragraphs −

Source computer − System used to compile the program.
Object computer − System used to execute the program.
@@@Source computer − System used to compile the program.@@@Object computer − System used to execute the program.@@@Input-Output section provides information about the files to be used in the program. It consists of two paragraphs −

File control − Provides information of external data sets used in the program.
I-O control − Provides information of files used in the program.
@@@File control − Provides information of external data sets used in the program.@@@I-O control − Provides information of files used in the program.|||Source computer − System used to compile the program.@@@Object computer − System used to execute the program.|||File control − Provides information of external data sets used in the program.@@@I-O control − Provides information of files used in the program.|||File section is used to define the record structure of the file.@@@Working-Storage section is used to declare temporary variables and file structures which are used in the program.@@@Local-Storage section is similar to Working-Storage section. The only difference is that the variables will be allocated and initialized every time a program starts execution.@@@Linkage section is used to describe the data names that are received from an external program.",,,"PROCEDURE DIVISION.A0000-FIRST-PARA SECTION.FIRST-PARAGRAPH.ACCEPT WS-ID            - Statement-1  -----|MOVE '10' TO WS-ID      - Statement-2       |-- Sentence - 1DISPLAY WS-ID           - Statement-3  -----|.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.DISPLAY 'Welcome to Tutorialspoint'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||ENVIRONMENT DIVISION.CONFIGURATION SECTION.   SOURCE-COMPUTER. XXX-ZOS.   OBJECT-COMPUTER. XXX-ZOS.INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT FILEN ASSIGN TO DDNAME   ORGANIZATION IS SEQUENTIAL.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT FILEN ASSIGN TO INPUT.      ORGANIZATION IS SEQUENTIAL.      ACCESS IS SEQUENTIAL.DATA DIVISION.   FILE SECTION.   FD FILEN   01 NAME PIC A(25).      WORKING-STORAGE SECTION.   01 WS-STUDENT PIC A(30).   01 WS-ID PIC 9(5).   LOCAL-STORAGE SECTION.   01 LS-CLASS PIC 9(3).      LINKAGE SECTION.   01 LS-ID PIC 9(5).   PROCEDURE DIVISION.   DISPLAY 'Executing COBOL program using JCL'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//INPUT DD DSN = ABC.EFG.XYZ,DISP = SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NAME PIC A(30).   01 WS-ID PIC 9(5) VALUE 12345.PROCEDURE DIVISION.   A000-FIRST-PARA.   DISPLAY 'Hello World'.   MOVE 'TutorialsPoint' TO WS-NAME.   DISPLAY ""My name is : ""WS-NAME.   DISPLAY ""My ID is : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - Basic Syntax,COBOL - Basic Syntax|||Character Set@@@Coding Sheet@@@Character Strings@@@Comment@@@Literal@@@COBOL Word@@@Useful Video Courses|||Example@@@Comment Line@@@Comment Entry@@@Alphanumeric Literal@@@Numeric Literal@@@User-Defined@@@Reserved Words@@@Figurative Constants|||COBOL Online Training,"'Characters' are lowest in the hierarchy and they cannot be divided further. The COBOL Character Set includes 78 characters which are shown below −|||A-Z|||Alphabets(Upper Case)|||a-z|||Alphabets (Lower Case)|||0-9|||Numeric||| |||Space|||+|||Plus Sign|||-|||Minus Sign or Hyphen|||*|||Asterisk|||/|||Forward Slash|||$|||Currency Sign|||,|||Comma|||;|||Semicolon|||.|||Decimal Point or Period|||""|||Quotation Marks|||(|||Left Parenthesis|||)|||Right Parenthesis|||>|||Greater than|||<|||Less than|||:|||Colon|||'|||Apostrophe|||=|||Equal Sign|||The source program of COBOL must be written in a format acceptable to the compilers. COBOL programs are written on COBOL coding sheets. There are 80 character positions on each line of a coding sheet.|||Character positions are grouped into the following five fields −|||The following example shows a COBOL coding sheet −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Character strings are formed by combining individual characters. A character string can be a|||All character strings must be ended with separators. A separator is used to separate character strings.|||Frequently used separators − Space, Comma, Period, Apostrophe, Left/Right Parenthesis, and Quotation mark.|||A comment is a character string that does not affect the execution of a program. It can be any combination of characters.|||There are two types of comments −|||A comment line can be written in any column. The compiler does not check a comment line for syntax and treats it for documentation.|||Comment entries are those that are included in the optional paragraphs of an Identification Division. They are written in Area B and programmers use it for reference.|||The text highlighted in Bold are the commented entries in the following example −|||JCL to execute above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Literal is a constant that is directly hard-coded in a program. In the following example, ""Hello World"" is a literal.|||There are two types of literals as discussed below −|||Alphanumeric Literals are enclosed in quotes or apostrophe. Length can be up to 160 characters. An apostrophe or a quote can be a part of a literal only if it is paired. Starting and ending of the literal should be same, either apostrophe or quote.|||Example|||The following example shows valid and invalid Alphanumeric Literals −|||A Numeric Literal is a combination of digits from 0 to 9, +, –, or decimal point. Length can be up to 18 characters. Sign cannot be the rightmost character. Decimal point should not appear at the end.|||Example|||The following example shows valid and invalid Numeric Literals −|||COBOL Word is a character string that can be a reserved word or a user-defined word. Length can be up to 30 characters.|||User-defined words are used for naming files, data, records, paragraph names, and sections. Alphabets, digits, and hyphens are allowed while forming userdefined words. You cannot use COBOL reserved words.|||Reserved words are predefined words in COBOL. Different types of reserved words that we use frequently are as follows −|||Keywords like ADD, ACCEPT, MOVE, etc.|||Special characters words like +, -, *, <, <=, etc|||Figurative constants are constant values like ZERO, SPACES, etc. All the constant values of figurative constants are mentioned in the following table.|||HIGH-VALUES|||One or more characters which will be at the highest position in descending order.|||LOW-VALUES|||One or more characters have zeros in binary representation.|||ZERO/ZEROES|||One or more zero depending on the size of the variable.|||SPACES|||One or more spaces.|||QUOTES|||Single or double quotes.|||ALL literal|||Fills the data-item with Literal.","Comment,@@@Literal, or@@@COBOL word.|||Keywords like ADD, ACCEPT, MOVE, etc.@@@Special characters words like +, -, *, <, <=, etc@@@Figurative constants are constant values like ZERO, SPACES, etc. All the constant values of figurative constants are mentioned in the following table.",,"Sr.No.@@@Character & Description|||1@@@A-Z
Alphabets(Upper Case)|||2@@@a-z
Alphabets (Lower Case)|||3@@@0-9
Numeric|||4@@@ 
Space|||5@@@+
Plus Sign|||6@@@-
Minus Sign or Hyphen|||7@@@*
Asterisk|||8@@@/
Forward Slash|||9@@@$
Currency Sign|||10@@@,
Comma|||11@@@;
Semicolon|||12@@@
.
Decimal Point or Period|||13@@@
""
Quotation Marks|||14@@@
(
Left Parenthesis|||15@@@
)
Right Parenthesis|||16@@@
>
Greater than|||17@@@
<
Less than|||18@@@
:
Colon|||19@@@
'
Apostrophe|||20@@@
=
Equal Sign&&&Positions@@@Field@@@Description|||1-6@@@Column Numbers@@@Reserved for line numbers.|||7@@@Indicator@@@It can have Asterisk (*) indicating comments, Hyphen (-) indicating continuation and Slash ( / ) indicating form feed.|||8-11@@@Area A@@@All COBOL divisions, sections, paragraphs and some special entries must begin in Area A.|||12-72@@@Area B@@@All COBOL statements must begin in area B.|||73-80@@@Identification Area@@@It can be used as needed by the programmer.&&&Sr.No.@@@Figurative Constants & Description|||1@@@
HIGH-VALUES
One or more characters which will be at the highest position in descending order.|||2@@@
LOW-VALUES
One or more characters have zeros in binary representation.|||3@@@
ZERO/ZEROES
One or more zero depending on the size of the variable.|||4@@@
SPACES
One or more spaces.|||5@@@
QUOTES
Single or double quotes.|||6@@@
ALL literal
Fills the data-item with Literal.","000100 IDENTIFICATION DIVISION.                                         000100000200 PROGRAM-ID. HELLO.                                               000101000250* THIS IS A COMMENT LINE                                          000102000300 PROCEDURE DIVISION.                                              000103000350 A000-FIRST-PARA.                                                 000104000400     DISPLAY “Coding Sheet”.                                      000105000500 STOP RUN.                                                        000106|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||000100 IDENTIFICATION DIVISION.                                         000100000150 PROGRAM-ID. HELLO.                                               000101 000200 AUTHOR. TUTORIALSPOINT.                                          000102000250* THIS IS A COMMENT LINE                                          000103000300 PROCEDURE DIVISION.                                              000104000350 A000-FIRST-PARA.                                                 000105  000360/ First Para Begins - Documentation Purpose                       000106000400     DISPLAY “Comment line”.                                      000107000500 STOP RUN.                                                        000108|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||PROCEDURE DIVISION.DISPLAY 'Hello World'.|||Valid:   ‘This is valid’   ""This is valid""   ‘This isn’’t invalid’Invalid:   ‘This is invalid”   ‘This isn’t valid’|||Valid:   100   +10.9   -1.9Invalid:   1,00   10.   10.9-"
Learn COBOL,COBOL - Data Types,COBOL - Data Types|||Data Name@@@Level Number@@@Picture Clause@@@Value Clause@@@Useful Video Courses|||Example@@@Example@@@Example@@@Example|||COBOL Online Training,"Data Division is used to define the variables used in a program. To describe data in COBOL, one must understand the following terms −|||Data names must be defined in the Data Division before using them in the Procedure Division. They must have a user-defined name; reserved words cannot be used. Data names give reference to the memory locations where actual data is stored. They can be elementary or group type.|||The following example shows valid and invalid data names −|||Level number is used to specify the level of data in a record. They are used to differentiate between elementary items and group items. Elementary items can be grouped together to create group items.|||01|||Record description entry|||02 to 49|||Group and Elementary items|||66|||Rename Clause items|||77|||Items which cannot be sub-divided|||88|||Condition name entry|||Elementary items cannot be divided further. Level number, Data name, Picture clause, and Value clause (optional) are used to describe an elementary item.|||Group items consist of one or more elementary items. Level number, Data name, and Value clause (optional) are used to describe a group item. Group level number is always 01.|||The following example shows Group and Elementary items −|||Picture clause is used to define the following items −|||Data type can be numeric, alphabetic, or alphanumeric. Numeric type consists of only digits 0 to 9. Alphabetic type consists of letters A to Z and spaces. Alphanumeric type consists of digits, letters, and special characters.|||Sign can be used with numeric data. It can be either + or –.|||Decimal point position can be used with numeric data. Assumed position is the position of decimal point and not included in the data.|||Length defines the number of bytes used by the data item.|||Symbols used in a Picture clause −|||9|||Numeric|||A|||Alphabetic|||X|||Alphanumeric|||V|||Implicit Decimal|||S|||Sign|||P|||Assumed Decimal|||The following example shows the use of PIC clause −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Value clause is an optional clause which is used to initialize the data items. The values can be numeric literal, alphanumeric literal, or figurative constant. It can be used with both group and elementary items.|||The following example shows the use of VALUE clause −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −","Data Name@@@Level Number@@@Picture Clause@@@Value Clause|||Elementary items cannot be divided further. Level number, Data name, Picture clause, and Value clause (optional) are used to describe an elementary item.@@@Group items consist of one or more elementary items. Level number, Data name, and Value clause (optional) are used to describe a group item. Group level number is always 01.|||Data type can be numeric, alphabetic, or alphanumeric. Numeric type consists of only digits 0 to 9. Alphabetic type consists of letters A to Z and spaces. Alphanumeric type consists of digits, letters, and special characters.@@@Sign can be used with numeric data. It can be either + or –.@@@Decimal point position can be used with numeric data. Assumed position is the position of decimal point and not included in the data.@@@Length defines the number of bytes used by the data item.",,"Sr.No.@@@Level Number & Description|||1@@@
01
Record description entry|||2@@@
02 to 49
Group and Elementary items|||3@@@
66
Rename Clause items|||4@@@
77
Items which cannot be sub-divided|||5@@@
88
Condition name entry&&&Sr.No.@@@Symbol & Description|||1@@@
9
Numeric|||2@@@
A
Alphabetic|||3@@@
X
Alphanumeric|||4@@@
V
Implicit Decimal|||5@@@
S
Sign|||6@@@
P
Assumed Decimal","Valid:   WS-NAME   TOTAL-STUDENTS   A100   100BInvalid:   MOVE            (Reserved Words)   COMPUTE         (Reserved Words)   100             (No Alphabet)   100+B           (+ is not allowed) |||DATA DIVISION.WORKING-STORAGE SECTION.01 WS-NAME    PIC X(25).                               ---> ELEMENTARY ITEM 01 WS-CLASS   PIC 9(2)  VALUE  '10'.                   ---> ELEMENTARY ITEM01 WS-ADDRESS.                                         ---> GROUP ITEM      05 WS-HOUSE-NUMBER    PIC 9(3).                     ---> ELEMENTARY ITEM   05 WS-STREET          PIC X(15).                    ---> ELEMENTARY ITEM   05 WS-CITY            PIC X(15).                    ---> ELEMENTARY ITEM   05 WS-COUNTRY         PIC X(15)  VALUE 'INDIA'.     ---> ELEMENTARY ITEM|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC S9(3)V9(2).   01 WS-NUM2 PIC PPP999.   01 WS-NUM3 PIC S9(3)V9(2) VALUE -123.45.   01 WS-NAME PIC A(6) VALUE 'ABCDEF'.   01 WS-ID PIC X(5) VALUE 'A121$'.PROCEDURE DIVISION.   DISPLAY ""WS-NUM1 : ""WS-NUM1.   DISPLAY ""WS-NUM2 : ""WS-NUM2.   DISPLAY ""WS-NUM3 : ""WS-NUM3.   DISPLAY ""WS-NAME : ""WS-NAME.   DISPLAY ""WS-ID : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 99V9 VALUE IS 3.5.   01 WS-NAME PIC A(6) VALUE 'ABCD'.   01 WS-ID PIC 99 VALUE ZERO.PROCEDURE DIVISION.   DISPLAY ""WS-NUM1 : ""WS-NUM1.   DISPLAY ""WS-NAME : ""WS-NAME.   DISPLAY ""WS-ID   : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - Basic Verbs,COBOL - Basic Verbs|||Input / Output Verbs@@@Initialize Verb@@@Move Verb@@@Legal Moves@@@Add Verb@@@Subtract Verb@@@Multiply Verb@@@Divide Verb@@@Compute Statement@@@Useful Video Courses|||Accept Verb@@@Display Verb@@@Syntax@@@Syntax@@@Syntax@@@Syntax|||COBOL Online Training,"COBOL verbs are used in the procedure division for data processing. A statement always start with a COBOL verb. There are several COBOL verbs with different types of actions.|||Input/Output verbs are used to get data from the user and display the output of COBOL programs. The following two verbs are used for this process −|||Accept verb is used to get data such as date, time, and day from the operating system or directly from the user. If a program is accepting data from the user, then it needs to be passed through JCL. While getting data from the operating system, FROM option is included as shown in the following example −|||Display verb is used to display the output of a COBOL program.|||COBOL PROGRAM|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Initialize verb is used to initialize a group item or an elementary item. Data names with RENAME clause cannot be initialized. Numeric data items are replaced by ZEROES. Alphanumeric or alphabetic data items are replaced by SPACES. If we include REPLACING term, then data items can be initialized to the given replacing value as shown in the following example −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Move verb is used to copy data from source data to destination data. It can be used on both elementary and group data items. For group data items, MOVE CORRESPONDING/CORR is used. In try it option, MOVE CORR is not working; but on a mainframe server, it will work.|||For moving data from a string, MOVE(x:l) is used where x is the starting position and l is the length. Data will be truncated if the destination data item PIC clause is less than the source data item PIC clause. If the destination data item PIC clause is more than the source data item PIC clause, then ZEROS or SPACES will be added in the extra bytes. The following example makes it clear.|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||The following table gives information about the legal moves −|||Add verb is used to add two or more numbers and store the result in the destination operand.|||Given below is the syntax to Add two or more numbers −|||In syntax-1, A, B, C are added and the result is stored in C (C=A+B+C). A, B, D are added and the result is stored in D (D = A + B + D).|||In syntax-2, A, B, C, D are added and the result is stored in E (E=A+B+C+D).|||In syntax-3, sub-group items within WS-GROUP1 and WS-GROUP2 are added and the result is stored in WS-GROUP2.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Subtract verb is used for subtraction operations.|||Given below is the syntax for Subtract operations −|||In syntax-1, A and B are added and subtracted from C. The result is stored in C (C = C-(A+B)). A and B are added and subtracted from D. The result is stored in D (D = D-(A+B)).|||In syntax-2, A, B, C are added and subtracted from D. The result is stored in E (E = D-(A+B+C))|||In syntax-3, sub-group items within WS-GROUP1 and WS-GROUP2 are subtracted and the result is stored in WS-GROUP2.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Multiply verb is used for multiplication operations.|||Given below is the syntax to multiply two or more numbers −|||In syntax-1, A and B are multipled and the result is stored in B (B=A*B). A and C are multipled and the result is stored in C (C = A * C).|||In syntax-2, A and B are multipled and the result is stored in E (E=A*B).|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Divide verb is used for division operations.|||Given below is the syntax for division operations −|||In syntax-1, B is divided by A and the result is stored in B (B=B/A).|||In syntax-2, A is divided by B and the result is stored in C (C=A/B) and the remainder is stored in R.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Compute statement is used to write arithmetic expressions in COBOL. This is a replacement for Add, Subtract, Multiply, and Divide.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||
      We make use of cookies to improve our user experience. By using this website, you agree with our Cookies Policy.
      Agree
Learn more
",,,@@@Alphabetic@@@Alphanumeric@@@Numeric@@@Alphabetic@@@Alphanumeric@@@Numeric|||Possible@@@Possible@@@Not Possible|||Possible@@@Possible@@@Possible|||Not Possible@@@Possible@@@Possible,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-NAME PIC X(25).   01 WS-DATE PIC X(10).PROCEDURE DIVISION.   ACCEPT WS-STUDENT-NAME.   ACCEPT WS-DATE FROM DATE.   DISPLAY ""Name :  "" WS-STUDENT-NAME.   DISPLAY ""Date : "" WS-DATE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//INPUT DD DSN=PROGRAM.DIRECTORY,DISP=SHR//SYSIN DD *TutorialsPoint/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NAME PIC A(30) VALUE 'ABCDEF'.   01 WS-ID PIC 9(5).   01 WS-ADDRESS.    05 WS-HOUSE-NUMBER PIC 9(3).   05 WS-COUNTRY PIC X(15).   05 WS-PINCODE PIC 9(6) VALUE 123456.PROCEDURE DIVISION.   A000-FIRST-PARA.   INITIALIZE WS-NAME, WS-ADDRESS.   INITIALIZE WS-ID REPLACING NUMERIC DATA BY 12345.   DISPLAY ""My name is   : ""WS-NAME.   DISPLAY ""My ID is     : ""WS-ID.   DISPLAY ""Address      : ""WS-ADDRESS.   DISPLAY ""House Number : ""WS-HOUSE-NUMBER.   DISPLAY ""Country      : ""WS-COUNTRY.   DISPLAY ""Pincode      : ""WS-PINCODE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).   01 WS-NUM3 PIC 9(5).   01 WS-NUM4 PIC 9(6).   01 WS-ADDRESS.    05 WS-HOUSE-NUMBER PIC 9(3).   05 WS-COUNTRY PIC X(5).   05 WS-PINCODE PIC 9(6).   01 WS-ADDRESS1.    05 WS-HOUSE-NUMBER1 PIC 9(3).   05 WS-COUNTRY1 PIC X(5).   05 WS-PINCODE1 PIC 9(6).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 123456789 TO WS-NUM1.   MOVE WS-NUM1 TO WS-NUM2 WS-NUM3.   MOVE WS-NUM1(3:6) TO WS-NUM4.   MOVE 123 TO WS-HOUSE-NUMBER.   MOVE 'INDIA' TO WS-COUNTRY.   MOVE 112233 TO WS-PINCODE.   MOVE WS-ADDRESS TO WS-ADDRESS1.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-ADDRESS  : "" WS-ADDRESS   DISPLAY ""WS-ADDRESS1 : "" WS-ADDRESS1STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUM4 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.   01 WS-NUMD PIC 9(9) VALUE 10.   01 WS-NUME PIC 9(9) VALUE 10.PROCEDURE DIVISION.   ADD WS-NUM1 WS-NUM2 TO WS-NUM3 WS-NUM4.   ADD WS-NUMA WS-NUMB WS-NUMC TO WS-NUMD GIVING WS-NUME.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-NUMD     : "" WS-NUMD   DISPLAY ""WS-NUME     : "" WS-NUMESTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 100.   01 WS-NUM4 PIC 9(9) VALUE 100.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.   01 WS-NUMD PIC 9(9) VALUE 100.   01 WS-NUME PIC 9(9) VALUE 10.PROCEDURE DIVISION.   SUBTRACT WS-NUM1 WS-NUM2 FROM WS-NUM3 WS-NUM4.   SUBTRACT WS-NUMA WS-NUMB WS-NUMC FROM WS-NUMD GIVING WS-NUME.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-NUMD     : "" WS-NUMD   DISPLAY ""WS-NUME     : "" WS-NUMESTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.PROCEDURE DIVISION.   MULTIPLY WS-NUM1 BY WS-NUM2 WS-NUM3.   MULTIPLY WS-NUMA BY WS-NUMB GIVING WS-NUMC.      DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 5.   01 WS-NUM2 PIC 9(9) VALUE 250.   01 WS-NUMA PIC 9(9) VALUE 100.   01 WS-NUMB PIC 9(9) VALUE 15.   01 WS-NUMC PIC 9(9).   01 WS-REM PIC 9(9). PROCEDURE DIVISION.   DIVIDE WS-NUM1 INTO WS-NUM2.   DIVIDE WS-NUMA BY WS-NUMB GIVING WS-NUMC REMAINDER WS-REM.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-REM      : "" WS-REM   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 50.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9).PROCEDURE DIVISION.   COMPUTE WS-NUMC= (WS-NUM1 * WS-NUM2) - (WS-NUMA / WS-NUMB) + WS-NUM3.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMCSTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - Data Layout,COBOL - Data Layout|||Redefines Clause@@@Renames Clause@@@Usage Clause@@@Copybooks@@@Useful Video Courses|||Syntax@@@Display@@@COMPUTATIONAL / COMP@@@COMP-1@@@COMP-2@@@COMP-3|||COBOL Online Training,"COBOL layout is the description of use of each field and the values present in it. Following are the data description entries used in COBOL −|||Redefines clause is used to define a storage with different data description. If one or more data items are not used simultaneously, then the same storage can be utilized for another data item. So the same storage can be referred with different data items.|||Following is the syntax for Redefines clause −|||Following are the details of the used parameters −|||Level numbers of redefined item and redefining item must be the same and it cannot be 66 or 88 level number. Do not use VALUE clause with a redefining item. In File Section, do not use a redefines clause with 01 level number. Redefines definition must be the next data description you want to redefine. A redefining item will always have the same value as a redefined item.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Renames clause is used to give different names to existing data items. It is used to re-group the data names and give a new name to them. The new data names can rename across groups or elementary items. Level number 66 is reserved for renames.|||Syntax|||Following is the syntax for Renames clause −|||Renaming is possible at same level only. In the above example, WS-A, WS-B, and WS-C are at the same level. Renames definition must be the next data description you want to rename. Do not use Renames with the level numbers 01 or, 77. The data names used for renames must come in sequence. Data items with occur clause cannot be renamed.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Usage clause specifies the operating system in which the format data is stored. It cannot be used with level numbers 66 or 88. If usage clause is specified on a group, then all the elementary items will have the same usage clause. The different options available with Usage clause are as follows −|||Data item is stored in ASCII format and each character will take 1 byte. It is default usage.|||The following example calculates the number of bytes required −|||Data item is stored in binary format. Here, data items must be integer.|||The following example calculates the number of bytes required −|||Data item is similar to Real or Float and is represented as a single precision floating point number. Internally, data is stored in hexadecimal format. COMP-1 does not accept PIC clause. Here 1 word is equal to 4 bytes.|||Data item is similar to Long or Double and is represented as double precision floating point number. Internally, data is stored in hexadecimal format.  COMP-2 does not specify PIC clause. Here 2 word is equal to 8 bytes.|||Data item is stored in packed decimal format. Each digit occupies half a byte (1 nibble) and the sign is stored at the rightmost nibble.|||The following example calculates the number of bytes required −|||A COBOL copybook is a selection of code that defines data structures. If a particular data structure is used in many programs, then instead of writing the same data structure again, we can use copybooks. We use the COPY statement to include a copybook in a program. COPY statement is used in the WorkingStorage Section.|||The following example includes a copybook inside a COBOL program −|||Here ABC is the copybook name. The following data items in ABC copybook can be used inside a program.",Redefines Clause@@@Renames Clause@@@Usage Clause@@@Copybooks|||WS-OLD is Redefined Item@@@WS-NEW1 and WS-NEW2 are Redefining Item,,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-DESCRIPTION.   05 WS-DATE1 VALUE '20140831'.   10 WS-YEAR PIC X(4).   10 WS-MONTH PIC X(2).   10 WS-DATE PIC X(2).   05 WS-DATE2 REDEFINES WS-DATE1 PIC 9(8).PROCEDURE DIVISION.   DISPLAY ""WS-DATE1 : ""WS-DATE1.   DISPLAY ""WS-DATE2 : ""WS-DATE2.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-DESCRIPTION.   05 WS-NUM.   10 WS-NUM1 PIC 9(2) VALUE 20.   10 WS-NUM2 PIC 9(2) VALUE 56.   05 WS-CHAR.   10 WS-CHAR1 PIC X(2) VALUE 'AA'.   10 WS-CHAR2 PIC X(2) VALUE 'BB'.   66 WS-RENAME RENAMES WS-NUM2 THRU WS-CHAR2.PROCEDURE DIVISION.   DISPLAY ""WS-RENAME : "" WS-RENAME.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||01 WS-NUM PIC S9(5)V9(3) USAGE IS DISPLAY.It requires 8 bytes as sign and decimal doesn't require any byte.01 WS-NUM PIC 9(5) USAGE IS DISPLAY.It requires 5 bytes as sign.|||01 WS-NUM PIC S9(n) USAGE IS COMP.If 'n' = 1 to 4, it takes 2 bytes.If 'n' = 5 to 9, it takes 4 bytes.If 'n' = 10 to 18, it takes 8 bytes.|||01 WS-NUM PIC 9(n) USAGE IS COMP.Number of bytes = n/2 (If n is even)Number of bytes = n/2 + 1(If n is odd, consider only integer part)01 WS-NUM PIC 9(4) USAGE IS COMP-3 VALUE 21.It requires 2 bytes of storage as each digit occupies half a byte.01 WS-NUM PIC 9(5) USAGE IS COMP-3 VALUE 21.It requires 3 bytes of storage as each digit occupies half a byte.|||DATA DIVISION.WORKING-STORAGE SECTION.COPY ABC.|||01 WS-DESCRIPTION.   05 WS-NUM.      10 WS-NUM1 PIC 9(2) VALUE 20.      10 WS-NUM2 PIC 9(2) VALUE 56.   05 WS-CHAR.      10 WS-CHAR1 PIC X(2) VALUE 'AA'.      10 WS-CHAR2 PIC X(2) VALUE 'BB'."
Learn COBOL,COBOL - Conditional Statements,COBOL - Conditional Statements|||IF Condition Statement@@@Relation Condition@@@Sign Condition@@@Class Condition@@@Condition-name Condition@@@Negated Condition@@@Combined Condition@@@Evaluate Verb@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax|||COBOL Online Training,"Conditional statements are used to change the execution flow depending on certain conditions specified by the programmer. Conditional statements will always evaluate to true or false. Conditions are used in IF, Evaluate, and Perform statements. The different types of conditions are as follows −|||IF statement checks for conditions. If a condition is true, the IF block is executed; and if the condition is false, the ELSE block is executed.|||END-IF is used to end the IF block. To end the IF block, a period can be used instead of END-IF. But it is always preferable to use END-IF for multiple IF blocks.|||Nested-IF − IF blocks appearing inside another IF block. There is no limit to the depth of nested IF statements.|||Following is the syntax of IF condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Relation condition compares two operands, either of which can be an identifier, literal, or arithmetic expression. Algebraic comparison of numeric fields is done regardless of size and usage clause.|||For non-numeric operands|||If two non-numeric operands of equal size are compared, then the characters are compared from left with the corresponding positions till the end is reached. The operand containing greater number of characters is declared greater.|||If two non-numeric operands of unequal size are compared, then the shorter data item is appended with spaces at the end till the size of the operands becomes equal and then compared according to the rules mentioned in the previous point.|||Given below is the syntax of Relation condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Sign condition is used to check the sign of a numeric operand. It determines whether a given numeric value is greater than, less than, or equal to ZERO.|||Following is the syntax of Sign condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Class condition is used to check if an operand contains only alphabets or numeric data. Spaces are considered in ALPHABETIC, ALPHABETIC-LOWER, and ALPHABETIC-UPPER.|||Following is the syntax of Class condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A condition-name is a user-defined name. It contains a set of values specified by the user. It behaves like Boolean variables. They are defined with level number 88. It will not have a PIC clause.|||Following is the syntax of user-defined condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Negated condition is given by using the NOT keyword. If a condition is true and we have given NOT in front of it, then its final value will be false.|||Following is the syntax of Negated condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A combined condition contains two or more conditions connected using logical operators AND or OR.|||Following is the syntax of combined condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Evaluate verb is a replacement of series of IF-ELSE statement. It can be used to evaluate more than one condition. It is similar to SWITCH statement in C programs.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −",IF Condition Statement@@@Relation Condition@@@Sign Condition@@@Class Condition@@@Condition-Name Condition@@@Negated Condition@@@Combined Condition,,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).   01 WS-NUM3 PIC 9(5).   01 WS-NUM4 PIC 9(6).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 25 TO WS-NUM1 WS-NUM3.   MOVE 15 TO WS-NUM2 WS-NUM4.      IF WS-NUM1 > WS-NUM2 THEN      DISPLAY 'IN LOOP 1 - IF BLOCK'            IF WS-NUM3 = WS-NUM4 THEN         DISPLAY 'IN LOOP 2 - IF BLOCK'      ELSE         DISPLAY 'IN LOOP 2 - ELSE BLOCK'      END-IF         ELSE      DISPLAY 'IN LOOP 1 - ELSE BLOCK'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 25 TO WS-NUM1.   MOVE 15 TO WS-NUM2.      IF WS-NUM1 IS GREATER THAN OR EQUAL TO WS-NUM2 THEN      DISPLAY 'WS-NUM1 IS GREATER THAN WS-NUM2'   ELSE      DISPLAY 'WS-NUM1 IS LESS THAN WS-NUM2'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC S9(9) VALUE -1234.   01 WS-NUM2 PIC S9(9) VALUE 123456.PROCEDURE DIVISION.   A000-FIRST-PARA.   IF WS-NUM1 IS POSITIVE THEN      DISPLAY 'WS-NUM1 IS POSITIVE'.         IF WS-NUM1 IS NEGATIVE THEN      DISPLAY 'WS-NUM1 IS NEGATIVE'.         IF WS-NUM1 IS ZERO THEN      DISPLAY 'WS-NUM1 IS ZERO'.         IF WS-NUM2 IS POSITIVE THEN      DISPLAY 'WS-NUM2 IS POSITIVE'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC X(9) VALUE 'ABCD '.   01 WS-NUM2 PIC 9(9) VALUE 123456789.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF WS-NUM1 IS ALPHABETIC THEN      DISPLAY 'WS-NUM1 IS ALPHABETIC'.         IF WS-NUM1 IS NUMERIC THEN      DISPLAY 'WS-NUM1 IS NUMERIC'.         IF WS-NUM2 IS NUMERIC THEN      DISPLAY 'WS-NUM2 IS NUMERIC'.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM PIC 9(3).   88 PASS VALUES ARE 041 THRU 100.   88 FAIL VALUES ARE 000 THRU 40.PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 65 TO WS-NUM.      IF PASS       DISPLAY 'Passed with ' WS-NUM ' marks'.         IF FAIL       DISPLAY 'FAILED with ' WS-NUM 'marks'.      STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(2) VALUE 20.   01 WS-NUM2 PIC 9(9) VALUE 25.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF NOT WS-NUM1 IS LESS THAN WS-NUM2 THEN      DISPLAY 'IF-BLOCK'   ELSE      DISPLAY 'ELSE-BLOCK'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(2) VALUE 20.   01 WS-NUM2 PIC 9(2) VALUE 25.   01 WS-NUM3 PIC 9(2) VALUE 20.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF WS-NUM1 IS LESS THAN WS-NUM2 AND WS-NUM1=WS-NUM3 THEN      DISPLAY 'Both condition OK'   ELSE      DISPLAY 'Error'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 0.   PROCEDURE DIVISION.   MOVE 3 TO WS-A.      EVALUATE TRUE      WHEN WS-A > 2         DISPLAY 'WS-A GREATER THAN 2'      WHEN WS-A < 0         DISPLAY 'WS-A LESS THAN 0'      WHEN OTHER         DISPLAY 'INVALID VALUE OF WS-A'   END-EVALUATE.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - Loop Statements,COBOL - Loop Statements|||Perform Thru@@@Perform Until@@@Perform Times@@@Perform Varying@@@GO TO Statement@@@Useful Video Courses|||In-line Perform@@@Syntax@@@Out-of-line Perform@@@Syntax@@@Syntax@@@Syntax @@@Syntax@@@Unconditional GO TO@@@Conditional GO TO|||COBOL Online Training,"There are some tasks that need to be done over and over again like reading each record of a file till its end. The loop statements used in COBOL are −|||Perform Thru is used to execute a series of paragraph by giving the first and last paragraph names in the sequence. After executing the last paragraph, the control is returned back.|||Statements inside the PERFORM will be executed till END-PERFORM is reached.|||Following is the syntax of In-line perform −|||Here, a statement is executed in one paragraph and then the control is transferred to other paragraph or section.|||Following is the syntax of Out-of-line perform −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||In ‘perform until’, a paragraph is executed until the given condition becomes true. ‘With test before’ is the default condition and it indicates that the condition is checked before the execution of statements in a paragraph.|||Following is the syntax of perform until −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||In ‘perform times’, a paragraph will be executed the number of times specified.|||Following is the syntax of perform times −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||In perform varying, a paragraph will be executed till the condition in Until phrase becomes true.|||Following is the syntax of perform varying −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||GO TO statement is used to change the flow of execution in a program. In GO TO statements, transfer goes only in the forward direction. It is used to exit a paragraph. The different types of GO TO statements used are as follows −|||If 'x' is equal to 1, then the control will be transferred to the first paragraph; and if 'x' is equal to 2, then the control will be transferred to the second paragraph, and so on.|||Example|||JCL to execute the above COBOL program:|||When you compile and execute the above program, it produces the following result:",Perform Thru@@@Perform Until@@@Perform Times@@@Perform Varying,,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   A-PARA.   PERFORM DISPLAY 'IN A-PARA'   END-PERFORM.   PERFORM C-PARA THRU E-PARA.      B-PARA.   DISPLAY 'IN B-PARA'.   STOP RUN.      C-PARA.   DISPLAY 'IN C-PARA'.      D-PARA.   DISPLAY 'IN D-PARA'.      E-PARA.   DISPLAY 'IN E-PARA'.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||PERFORM A-PARA UNTIL COUNT=5PERFORM A-PARA WITH TEST BEFORE UNTIL COUNT=5PERFORM A-PARA WITH TEST AFTER UNTIL COUNT=5|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-CNT PIC 9(1) VALUE 0. PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA WITH TEST AFTER UNTIL WS-CNT>3.   STOP RUN.      B-PARA.   DISPLAY 'WS-CNT : 'WS-CNT.   ADD 1 TO WS-CNT.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA 3 TIMES.   STOP RUN.      B-PARA.   DISPLAY 'IN B-PARA'.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 0.PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA VARYING WS-A FROM 1 BY 1 UNTIL WS-A=5   STOP RUN.      B-PARA.   DISPLAY 'IN B-PARA ' WS-A.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 2.   PROCEDURE DIVISION.   A-PARA.   DISPLAY 'IN A-PARA'   GO TO B-PARA.      B-PARA.   DISPLAY 'IN B-PARA '.   GO TO C-PARA D-PARA DEPENDING ON WS-A.      C-PARA.   DISPLAY 'IN C-PARA '.      D-PARA.   DISPLAY 'IN D-PARA '.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - String Handling,COBOL - String Handling|||Inspect@@@String@@@Unstring@@@Useful Video Courses|||Tallying@@@Replacing|||COBOL Online Training,"String handling statements in COBOL are used to do multiple functional operations on strings. Following are the string handling statements −|||Inspect verb is used to count or replace the characters in a string. String operations can be performed on alphanumeric, numeric, or alphabetic values. Inspect operations are performed from left to right. The options used for the string operations are as follows −|||Tallying option is used to count the string characters.|||Syntax|||Following is the syntax of Tallying option −|||The parameters used are −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Replacing option is used to replace the string characters.|||Syntax|||Following is the syntax of Replacing option −|||The parameter used is −|||input-string − The string whose characters are to be replaced from char1 to char2.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||String verb is used to concatenate the strings. Using STRING statement, two or more strings of characters can be combined to form a longer string. ‘Delimited By’ clause is compulsory.|||Syntax|||Following is the syntax of String verb −|||Following are the details of the used parameters −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Unstring verb is used to split one string into multiple sub-strings. Delimited By clause is compulsory.|||Syntax|||Following is the syntax of Unstring verb −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −",Inspect@@@String@@@Unstring|||input-string − The string whose characters are to be counted.@@@output-count − Data item to hold the count of characters.|||input-string − The string whose characters are to be replaced from char1 to char2.|||ws-string1 and ws-string2 : Input strings to be concatenated@@@ws-string : Output string@@@ws-count : Used to count the length of new concatenated string@@@Delimited specifies the end of string@@@Pointer and Overflow are optional,,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-CNT1 PIC 9(2) VALUE 0.   01 WS-CNT2 PIC 9(2) VALUE 0.   01 WS-STRING PIC X(15) VALUE 'ABCDACDADEAAAFF'.   PROCEDURE DIVISION.   INSPECT WS-STRING TALLYING WS-CNT1 FOR CHARACTER.   DISPLAY ""WS-CNT1 : ""WS-CNT1.   INSPECT WS-STRING TALLYING WS-CNT2 FOR ALL 'A'.   DISPLAY ""WS-CNT2 : ""WS-CNT2   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC X(15) VALUE 'ABCDACDADEAAAFF'.PROCEDURE DIVISION.   DISPLAY ""OLD STRING : ""WS-STRING.   INSPECT WS-STRING REPLACING ALL 'A' BY 'X'.   DISPLAY ""NEW STRING : ""WS-STRING.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||STRING ws-string1 DELIMITED BY SPACE   ws-string2 DELIMITED BY SIZE   INTO ws-destination-string   WITH POINTER ws-count   ON OVERFLOW DISPLAY message1   NOT ON OVERFLOW DISPLAY message2END-STRING.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC A(30).   01 WS-STR1 PIC A(15) VALUE 'Tutorialspoint'.   01 WS-STR2 PIC A(7) VALUE 'Welcome'.   01 WS-STR3 PIC A(7) VALUE 'To AND'.   01 WS-COUNT PIC 99 VALUE 1.PROCEDURE DIVISION.   STRING WS-STR2 DELIMITED BY SIZE      WS-STR3 DELIMITED BY SPACE      WS-STR1 DELIMITED BY SIZE      INTO WS-STRING       WITH POINTER WS-COUNT      ON OVERFLOW DISPLAY 'OVERFLOW!'    END-STRING.      DISPLAY 'WS-STRING : 'WS-STRING.   DISPLAY 'WS-COUNT : 'WS-COUNT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||UNSTRING ws-string DELIMITED BY SPACEINTO ws-str1, ws-str2WITH POINTER ws-countON OVERFLOW DISPLAY messageNOT ON OVERFLOW DISPLAY messageEND-UNSTRING.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC A(30) VALUE 'WELCOME TO TUTORIALSPOINT'.   01 WS-STR1 PIC A(7).   01 WS-STR2 PIC A(2).   01 WS-STR3 PIC A(15).   01 WS-COUNT PIC 99 VALUE 1.PROCEDURE DIVISION.   UNSTRING WS-STRING DELIMITED BY SPACE      INTO WS-STR1, WS-STR2, WS-STR3   END-UNSTRING.      DISPLAY 'WS-STR1 : 'WS-STR1.   DISPLAY 'WS-STR2 : 'WS-STR2.   DISPLAY 'WS-STR3 : 'WS-STR3.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - Table Processing,COBOL - Table Processing|||Table Declaration@@@Subscript@@@Index@@@Set Statement@@@Search@@@Search All@@@Useful Video Courses|||One-Dimensional Table@@@Two-Dimensional Table|||COBOL Online Training,"Arrays in COBOL are known as tables. An array is a linear data structure and is a collection of individual data items of same type. Data items of a table are internally sorted.|||Table is declared in Data Division. Occurs clause is used to define a table. Occurs clause indicates the repetition of data name definition. It can be used only with level numbers starting from 02 to 49. Do not use occurs clause with Redefines. Description of one-dimensional and two-dimensional table is as follows −|||In a one-dimensional table, occurs clause is used only once in declaration. WSTABLE is the group item that contains table. WS-B names the table elements that occur 10 times.|||Syntax|||Following is the syntax for defining a one-dimensional table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A two-dimensional table is created with both data elements being variable length. For reference, go through the syntax and then try to analyze the table. The first array (WS-A) can occur from 1 to 10 times and the inner array (WS-C) can occur from 1 to 5 times. For each entry of WS-A, there will be corresponding 5 entries of WS-C.|||Syntax|||Following is the syntax for defining a two-dimensional table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Table individual elements can be accessed by using subscript. Subscript values can range from 1 to the number of times the table occurs. A subscript can be any positive number. It does not require any declaration in data division. It is automatically created with occurs clause.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Table elements can also be accessed using index. An index is a displacement of element from the start of the table. An index is declared with Occurs clause using INDEXED BY clause. The value of index can be changed using SET statement and PERFORM Varying option.|||Syntax|||Following is the syntax for defining Index in a table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Set statement is used to change the index value. Set verb is used to initialize, increment, or decrement the index value. It is used with Search and Search All to locate elements in table.|||Syntax|||Following is the syntax for using a Set statement −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Search is a linear search method, which is used to find elements inside the table. It can be performed on sorted as well as unsorted table. It is used only for tables declared by Index phrase. It starts with the initial value of index. If the searched element is not found, then the index is automatically incremented by 1 and it continues till the end of table.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Search All is a binary search method, which is used to find elements inside the table. Table must be in sorted order for Search All option. The index does not require initialization. In binary search, the table is divided into two halves and it determines in which half the searched element is present. This process repeats till the element is found or the end is reached.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −",,,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A PIC A(10) VALUE 'TUTORIALS' OCCURS 5 TIMES.     PROCEDURE DIVISION.   DISPLAY ""ONE-D TABLE : ""WS-TABLE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 2 TIMES.         10 WS-B PIC A(10) VALUE ' TUTORIALS'.         10 WS-C OCCURS 2 TIMES.            15 WS-D PIC X(6) VALUE ' POINT'.PROCEDURE DIVISION.   DISPLAY ""TWO-D TABLE : ""WS-TABLE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   DISPLAY 'WS-TABLE  : ' WS-TABLE.   DISPLAY 'WS-A(1)   : ' WS-A(1).   DISPLAY 'WS-C(1,1) : ' WS-C(1,1).   DISPLAY 'WS-C(1,2) : ' WS-C(1,2).   DISPLAY 'WS-A(2)   : ' WS-A(2).   DISPLAY 'WS-C(2,1) : ' WS-C(2,1).   DISPLAY 'WS-C(2,2) : ' WS-C(2,2).   DISPLAY 'WS-A(3)   : ' WS-A(3).   DISPLAY 'WS-C(3,1) : ' WS-C(3,1).   DISPLAY 'WS-C(3,2) : ' WS-C(3,2).   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES INDEXED BY I.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES INDEXED BY J.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   PERFORM A-PARA VARYING I FROM 1 BY 1 UNTIL I >3    STOP RUN.      A-PARA.   PERFORM C-PARA VARYING J FROM 1 BY 1 UNTIL J>2.      C-PARA.   DISPLAY WS-C(I,J).|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES INDEXED BY I.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES INDEXED BY J.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   SET I J TO 1.   DISPLAY WS-C(I,J).   SET I J UP BY 1.   DISPLAY WS-C(I,J).   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A PIC X(1) OCCURS 18 TIMES INDEXED BY I.   01 WS-SRCH PIC A(1) VALUE 'M'.PROCEDURE DIVISION.   MOVE 'ABCDEFGHIJKLMNOPQR' TO WS-TABLE.   SET I TO 1.   SEARCH WS-A      AT END DISPLAY 'M NOT FOUND IN TABLE'      WHEN WS-A(I) = WS-SRCH      DISPLAY 'LETTER M FOUND IN TABLE'   END-SEARCH.  STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-RECORD OCCURS 10 TIMES ASCENDING KEY IS WS-NUM INDEXED BY I.      10 WS-NUM PIC 9(2).      10 WS-NAME PIC A(3).PROCEDURE DIVISION.   MOVE '12ABC56DEF34GHI78JKL93MNO11PQR' TO WS-TABLE.   SEARCH ALL WS-RECORD     AT END DISPLAY 'RECORD NOT FOUND'     WHEN WS-NUM(I) = 93     DISPLAY 'RECORD FOUND '     DISPLAY WS-NUM(I)     DISPLAY WS-NAME(I)END-SEARCH. |||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO"
Learn COBOL,COBOL - File Handling,COBOL - File Handling|||Field@@@Record@@@File@@@Useful Video Courses|||Physical Record@@@Logical Record|||COBOL Online Training,"The concept of files in COBOL is different from that in C/C++. While learning the basics of 'File' in COBOL, the concepts of both languages should not be corelated. Simple text files cannot be used in COBOL, instead PS (Physical Sequential) and VSAM files are used. PS files will be discussed in this module.|||To understand file handling in COBOL, one must know the basic terms. These terms only serve to understand the fundamentals of file handling. Further in depth terminology would be discussed in the chapter 'File Handling Verbs'. Following are the basic terms −|||The following example helps in understanding these terms −|||Field is used to indicate the data stored about an element. It represents a single element as shown in the above example such as student id, name, marks, total marks, and percentage. The number of characters in any field is known as field size, for example, student name can have 10 characters. Fields can have the following attributes −|||Primary keys are those fields that are unique to each record and are used to identify a particular record. For example, in students marks file, each student will be having a unique student id which forms the primary key.|||Secondary keys are unique or non-unique fields that are used to search for related data. For example, in students marks file, full name of student can be used as secondary key when student id is not known.|||Descriptors fields are used to describe an entity. For example, in students marks file, marks and percentage fields that add meaning to the record are known descriptors.|||Record is a collection of fields that is used to describe an entity. One or more fields together form a record. For example, in students marks file, student id, name, marks, total marks, and percentage form one record. The cumulative size of all the fields in a record is known as the record size. The records present in a file may be of fixed length or variable length.|||Physical record is the information that exists on the external device. It is also known as a block.|||Logical record is the information used by the program. In COBOL programs, only one record can be handled at any point of time and it is called as logical record.|||File is a collection of related records. For example, the students marks file consists of records of all the students.","Field@@@Record@@@Physical Record@@@Logical Record@@@File|||Primary keys are those fields that are unique to each record and are used to identify a particular record. For example, in students marks file, each student will be having a unique student id which forms the primary key.@@@Secondary keys are unique or non-unique fields that are used to search for related data. For example, in students marks file, full name of student can be used as secondary key when student id is not known.@@@Descriptors fields are used to describe an entity. For example, in students marks file, marks and percentage fields that add meaning to the record are known descriptors.",,,
Learn COBOL,COBOL - File Organization,COBOL - File Organization|||Sequential File Organization@@@Indexed Sequential File Organization@@@Relative File Organization@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax|||COBOL Online Training,"File organization indicates how the records are organized in a file. There are different types of organizations for files so as to increase their efficiency of accessing the records. Following are the types of file organization schemes −|||The syntaxes in this module, mentioned along with their respective terms, only refer to their usage in the program. The complete programs using these syntaxes would be discussed in the chapter 'File handling Verbs'.|||A sequential file consists of records that are stored and accessed in sequential order. Following are the key attributes of sequential file organization −|||Records can be read in sequential order. For reading the 10th record, all the previous 9 records should be read.|||Records are written in sequential order. A new record cannot be inserted in between. A new record is always inserted at the end of the file.|||After placing a record into a sequential file, it is not possible to delete,  shorten, or lengthen a record.|||Order of the records, once inserted, can never be changed.|||Updation of record is possible. A record can be overwritten, if the new record length is same as the old record length.|||Sequential output files are good option for printing.|||Following is the syntax of sequential file organization −|||An indexed sequential file consists of records that can be accessed sequentially. Direct access is also possible. It consists of two parts −|||Data File contains records in sequential scheme.|||Index File contains the primary key and its address in the data file.|||Following are the key attributes of sequential file organization −|||Records can be read in sequential order just like in sequential file organization.|||Records can be accessed randomly if the primary key is known. Index file is used to get the address of a record and then the record is fetched from the data file.|||Sorted index is maintained in this file system which relates the key value to the position of the record in the file.|||Alternate index can also be created to fetch the records.|||Following is the syntax of indexed sequential file organization −|||A relative file consists of records ordered by their relative address. Following are the key attributes of relative file organization −|||Records can be read in sequential order just like in sequential and indexed file organization.|||Records can be accessed using relative key. Relative key represents the record’s location relative to the address of the start of the file.|||Records can be inserted using relative key. Relative address is calculated using relative key.|||Relative file provides the fastest access to the records.|||The main disadvantage of this file system is that if some intermediate records are missing, they will also occupy space.|||Following is the syntax of relative file organization −","Sequential file organization@@@Indexed sequential file organization@@@Relative file organization|||Records can be read in sequential order. For reading the 10th record, all the previous 9 records should be read.@@@Records are written in sequential order. A new record cannot be inserted in between. A new record is always inserted at the end of the file.@@@After placing a record into a sequential file, it is not possible to delete,  shorten, or lengthen a record.@@@Order of the records, once inserted, can never be changed.@@@Updation of record is possible. A record can be overwritten, if the new record length is same as the old record length.@@@Sequential output files are good option for printing.|||Data File contains records in sequential scheme.@@@Index File contains the primary key and its address in the data file.|||Records can be read in sequential order just like in sequential file organization.@@@Records can be accessed randomly if the primary key is known. Index file is used to get the address of a record and then the record is fetched from the data file.@@@Sorted index is maintained in this file system which relates the key value to the position of the record in the file.@@@Alternate index can also be created to fetch the records.|||Records can be read in sequential order just like in sequential and indexed file organization.@@@Records can be accessed using relative key. Relative key represents the record’s location relative to the address of the start of the file.@@@Records can be inserted using relative key. Relative address is calculated using relative key.@@@Relative file provides the fastest access to the records.@@@The main disadvantage of this file system is that if some intermediate records are missing, they will also occupy space.",,,INPUT-OUTPUT SECTION.FILE-CONTROL.   SELECT file-name ASSIGN TO dd-name-jcl   ORGANIZATION IS INDEXED   RECORD KEY IS primary-key   ALTERNATE RECORD KEY IS rec-key|||INPUT-OUTPUT SECTION.FILE-CONTROL.   SELECT file-name ASSIGN TO dd-name-jcl   ORGANIZATION IS RELATIVE   RELATIVE KEY IS rec-key
Learn COBOL,COBOL - File Access Mode,COBOL - File Access Mode|||Sequential Access@@@Random Access@@@Dynamic Access@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax|||COBOL Online Training,"Till now, file organization schemes have been discussed. For each file organization scheme, different access modes can be used. Following are the types of file access modes −|||The syntaxes in this module, mentioned along with their respective terms, only refer to their usage in the program. The complete programs using these syntaxes would be discussed in the next chapter.|||When the access mode is sequential, the method of record retrieval changes as per the selected file organization.|||For sequential files, records are accessed in the same order in which they were inserted.|||For indexed files, the parameter used to fetch the records are the record key values.|||For relative files, relative record keys are used to retrieve the records.|||Following is the syntax of sequential access mode −|||When the access mode is RANDOM, the method of record retrieval changes as per the selected file organization.|||For indexed files, records are accessed according to the value placed in a key field which can be primary or alternate key. There can be one or more alternate indexes.|||For relative files , records are retrieved through relative record keys.|||Following is the syntax of random access mode −|||Dynamic access supports both sequential and random access in the same program. With dynamic access, one file definition is used to perform both sequential and random processing like accessing some records in sequential order and other records by their keys.|||With relative and indexed files, the dynamic access mode allows you to switch back and forth between sequential access mode and random access mode while reading a file by using the NEXT phrase on the READ statement. NEXT and READ functionalities will be discussed in the next chapter.|||Following is the syntax of dynamic access mode −","Sequential Access@@@Random Access@@@Dynamic Access|||For sequential files, records are accessed in the same order in which they were inserted.@@@For indexed files, the parameter used to fetch the records are the record key values.@@@For relative files, relative record keys are used to retrieve the records.|||For indexed files, records are accessed according to the value placed in a key field which can be primary or alternate key. There can be one or more alternate indexes.@@@For relative files , records are retrieved through relative record keys.",,,
Learn COBOL,COBOL - File Handling Verbs,COBOL - File Handling Verbs|||Open Verb@@@Read Verb@@@Write Verb@@@Rewrite Verb@@@Delete Verb@@@Start Verb@@@Close Verb@@@Useful Video Courses|||Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax|||COBOL Online Training,"File handling verbs are used to perform various operations on files. Following are the file handling verbs −|||Open is the first file operation that must be performed. If Open is successful, then only further operations are possible on a file. Only after opening a file, the variables in the file structure are available for processing. FILE STATUS variable is updated after each file operation.|||Here, file-name is string literal, which you will use to name your file. A file can be opened in the following modes −|||Input|||Input mode is used for existing files. In this mode, we can only read the file, no other operations are allowed on the file.|||Output|||Output mode is used to insert records in files. If a sequential file is  used and the file is holding some records, then the existing records will be deleted first and then new records will be inserted in the file. It will not happen so in case of an indexed file or a relative file.|||Extend|||Extend mode is used to append records in a sequential file. In this mode, records are inserted at the end. If file access mode is Random or Dynamic, then extend mode cannot be used.|||I-O|||Input-Output mode is used to read and rewrite the records of a file.|||Read verb is used to read the file records. The function of read is to fetch records from a file. At each read verb, only one record can be read into the file structure. To perform a read operation, open the file in INPUT or I-O mode. At each read statement, the file pointer is incremented and hence the successive records are read.|||Following is the syntax to read the records when the file access mode is sequential −|||Following are the parameters used −|||NEXT RECORD is optional and is specified when an indexed sequential file is being read sequentially.|||INTO clause is optional. ws-file-structure is defined in the WorkingStorage Section to get the values from the READ statement.|||AT END condition becomes True when the end of file is reached.|||Example − The following example reads an existing file using line sequential organization. This program can be compiled and executed using Live Demo option where it will display all the records present in the file.|||Suppose the input file data available in the input.txt file contains the following −|||When you compile and execute the above program, it produces the following result −|||Following is the syntax to write a record when the file access mode is random −|||Example − The following example reads an existing file using indexed organization. This program can be compiled and executed using JCL on Mainframes where it will display all the records present in the file. On Mainframes server, we do not use text files; instead we use PS files.|||Let's assume that the file present on Mainframes have same content as input.txt file in the above example.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Write verb is used to insert records in a file. Once the record is written, it is no longer available in the record buffer. Before inserting records into the file, move the values into the record buffer and then perform write verb.|||Write statement can be used with FROM option to directly write records from the working storage variables. From is an optional clause. If the access mode is sequential, then to write a record, the file must open in Output mode or Extend mode. If the access mode is random or dynamic, then to write a record, the file must open in Output mode or I-O mode.|||Following is the syntax to read a record when the file organization is sequential −|||Following is the syntax to read a record when the file organization is indexed or relative −|||Example − The following example shows how to insert a new record in a new file when the organization is sequential.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it will add a new record to the output file.|||Rewrite verb is used to update the records. File should be opened in I-O mode for rewrite operations. It can be used only after a successful Read operation. Rewrite verb overwrites the last record read.|||Following is the syntax to read a record when the file organization is sequential −|||Following is the syntax to read a record when the file organization is indexed or relative −|||Example − The following example shows how to update an existing record which we have inserted in the previous Write step −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it will update the record −|||Delete verb can be performed only on indexed and relative files. The file must be opened in I-O mode. In sequential file organization, records cannot be deleted. The record last read by the Read statement is deleted in case of sequential access mode. In random access mode, specify the record key and then perform the Delete operation.|||Following is the syntax to delete a record −|||Example − to delete an existing record −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Start verb can be performed only on indexed and relative files. It is used to place the file pointer at a specific record. The access mode must be sequential or dynamic. File must be opened in I-O or Input mode.|||Following is the syntax to place the pointer at a specific record −|||Close verb is used to close a file. After performing Close operation, the variables in the file structure will not be available for processing. The link between program and file is lost.|||Following is the syntax to close a file −",Open@@@Read@@@Write@@@Rewrite@@@Delete@@@Start@@@Close|||NEXT RECORD is optional and is specified when an indexed sequential file is being read sequentially.@@@INTO clause is optional. ws-file-structure is defined in the WorkingStorage Section to get the values from the READ statement.@@@AT END condition becomes True when the end of file is reached.,,"Sr.No.@@@Mode & Description|||1@@@
Input
Input mode is used for existing files. In this mode, we can only read the file, no other operations are allowed on the file.|||2@@@
Output
Output mode is used to insert records in files. If a sequential file is  used and the file is holding some records, then the existing records will be deleted first and then new records will be inserted in the file. It will not happen so in case of an indexed file or a relative file.|||3@@@
Extend
Extend mode is used to append records in a sequential file. In this mode, records are inserted at the end. If file access mode is Random or Dynamic, then extend mode cannot be used.|||4@@@
I-O
Input-Output mode is used to read and rewrite the records of a file.","IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.      FILE-CONTROL.      SELECT STUDENT ASSIGN TO 'input.txt'      ORGANIZATION IS LINE SEQUENTIAL.            DATA DIVISION.   FILE SECTION.   FD STUDENT.   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).   01 WS-EOF PIC A(1). PROCEDURE DIVISION.   OPEN INPUT STUDENT.      PERFORM UNTIL WS-EOF='Y'         READ STUDENT INTO WS-STUDENT            AT END MOVE 'Y' TO WS-EOF            NOT AT END DISPLAY WS-STUDENT         END-READ      END-PERFORM.   CLOSE STUDENT.STOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO IN1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT.      01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).        WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).PROCEDURE DIVISION.   OPEN INPUT STUDENT.      MOVE 20005 TO STUDENT-ID.            READ STUDENT RECORD INTO WS-STUDENT-FILE         KEY IS STUDENT-ID         INVALID KEY DISPLAY 'Invalid Key'         NOT INVALID KEY DISPLAY WS-STUDENT-FILE      END-READ.         CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN = STUDENT-FILE-NAME,DISP=SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO OUT1      ORGANIZATION IS SEQUENTIAL      ACCESS IS SEQUENTIAL      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).      05 CLASS PIC X(3).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN EXTEND STUDENT.      MOVE 1000 TO STUDENT-ID.      MOVE 'Tim' TO NAME.      MOVE '10' TO CLASS.      WRITE STUDENT-FILE      END-WRITE.	   CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//OUT1 DD DSN = OUTPUT-FILE-NAME,DISP = (NEW,CATALOG,DELETE)|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO IN1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(4).      05 NAME PIC A(12).      05 CLASS PIC X(3).         WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN I-O STUDENT.   MOVE '1000' TO STUDENT-ID.     READ STUDENT      KEY IS STUDENT-ID      INVALID KEY DISPLAY ‘KEY IS NOT EXISTING’   END-READ.     MOVE 'Tim Dumais' TO NAME.   REWRITE STUDENT-FILE   END-REWRITE.   CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN = OUTPUT-FILE-NAME,DISP = SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO OUT1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(4).      05 NAME PIC A(12).      05 CLASS PIC X(3).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN I-O STUDENT.   MOVE '1000' TO STUDENT-ID.      DELETE STUDENT RECORD      INVALID KEY DISPLAY 'Invalid Key'      NOT INVALID KEY DISPLAY 'Record Deleted'   END-DELETE.      CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//OUT1 DD DSN = OUTPUT-FILE-NAME,DISP = SHR"
Learn COBOL,COBOL - Subroutines,COBOL - Subroutines|||Call Verb@@@Call By Reference@@@Call By Content@@@Types of Call@@@Useful Video Courses|||Called Program Constraints@@@Syntax@@@Called Program@@@Syntax@@@Called Program|||COBOL Online Training,"Cobol subroutine is a program that can be compiled independently but cannot be executed independently. There are two types of subroutines: internal subroutines like Perform statements and external subroutines like CALL verb.|||Call verb is used to transfer the control from one program to another program. The program that contains the CALL verb is the Calling Program and the program being called is known as the Called Program. Calling program execution will halt until the called program finishes the execution. Exit Program statement is used in the Called program to transfer the control back.|||Following are the called program requirements −|||Linkage section must be defined in the called program. It consists of data elements passed in the program. The data items should not have Value clause. PIC clause must be compatible with the variables passed through the calling program.|||Procedure division using has a list of variables passed from the calling program and the order must be same as mentioned in the Call verb.|||Exit program statement is used in the called program to transfer the control back. It must be the last statement in the called program.|||The parameters can be passed between programs in two ways −|||If the values of variables in the called program are modified, then their new values will reflect in the calling program. If BY clause is not specified, then variables are always passed by reference.|||Following is the syntax of calling subroutine by reference −|||Example|||Following example is the MAIN calling program and UTIL is the called program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||If the values of variables in the called program are modified, then their new values will not reflect in the calling program.|||Following is the syntax of calling subroutine by content −|||Example|||Following example is the MAIN calling program and UTIL is the called program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||There are two types of calls −|||Static Call occurs when a program is compiled with the NODYNAM compiler option. A static called program is loaded into storage at compile time.|||Dynamic Call occurs when a program is compiled with the DYNAM and NODLL compiler option. A dynamic called program is loaded into storage at runtime.",Linkage section must be defined in the called program. It consists of data elements passed in the program. The data items should not have Value clause. PIC clause must be compatible with the variables passed through the calling program.@@@Procedure division using has a list of variables passed from the calling program and the order must be same as mentioned in the Call verb.@@@Exit program statement is used in the called program to transfer the control back. It must be the last statement in the called program.|||By Reference@@@By Content|||Static Call occurs when a program is compiled with the NODYNAM compiler option. A static called program is loaded into storage at compile time.@@@Dynamic Call occurs when a program is compiled with the DYNAM and NODLL compiler option. A dynamic called program is loaded into storage at runtime.,,,"IDENTIFICATION DIVISION.PROGRAM-ID. MAIN.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.PROCEDURE DIVISION.   CALL 'UTIL' USING WS-STUDENT-ID, WS-STUDENT-NAME.   DISPLAY 'Student Id : ' WS-STUDENT-ID   DISPLAY 'Student Name : ' WS-STUDENT-NAMESTOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. UTIL.DATA DIVISION.   LINKAGE SECTION.   01 LS-STUDENT-ID PIC 9(4).   01 LS-STUDENT-NAME PIC A(15).PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.   DISPLAY 'In Called Program'.   MOVE 1111 TO LS-STUDENT-ID.EXIT PROGRAM.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = MAIN|||IDENTIFICATION DIVISION.PROGRAM-ID. MAIN.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.PROCEDURE DIVISION.   CALL 'UTIL' USING BY CONTENT WS-STUDENT-ID, BY CONTENT WS-STUDENT-NAME.   DISPLAY 'Student Id : ' WS-STUDENT-ID   DISPLAY 'Student Name : ' WS-STUDENT-NAMESTOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. UTIL.DATA DIVISION.   LINKAGE SECTION.   01 LS-STUDENT-ID PIC 9(4).   01 LS-STUDENT-NAME PIC A(15).PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.   DISPLAY 'In Called Program'.   MOVE 1111 TO LS-STUDENT-ID.EXIT PROGRAM.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = MAIN"
Learn COBOL,COBOL - Internal Sort,COBOL - Internal Sort|||Sort Verb@@@Merge Verb@@@Useful Video Courses|||Syntax@@@Syntax|||COBOL Online Training,"Sorting of data in a file or merging of two or more files is a common necessity in almost all business-oriented applications. Sorting is used for arranging records either in ascending or descending order, so that sequential processing can be performed. There are two techniques which are used for sorting files in COBOL −|||External sort is used to sort files by using the SORT utility in JCL. We have discussed this in the JCL chapter. As of now, we will focus on internal sort.|||Internal sort is used to sort files within a COBOL program. SORT verb is used to sort a file.|||Three files are used in the sort process in COBOL −|||Input file is the file which we have to sort either in ascending or descending order.|||Work file is used to hold records while the sort process is in progress. Input file records are transferred to the work file for the sorting process. This file should be defined in the File-Section under SD entry.|||Output file is the file which we get after the sorting process. It is the final output of the Sort verb.|||Following is the syntax to sort a file −|||SORT performs the following operations −|||Opens work-file in I-O mode, input-file in the INPUT mode and output-file in the OUTPUT mode.|||Transfers the records present in the input-file to the work-file.|||Sorts the SORT-FILE in ascending/descending sequence by rec-key.|||Transfers the sorted records from the work-file to the output-file.|||Closes the input-file and the output-file and deletes the work-file.|||Example|||In the following example, INPUT is the input file which needs to be sorted in ascending order −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Two or more identically sequenced files are combined using Merge statement. Files used in the merge process −|||Following is the syntax to merge two or more files −|||Merge performs the following operations −|||Opens the work-file in I-O mode, input-files in the INPUT mode and output-file in the OUTPUT mode.|||Transfers the records present in the input-files to the work-file.|||Sorts the SORT-FILE in ascending/descending sequence by rec-key.|||Transfers the sorted records from the work-file to the output-file.|||Closes the input-file and the output-file and deletes the work-file.|||Example|||In the following example, INPUT1 and INPUT2 are the input files which are to be merged in ascending order −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −","External sort is used to sort files by using the SORT utility in JCL. We have discussed this in the JCL chapter. As of now, we will focus on internal sort.@@@Internal sort is used to sort files within a COBOL program. SORT verb is used to sort a file.|||Input file is the file which we have to sort either in ascending or descending order.@@@Work file is used to hold records while the sort process is in progress. Input file records are transferred to the work file for the sorting process. This file should be defined in the File-Section under SD entry.@@@Output file is the file which we get after the sorting process. It is the final output of the Sort verb.|||Opens work-file in I-O mode, input-file in the INPUT mode and output-file in the OUTPUT mode.@@@Transfers the records present in the input-file to the work-file.@@@Sorts the SORT-FILE in ascending/descending sequence by rec-key.@@@Transfers the sorted records from the work-file to the output-file.@@@Closes the input-file and the output-file and deletes the work-file.|||Input Files − Input-1, Input-2@@@Work File@@@Output File|||Opens the work-file in I-O mode, input-files in the INPUT mode and output-file in the OUTPUT mode.@@@Transfers the records present in the input-files to the work-file.@@@Sorts the SORT-FILE in ascending/descending sequence by rec-key.@@@Transfers the sorted records from the work-file to the output-file.@@@Closes the input-file and the output-file and deletes the work-file.",,,"IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.      SELECT INPUT ASSIGN TO IN.      SELECT OUTPUT ASSIGN TO OUT.      SELECT WORK ASSIGN TO WRK.DATA DIVISION.   FILE SECTION.   FD INPUT.      01 INPUT-STUDENT.         05 STUDENT-ID-I PIC 9(5).         05 STUDENT-NAME-I PIC A(25).   FD OUTPUT.      01 OUTPUT-STUDENT.         05 STUDENT-ID-O PIC 9(5).         05 STUDENT-NAME-O PIC A(25).   SD WORK.      01 WORK-STUDENT.         05 STUDENT-ID-W PIC 9(5).         05 STUDENT-NAME-W PIC A(25).PROCEDURE DIVISION.   SORT WORK ON ASCENDING KEY STUDENT-ID-O   USING INPUT GIVING OUTPUT.   DISPLAY 'Sort Successful'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN DD DSN = INPUT-FILE-NAME,DISP = SHR//OUT DD DSN = OUTPUT-FILE-NAME,DISP = SHR//WRK DD DSN = &&TEMP|||MERGE work-file ON ASCENDING KEY rec-key1   [ON DESCENDING KEY rec-key2]USING input-1, input-2 GIVING output-file.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.      SELECT INPUT1 ASSIGN TO IN1.      SELECT INPUT2 ASSIGN TO IN2.      SELECT OUTPUT ASSIGN TO OUT.      SELECT WORK ASSIGN TO WRK.DATA DIVISION.   FILE SECTION.   FD INPUT1.      01 INPUT1-STUDENT.         05 STUDENT-ID-I1 PIC 9(5).         05 STUDENT-NAME-I1 PIC A(25).   FD INPUT2.      01 INPUT2-STUDENT.         05 STUDENT-ID-I2 PIC 9(5).         05 STUDENT-NAME-I2 PIC A(25).   FD OUTPUT.      01 OUTPUT-STUDENT.         05 STUDENT-ID-O PIC 9(5).         05 STUDENT-NAME-O PIC A(25).   SD WORK.      01 WORK-STUDENT.         05 STUDENT-ID-W PIC 9(5).         05 STUDENT-NAME-W PIC A(25).PROCEDURE DIVISION.   MERGE WORK ON ASCENDING KEY STUDENT-ID-O   USING INPUT1, INPUT2 GIVING OUTPUT.   DISPLAY 'Merge Successful'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN=INPUT1-FILE-NAME,DISP=SHR//IN2 DD DSN=INPUT2-FILE-NAME,DISP=SHR//OUT DD DSN = OUTPUT-FILE-NAME,DISP=SHR//WRK DD DSN = &&TEMP"
Learn COBOL,COBOL - Database Interface,COBOL - Database Interface|||Embedded SQL@@@DB2 Application Programming@@@Host Variables@@@SQLCA@@@SQL Queries@@@Cursors@@@Useful Video Courses|||Syntax@@@Syntax@@@Declare Cursor@@@Open@@@Close@@@Fetch|||COBOL Online Training,"As of now, we have learnt the use of files in COBOL. Now, we will discuss how a COBOL program interacts with DB2. It involves the following terms −|||Embedded SQL statements are used in COBOL programs to perform standard SQL operations. Embedded SQL statements are preprocessed by the SQL processor before the application program is compiled. COBOL is known as the Host Language. COBOL-DB2 applications are those applications that include both COBOL and DB2.|||Embedded SQL statements work like normal SQL statements with some minor changes. For example, the output of a query is directed to a predefined set of variables which are referred as Host Variables. An additional INTO clause is placed in the SELECT statement.|||Following are rules to be followed while coding a COBOL-DB2 program −|||All the SQL statements must be delimited between EXEC SQL and ENDEXEC..|||SQL statements must be coded in Area B.|||All the tables that are used in a program must be declared in the WorkingStorage Section. This is done by using the INCLUDE statement.|||All SQL statements other than INCLUDE and DECLARE TABLE must appear in the Procedure Division.|||Host variables are used for receiving data from a table or inserting data in a table. Host variables must be declared for all values that are to be passed between the program and the DB2. They are declared in the Working-Storage Section.|||Host variables cannot be group items, but they may be grouped together in host structure. They cannot be Renamed or Redefined. Using host variables with SQL statements, prefix them with a colon (:)..|||Following is the syntax to declare host variables and include tables in the Working-Storage section −|||SQLCA is a SQL communication area through which DB2 passes the feedback of SQL execution to the program. It tells the program whether an execution was successful or not. There are a number of predefined variables under SQLCA like SQLCODE which contains the error code. The value '000' in SQLCODE states a successful execution.|||Following is the syntax to declare an SQLCA in the Working-Storage section −|||Let’s assume we have one table named as 'Student' that contains Student-Id, Student-Name, and Student-Address.|||The STUDENT table contains the following data −|||The following example shows the usage of SELECT query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of INSERT query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of UPDATE query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of DELETE query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Cursors are used to handle multiple row selections at a time. They are data structures that hold all the results of a query. They can be defined in the Working-Storage Section or the Procedure Division. Following are the operations associated with Cursor −|||Cursor declaration can be done in the Working-Storage Section or the Procedure Division. The first statement is the DECLARE statement which is a nonexecutable statement.|||Before using a cursor, Open statement must be performed. The Open statement prepares the SELECT for execution.|||Close statement releases all the memory occupied by the cursor. It is mandatory to close a cursor before ending a program.|||Fetch statement identifies the cursor and puts the value in the INTO clause. A Fetch statement is coded in loop as we get one row at a time.|||The following example shows the usage of cursor to fetch all the records from the STUDENT table −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −",Embedded SQL@@@DB2 Application Programming@@@Host Variables@@@SQLCA@@@SQL Queries@@@Cursors|||All the SQL statements must be delimited between EXEC SQL and ENDEXEC..@@@SQL statements must be coded in Area B.@@@All the tables that are used in a program must be declared in the WorkingStorage Section. This is done by using the INCLUDE statement.@@@All SQL statements other than INCLUDE and DECLARE TABLE must appear in the Procedure Division.|||Declare@@@Open@@@Close@@@Fetch,,,"DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE table-name   END-EXEC.   EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 STUDENT-REC.      05 STUDENT-ID PIC 9(4).      05 STUDENT-NAME PIC X(25).      05 STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   EXEC SQL      INCLUDE SQLCA   END-EXEC.      EXEC SQL      INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   EXEC SQL      SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS      INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS FROM STUDENT      WHERE STUDENT-ID=1004   END-EXEC.      IF SQLCODE = 0       DISPLAY WS-STUDENT-RECORD   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP = SHR//SYSPRINT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 1005 TO WS-STUDENT-ID.   MOVE 'TutorialsPoint' TO WS-STUDENT-NAME.   MOVE 'Hyderabad' TO WS-STUDENT-ADDRESS.      EXEC SQL      INSERT INTO STUDENT(STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS)      VALUES (:WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS)   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Inserted Successfully'      DISPLAY WS-STUDENT-REC   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 'Bangalore' TO WS-STUDENT-ADDRESS.   EXEC SQL      UPDATE STUDENT SET STUDENT-ADDRESS=:WS-STUDENT-ADDRESS      WHERE STUDENT-ID = 1003   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Updated Successfully'   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP = SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.WORKING-STORAGE SECTION.   EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 1005 TO WS-STUDENT-ID.      EXEC SQL      DELETE FROM STUDENT      WHERE STUDENT-ID=:WS-STUDENT-ID   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Deleted Successfully'   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||EXEC SQL   DECLARE STUDCUR CURSOR FOR   SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS FROM STUDENT   WHERE STUDENT-ID >:WS-STUDENT-IDEND-EXEC.|||EXEC SQL   OPEN STUDCUREND-EXEC.|||EXEC SQL   CLOSE STUDCUREND-EXEC.|||EXEC SQL   FETCH STUDCUR   INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESSEND-EXEC.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.      EXEC SQL      DECLARE STUDCUR CURSOR FOR      SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS FROM STUDENT      WHERE STUDENT-ID >:WS-STUDENT-ID   END-EXEC.PROCEDURE DIVISION.   MOVE 1001 TO WS-STUDENT-ID.   PERFORM UNTIL SQLCODE = 100      EXEC SQL      FETCH STUDCUR      INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS   END-EXEC      DISPLAY WS-STUDENT-RECEND-PERFORM	STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM=IKJEFT01//STEPLIB  DD DSN=MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*"
Learn COBOL,COBOL Questions and Answers,COBOL Questions and Answers|||Useful Video Courses|||COBOL Online Training,"COBOL Questions and Answers has been designed with a special intention of helping students and professionals preparing for various Certification Exams and Job Interviews. This section provides a useful collection of sample Interview Questions and  Multiple Choice Questions (MCQs) and their answers with appropriate explanations.|||This section provides a huge collection of COBOL Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.|||This section provides a great collection of COBOL Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.|||If you are preparing to appear for a Java and COBOL Framework related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.|||This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.",,,"SN@@@Question/Answers Type|||1@@@COBOL Interview Questions
This section provides a huge collection of COBOL Interview Questions with their answers hidden in a box to challenge you to have a go at them before discovering the correct answer.
|||2@@@COBOL Online Quiz
This section provides a great collection of COBOL Multiple Choice Questions (MCQs) on a single page along with their correct answers and explanation. If you select the right option, it turns green; else red.
|||3@@@COBOL Online Test
If you are preparing to appear for a Java and COBOL Framework related certification exam, then this section is a must for you. This section simulates a real online test along with a given timer which challenges you to complete the test within a given time-frame. Finally you can check your overall test score and how you fared among millions of other candidates who attended this online test.
|||4@@@COBOL Mock Test
This section provides various mock tests that you can download at your local machine and solve offline. Every mock test is supplied with a mock test key to let you verify the final score and grade yourself.
",
Learn COBOL,COBOL - Quick Guide,COBOL - Quick Guide@@@COBOL - Overview@@@COBOL - Environment Setup@@@COBOL - Program Structure@@@COBOL - Basic Syntax@@@COBOL - Data Types@@@COBOL - Basic Verbs@@@COBOL - Data Layout@@@COBOL - Conditional Statements@@@COBOL - Loop Statements@@@COBOL - String Handling@@@COBOL - Table Processing@@@COBOL - File Handling@@@COBOL - File Organization@@@COBOL - File Access Mode@@@COBOL - File Handling Verbs@@@COBOL - Subroutines@@@COBOL - Internal Sort@@@COBOL - Database Interface|||Introduction to COBOL@@@Evolution of COBOL@@@Importance of COBOL@@@Features of COBOL@@@Installing COBOL on Windows/Linux@@@Compiling COBOL Programs@@@Executing COBOL Programs@@@Executing COBOL-DB2 programs@@@Divisions@@@Character Set@@@Coding Sheet@@@Character Strings@@@Comment@@@Literal@@@COBOL Word@@@Data Name@@@Level Number@@@Picture Clause@@@Value Clause@@@Input / Output Verbs@@@Initialize Verb@@@Move Verb@@@Legal Moves@@@Add Verb@@@Subtract Verb@@@Multiply Verb@@@Divide Verb@@@Compute Statement@@@Redefines Clause@@@Renames Clause@@@Usage Clause@@@Copybooks@@@IF Condition Statement@@@Relation Condition@@@Sign Condition@@@Class Condition@@@Condition-name Condition@@@Negated Condition@@@Combined Condition@@@Evaluate Verb@@@Perform Thru@@@Perform Until@@@Perform Times@@@Perform Varying@@@GO TO Statement@@@Inspect@@@String@@@Unstring@@@Table Declaration@@@Subscript@@@Index@@@Set Statement@@@Search@@@Search All@@@Field@@@Record@@@File@@@Sequential File Organization@@@Indexed Sequential File Organization@@@Relative File Organization@@@Sequential Access@@@Random Access@@@Dynamic Access@@@Open Verb@@@Read Verb@@@Write Verb@@@Rewrite Verb@@@Delete Verb@@@Start Verb@@@Close Verb@@@Call Verb@@@Call By Reference@@@Call By Content@@@Types of Call@@@Sort Verb@@@Merge Verb@@@Embedded SQL@@@DB2 Application Programming@@@Host Variables@@@SQLCA@@@SQL Queries@@@Cursors@@@Useful Video Courses|||Standard Language@@@Business Oriented@@@Robust Language@@@Structured Language@@@Identification Division@@@Environment Division@@@Data Division@@@Procedure Division@@@Example@@@Comment Line@@@Comment Entry@@@Alphanumeric Literal@@@Numeric Literal@@@User-Defined@@@Reserved Words@@@Figurative Constants@@@Example@@@Example@@@Example@@@Example@@@Accept Verb@@@Display Verb@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Display@@@COMPUTATIONAL / COMP@@@COMP-1@@@COMP-2@@@COMP-3@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@In-line Perform@@@Syntax@@@Out-of-line Perform@@@Syntax@@@Syntax@@@Syntax @@@Syntax@@@Unconditional GO TO@@@Conditional GO TO@@@Tallying@@@Replacing@@@One-Dimensional Table@@@Two-Dimensional Table@@@Physical Record@@@Logical Record@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Called Program Constraints@@@Syntax@@@Called Program@@@Syntax@@@Called Program@@@Syntax@@@Syntax@@@Syntax@@@Syntax@@@Declare Cursor@@@Open@@@Close@@@Fetch|||COBOL Online Training,"COBOL is a high-level language. One must understand the way COBOL works. Computers only understand machine code, a binary stream of 0s and 1s. COBOL code must be converted into machine code  using a compiler. Run the program source through a compiler. The compiler first checks for any syntax errors and then converts it into machine language. The compiler creates an output file which is known as load module. This output file contains executable code in the form of 0s and 1s.|||During 1950s, when the businesses were growing in the western part of the world, there was a need to automate various processes for ease of operation and this gave birth to a high-level programming language meant for business data processing.|||In 1959, COBOL was developed by CODASYL (Conference on Data Systems Language).|||The next version, COBOL-61, was released in 1961 with some revisions.|||In 1968, COBOL was approved by ANSI as a standard language for commercial use (COBOL-68).|||It was again revised in 1974 and 1985 to develop subsequent versions named COBOL-74 and COBOL-85 respectively.|||In 2002, Object-Oriented COBOL was released, which could use encapsulated objects as a normal part of COBOL programming.|||COBOL was the first widely used high-level programming language. It is an English-like language which is user friendly. All the instructions can be coded in simple English words.|||COBOL is also used as a self-documenting language.|||COBOL can handle huge data processing.|||COBOL is compatible with its previous versions.|||COBOL has effective error messages and so, resolution of bugs is easier.|||COBOL is a standard language that can be compiled and executed on machines such as IBM AS/400, personal computers, etc.|||COBOL was designed for business-oriented applications related to financial domain, defense domain, etc. It can handle huge volumes of data because of its advanced file handling capabilities.|||COBOL is a robust language as its numerous debugging and testing tools are available for almost all computer platforms.|||Logical control structures are available in COBOL which makes it easier to read and modify. COBOL has different divisions, so it is easy to debug.|||We have set up the COBOL Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.|||For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.|||There are many Free Mainframe Emulators available for Windows which can be used to write and learn simple COBOL programs.|||One such emulator is Hercules, which can be easily installed on Windows by following a few simple steps as given below −|||Download and install the Hercules emulator, which is available from the Hercules' home site: www.hercules-390.eu|||Once you have installed the package on Windows machine, it will create a folder like C:/hercules/mvs/cobol.|||Run the Command Prompt (CMD) and reach the directory C:/hercules/mvs/cobol on CMD.|||The complete guide on various commands to write and execute a JCL and COBOL programs can be found at:|||www.jaymoseley.com/hercules/installmvs/instmvs2.htm|||Hercules is an open-source software implementation of the mainframe System/370 and ESA/390 architectures, in addition to the latest 64-bit z/Architecture. Hercules runs under Linux, Windows, Solaris, FreeBSD, and Mac OS X.|||A user can connect to a mainframe server in a number of ways such as thin client, dummy terminal, Virtual Client System (VCS), or Virtual Desktop System (VDS). Every valid user is given a login id to enter into the Z/OS interface (TSO/E or ISPF).|||In order to execute a COBOL program in batch mode using JCL, the program needs to be compiled, and a load module is created with all the sub-programs. The JCL uses the load module and not the actual program at the time of execution. The load libraries are concatenated and given to the JCL at the time of execution using JCLLIB or STEPLIB.|||There are many mainframe compiler utilities available to compile a COBOL program. Some corporate companies use Change Management tools like Endevor, which compiles and stores every version of the program. This is useful in tracking the changes made to the program.|||IGYCRCTL is an IBM COBOL compiler utility. The compiler options are passed using the PARM parameter. In the above example, RMODE instructs the compiler to use relative addressing mode in the program. The COBOL program is passed using the SYSIN parameter. Copybook is the library used by the program in SYSLIB.|||Given below is a JCL example where the program MYPROG is executed using the input file MYDATA.URMI.INPUT and produces two output files written to the spool.|||The load module of MYPROG is located in MYDATA.URMI.LOADLIB. This is important to note that the above JCL can be used for a non-DB2 COBOL module only.|||For running a COBOL-DB2 program, a specialized IBM utility is used in the JCL and the program; DB2 region and required parameters are passed as input to the utility.|||The steps followed in running a COBOL-DB2 program are as follows −|||When a COBOL-DB2 program is compiled, a DBRM (Database Request Module) is created along with the load module. The DBRM contains the SQL statements of the COBOL programs with its syntax checked to be correct.|||The DBRM is bound to the DB2 region (environment) in which the COBOL will run. This can be done using the IKJEFT01 utility in a JCL.|||After the bind step, the COBOL-DB2 program is run using IKJEFT01 (again) with the load library and the DBRM library as the input to the JCL.|||In the above example, MYCOBB is the COBOL-DB2 program run using IKJEFT01. Please note that the program name, DB2 Sub-System Id (SSID), and DB2 Plan name are passed within the SYSTSIN DD statement. The DBRM library is specified in the STEPLIB.|||A COBOL program structure consists of divisions as shown in the following image −|||A brief introduction of these divisions is given below −|||Sections are the logical subdivision of program logic. A section is a collection of paragraphs.|||Paragraphs are the subdivision of a section or division. It is either a user-defined or a predefined name followed by a period, and consists of zero or more sentences/entries.|||Sentences are the combination of one or more statements. Sentences appear only in the Procedure division. A sentence must end with a period.|||Statements are meaningful COBOL statements that perform some processing.|||Characters are the lowest in the hierarchy and cannot be divisible.|||You can co-relate the above-mentioned terms with the COBOL program in the following example −|||A COBOL program consists of four divisions.|||It is the first and only mandatory division of every COBOL program. The programmer and the compiler use this division to identify the program. In this division, PROGRAM-ID is the only mandatory paragraph. PROGRAM-ID specifies the program name that can consist 1 to 30 characters.|||Try the following example using the Live Demo option online.|||Given below is the JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Environment division is used to specify input and output files to the program. It consists of two sections −|||Configuration section provides information about the system on which the program is written and executed. It consists of two paragraphs −|||Source computer − System used to compile the program.|||Object computer − System used to execute the program.|||Input-Output section provides information about the files to be used in the program. It consists of two paragraphs −|||File control − Provides information of external data sets used in the program.|||I-O control − Provides information of files used in the program.|||Data division is used to define the variables used in the program. It consists of four sections −|||File section is used to define the record structure of the file.|||Working-Storage section is used to declare temporary variables and file structures which are used in the program.|||Local-Storage section is similar to Working-Storage section. The only difference is that the variables will be allocated and initialized every time a program starts execution.|||Linkage section is used to describe the data names that are received from an external program.|||COBOL Program|||The JCL to execute the above COBOL program is as follows −|||When you compile and execute the above program, it produces the following result −|||Procedure division is used to include the logic of the program. It consists of executable statements using variables defined in the data division. In this division, paragraph and section names are user-defined.|||There must be at least one statement in the procedure division. The last statement to end the execution in this division is either STOP RUN which is used in the calling programs or EXIT PROGRAM which is used in the called programs.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||'Characters' are lowest in the hierarchy and they cannot be divided further. The COBOL Character Set includes 78 characters which are shown below −|||A-Z|||Alphabets(Upper Case)|||a-z|||Alphabets (Lower Case)|||0-9|||Numeric||| |||Space|||+|||Plus Sign|||-|||Minus Sign or Hyphen|||*|||Asterisk|||/|||Forward Slash|||$|||Currency Sign|||,|||Comma|||;|||Semicolon|||.|||Decimal Point or Period|||""|||Quotation Marks|||(|||Left Parenthesis|||)|||Right Parenthesis|||>|||Greater than|||<|||Less than|||:|||Colon|||'|||Apostrophe|||=|||Equal Sign|||The source program of COBOL must be written in a format acceptable to the compilers. COBOL programs are written on COBOL coding sheets. There are 80 character positions on each line of a coding sheet.|||Character positions are grouped into the following five fields −|||The following example shows a COBOL coding sheet −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Character strings are formed by combining individual characters. A character string can be a|||All character strings must be ended with separators. A separator is used to separate character strings.|||Frequently used separators − Space, Comma, Period, Apostrophe, Left/Right Parenthesis, and Quotation mark.|||A comment is a character string that does not affect the execution of a program. It can be any combination of characters.|||There are two types of comments −|||A comment line can be written in any column. The compiler does not check a comment line for syntax and treats it for documentation.|||Comment entries are those that are included in the optional paragraphs of an Identification Division. They are written in Area B and programmers use it for reference.|||The text highlighted in Bold are the commented entries in the following example −|||JCL to execute above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Literal is a constant that is directly hard-coded in a program. In the following example, ""Hello World"" is a literal.|||There are two types of literals as discussed below −|||Alphanumeric Literals are enclosed in quotes or apostrophe. Length can be up to 160 characters. An apostrophe or a quote can be a part of a literal only if it is paired. Starting and ending of the literal should be same, either apostrophe or quote.|||Example|||The following example shows valid and invalid Alphanumeric Literals −|||A Numeric Literal is a combination of digits from 0 to 9, +, –, or decimal point. Length can be up to 18 characters. Sign cannot be the rightmost character. Decimal point should not appear at the end.|||Example|||The following example shows valid and invalid Numeric Literals −|||COBOL Word is a character string that can be a reserved word or a user-defined word. Length can be up to 30 characters.|||User-defined words are used for naming files, data, records, paragraph names, and sections. Alphabets, digits, and hyphens are allowed while forming userdefined words. You cannot use COBOL reserved words.|||Reserved words are predefined words in COBOL. Different types of reserved words that we use frequently are as follows −|||Keywords like ADD, ACCEPT, MOVE, etc.|||Special characters words like +, -, *, <, <=, etc|||Figurative constants are constant values like ZERO, SPACES, etc. All the constant values of figurative constants are mentioned in the following table.|||HIGH-VALUES|||One or more characters which will be at the highest position in descending order.|||LOW-VALUES|||One or more characters have zeros in binary representation.|||ZERO/ZEROES|||One or more zero depending on the size of the variable.|||SPACES|||One or more spaces.|||QUOTES|||Single or double quotes.|||ALL literal|||Fills the data-item with Literal.|||Data Division is used to define the variables used in a program. To describe data in COBOL, one must understand the following terms −|||Data names must be defined in the Data Division before using them in the Procedure Division. They must have a user-defined name; reserved words cannot be used. Data names give reference to the memory locations where actual data is stored. They can be elementary or group type.|||The following example shows valid and invalid data names −|||Level number is used to specify the level of data in a record. They are used to differentiate between elementary items and group items. Elementary items can be grouped together to create group items.|||01|||Record description entry|||02 to 49|||Group and Elementary items|||66|||Rename Clause items|||77|||Items which cannot be sub-divided|||88|||Condition name entry|||Elementary items cannot be divided further. Level number, Data name, Picture clause, and Value clause (optional) are used to describe an elementary item.|||Group items consist of one or more elementary items. Level number, Data name, and Value clause (optional) are used to describe a group item. Group level number is always 01.|||The following example shows Group and Elementary items −|||Picture clause is used to define the following items −|||Data type can be numeric, alphabetic, or alphanumeric. Numeric type consists of only digits 0 to 9. Alphabetic type consists of letters A to Z and spaces. Alphanumeric type consists of digits, letters, and special characters.|||Sign can be used with numeric data. It can be either + or –.|||Decimal point position can be used with numeric data. Assumed position is the position of decimal point and not included in the data.|||Length defines the number of bytes used by the data item.|||Symbols used in a Picture clause −|||9|||Numeric|||A|||Alphabetic|||X|||Alphanumeric|||V|||Implicit Decimal|||S|||Sign|||P|||Assumed Decimal|||The following example shows the use of PIC clause −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Value clause is an optional clause which is used to initialize the data items. The values can be numeric literal, alphanumeric literal, or figurative constant. It can be used with both group and elementary items.|||The following example shows the use of VALUE clause −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||COBOL verbs are used in the procedure division for data processing. A statement always start with a COBOL verb. There are several COBOL verbs with different types of actions.|||Input/Output verbs are used to get data from the user and display the output of COBOL programs. The following two verbs are used for this process −|||Accept verb is used to get data such as date, time, and day from the operating system or directly from the user. If a program is accepting data from the user, then it needs to be passed through JCL. While getting data from the operating system, FROM option is included as shown in the following example −|||Display verb is used to display the output of a COBOL program.|||COBOL PROGRAM|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Initialize verb is used to initialize a group item or an elementary item. Data names with RENAME clause cannot be initialized. Numeric data items are replaced by ZEROES. Alphanumeric or alphabetic data items are replaced by SPACES. If we include REPLACING term, then data items can be initialized to the given replacing value as shown in the following example −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Move verb is used to copy data from source data to destination data. It can be used on both elementary and group data items. For group data items, MOVE CORRESPONDING/CORR is used. In try it option, MOVE CORR is not working; but on a mainframe server, it will work.|||For moving data from a string, MOVE(x:l) is used where x is the starting position and l is the length. Data will be truncated if the destination data item PIC clause is less than the source data item PIC clause. If the destination data item PIC clause is more than the source data item PIC clause, then ZEROS or SPACES will be added in the extra bytes. The following example makes it clear.|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||The following table gives information about the legal moves −|||Add verb is used to add two or more numbers and store the result in the destination operand.|||Given below is the syntax to Add two or more numbers −|||In syntax-1, A, B, C are added and the result is stored in C (C=A+B+C). A, B, D are added and the result is stored in D (D = A + B + D).|||In syntax-2, A, B, C, D are added and the result is stored in E (E=A+B+C+D).|||In syntax-3, sub-group items within WS-GROUP1 and WS-GROUP2 are added and the result is stored in WS-GROUP2.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Subtract verb is used for subtraction operations.|||Given below is the syntax for Subtract operations −|||In syntax-1, A and B are added and subtracted from C. The result is stored in C (C = C-(A+B)). A and B are added and subtracted from D. The result is stored in D (D = D-(A+B)).|||In syntax-2, A, B, C are added and subtracted from D. The result is stored in E (E = D-(A+B+C))|||In syntax-3, sub-group items within WS-GROUP1 and WS-GROUP2 are subtracted and the result is stored in WS-GROUP2.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Multiply verb is used for multiplication operations.|||Given below is the syntax to multiply two or more numbers −|||In syntax-1, A and B are multipled and the result is stored in B (B=A*B). A and C are multipled and the result is stored in C (C = A * C).|||In syntax-2, A and B are multipled and the result is stored in E (E=A*B).|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Divide verb is used for division operations.|||Given below is the syntax for division operations −|||In syntax-1, B is divided by A and the result is stored in B (B=B/A).|||In syntax-2, A is divided by B and the result is stored in C (C=A/B) and the remainder is stored in R.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Compute statement is used to write arithmetic expressions in COBOL. This is a replacement for Add, Subtract, Multiply, and Divide.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||COBOL layout is the description of use of each field and the values present in it. Following are the data description entries used in COBOL −|||Redefines clause is used to define a storage with different data description. If one or more data items are not used simultaneously, then the same storage can be utilized for another data item. So the same storage can be referred with different data items.|||Following is the syntax for Redefines clause −|||Following are the details of the used parameters −|||Level numbers of redefined item and redefining item must be the same and it cannot be 66 or 88 level number. Do not use VALUE clause with a redefining item. In File Section, do not use a redefines clause with 01 level number. Redefines definition must be the next data description you want to redefine. A redefining item will always have the same value as a redefined item.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Renames clause is used to give different names to existing data items. It is used to re-group the data names and give a new name to them. The new data names can rename across groups or elementary items. Level number 66 is reserved for renames.|||Syntax|||Following is the syntax for Renames clause −|||Renaming is possible at same level only. In the above example, WS-A, WS-B, and WS-C are at the same level. Renames definition must be the next data description you want to rename. Do not use Renames with 01, 77, or 66 level number. The data names used for renames must come in sequence. Data items with occur clause cannot be renamed.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Usage clause specifies the operating system in which the format data is stored. It cannot be used with level numbers 66 or 88. If usage clause is specified on a group, then all the elementary items will have the same usage clause. The different options available with Usage clause are as follows −|||Data item is stored in ASCII format and each character will take 1 byte. It is default usage.|||The following example calculates the number of bytes required −|||Data item is stored in binary format. Here, data items must be integer.|||The following example calculates the number of bytes required −|||Data item is similar to Real or Float and is represented as a single precision floating point number. Internally, data is stored in hexadecimal format. COMP-1 does not accept PIC clause. Here 1 word is equal to 4 bytes.|||Data item is similar to Long or Double and is represented as double precision floating point number. Internally, data is stored in hexadecimal format.  COMP-2 does not specify PIC clause. Here 2 word is equal to 8 bytes.|||Data item is stored in packed decimal format. Each digit occupies half a byte (1 nibble) and the sign is stored at the rightmost nibble.|||The following example calculates the number of bytes required −|||A COBOL copybook is a selection of code that defines data structures. If a particular data structure is used in many programs, then instead of writing the same data structure again, we can use copybooks. We use the COPY statement to include a copybook in a program. COPY statement is used in the WorkingStorage Section.|||The following example includes a copybook inside a COBOL program −|||Here ABC is the copybook name. The following data items in ABC copybook can be used inside a program.|||Conditional statements are used to change the execution flow depending on certain conditions specified by the programmer. Conditional statements will always evaluate to true or false. Conditions are used in IF, Evaluate, and Perform statements. The different types of conditions are as follows −|||IF statement checks for conditions. If a condition is true, the IF block is executed; and if the condition is false, the ELSE block is executed.|||END-IF is used to end the IF block. To end the IF block, a period can be used instead of END-IF. But it is always preferable to use END-IF for multiple IF blocks.|||Nested-IF − IF blocks appearing inside another IF block. There is no limit to the depth of nested IF statements.|||Following is the syntax of IF condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Relation condition compares two operands, either of which can be an identifier, literal, or arithmetic expression. Algebraic comparison of numeric fields is done regardless of size and usage clause.|||For non-numeric operands|||If two non-numeric operands of equal size are compared, then the characters are compared from left with the corresponding positions till the end is reached. The operand containing greater number of characters is declared greater.|||If two non-numeric operands of unequal size are compared, then the shorter data item is appended with spaces at the end till the size of the operands becomes equal and then compared according to the rules mentioned in the previous point.|||Given below is the syntax of Relation condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Sign condition is used to check the sign of a numeric operand. It determines whether a given numeric value is greater than, less than, or equal to ZERO.|||Following is the syntax of Sign condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program it produces the following result −|||Class condition is used to check if an operand contains only alphabets or numeric data. Spaces are considered in ALPHABETIC, ALPHABETIC-LOWER, and ALPHABETIC-UPPER.|||Following is the syntax of Class condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A condition-name is a user-defined name. It contains a set of values specified by the user. It behaves like Boolean variables. They are defined with level number 88. It will not have a PIC clause.|||Following is the syntax of user-defined condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Negated condition is given by using the NOT keyword. If a condition is true and we have given NOT in front of it, then its final value will be false.|||Following is the syntax of Negated condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A combined condition contains two or more conditions connected using logical operators AND or OR.|||Following is the syntax of combined condition statements −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Evaluate verb is a replacement of series of IF-ELSE statement. It can be used to evaluate more than one condition. It is similar to SWITCH statement in C programs.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||There are some tasks that need to be done over and over again like reading each record of a file till its end. The loop statements used in COBOL are −|||Perform Thru is used to execute a series of paragraph by giving the first and last paragraph names in the sequence. After executing the last paragraph, the control is returned back.|||Statements inside the PERFORM will be executed till END-PERFORM is reached.|||Following is the syntax of In-line perform −|||Here, a statement is executed in one paragraph and then the control is transferred to other paragraph or section.|||Following is the syntax of Out-of-line perform −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||In ‘perform until’, a paragraph is executed until the given condition becomes true. ‘With test before’ is the default condition and it indicates that the condition is checked before the execution of statements in a paragraph.|||Following is the syntax of perform until −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||In ‘perform times’, a paragraph will be executed the number of times specified.|||Following is the syntax of perform times −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||In perform varying, a paragraph will be executed till the condition in Until phrase becomes true.|||Following is the syntax of perform varying −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||GO TO statement is used to change the flow of execution in a program. In GO TO statements, transfer goes only in the forward direction. It is used to exit a paragraph. The different types of GO TO statements used are as follows −|||If 'x' is equal to 1, then the control will be transferred to the first paragraph; and if 'x' is equal to 2, then the control will be transferred to the second paragraph, and so on.|||Example|||JCL to execute the above COBOL program:|||When you compile and execute the above program, it produces the following result:|||String handling statements in COBOL are used to do multiple functional operations on strings. Following are the string handling statements −|||Inspect verb is used to count or replace the characters in a string. String operations can be performed on alphanumeric, numeric, or alphabetic values. Inspect operations are performed from left to right. The options used for the string operations are as follows −|||Tallying option is used to count the string characters.|||Syntax|||Following is the syntax of Tallying option −|||The parameters used are −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Replacing option is used to replace the string characters.|||Syntax|||Following is the syntax of Replacing option −|||The parameter used is −|||input-string − The string whose characters are to be replaced from char1 to char2.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||String verb is used to concatenate the strings. Using STRING statement, two or more strings of characters can be combined to form a longer string. ‘Delimited By’ clause is compulsory.|||Syntax|||Following is the syntax of String verb −|||Following are the details of the used parameters −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Unstring verb is used to split one string into multiple sub-strings. Delimited By clause is compulsory.|||Syntax|||Following is the syntax of Unstring verb −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Arrays in COBOL are known as tables. An array is a linear data structure and is a collection of individual data items of same type. Data items of a table are internally sorted.|||Table is declared in Data Division. Occurs clause is used to define a table. Occurs clause indicates the repetition of data name definition. It can be used only with level numbers starting from 02 to 49. Do not use occurs clause with Redefines. Description of one-dimensional and two-dimensional table is as follows −|||In a one-dimensional table, occurs clause is used only once in declaration. WSTABLE is the group item that contains table. WS-B names the table elements that occur 10 times.|||Syntax|||Following is the syntax for defining a one-dimensional table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||A two-dimensional table is created with both data elements being variable length. For reference, go through the syntax and then try to analyze the table. The first array (WS-A) can occur from 1 to 10 times and the inner array (WS-C) can occur from 1 to 5 times. For each entry of WS-A, there will be corresponding 5 entries of WS-C.|||Syntax|||Following is the syntax for defining a two-dimensional table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Table individual elements can be accessed by using subscript. Subscript values can range from 1 to the number of times the table occurs. A subscript can be any positive number. It does not require any declaration in data division. It is automatically created with occurs clause.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Table elements can also be accessed using index. An index is a displacement of element from the start of the table. An index is declared with Occurs clause using INDEXED BY clause. The value of index can be changed using SET statement and PERFORM Varying option.|||Syntax|||Following is the syntax for defining Index in a table −|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Set statement is used to change the index value. Set verb is used to initialize, increment, or decrement the index value. It is used with Search and Search All to locate elements in table.|||Syntax|||Following is the syntax for using a Set statement −|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Search is a linear search method, which is used to find elements inside the table. It can be performed on sorted as well as unsorted table. It is used only for tables declared by Index phrase. It starts with the initial value of index. If the searched element is not found, then the index is automatically incremented by 1 and it continues till the end of table.|||Example|||JCL to execute the above COBOL program.|||When you compile and execute the above program, it produces the following result −|||Search All is a binary search method, which is used to find elements inside the table. Table must be in sorted order for Search All option. The index does not require initialization. In binary search, the table is divided into two halves and it determines in which half the searched element is present. This process repeats till the element is found or the end is reached.|||Example|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The concept of files in COBOL is different from that in C/C++. While learning the basics of 'File' in COBOL, the concepts of both languages should not be corelated. Simple text files cannot be used in COBOL, instead PS (Physical Sequential) and VSAM files are used. PS files will be discussed in this module.|||To understand file handling in COBOL, one must know the basic terms. These terms only serve to understand the fundamentals of file handling. Further in depth terminology would be discussed in the chapter 'File Handling Verbs'. Following are the basic terms −|||The following example helps in understanding these terms −|||Field is used to indicate the data stored about an element. It represents a single element as shown in the above example such as student id, name, marks, total marks, and percentage. The number of characters in any field is known as field size, for example, student name can have 10 characters. Fields can have the following attributes −|||Primary keys are those fields that are unique to each record and are used to identify a particular record. For example, in students marks file, each student will be having a unique student id which forms the primary key.|||Secondary keys are unique or non-unique fields that are used to search for related data. For example, in students marks file, full name of student can be used as secondary key when student id is not known.|||Descriptors fields are used to describe an entity. For example, in students marks file, marks and percentage fields that add meaning to the record are known descriptors.|||Record is a collection of fields that is used to describe an entity. One or more fields together form a record. For example, in students marks file, student id, name, marks, total marks, and percentage form one record. The cumulative size of all the fields in a record is known as the record size. The records present in a file may be of fixed length or variable length.|||Physical record is the information that exists on the external device. It is also known as a block.|||Logical record is the information used by the program. In COBOL programs, only one record can be handled at any point of time and it is called as logical record.|||File is a collection of related records. For example, the students marks file consists of records of all the students.|||File organization indicates how the records are organized in a file. There are different types of organizations for files so as to increase their efficiency of accessing the records. Following are the types of file organization schemes −|||The syntaxes in this module, mentioned along with their respective terms, only refer to their usage in the program. The complete programs using these syntaxes would be discussed in the chapter 'File handling Verbs'.|||A sequential file consists of records that are stored and accessed in sequential order. Following are the key attributes of sequential file organization −|||Records can be read in sequential order. For reading the 10th record, all the previous 9 records should be read.|||Records are written in sequential order. A new record cannot be inserted in between. A new record is always inserted at the end of the file.|||After placing a record into a sequential file, it is not possible to delete,  shorten, or lengthen a record.|||Order of the records, once inserted, can never be changed.|||Updation of record is possible. A record can be overwritten, if the new record length is same as the old record length.|||Sequential output files are good option for printing.|||Following is the syntax of sequential file organization −|||An indexed sequential file consists of records that can be accessed sequentially. Direct access is also possible. It consists of two parts −|||Data File contains records in sequential scheme.|||Index File contains the primary key and its address in the data file.|||Following are the key attributes of sequential file organization −|||Records can be read in sequential order just like in sequential file organization.|||Records can be accessed randomly if the primary key is known. Index file is used to get the address of a record and then the record is fetched from the data file.|||Sorted index is maintained in this file system which relates the key value to the position of the record in the file.|||Alternate index can also be created to fetch the records.|||Following is the syntax of indexed sequential file organization −|||A relative file consists of records ordered by their relative address. Following are the key attributes of relative file organization −|||Records can be read in sequential order just like in sequential and indexed file organization.|||Records can be accessed using relative key. Relative key represents the record’s location relative to the address of the start of the file.|||Records can be inserted using relative key. Relative address is calculated using relative key.|||Relative file provides the fastest access to the records.|||The main disadvantage of this file system is that if some intermediate records are missing, they will also occupy space.|||Following is the syntax of relative file organization −|||Till now, file organization schemes have been discussed. For each file organization scheme, different access modes can be used. Following are the types of file access modes −|||The syntaxes in this module, mentioned along with their respective terms, only refer to their usage in the program. The complete programs using these syntaxes would be discussed in the next chapter.|||When the access mode is sequential, the method of record retrieval changes as per the selected file organization.|||For sequential files, records are accessed in the same order in which they were inserted.|||For indexed files, the parameter used to fetch the records are the record key values.|||For relative files, relative record keys are used to retrieve the records.|||Following is the syntax of sequential access mode −|||When the access mode is RANDOM, the method of record retrieval changes as per the selected file organization.|||For indexed files, records are accessed according to the value placed in a key field which can be primary or alternate key. There can be one or more alternate indexes.|||For relative files , records are retrieved through relative record keys.|||Following is the syntax of random access mode −|||Dynamic access supports both sequential and random access in the same program. With dynamic access, one file definition is used to perform both sequential and random processing like accessing some records in sequential order and other records by their keys.|||With relative and indexed files, the dynamic access mode allows you to switch back and forth between sequential access mode and random access mode while reading a file by using the NEXT phrase on the READ statement. NEXT and READ functionalities will be discussed in the next chapter.|||Following is the syntax of dynamic access mode −|||File handling verbs are used to perform various operations on files. Following are the file handling verbs −|||Open is the first file operation that must be performed. If Open is successful, then only further operations are possible on a file. Only after opening a file, the variables in the file structure are available for processing. FILE STATUS variable is updated after each file operation.|||Here, file-name is string literal, which you will use to name your file. A file can be opened in the following modes −|||Input|||Input mode is used for existing files. In this mode, we can only read the file, no other operations are allowed on the file.|||Output|||Output mode is used to insert records in files. If a sequential file is  used and the file is holding some records, then the existing records will be deleted first and then new records will be inserted in the file. It will not happen so in case of an indexed file or a relative file.|||Extend|||Extend mode is used to append records in a sequential file. In this mode, records are inserted at the end. If file access mode is Random or Dynamic, then extend mode cannot be used.|||I-O|||Input-Output mode is used to read and rewrite the records of a file.|||Read verb is used to read the file records. The function of read is to fetch records from a file. At each read verb, only one record can be read into the file structure. To perform a read operation, open the file in INPUT or I-O mode. At each read statement, the file pointer is incremented and hence the successive records are read.|||Following is the syntax to read the records when the file access mode is sequential −|||Following are the parameters used −|||NEXT RECORD is optional and is specified when an indexed sequential file is being read sequentially.|||INTO clause is optional. ws-file-structure is defined in the WorkingStorage Section to get the values from the READ statement.|||AT END condition becomes True when the end of file is reached.|||Example − The following example reads an existing file using line sequential organization. This program can be compiled and executed using Live Demo option where it will display all the records present in the file.|||Suppose the input file data available in the input.txt file contains the following −|||When you compile and execute the above program, it produces the following result −|||Following is the syntax to read a record when the file access mode is random −|||Example − The following example reads an existing file using indexed organization. This program can be compiled and executed using JCL on Mainframes where it will display all the records present in the file. On Mainframes server, we do not use text files; instead we use PS files.|||Let's assume that the file present on Mainframes have same content as input.txt file in the above example.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Write verb is used to insert records in a file. Once the record is written, it is no longer available in the record buffer. Before inserting records into the file, move the values into the record buffer and then perform write verb.|||Write statement can be used with FROM option to directly write records from the working storage variables. From is an optional clause. If the access mode is sequential, then to write a record, the file must open in Output mode or Extend mode. If the access mode is random or dynamic, then to write a record, the file must open in Output mode or I-O mode.|||Following is the syntax to read a record when the file organization is sequential −|||Following is the syntax to read a record when the file organization is indexed or relative −|||Example − The following example shows how to insert a new record in a new file when the organization is sequential.|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it will add a new record to the output file.|||Rewrite verb is used to update the records. File should be opened in I-O mode for rewrite operations. It can be used only after a successful Read operation. Rewrite verb overwrites the last record read.|||Following is the syntax to read a record when the file organization is sequential −|||Following is the syntax to read a record when the file organization is indexed or relative −|||Example − The following example shows how to update an existing record which we have inserted in the previous Write step −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it will update the record −|||Delete verb can be performed only on indexed and relative files. The file must be opened in I-O mode. In sequential file organization, records cannot be deleted. The record last read by the Read statement is deleted in case of sequential access mode. In random access mode, specify the record key and then perform the Delete operation.|||Following is the syntax to delete a record −|||Example − to delete an existing record −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Start verb can be performed only on indexed and relative files. It is used to place the file pointer at a specific record. The access mode must be sequential or dynamic. File must be opened in I-O or Input mode.|||Following is the syntax to place the pointer at a specific record −|||Close verb is used to close a file. After performing Close operation, the variables in the file structure will not be available for processing. The link between program and file is lost.|||Following is the syntax to close a file −|||Cobol subroutine is a program that can be compiled independently but cannot be executed independently. There are two types of subroutines: internal subroutines like Perform statements and external subroutines like CALL verb.|||Call verb is used to transfer the control from one program to another program. The program that contains the CALL verb is the Calling Program and the program being called is known as the Called Program. Calling program execution will halt until the called program finishes the execution. Exit Program statement is used in the Called program to transfer the control back.|||Following are the called program requirements −|||Linkage section must be defined in the called program. It consists of data elements passed in the program. The data items should not have Value clause. PIC clause must be compatible with the variables passed through the calling program.|||Procedure division using has a list of variables passed from the calling program and the order must be same as mentioned in the Call verb.|||Exit program statement is used in the called program to transfer the control back. It must be the last statement in the called program.|||The parameters can be passed between programs in two ways −|||If the values of variables in the called program are modified, then their new values will reflect in the calling program. If BY clause is not specified, then variables are always passed by reference.|||Following is the syntax of calling subroutine by reference −|||Example|||Following example is the MAIN calling program and UTIL is the called program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||If the values of variables in the called program are modified, then their new values will not reflect in the calling program.|||Following is the syntax of calling subroutine by content −|||Example|||Following example is the MAIN calling program and UTIL is the called program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||There are two types of calls −|||Static Call occurs when a program is compiled with the NODYNAM compiler option. A static called program is loaded into storage at compile time.|||Dynamic Call occurs when a program is compiled with the DYNAM and NODLL compiler option. A dynamic called program is loaded into storage at runtime.|||Sorting of data in a file or merging of two or more files is a common necessity in almost all business-oriented applications. Sorting is used for arranging records either in ascending or descending order, so that sequential processing can be performed. There are two techniques which are used for sorting files in COBOL −|||External sort is used to sort files by using the SORT utility in JCL. We have discussed this in the JCL chapter. As of now, we will focus on internal sort.|||Internal sort is used to sort files within a COBOL program. SORT verb is used to sort a file.|||Three files are used in the sort process in COBOL −|||Input file is the file which we have to sort either in ascending or descending order.|||Work file is used to hold records while the sort process is in progress. Input file records are transferred to the work file for the sorting process. This file should be defined in the File-Section under SD entry.|||Output file is the file which we get after the sorting process. It is the final output of the Sort verb.|||Following is the syntax to sort a file −|||SORT performs the following operations −|||Opens work-file in I-O mode, input-file in the INPUT mode and output-file in the OUTPUT mode.|||Transfers the records present in the input-file to the work-file.|||Sorts the SORT-FILE in ascending/descending sequence by rec-key.|||Transfers the sorted records from the work-file to the output-file.|||Closes the input-file and the output-file and deletes the work-file.|||Example|||In the following example, INPUT is the input file which needs to be sorted in ascending order −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Two or more identically sequenced files are combined using Merge statement. Files used in the merge process −|||Following is the syntax to merge two or more files −|||Merge performs the following operations −|||Opens the work-file in I-O mode, input-files in the INPUT mode and output-file in the OUTPUT mode.|||Transfers the records present in the input-files to the work-file.|||Sorts the SORT-FILE in ascending/descending sequence by rec-key.|||Transfers the sorted records from the work-file to the output-file.|||Closes the input-file and the output-file and deletes the work-file.|||Example|||In the following example, INPUT1 and INPUT2 are the input files which are to be merged in ascending order −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||As of now, we have learnt the use of files in COBOL. Now, we will discuss how a COBOL program interacts with DB2. It involves the following terms −|||Embedded SQL statements are used in COBOL programs to perform standard SQL operations. Embedded SQL statements are preprocessed by the SQL processor before the application program is compiled. COBOL is known as the Host Language. COBOL-DB2 applications are those applications that include both COBOL and DB2.|||Embedded SQL statements work like normal SQL statements with some minor changes. For example, the output of a query is directed to a predefined set of variables which are referred as Host Variables. An additional INTO clause is placed in the SELECT statement.|||Following are rules to be followed while coding a COBOL-DB2 program −|||All the SQL statements must be delimited between EXEC SQL and ENDEXEC..|||SQL statements must be coded in Area B.|||All the tables that are used in a program must be declared in the WorkingStorage Section. This is done by using the INCLUDE statement.|||All SQL statements other than INCLUDE and DECLARE TABLE must appear in the Procedure Division.|||Host variables are used for receiving data from a table or inserting data in a table. Host variables must be declared for all values that are to be passed between the program and the DB2. They are declared in the Working-Storage Section.|||Host variables cannot be group items, but they may be grouped together in host structure. They cannot be Renamed or Redefined. Using host variables with SQL statements, prefix them with a colon (:)..|||Following is the syntax to declare host variables and include tables in the Working-Storage section −|||SQLCA is a SQL communication area through which DB2 passes the feedback of SQL execution to the program. It tells the program whether an execution was successful or not. There are a number of predefined variables under SQLCA like SQLCODE which contains the error code. The value '000' in SQLCODE states a successful execution.|||Following is the syntax to declare an SQLCA in the Working-Storage section −|||Let’s assume we have one table named as 'Student' that contains Student-Id, Student-Name, and Student-Address.|||The STUDENT table contains the following data −|||The following example shows the usage of SELECT query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of INSERT query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of UPDATE query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||The following example shows the usage of DELETE query in a COBOL program −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −|||Cursors are used to handle multiple row selections at a time. They are data structures that hold all the results of a query. They can be defined in the Working-Storage Section or the Procedure Division. Following are the operations associated with Cursor −|||Cursor declaration can be done in the Working-Storage Section or the Procedure Division. The first statement is the DECLARE statement which is a nonexecutable statement.|||Before using a cursor, Open statement must be performed. The Open statement prepares the SELECT for execution.|||Close statement releases all the memory occupied by the cursor. It is mandatory to close a cursor before ending a program.|||Fetch statement identifies the cursor and puts the value in the INTO clause. A Fetch statement is coded in loop as we get one row at a time.|||The following example shows the usage of cursor to fetch all the records from the STUDENT table −|||JCL to execute the above COBOL program −|||When you compile and execute the above program, it produces the following result −","In 1959, COBOL was developed by CODASYL (Conference on Data Systems Language).@@@The next version, COBOL-61, was released in 1961 with some revisions.@@@In 1968, COBOL was approved by ANSI as a standard language for commercial use (COBOL-68).@@@It was again revised in 1974 and 1985 to develop subsequent versions named COBOL-74 and COBOL-85 respectively.@@@In 2002, Object-Oriented COBOL was released, which could use encapsulated objects as a normal part of COBOL programming.|||COBOL was the first widely used high-level programming language. It is an English-like language which is user friendly. All the instructions can be coded in simple English words.@@@COBOL is also used as a self-documenting language.@@@COBOL can handle huge data processing.@@@COBOL is compatible with its previous versions.@@@COBOL has effective error messages and so, resolution of bugs is easier.|||Download and install the Hercules emulator, which is available from the Hercules' home site: www.hercules-390.eu@@@Once you have installed the package on Windows machine, it will create a folder like C:/hercules/mvs/cobol.@@@Run the Command Prompt (CMD) and reach the directory C:/hercules/mvs/cobol on CMD.@@@The complete guide on various commands to write and execute a JCL and COBOL programs can be found at:
www.jaymoseley.com/hercules/installmvs/instmvs2.htm|||When a COBOL-DB2 program is compiled, a DBRM (Database Request Module) is created along with the load module. The DBRM contains the SQL statements of the COBOL programs with its syntax checked to be correct.@@@The DBRM is bound to the DB2 region (environment) in which the COBOL will run. This can be done using the IKJEFT01 utility in a JCL.@@@After the bind step, the COBOL-DB2 program is run using IKJEFT01 (again) with the load library and the DBRM library as the input to the JCL.|||Sections are the logical subdivision of program logic. A section is a collection of paragraphs.@@@Paragraphs are the subdivision of a section or division. It is either a user-defined or a predefined name followed by a period, and consists of zero or more sentences/entries.@@@Sentences are the combination of one or more statements. Sentences appear only in the Procedure division. A sentence must end with a period.@@@Statements are meaningful COBOL statements that perform some processing.@@@Characters are the lowest in the hierarchy and cannot be divisible.|||Configuration section provides information about the system on which the program is written and executed. It consists of two paragraphs −

Source computer − System used to compile the program.
Object computer − System used to execute the program.
@@@Source computer − System used to compile the program.@@@Object computer − System used to execute the program.@@@Input-Output section provides information about the files to be used in the program. It consists of two paragraphs −

File control − Provides information of external data sets used in the program.
I-O control − Provides information of files used in the program.
@@@File control − Provides information of external data sets used in the program.@@@I-O control − Provides information of files used in the program.|||Source computer − System used to compile the program.@@@Object computer − System used to execute the program.|||File control − Provides information of external data sets used in the program.@@@I-O control − Provides information of files used in the program.|||File section is used to define the record structure of the file.@@@Working-Storage section is used to declare temporary variables and file structures which are used in the program.@@@Local-Storage section is similar to Working-Storage section. The only difference is that the variables will be allocated and initialized every time a program starts execution.@@@Linkage section is used to describe the data names that are received from an external program.|||Comment,@@@Literal, or@@@COBOL word.|||Keywords like ADD, ACCEPT, MOVE, etc.@@@Special characters words like +, -, *, <, <=, etc@@@Figurative constants are constant values like ZERO, SPACES, etc. All the constant values of figurative constants are mentioned in the following table.|||Data Name@@@Level Number@@@Picture Clause@@@Value Clause|||Elementary items cannot be divided further. Level number, Data name, Picture clause, and Value clause (optional) are used to describe an elementary item.@@@Group items consist of one or more elementary items. Level number, Data name, and Value clause (optional) are used to describe a group item. Group level number is always 01.|||Data type can be numeric, alphabetic, or alphanumeric. Numeric type consists of only digits 0 to 9. Alphabetic type consists of letters A to Z and spaces. Alphanumeric type consists of digits, letters, and special characters.@@@Sign can be used with numeric data. It can be either + or –.@@@Decimal point position can be used with numeric data. Assumed position is the position of decimal point and not included in the data.@@@Length defines the number of bytes used by the data item.|||Redefines Clause@@@Renames Clause@@@Usage Clause@@@Copybooks|||WS-OLD is Redefined Item@@@WS-NEW1 and WS-NEW2 are Redefining Item|||IF Condition Statement@@@Relation Condition@@@Sign Condition@@@Class Condition@@@Condition-Name Condition@@@Negated Condition@@@Combined Condition|||Perform Thru@@@Perform Until@@@Perform Times@@@Perform Varying|||Inspect@@@String@@@Unstring|||input-string − The string whose characters are to be counted.@@@output-count − Data item to hold the count of characters.|||input-string − The string whose characters are to be replaced from char1 to char2.|||ws-string1 and ws-string2 : Input strings to be concatenated@@@ws-string : Output string@@@ws-count : Used to count the length of new concatenated string@@@Delimited specifies the end of string@@@Pointer and Overflow are optional|||Field@@@Record@@@Physical Record@@@Logical Record@@@File|||Primary keys are those fields that are unique to each record and are used to identify a particular record. For example, in students marks file, each student will be having a unique student id which forms the primary key.@@@Secondary keys are unique or non-unique fields that are used to search for related data. For example, in students marks file, full name of student can be used as secondary key when student id is not known.@@@Descriptors fields are used to describe an entity. For example, in students marks file, marks and percentage fields that add meaning to the record are known descriptors.|||Sequential file organization@@@Indexed sequential file organization@@@Relative file organization|||Records can be read in sequential order. For reading the 10th record, all the previous 9 records should be read.@@@Records are written in sequential order. A new record cannot be inserted in between. A new record is always inserted at the end of the file.@@@After placing a record into a sequential file, it is not possible to delete,  shorten, or lengthen a record.@@@Order of the records, once inserted, can never be changed.@@@Updation of record is possible. A record can be overwritten, if the new record length is same as the old record length.@@@Sequential output files are good option for printing.|||Data File contains records in sequential scheme.@@@Index File contains the primary key and its address in the data file.|||Records can be read in sequential order just like in sequential file organization.@@@Records can be accessed randomly if the primary key is known. Index file is used to get the address of a record and then the record is fetched from the data file.@@@Sorted index is maintained in this file system which relates the key value to the position of the record in the file.@@@Alternate index can also be created to fetch the records.|||Records can be read in sequential order just like in sequential and indexed file organization.@@@Records can be accessed using relative key. Relative key represents the record’s location relative to the address of the start of the file.@@@Records can be inserted using relative key. Relative address is calculated using relative key.@@@Relative file provides the fastest access to the records.@@@The main disadvantage of this file system is that if some intermediate records are missing, they will also occupy space.|||Sequential Access@@@Random Access@@@Dynamic Access|||For sequential files, records are accessed in the same order in which they were inserted.@@@For indexed files, the parameter used to fetch the records are the record key values.@@@For relative files, relative record keys are used to retrieve the records.|||For indexed files, records are accessed according to the value placed in a key field which can be primary or alternate key. There can be one or more alternate indexes.@@@For relative files , records are retrieved through relative record keys.|||Open@@@Read@@@Write@@@Rewrite@@@Delete@@@Start@@@Close|||NEXT RECORD is optional and is specified when an indexed sequential file is being read sequentially.@@@INTO clause is optional. ws-file-structure is defined in the WorkingStorage Section to get the values from the READ statement.@@@AT END condition becomes True when the end of file is reached.|||Linkage section must be defined in the called program. It consists of data elements passed in the program. The data items should not have Value clause. PIC clause must be compatible with the variables passed through the calling program.@@@Procedure division using has a list of variables passed from the calling program and the order must be same as mentioned in the Call verb.@@@Exit program statement is used in the called program to transfer the control back. It must be the last statement in the called program.|||By Reference@@@By Content|||Static Call occurs when a program is compiled with the NODYNAM compiler option. A static called program is loaded into storage at compile time.@@@Dynamic Call occurs when a program is compiled with the DYNAM and NODLL compiler option. A dynamic called program is loaded into storage at runtime.|||External sort is used to sort files by using the SORT utility in JCL. We have discussed this in the JCL chapter. As of now, we will focus on internal sort.@@@Internal sort is used to sort files within a COBOL program. SORT verb is used to sort a file.|||Input file is the file which we have to sort either in ascending or descending order.@@@Work file is used to hold records while the sort process is in progress. Input file records are transferred to the work file for the sorting process. This file should be defined in the File-Section under SD entry.@@@Output file is the file which we get after the sorting process. It is the final output of the Sort verb.|||Opens work-file in I-O mode, input-file in the INPUT mode and output-file in the OUTPUT mode.@@@Transfers the records present in the input-file to the work-file.@@@Sorts the SORT-FILE in ascending/descending sequence by rec-key.@@@Transfers the sorted records from the work-file to the output-file.@@@Closes the input-file and the output-file and deletes the work-file.|||Input Files − Input-1, Input-2@@@Work File@@@Output File|||Opens the work-file in I-O mode, input-files in the INPUT mode and output-file in the OUTPUT mode.@@@Transfers the records present in the input-files to the work-file.@@@Sorts the SORT-FILE in ascending/descending sequence by rec-key.@@@Transfers the sorted records from the work-file to the output-file.@@@Closes the input-file and the output-file and deletes the work-file.|||Embedded SQL@@@DB2 Application Programming@@@Host Variables@@@SQLCA@@@SQL Queries@@@Cursors|||All the SQL statements must be delimited between EXEC SQL and ENDEXEC..@@@SQL statements must be coded in Area B.@@@All the tables that are used in a program must be declared in the WorkingStorage Section. This is done by using the INCLUDE statement.@@@All SQL statements other than INCLUDE and DECLARE TABLE must appear in the Procedure Division.|||Declare@@@Open@@@Close@@@Fetch",,"Sr.No.@@@Character & Description|||1@@@A-Z
Alphabets(Upper Case)|||2@@@a-z
Alphabets (Lower Case)|||3@@@0-9
Numeric|||4@@@ 
Space|||5@@@+
Plus Sign|||6@@@-
Minus Sign or Hyphen|||7@@@*
Asterisk|||8@@@/
Forward Slash|||9@@@$
Currency Sign|||10@@@,
Comma|||11@@@;
Semicolon|||12@@@
.
Decimal Point or Period|||13@@@
""
Quotation Marks|||14@@@
(
Left Parenthesis|||15@@@
)
Right Parenthesis|||16@@@
>
Greater than|||17@@@
<
Less than|||18@@@
:
Colon|||19@@@
'
Apostrophe|||20@@@
=
Equal Sign&&&Positions@@@Field@@@Description|||1-6@@@Column Numbers@@@Reserved for line numbers.|||7@@@Indicator@@@It can have Asterisk (*) indicating comments, Hyphen (-) indicating continuation and Slash ( / ) indicating form feed.|||8-11@@@Area A@@@All COBOL divisions, sections, paragraphs and some special entries must begin in Area A.|||12-72@@@Area B@@@All COBOL statements must begin in area B.|||73-80@@@Identification Area@@@It can be used as needed by the programmer.&&&Sr.No.@@@Figurative Constants & Description|||1@@@
HIGH-VALUES
One or more characters which will be at the highest position in descending order.|||2@@@
LOW-VALUES
One or more characters have zeros in binary representation.|||3@@@
ZERO/ZEROES
One or more zero depending on the size of the variable.|||4@@@
SPACES
One or more spaces.|||5@@@
QUOTES
Single or double quotes.|||6@@@
ALL literal
Fills the data-item with Literal.&&&Sr.No.@@@Level Number & Description|||1@@@
01
Record description entry|||2@@@
02 to 49
Group and Elementary items|||3@@@
66
Rename Clause items|||4@@@
77
Items which cannot be sub-divided|||5@@@
88
Condition name entry&&&Sr.No.@@@Symbol & Description|||1@@@
9
Numeric|||2@@@
A
Alphabetic|||3@@@
X
Alphanumeric|||4@@@
V
Implicit Decimal|||5@@@
S
Sign|||6@@@
P
Assumed Decimal&&&@@@Alphabetic@@@Alphanumeric@@@Numeric@@@Alphabetic@@@Alphanumeric@@@Numeric|||Possible@@@Possible@@@Not Possible|||Possible@@@Possible@@@Possible|||Not Possible@@@Possible@@@Possible&&&Sr.No.@@@Mode & Description|||1@@@
Input
Input mode is used for existing files. In this mode, we can only read the file, no other operations are allowed on the file.|||2@@@
Output
Output mode is used to insert records in files. If a sequential file is  used and the file is holding some records, then the existing records will be deleted first and then new records will be inserted in the file. It will not happen so in case of an indexed file or a relative file.|||3@@@
Extend
Extend mode is used to append records in a sequential file. In this mode, records are inserted at the end. If file access mode is Random or Dynamic, then extend mode cannot be used.|||4@@@
I-O
Input-Output mode is used to read and rewrite the records of a file.","IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   DISPLAY 'Hello World'.STOP RUN.|||//COMPILE   JOB ,CLASS=6,MSGCLASS=X,NOTIFY=&SYSUID             //*            //STEP1     EXEC IGYCRCTL,PARM=RMODE,DYNAM,SSRANGE//SYSIN     DD DSN=MYDATA.URMI.SOURCES(MYCOBB),DISP=SHR//SYSLIB    DD DSN=MYDATA.URMI.COPYBOOK(MYCOPY),DISP=SHR//SYSLMOD   DD DSN=MYDATA.URMI.LOAD(MYCOBB),DISP=SHR//SYSPRINT  DD SYSOUT=*//*|||//COBBSTEP  JOB CLASS=6,NOTIFY=&SYSUID////STEP10    EXEC PGM=MYPROG,PARM=ACCT5000//STEPLIB   DD DSN=MYDATA.URMI.LOADLIB,DISP=SHR//INPUT1    DD DSN=MYDATA.URMI.INPUT,DISP=SHR//OUT1      DD SYSOUT=*//OUT2      DD SYSOUT=*//SYSIN     DD *//CUST1     1000//CUST2     1001/*|||//STEP001  EXEC PGM=IKJEFT01//*//STEPLIB  DD DSN=MYDATA.URMI.DBRMLIB,DISP=SHR//*//input files//output files//SYSPRINT DD SYSOUT=*//SYSABOUT DD SYSOUT=*//SYSDBOUT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//DISPLAY  DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSPRT DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(MYCOBB) PLAN(PLANNAME) PARM(parameters to cobol program) -   LIB('MYDATA.URMI.LOADLIB')   END/*|||PROCEDURE DIVISION.A0000-FIRST-PARA SECTION.FIRST-PARAGRAPH.ACCEPT WS-ID            - Statement-1  -----|MOVE '10' TO WS-ID      - Statement-2       |-- Sentence - 1DISPLAY WS-ID           - Statement-3  -----|.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.DISPLAY 'Welcome to Tutorialspoint'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||ENVIRONMENT DIVISION.CONFIGURATION SECTION.   SOURCE-COMPUTER. XXX-ZOS.   OBJECT-COMPUTER. XXX-ZOS.INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT FILEN ASSIGN TO DDNAME   ORGANIZATION IS SEQUENTIAL.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT FILEN ASSIGN TO INPUT.      ORGANIZATION IS SEQUENTIAL.      ACCESS IS SEQUENTIAL.DATA DIVISION.   FILE SECTION.   FD FILEN   01 NAME PIC A(25).      WORKING-STORAGE SECTION.   01 WS-STUDENT PIC A(30).   01 WS-ID PIC 9(5).   LOCAL-STORAGE SECTION.   01 LS-CLASS PIC 9(3).      LINKAGE SECTION.   01 LS-ID PIC 9(5).   PROCEDURE DIVISION.   DISPLAY 'Executing COBOL program using JCL'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//INPUT DD DSN = ABC.EFG.XYZ,DISP = SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NAME PIC A(30).   01 WS-ID PIC 9(5) VALUE '12345'.PROCEDURE DIVISION.   A000-FIRST-PARA.   DISPLAY 'Hello World'.   MOVE 'TutorialsPoint' TO WS-NAME.   DISPLAY ""My name is : ""WS-NAME.   DISPLAY ""My ID is : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||000100 IDENTIFICATION DIVISION.                                         000100000200 PROGRAM-ID. HELLO.                                               000101000250* THIS IS A COMMENT LINE                                          000102000300 PROCEDURE DIVISION.                                              000103000350 A000-FIRST-PARA.                                                 000104000400     DISPLAY “Coding Sheet”.                                      000105000500 STOP RUN.                                                        000106|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||000100 IDENTIFICATION DIVISION.                                         000100000150 PROGRAM-ID. HELLO.                                               000101 000200 AUTHOR. TUTORIALSPOINT.                                          000102000250* THIS IS A COMMENT LINE                                          000103000300 PROCEDURE DIVISION.                                              000104000350 A000-FIRST-PARA.                                                 000105  000360/ First Para Begins - Documentation Purpose                       000106000400     DISPLAY “Comment line”.                                      000107000500 STOP RUN.                                                        000108|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||PROCEDURE DIVISION.DISPLAY 'Hello World'.|||Valid:   ‘This is valid’   ""This is valid""   ‘This isn’’t invalid’Invalid:   ‘This is invalid”   ‘This isn’t valid’|||Valid:   100   +10.9   -1.9Invalid:   1,00   10.   10.9-|||Valid:   WS-NAME   TOTAL-STUDENTS   A100   100BInvalid:   MOVE            (Reserved Words)   COMPUTE         (Reserved Words)   100             (No Alphabet)   100+B           (+ is not allowed) |||DATA DIVISION.WORKING-STORAGE SECTION.01 WS-NAME    PIC X(25).                               ---> ELEMENTARY ITEM 01 WS-CLASS   PIC 9(2)  VALUE  '10'.                   ---> ELEMENTARY ITEM01 WS-ADDRESS.                                         ---> GROUP ITEM      05 WS-HOUSE-NUMBER    PIC 9(3).                     ---> ELEMENTARY ITEM   05 WS-STREET          PIC X(15).                    ---> ELEMENTARY ITEM   05 WS-CITY            PIC X(15).                    ---> ELEMENTARY ITEM   05 WS-COUNTRY         PIC X(15)  VALUE 'INDIA'.     ---> ELEMENTARY ITEM|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC S9(3)V9(2).   01 WS-NUM2 PIC PPP999.   01 WS-NUM3 PIC S9(3)V9(2) VALUE -123.45.   01 WS-NAME PIC A(6) VALUE 'ABCDEF'.   01 WS-ID PIC X(5) VALUE 'A121$'.PROCEDURE DIVISION.   DISPLAY ""WS-NUM1 : ""WS-NUM1.   DISPLAY ""WS-NUM2 : ""WS-NUM2.   DISPLAY ""WS-NUM3 : ""WS-NUM3.   DISPLAY ""WS-NAME : ""WS-NAME.   DISPLAY ""WS-ID : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 99V9 VALUE IS 3.5.   01 WS-NAME PIC A(6) VALUE 'ABCD'.   01 WS-ID PIC 99 VALUE ZERO.PROCEDURE DIVISION.   DISPLAY ""WS-NUM1 : ""WS-NUM1.   DISPLAY ""WS-NAME : ""WS-NAME.   DISPLAY ""WS-ID   : ""WS-ID.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-NAME PIC X(25).   01 WS-DATE PIC X(10).PROCEDURE DIVISION.   ACCEPT WS-STUDENT-NAME.   ACCEPT WS-DATE FROM DATE.   DISPLAY ""Name :  "" WS-STUDENT-NAME.   DISPLAY ""Date : "" WS-DATE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//INPUT DD DSN=PROGRAM.DIRECTORY,DISP=SHR//SYSIN DD *TutorialsPoint/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NAME PIC A(30) VALUE 'ABCDEF'.   01 WS-ID PIC 9(5).   01 WS-ADDRESS.    05 WS-HOUSE-NUMBER PIC 9(3).   05 WS-COUNTRY PIC X(15).   05 WS-PINCODE PIC 9(6) VALUE 123456.PROCEDURE DIVISION.   A000-FIRST-PARA.   INITIALIZE WS-NAME, WS-ADDRESS.   INITIALIZE WS-ID REPLACING NUMERIC DATA BY 12345.   DISPLAY ""My name is   : ""WS-NAME.   DISPLAY ""My ID is     : ""WS-ID.   DISPLAY ""Address      : ""WS-ADDRESS.   DISPLAY ""House Number : ""WS-HOUSE-NUMBER.   DISPLAY ""Country      : ""WS-COUNTRY.   DISPLAY ""Pincode      : ""WS-PINCODE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).   01 WS-NUM3 PIC 9(5).   01 WS-NUM4 PIC 9(6).   01 WS-ADDRESS.    05 WS-HOUSE-NUMBER PIC 9(3).   05 WS-COUNTRY PIC X(5).   05 WS-PINCODE PIC 9(6).   01 WS-ADDRESS1.    05 WS-HOUSE-NUMBER1 PIC 9(3).   05 WS-COUNTRY1 PIC X(5).   05 WS-PINCODE1 PIC 9(6).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 123456789 TO WS-NUM1.   MOVE WS-NUM1 TO WS-NUM2 WS-NUM3.   MOVE WS-NUM1(3:6) TO WS-NUM4.   MOVE 123 TO WS-HOUSE-NUMBER.   MOVE 'INDIA' TO WS-COUNTRY.   MOVE 112233 TO WS-PINCODE.   MOVE WS-ADDRESS TO WS-ADDRESS1.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-ADDRESS  : "" WS-ADDRESS   DISPLAY ""WS-ADDRESS1 : "" WS-ADDRESS1STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUM4 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.   01 WS-NUMD PIC 9(9) VALUE 10.   01 WS-NUME PIC 9(9) VALUE 10.PROCEDURE DIVISION.   ADD WS-NUM1 WS-NUM2 TO WS-NUM3 WS-NUM4.   ADD WS-NUMA WS-NUMB WS-NUMC TO WS-NUMD GIVING WS-NUME.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-NUMD     : "" WS-NUMD   DISPLAY ""WS-NUME     : "" WS-NUMESTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 100.   01 WS-NUM4 PIC 9(9) VALUE 100.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.   01 WS-NUMD PIC 9(9) VALUE 100.   01 WS-NUME PIC 9(9) VALUE 10.PROCEDURE DIVISION.   SUBTRACT WS-NUM1 WS-NUM2 FROM WS-NUM3 WS-NUM4.   SUBTRACT WS-NUMA WS-NUMB WS-NUMC FROM WS-NUMD GIVING WS-NUME.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUM4     : "" WS-NUM4   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-NUMD     : "" WS-NUMD   DISPLAY ""WS-NUME     : "" WS-NUMESTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 10.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9) VALUE 10.PROCEDURE DIVISION.   MULTIPLY WS-NUM1 BY WS-NUM2 WS-NUM3.   MULTIPLY WS-NUMA BY WS-NUMB GIVING WS-NUMC.      DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 5.   01 WS-NUM2 PIC 9(9) VALUE 250.   01 WS-NUMA PIC 9(9) VALUE 100.   01 WS-NUMB PIC 9(9) VALUE 15.   01 WS-NUMC PIC 9(9).   01 WS-REM PIC 9(9). PROCEDURE DIVISION.   DIVIDE WS-NUM1 INTO WS-NUM2.   DIVIDE WS-NUMA BY WS-NUMB GIVING WS-NUMC REMAINDER WS-REM.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMC   DISPLAY ""WS-REM      : "" WS-REM   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9) VALUE 10 .   01 WS-NUM2 PIC 9(9) VALUE 10.   01 WS-NUM3 PIC 9(9) VALUE 10.   01 WS-NUMA PIC 9(9) VALUE 50.   01 WS-NUMB PIC 9(9) VALUE 10.   01 WS-NUMC PIC 9(9).PROCEDURE DIVISION.   COMPUTE WS-NUMC= (WS-NUM1 * WS-NUM2) - (WS-NUMA / WS-NUMB) + WS-NUM3.   DISPLAY ""WS-NUM1     : "" WS-NUM1   DISPLAY ""WS-NUM2     : "" WS-NUM2   DISPLAY ""WS-NUM3     : "" WS-NUM3   DISPLAY ""WS-NUMA     : "" WS-NUMA   DISPLAY ""WS-NUMB     : "" WS-NUMB   DISPLAY ""WS-NUMC     : "" WS-NUMCSTOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-DESCRIPTION.   05 WS-DATE1 VALUE '20140831'.   10 WS-YEAR PIC X(4).   10 WS-MONTH PIC X(2).   10 WS-DATE PIC X(2).   05 WS-DATE2 REDEFINES WS-DATE1 PIC 9(8).PROCEDURE DIVISION.   DISPLAY ""WS-DATE1 : ""WS-DATE1.   DISPLAY ""WS-DATE2 : ""WS-DATE2.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-DESCRIPTION.   05 WS-NUM.   10 WS-NUM1 PIC 9(2) VALUE 20.   10 WS-NUM2 PIC 9(2) VALUE 56.   05 WS-CHAR.   10 WS-CHAR1 PIC X(2) VALUE 'AA'.   10 WS-CHAR2 PIC X(2) VALUE 'BB'.   66 WS-RENAME RENAMES WS-NUM2 THRU WS-CHAR2.PROCEDURE DIVISION.   DISPLAY ""WS-RENAME : "" WS-RENAME.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||01 WS-NUM PIC S9(5)V9(3) USAGE IS DISPLAY.It requires 8 bytes as sign and decimal doesn't require any byte.01 WS-NUM PIC 9(5) USAGE IS DISPLAY.It requires 5 bytes as sign.|||01 WS-NUM PIC S9(n) USAGE IS COMP.If 'n' = 1 to 4, it takes 2 bytes.If 'n' = 5 to 9, it takes 4 bytes.If 'n' = 10 to 18, it takes 8 bytes.|||01 WS-NUM PIC 9(n) USAGE IS COMP.Number of bytes = n/2 (If n is even)Number of bytes = n/2 + 1(If n is odd, consider only integer part)01 WS-NUM PIC 9(4) USAGE IS COMP-3 VALUE 21.It requires 2 bytes of storage as each digit occupies half a byte.01 WS-NUM PIC 9(5) USAGE IS COMP-3 VALUE 21.It requires 3 bytes of storage as each digit occupies half a byte.|||DATA DIVISION.WORKING-STORAGE SECTION.COPY ABC.|||01 WS-DESCRIPTION.   05 WS-NUM.      10 WS-NUM1 PIC 9(2) VALUE 20.      10 WS-NUM2 PIC 9(2) VALUE 56.   05 WS-CHAR.      10 WS-CHAR1 PIC X(2) VALUE 'AA'.      10 WS-CHAR2 PIC X(2) VALUE 'BB'.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).   01 WS-NUM3 PIC 9(5).   01 WS-NUM4 PIC 9(6).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 25 TO WS-NUM1 WS-NUM3.   MOVE 15 TO WS-NUM2 WS-NUM4.      IF WS-NUM1 > WS-NUM2 THEN      DISPLAY 'IN LOOP 1 - IF BLOCK'            IF WS-NUM3 = WS-NUM4 THEN         DISPLAY 'IN LOOP 2 - IF BLOCK'      ELSE         DISPLAY 'IN LOOP 2 - ELSE BLOCK'      END-IF         ELSE      DISPLAY 'IN LOOP 1 - ELSE BLOCK'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(9).   01 WS-NUM2 PIC 9(9).PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 25 TO WS-NUM1.   MOVE 15 TO WS-NUM2.      IF WS-NUM1 IS GREATER THAN OR EQUAL TO WS-NUM2 THEN      DISPLAY 'WS-NUM1 IS GREATER THAN WS-NUM2'   ELSE      DISPLAY 'WS-NUM1 IS LESS THAN WS-NUM2'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC S9(9) VALUE -1234.   01 WS-NUM2 PIC S9(9) VALUE 123456.PROCEDURE DIVISION.   A000-FIRST-PARA.   IF WS-NUM1 IS POSITIVE THEN      DISPLAY 'WS-NUM1 IS POSITIVE'.         IF WS-NUM1 IS NEGATIVE THEN      DISPLAY 'WS-NUM1 IS NEGATIVE'.         IF WS-NUM1 IS ZERO THEN      DISPLAY 'WS-NUM1 IS ZERO'.         IF WS-NUM2 IS POSITIVE THEN      DISPLAY 'WS-NUM2 IS POSITIVE'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC X(9) VALUE 'ABCD '.   01 WS-NUM2 PIC 9(9) VALUE 123456789.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF WS-NUM1 IS ALPHABETIC THEN      DISPLAY 'WS-NUM1 IS ALPHABETIC'.         IF WS-NUM1 IS NUMERIC THEN      DISPLAY 'WS-NUM1 IS NUMERIC'.         IF WS-NUM2 IS NUMERIC THEN      DISPLAY 'WS-NUM2 IS NUMERIC'.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM PIC 9(3).   88 PASS VALUES ARE 041 THRU 100.   88 FAIL VALUES ARE 000 THRU 40.PROCEDURE DIVISION.   A000-FIRST-PARA.   MOVE 65 TO WS-NUM.      IF PASS       DISPLAY 'Passed with ' WS-NUM ' marks'.         IF FAIL       DISPLAY 'FAILED with ' WS-NUM 'marks'.      STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(2) VALUE 20.   01 WS-NUM2 PIC 9(9) VALUE 25.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF NOT WS-NUM1 IS LESS THAN WS-NUM2 THEN      DISPLAY 'IF-BLOCK'   ELSE      DISPLAY 'ELSE-BLOCK'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-NUM1 PIC 9(2) VALUE 20.   01 WS-NUM2 PIC 9(2) VALUE 25.   01 WS-NUM3 PIC 9(2) VALUE 20.PROCEDURE DIVISION.   A000-FIRST-PARA.      IF WS-NUM1 IS LESS THAN WS-NUM2 AND WS-NUM1=WS-NUM3 THEN      DISPLAY 'Both condition OK'   ELSE      DISPLAY 'Error'   END-IF.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 0.   PROCEDURE DIVISION.   MOVE 3 TO WS-A.      EVALUATE TRUE      WHEN WS-A > 2         DISPLAY 'WS-A GREATER THAN 2'      WHEN WS-A < 0         DISPLAY 'WS-A LESS THAN 0'      WHEN OTHER         DISPLAY 'INVALID VALUE OF WS-A'   END-EVALUATE.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   A-PARA.   PERFORM DISPLAY 'IN A-PARA'   END-PERFORM.   PERFORM C-PARA THRU E-PARA.      B-PARA.   DISPLAY 'IN B-PARA'.   STOP RUN.      C-PARA.   DISPLAY 'IN C-PARA'.      D-PARA.   DISPLAY 'IN D-PARA'.      E-PARA.   DISPLAY 'IN E-PARA'.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||PERFORM A-PARA UNTIL COUNT=5PERFORM A-PARA WITH TEST BEFORE UNTIL COUNT=5PERFORM A-PARA WITH TEST AFTER UNTIL COUNT=5|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-CNT PIC 9(1) VALUE 0. PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA WITH TEST AFTER UNTIL WS-CNT>3.   STOP RUN.      B-PARA.   DISPLAY 'WS-CNT : 'WS-CNT.   ADD 1 TO WS-CNT.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA 3 TIMES.   STOP RUN.      B-PARA.   DISPLAY 'IN B-PARA'.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 0.PROCEDURE DIVISION.   A-PARA.   PERFORM B-PARA VARYING WS-A FROM 1 BY 1 UNTIL WS-A=5   STOP RUN.      B-PARA.   DISPLAY 'IN B-PARA ' WS-A.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-A PIC 9 VALUE 2.   PROCEDURE DIVISION.   A-PARA.   DISPLAY 'IN A-PARA'   GO TO B-PARA.      B-PARA.   DISPLAY 'IN B-PARA '.   GO TO C-PARA D-PARA DEPENDING ON WS-A.      C-PARA.   DISPLAY 'IN C-PARA '.      D-PARA.   DISPLAY 'IN D-PARA '.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-CNT1 PIC 9(2) VALUE 0.   01 WS-CNT2 PIC 9(2) VALUE 0.   01 WS-STRING PIC X(15) VALUE 'ABCDACDADEAAAFF'.   PROCEDURE DIVISION.   INSPECT WS-STRING TALLYING WS-CNT1 FOR CHARACTER.   DISPLAY ""WS-CNT1 : ""WS-CNT1.   INSPECT WS-STRING TALLYING WS-CNT2 FOR ALL 'A'.   DISPLAY ""WS-CNT2 : ""WS-CNT2   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC X(15) VALUE 'ABCDACDADEAAAFF'.PROCEDURE DIVISION.   DISPLAY ""OLD STRING : ""WS-STRING.   INSPECT WS-STRING REPLACING ALL 'A' BY 'X'.   DISPLAY ""NEW STRING : ""WS-STRING.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||STRING ws-string1 DELIMITED BY SPACE   ws-string2 DELIMITED BY SIZE   INTO ws-destination-string   WITH POINTER ws-count   ON OVERFLOW DISPLAY message1   NOT ON OVERFLOW DISPLAY message2END-STRING.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC A(30).   01 WS-STR1 PIC A(15) VALUE 'Tutorialspoint'.   01 WS-STR2 PIC A(7) VALUE 'Welcome'.   01 WS-STR3 PIC A(7) VALUE 'To AND'.   01 WS-COUNT PIC 99 VALUE 1.PROCEDURE DIVISION.   STRING WS-STR2 DELIMITED BY SIZE      WS-STR3 DELIMITED BY SPACE      WS-STR1 DELIMITED BY SIZE      INTO WS-STRING       WITH POINTER WS-COUNT      ON OVERFLOW DISPLAY 'OVERFLOW!'    END-STRING.      DISPLAY 'WS-STRING : 'WS-STRING.   DISPLAY 'WS-COUNT : 'WS-COUNT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||UNSTRING ws-string DELIMITED BY SPACEINTO ws-str1, ws-str2WITH POINTER ws-countON OVERFLOW DISPLAY messageNOT ON OVERFLOW DISPLAY messageEND-UNSTRING.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STRING PIC A(30) VALUE 'WELCOME TO TUTORIALSPOINT'.   01 WS-STR1 PIC A(7).   01 WS-STR2 PIC A(2).   01 WS-STR3 PIC A(15).   01 WS-COUNT PIC 99 VALUE 1.PROCEDURE DIVISION.   UNSTRING WS-STRING DELIMITED BY SPACE      INTO WS-STR1, WS-STR2, WS-STR3   END-UNSTRING.      DISPLAY 'WS-STR1 : 'WS-STR1.   DISPLAY 'WS-STR2 : 'WS-STR2.   DISPLAY 'WS-STR3 : 'WS-STR3.   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A PIC A(10) VALUE 'TUTORIALS' OCCURS 5 TIMES.     PROCEDURE DIVISION.   DISPLAY ""ONE-D TABLE : ""WS-TABLE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 2 TIMES.         10 WS-B PIC A(10) VALUE ' TUTORIALS'.         10 WS-C OCCURS 2 TIMES.            15 WS-D PIC X(6) VALUE ' POINT'.PROCEDURE DIVISION.   DISPLAY ""TWO-D TABLE : ""WS-TABLE.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   DISPLAY 'WS-TABLE  : ' WS-TABLE.   DISPLAY 'WS-A(1)   : ' WS-A(1).   DISPLAY 'WS-C(1,1) : ' WS-C(1,1).   DISPLAY 'WS-C(1,2) : ' WS-C(1,2).   DISPLAY 'WS-A(2)   : ' WS-A(2).   DISPLAY 'WS-C(2,1) : ' WS-C(2,1).   DISPLAY 'WS-C(2,2) : ' WS-C(2,2).   DISPLAY 'WS-A(3)   : ' WS-A(3).   DISPLAY 'WS-C(3,1) : ' WS-C(3,1).   DISPLAY 'WS-C(3,2) : ' WS-C(3,2).   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES INDEXED BY I.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES INDEXED BY J.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   PERFORM A-PARA VARYING I FROM 1 BY 1 UNTIL I >3    STOP RUN.      A-PARA.   PERFORM C-PARA VARYING J FROM 1 BY 1 UNTIL J>2.      C-PARA.   DISPLAY WS-C(I,J).|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A OCCURS 3 TIMES INDEXED BY I.         10 WS-B PIC A(2).         10 WS-C OCCURS 2 TIMES INDEXED BY J.            15 WS-D PIC X(3).PROCEDURE DIVISION.   MOVE '12ABCDEF34GHIJKL56MNOPQR' TO WS-TABLE.   SET I J TO 1.   DISPLAY WS-C(I,J).   SET I J UP BY 1.   DISPLAY WS-C(I,J).   STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-A PIC X(1) OCCURS 18 TIMES INDEXED BY I.   01 WS-SRCH PIC A(1) VALUE 'M'.PROCEDURE DIVISION.   MOVE 'ABCDEFGHIJKLMNOPQR' TO WS-TABLE.   SET I TO 1.   SEARCH WS-A      AT END DISPLAY 'M NOT FOUND IN TABLE'      WHEN WS-A(I) = WS-SRCH      DISPLAY 'LETTER M FOUND IN TABLE'   END-SEARCH.  STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-TABLE.      05 WS-RECORD OCCURS 10 TIMES ASCENDING KEY IS WS-NUM INDEXED BY I.      10 WS-NUM PIC 9(2).      10 WS-NAME PIC A(3).PROCEDURE DIVISION.   MOVE '12ABC56DEF34GHI78JKL93MNO11PQR' TO WS-TABLE.   SEARCH ALL WS-RECORD     AT END DISPLAY 'RECORD NOT FOUND'     WHEN WS-NUM(I) = 93     DISPLAY 'RECORD FOUND '     DISPLAY WS-NUM(I)     DISPLAY WS-NAME(I)END-SEARCH. |||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO|||INPUT-OUTPUT SECTION.FILE-CONTROL.   SELECT file-name ASSIGN TO dd-name-jcl   ORGANIZATION IS INDEXED   RECORD KEY IS primary-key   ALTERNATE RECORD KEY IS rec-key|||INPUT-OUTPUT SECTION.FILE-CONTROL.   SELECT file-name ASSIGN TO dd-name-jcl   ORGANIZATION IS RELATIVE   RELATIVE KEY IS rec-key|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.      FILE-CONTROL.      SELECT STUDENT ASSIGN TO 'input.txt'      ORGANIZATION IS LINE SEQUENTIAL.            DATA DIVISION.   FILE SECTION.   FD STUDENT.   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).   01 WS-EOF PIC A(1). PROCEDURE DIVISION.   OPEN INPUT STUDENT.      PERFORM UNTIL WS-EOF='Y'         READ STUDENT INTO WS-STUDENT            AT END MOVE 'Y' TO WS-EOF            NOT AT END DISPLAY WS-STUDENT         END-READ      END-PERFORM.   CLOSE STUDENT.STOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO IN1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT.      01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).        WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).PROCEDURE DIVISION.   OPEN INPUT STUDENT.      MOVE 20005 TO STUDENT-ID.            READ STUDENT RECORD INTO WS-STUDENT-FILE         KEY IS STUDENT-ID         INVALID KEY DISPLAY 'Invalid Key'         NOT INVALID KEY DISPLAY WS-STUDENT-FILE      END-READ.         CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN = STUDENT-FILE-NAME,DISP=SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO OUT1      ORGANIZATION IS SEQUENTIAL      ACCESS IS SEQUENTIAL      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(5).      05 NAME PIC A(25).      05 CLASS PIC X(3).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN EXTEND STUDENT.      MOVE 1000 TO STUDENT-ID.      MOVE 'Tim' TO NAME.      MOVE '10' TO CLASS.      WRITE STUDENT-FILE      END-WRITE.	   CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//OUT1 DD DSN = OUTPUT-FILE-NAME,DISP = (NEW,CATALOG,DELETE)|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO IN1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(4).      05 NAME PIC A(12).      05 CLASS PIC X(3).         WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN I-O STUDENT.   MOVE '1000' TO STUDENT-ID.     READ STUDENT      KEY IS STUDENT-ID      INVALID KEY DISPLAY ‘KEY IS NOT EXISTING’   END-READ.     MOVE 'Tim Dumais' TO NAME.   REWRITE STUDENT-FILE   END-REWRITE.   CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN = OUTPUT-FILE-NAME,DISP = SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.   SELECT STUDENT ASSIGN TO OUT1      ORGANIZATION IS INDEXED      ACCESS IS RANDOM      RECORD KEY IS STUDENT-ID      FILE STATUS IS FS.DATA DIVISION.   FILE SECTION.   FD STUDENT   01 STUDENT-FILE.      05 STUDENT-ID PIC 9(4).      05 NAME PIC A(12).      05 CLASS PIC X(3).   WORKING-STORAGE SECTION.   01 WS-STUDENT.      05 WS-STUDENT-ID PIC 9(5).      05 WS-NAME PIC A(25).      05 WS-CLASS PIC X(3).PROCEDURE DIVISION.   OPEN I-O STUDENT.   MOVE '1000' TO STUDENT-ID.      DELETE STUDENT RECORD      INVALID KEY DISPLAY 'Invalid Key'      NOT INVALID KEY DISPLAY 'Record Deleted'   END-DELETE.      CLOSE STUDENT.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//OUT1 DD DSN = OUTPUT-FILE-NAME,DISP = SHR|||IDENTIFICATION DIVISION.PROGRAM-ID. MAIN.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.PROCEDURE DIVISION.   CALL 'UTIL' USING WS-STUDENT-ID, WS-STUDENT-NAME.   DISPLAY 'Student Id : ' WS-STUDENT-ID   DISPLAY 'Student Name : ' WS-STUDENT-NAMESTOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. UTIL.DATA DIVISION.   LINKAGE SECTION.   01 LS-STUDENT-ID PIC 9(4).   01 LS-STUDENT-NAME PIC A(15).PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.   DISPLAY 'In Called Program'.   MOVE 1111 TO LS-STUDENT-ID.EXIT PROGRAM.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = MAIN|||IDENTIFICATION DIVISION.PROGRAM-ID. MAIN.DATA DIVISION.   WORKING-STORAGE SECTION.   01 WS-STUDENT-ID PIC 9(4) VALUE 1000.   01 WS-STUDENT-NAME PIC A(15) VALUE 'Tim'.PROCEDURE DIVISION.   CALL 'UTIL' USING BY CONTENT WS-STUDENT-ID, BY CONTENT WS-STUDENT-NAME.   DISPLAY 'Student Id : ' WS-STUDENT-ID   DISPLAY 'Student Name : ' WS-STUDENT-NAMESTOP RUN.|||IDENTIFICATION DIVISION.PROGRAM-ID. UTIL.DATA DIVISION.   LINKAGE SECTION.   01 LS-STUDENT-ID PIC 9(4).   01 LS-STUDENT-NAME PIC A(15).PROCEDURE DIVISION USING LS-STUDENT-ID, LS-STUDENT-NAME.   DISPLAY 'In Called Program'.   MOVE 1111 TO LS-STUDENT-ID.EXIT PROGRAM.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = MAIN|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.      SELECT INPUT ASSIGN TO IN.      SELECT OUTPUT ASSIGN TO OUT.      SELECT WORK ASSIGN TO WRK.DATA DIVISION.   FILE SECTION.   FD INPUT.      01 INPUT-STUDENT.         05 STUDENT-ID-I PIC 9(5).         05 STUDENT-NAME-I PIC A(25).   FD OUTPUT.      01 OUTPUT-STUDENT.         05 STUDENT-ID-O PIC 9(5).         05 STUDENT-NAME-O PIC A(25).   SD WORK.      01 WORK-STUDENT.         05 STUDENT-ID-W PIC 9(5).         05 STUDENT-NAME-W PIC A(25).PROCEDURE DIVISION.   SORT WORK ON ASCENDING KEY STUDENT-ID-O   USING INPUT GIVING OUTPUT.   DISPLAY 'Sort Successful'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN DD DSN = INPUT-FILE-NAME,DISP = SHR//OUT DD DSN = OUTPUT-FILE-NAME,DISP = SHR//WRK DD DSN = &&TEMP|||MERGE work-file ON ASCENDING KEY rec-key1   [ON DESCENDING KEY rec-key2]USING input-1, input-2 GIVING output-file.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.ENVIRONMENT DIVISION.   INPUT-OUTPUT SECTION.   FILE-CONTROL.      SELECT INPUT1 ASSIGN TO IN1.      SELECT INPUT2 ASSIGN TO IN2.      SELECT OUTPUT ASSIGN TO OUT.      SELECT WORK ASSIGN TO WRK.DATA DIVISION.   FILE SECTION.   FD INPUT1.      01 INPUT1-STUDENT.         05 STUDENT-ID-I1 PIC 9(5).         05 STUDENT-NAME-I1 PIC A(25).   FD INPUT2.      01 INPUT2-STUDENT.         05 STUDENT-ID-I2 PIC 9(5).         05 STUDENT-NAME-I2 PIC A(25).   FD OUTPUT.      01 OUTPUT-STUDENT.         05 STUDENT-ID-O PIC 9(5).         05 STUDENT-NAME-O PIC A(25).   SD WORK.      01 WORK-STUDENT.         05 STUDENT-ID-W PIC 9(5).         05 STUDENT-NAME-W PIC A(25).PROCEDURE DIVISION.   MERGE WORK ON ASCENDING KEY STUDENT-ID-O   USING INPUT1, INPUT2 GIVING OUTPUT.   DISPLAY 'Merge Successful'.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP1 EXEC PGM = HELLO//IN1 DD DSN=INPUT1-FILE-NAME,DISP=SHR//IN2 DD DSN=INPUT2-FILE-NAME,DISP=SHR//OUT DD DSN = OUTPUT-FILE-NAME,DISP=SHR//WRK DD DSN = &&TEMP|||DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE table-name   END-EXEC.   EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 STUDENT-REC.      05 STUDENT-ID PIC 9(4).      05 STUDENT-NAME PIC X(25).      05 STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   EXEC SQL      INCLUDE SQLCA   END-EXEC.      EXEC SQL      INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   EXEC SQL      SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS      INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS FROM STUDENT      WHERE STUDENT-ID=1004   END-EXEC.      IF SQLCODE = 0       DISPLAY WS-STUDENT-RECORD   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP = SHR//SYSPRINT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.   EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 1005 TO WS-STUDENT-ID.   MOVE 'TutorialsPoint' TO WS-STUDENT-NAME.   MOVE 'Hyderabad' TO WS-STUDENT-ADDRESS.      EXEC SQL      INSERT INTO STUDENT(STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS)      VALUES (:WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS)   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Inserted Successfully'      DISPLAY WS-STUDENT-REC   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 'Bangalore' TO WS-STUDENT-ADDRESS.   EXEC SQL      UPDATE STUDENT SET STUDENT-ADDRESS=:WS-STUDENT-ADDRESS      WHERE STUDENT-ID = 1003   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Updated Successfully'   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP = SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.WORKING-STORAGE SECTION.   EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.PROCEDURE DIVISION.   MOVE 1005 TO WS-STUDENT-ID.      EXEC SQL      DELETE FROM STUDENT      WHERE STUDENT-ID=:WS-STUDENT-ID   END-EXEC.      IF SQLCODE = 0       DISPLAY 'Record Deleted Successfully'   ELSE DISPLAY 'Error'   END-IF.STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM = IKJEFT01//STEPLIB  DD DSN = MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT = *//SYSUDUMP DD SYSOUT = *//SYSOUT   DD SYSOUT = *//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*|||EXEC SQL   DECLARE STUDCUR CURSOR FOR   SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS FROM STUDENT   WHERE STUDENT-ID >:WS-STUDENT-IDEND-EXEC.|||EXEC SQL   OPEN STUDCUREND-EXEC.|||EXEC SQL   CLOSE STUDCUREND-EXEC.|||EXEC SQL   FETCH STUDCUR   INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESSEND-EXEC.|||IDENTIFICATION DIVISION.PROGRAM-ID. HELLO.DATA DIVISION.   WORKING-STORAGE SECTION.      EXEC SQL   INCLUDE SQLCA   END-EXEC.      EXEC SQL   INCLUDE STUDENT   END-EXEC.      EXEC SQL BEGIN DECLARE SECTION   END-EXEC.      01 WS-STUDENT-REC.         05 WS-STUDENT-ID PIC 9(4).         05 WS-STUDENT-NAME PIC X(25).         05 WS-STUDENT-ADDRESS X(50).   EXEC SQL END DECLARE SECTION   END-EXEC.      EXEC SQL      DECLARE STUDCUR CURSOR FOR      SELECT STUDENT-ID, STUDENT-NAME, STUDENT-ADDRESS FROM STUDENT      WHERE STUDENT-ID >:WS-STUDENT-ID   END-EXEC.PROCEDURE DIVISION.   MOVE 1001 TO WS-STUDENT-ID.   PERFORM UNTIL SQLCODE = 100      EXEC SQL      FETCH STUDCUR      INTO :WS-STUDENT-ID, :WS-STUDENT-NAME, WS-STUDENT-ADDRESS   END-EXEC      DISPLAY WS-STUDENT-RECEND-PERFORM	STOP RUN.|||//SAMPLE JOB(TESTJCL,XXXXXX),CLASS = A,MSGCLASS = C//STEP001  EXEC PGM=IKJEFT01//STEPLIB  DD DSN=MYDATA.URMI.DBRMLIB,DISP=SHR//SYSPRINT DD SYSOUT=*//SYSUDUMP DD SYSOUT=*//SYSOUT   DD SYSOUT=*//SYSTSIN  DD *   DSN SYSTEM(SSID)   RUN PROGRAM(HELLO) PLAN(PLANNAME) -   END/*"
Learn COBOL,COBOL - Useful Resources,COBOL - Useful Resources|||Useful Video Courses@@@Useful eBooks|||COBOL Online Training@@@COBOL Tutorial,The following resources contain additional information on COBOL. Please use them to get more in-depth knowledge on this topic.,,,,
Learn COBOL,Discuss COBOL,Discuss COBOL|||Useful Video Courses|||COBOL Online Training,"COBOL stands for Common Business Oriented Language.The US Department of Defense, in a conference, formed CODASYL (Conference on Data Systems Language) to develop a language for business data processing needs which is now known as COBOL. COBOL is used for writing application programs and we cannot use it to write system software. The applications like those in defense domain, insurance domain, etc. which require huge data processing make extensive use of COBOL.",,,,
