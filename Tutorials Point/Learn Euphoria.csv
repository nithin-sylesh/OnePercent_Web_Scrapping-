Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Euphoria,Euphoria Programming Language Tutorial,Euphoria Programming Language Tutorial@@@Audience@@@Prerequisites,"This tutorial gives you basic understanding of Euphoria programming language. Euphoria is simple, flexible, easy to learn, and interpreted high-level programming language for DOS, Windows, Linux, FreeBSD, and more. This tutorial describes everything a programmer needs to know such as its environment, data types, syntax and operators, file handling, and controlling the flow of program.|||This tutorial is designed for the aspiring students who are keen to learn and understand Euphoria in detail. This tutorial would be of great help for the IT professionals working as programmers. The enthusiastic readers can access this tutorial as a source of additional reading.|||Before proceeding with this tutorial, you need to have a basic knowledge of working on Windows or Linux. You need to be familiar with any programming language such as C, C++. You need to have sound understanding of operating system, memory allocation and de-allocation, and basics of efficient programming and debugging.",,,,
Learn Euphoria,Euphoria - Overview,Euphoria - Overview|||Euphoria Features@@@Platform Requirements@@@Euphoria Limitations@@@Euphoria Licensing,"Euphoria stands for End-User Programming with Hierarchical Objects for Robust Interpreted Applications. Euphoria's first incarnation was created by Robert Craig on an Atari Mega-ST and it was first released in 1993. It is now maintained by Rapid Deployment Software.|||It is a free, simple, flexible, easy to learn, and interpreted but extremely fast 32-bit high-level programming language for DOS, Windows, Linux, FreeBSD and more.|||Euphoria is being used to develop Windows GUI programs, high-speed DOS games, and Linux/FreeBSD X Windows programs. Euphoria can also be used for CGI (Webbased) programming.|||Here is the list of major features of Euphoria −|||It is a simple, flexible, powerful language definition that is easy to learn and use.|||It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.|||It is extremely faster than conventional interpreters such as Perl and Python.|||Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.|||Euphoria programs are not subject to any 640K memory limitations.|||It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.|||Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.|||Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.|||It supports run-time error-handling, subscript, and type checking.|||It is an open source language and comes completely free of cost.|||Euphoria is available on Windows, Linux, FreeBSD, and OSX. Here is the bare minimum version required with the following platforms −|||WIN32 version − You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.|||Linux version − You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.|||FreeBSD version − You need any reasonably up-to-date FreeBSD distribution.|||Mac OS X version − You need any reasonably up-to-date Intel based Mac.|||Here are some prominent limitations of Euphoria −|||Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.|||Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.|||But these days, the language is getting popular very fast and you can hope to have nice utilities and books available for the language very soon.|||This product is free and open source, and has benefited from the contributions of many people. You have complete royalty-free rights to distribute any Euphoria programs that you develop.|||Icon files, such as euphoria.ico and binaries available in euphoria\bin, may be distributed with or without your changes.|||You can shroud or bind your program and distribute the resulting files royalty-free. Some additional 3rd party legal restrictions might apply when you use the Euphoria- To-C translator.|||The generous
 Open Source License  allows Euphoria to use for both personal and commercial purposes. Unlike many other open source licenses, your changes do not have to be made open source.","It is a simple, flexible, powerful language definition that is easy to learn and use.@@@It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.@@@It is extremely faster than conventional interpreters such as Perl and Python.@@@Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.@@@Euphoria programs are not subject to any 640K memory limitations.@@@It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.@@@Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.@@@Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.@@@It supports run-time error-handling, subscript, and type checking.@@@It is an open source language and comes completely free of cost.|||WIN32 version − You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.@@@Linux version − You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.@@@FreeBSD version − You need any reasonably up-to-date FreeBSD distribution.@@@Mac OS X version − You need any reasonably up-to-date Intel based Mac.|||Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.@@@Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.",,,
Learn Euphoria,Euphoria - Environment,"Euphoria - Environment|||Linux, Free BSD Installation@@@WIN32, and DOS Installation@@@Euphoria Interpreters","This chapter describes about the installation of Euphoria on various platforms. You can follow the steps to install Euphoria on Linux, FreeBSD, and 32-bit Windows. So you can choose the steps based on your working environment.|||Official website provides .tar.gz file to install Euphoria on your Linux or BSD OS. You can download your latest version of Euphoria from its official website − Download Euphoria.|||Once you have .tar.gz file, here are three simple steps to be performed to install Euphoria on your Linux or Free BSD machine −|||Step 1 − Installing Files|||Untar the downloaded file euphoria-4.0b2.tar.gz in a directory where you want to install Euphoria. If you want to install it in /home directory as follows, then −|||This creates a directory hierarchy inside /home/euphoria-4.0b2 directory as follows −|||NOTE − File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.|||Step 2 − Setting Up the Path|||After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up −|||Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.|||Set EUDIR environment variable to point to /home/euphoria-4.0b2.|||Set EUINC environment variable to point to /home/euphoria-4.0b2/include.|||These variables can be set as follows −|||NOTE − The above commands used to set environment variables may differ depending on your Shell. We used bash shell for executing these commands to set the variables.|||Step 3 − Confirmation Installation|||Confirm if you installed Euphoria successfully or not.|||Execute the following command −|||If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.|||That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.|||Official website provides .exe file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website − Download Euphoria.|||Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine −|||Step 1 − Installing Files|||Double click on the downloaded .exe setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.|||The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.|||By default Euphoria would be installed in C:\euphoria-40b2 directory but you can also select a desired location.|||Step 2 − Rebooting the Machine|||Re-boot your machine to complete the installation.|||Step 3 − Confirmation Installation|||Confirm if you installed Euphoria successfully or not.|||Execute the following command −|||If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.|||That is it, Euphoria Programming Environment is ready on your WIN32 machine, and you can start writing complex programs in easy steps.|||Depending on the platform you are using, Euphoria has multiple interpreters −|||The main interpreter is eui.|||On windows platforms, you have two choices. If you run eui then a console window is created. If you run euiw then no console is created, making it suitable for GUI applications.|||Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with .ex extension.|||GUI-based applications have .exw extension and the include files have .e extension.","Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.@@@Set EUDIR environment variable to point to /home/euphoria-4.0b2.@@@Set EUINC environment variable to point to /home/euphoria-4.0b2/include.|||The main interpreter is eui.@@@On windows platforms, you have two choices. If you run eui then a console window is created. If you run euiw then no console is created, making it suitable for GUI applications.@@@Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with .ex extension.@@@GUI-based applications have .exw extension and the include files have .e extension.",,,
Learn Euphoria,Euphoria - Basic Syntax,Euphoria - Basic Syntax|||First Euphoria Program@@@Euphoria Identifiers@@@Reserved Words@@@Expressions@@@Blocks of code@@@Multi-Line Statements@@@Escape Characters@@@Comments in Euphoria|||Examples,"The Euphoria language has many similarities to Perl, C, and Java. However, there are some definite differences between the languages. This chapter is designed to quickly get you up to speed on the syntax that is expected in Euphoria.|||This tutorial assumes you are working with Linux and all the examples have been written on Linux platform. But it is observed that there is no any prominent difference in program syntax on Linux and WIN32. Hence you can follow the same steps on WIN32.|||Let us write a simple Euphoria program in a script. Type the following source code in test.ex file and save it.|||Let us say, Euphoria interpreter is available in /home/euphoria-4.0b2/bin/ directory. Now run this program as follows −|||This produces the following result −|||This script used a built-in function puts() which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.|||A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.|||Euphoria does not allow punctuation characters such as @, $, and % within identifiers.|||Euphoria is a case sensitive programming language. Thus Manpower and manpower are two different identifiers in Euphoria. For example, the valid identifiers are −|||The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.|||Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.|||You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example −|||This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.|||One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.|||The following example shows if...then...end if block −|||Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example −|||Escape characters may be entered using a back-slash. For example −|||The following table is a list of escape or non-printable characters that can be represented with backslash notation.|||Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.|||There are three forms of comment text −|||Comments start by two dashes and extend to the end of the current line.|||The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.|||You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.|||This produces the following result −|||Note − You can use a special comment beginning with “#!”. This informs the Linux shell that your file should be executed by the Euphoria interpreter.","n@@@color26@@@ShellSort@@@quick_sort@@@a_very_long_indentifier|||Comments start by two dashes and extend to the end of the current line.@@@The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.@@@You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.",,"and@@@exit@@@override|||as@@@export@@@procedure|||break@@@fallthru@@@public|||by@@@for@@@retry|||case@@@function@@@return|||constant@@@global@@@routine|||continue@@@goto@@@switch|||do@@@if@@@then|||else@@@ifdef@@@to|||elsedef@@@include@@@type|||elsif@@@label@@@until|||elsifdef@@@loop@@@while|||end@@@namespace@@@with|||entry@@@not@@@without|||enum@@@or@@@xor&&&Backslash notation@@@Description|||\n@@@Newline|||\r@@@Carriage return|||\t@@@Tab|||\\@@@Backslash|||\""@@@Double quote|||\'@@@Single quote","#!/home/euphoria-4.0b2/bin/euiputs(1, ""Hello, Euphoria!\n"")|||$ chmod +x test.ex    # This is to make file executable$ ./test.ex|||if condition then   code block comes hereend if|||total = item_one +    item_two +    item_three|||#!/home/euphoria-4.0b2/bin/eui-- First commentputs(1, ""Hello, Euphoria!\n"") -- second comment/* This is a comment which extends over a number   of text lines and has no impact on the program*/"
Learn Euphoria,Euphoria - Variables,Euphoria - Variables|||Variable Declaration@@@Assigning Values@@@Identifier Scope,"Variables are nothing but reserved memory locations to store values. This means when you create a variable, you reserve some space in memory.|||Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables. Euphoria data types are explained in different chapter.|||These memory locations are called variables because their value can be changed during their life time.|||Euphoria variables have to be explicitly declared to reserve memory space. Thus declaration of a variable is mandatory before you assign a value to a variable.|||Variable declarations have a type name followed by a list of the variables being declared. For example −|||When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.|||The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as ""variable xyz has never been assigned a value"".|||The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner −|||Variable_Name = Variable_Value|||For example −|||Here 100, 1000.0 and ""John"" are the values assigned to counter, miles and name variables, respectively. This program produces the following result −|||To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment −|||This is equivalent to the following −|||The scope of an identifier is a description of what code can access it. Code in the same scope of an identifier can access that identifier and code not in the same scope as identifier cannot access it.|||The scope of a variable depends upon where and how it is declared.|||If it is declared within a for, while, loop or switch, its scope starts at the declaration and ends at the respective end statement.|||In an if statement, the scope starts at the declaration and ends either at the next else, elsif or end if statement.|||If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.|||If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.|||The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||The scope of a enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||The scope of all procedures, functions and types, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.|||Constants, enums, module variables, procedures, functions and types, which do not have a scope modifier are referred to as locals. However, these identifiers can have a scope modifier preceding their declaration, which causes their scope to extend beyond the file they are declared in.|||If the keyword global precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.|||If the keyword public precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn public includes the file containing the public declaration.|||If the keyword export precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.|||When you include a Euphoria file in another file, only the identifiers declared using a scope modifier are accessible to the file doing the include. The other declarations in the included file are invisible to the file doing the include.","If it is declared within a for, while, loop or switch, its scope starts at the declaration and ends at the respective end statement.@@@In an if statement, the scope starts at the declaration and ends either at the next else, elsif or end if statement.@@@If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.@@@If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.@@@The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.@@@The scope of a enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.@@@The scope of all procedures, functions and types, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.|||If the keyword global precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.@@@If the keyword public precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn public includes the file containing the public declaration.@@@If the keyword export precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.",,,"#!/home/euphoria/bin/eui-- Here is the declaration of the variables.integer counterinteger milessequence namecounter = 100 -- An integer assignmentmiles = 1000.0 -- A floating pointname = ""John"" -- A string ( sequence )printf(1, ""Value of counter %d\n"", counter )printf(1, ""Value of miles %f\n"", miles )printf(1, ""Value of name %s\n"", {name} )"
Learn Euphoria,Euphoria - Constants,Euphoria - Constants|||The enums|||Examples@@@Examples,"Constants are also variables that are assigned an initial value that can never change in the program’s life. Euphoria allows to define constants using constant keyword as follows −|||The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is ""locked in"".|||Constants may not be declared inside a subroutine. The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||This produces the following error −|||If you delete last two lines from the example, then it produces the following result −|||An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.|||Enums may not be declared inside a subroutine. The scope of an enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||This will produce following result −|||You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.|||This produce the following result −|||Sequences use integer indices, but with enum you may write code like this −",,,,"constant MAX = 100constant Upper = MAX - 10, Lower = 5constant name_list = {""Fred"", ""George"", ""Larry""}|||#!/home/euphoria-4.0b2/bin/euiconstant MAX = 100constant Upper = MAX - 10, Lower = 5printf(1, ""Value of MAX %d\n"", MAX )printf(1, ""Value of Upper %d\n"", Upper )printf(1, ""Value of Lower %d\n"", Lower )MAX = MAX + 1printf(1, ""Value of MAX %d\n"", MAX )|||#!/home/euphoria-4.0b2/bin/euienum ONE, TWO, THREE, FOURprintf(1, ""Value of ONE %d\n"", ONE )printf(1, ""Value of TWO %d\n"", TWO )printf(1, ""Value of THREE %d\n"", THREE )printf(1, ""Value of FOUR %d\n"", FOUR )|||#!/home/euphoria-4.0b2/bin/euienum ONE, TWO, THREE, ABC=10, XYZprintf(1, ""Value of ONE %d\n"", ONE )printf(1, ""Value of TWO %d\n"", TWO )printf(1, ""Value of THREE %d\n"", THREE )printf(1, ""Value of ABC %d\n"", ABC )printf(1, ""Value of XYZ %d\n"", XYZ )|||enum X, Ysequence point = { 0,0 }point[X] = 3point[Y] = 4"
Learn Euphoria,Euphoria - Data Types,Euphoria - Data Types|||Integers@@@Atoms@@@Sequences@@@Objects,"The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.|||Euphoria has some standard types that are used to define the operations possible on them and the storage method for each of them.|||Euphoria has following four standard data types −|||The understanding of atoms and sequences is the key to understanding Euphoria.|||Euphoria integer data types store numeric values. They are declared and defined as follows −|||The variables declared with type integer must be atoms with integer values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.|||All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows−|||The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an atom which must may be entered using single quotes. For example, all the following statements are legal −|||A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.|||Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows −|||A character string is just a sequence of characters which may be entered using double quotes. For example, all the following statements are legal −|||Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence −|||You will learn more about sequence in Euphoria − Sequences.|||This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows −|||An object may have one of the following values −|||a sequence|||an atom|||an integer|||an integer used as a file number|||a string sequence, or single-character atom","integer@@@atom@@@sequence@@@object|||a sequence@@@an atom@@@an integer@@@an integer used as a file number@@@a string sequence, or single-character atom",,,"integer var1, var2var1 = 1var2 = 100|||atom var1, var2, var3var1 = 1000var2 = 198.6121324234var3 = 'E'       |||sequence var1, var2, var3, var4var1 = {2, 3, 5, 7, 11, 13, 17, 19}var2 = {1, 2, {3, 3, 3}, 4, {5, {6}}}var3 = {{""zara"", ""ali""}, 52389, 97.25}     var4 = {} -- the 0 element sequence|||word = 'word'sentence = ""ABCDEFG""|||sentence = {65, 66, 67, 68, 69, 70, 71}|||object var1, var2, var3var1 = {2, 3, 5, 7, 11, 13, 17, 19}var2 = 100var3 = 'E'     "
Learn Euphoria,Euphoria - Operators,Euphoria - Operators|||The Arithmetic Operators@@@The Relational Operators@@@The Logical Operators@@@The Assignment Operators@@@Miscellaneous Operators@@@Precedence of Euphoria Operators|||The '&' Operator,"Euphoria provides a rich set of operators to manipulate variables. We can divide all the Euphoria operators into the following groups −|||Arithmetic operators are used in mathematical expressions in the same way that they are used in Algebra. The following table lists the arithmetic operators. Assume integer variable A holds 10 and variable B holds 20 then −|||Show Examples|||There are following relational operators supported by Euphoria language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||The following table lists the logical operators. Assume boolean variables A holds 1 and variable B holds 0 then −|||Show Examples|||You can also apply these operators to numbers other than 1 or 0. The convention is: zero means false and non-zero means true.|||There are following assignment operators supported by Euphoria language −|||Show Examples|||Note − The equals symbol '=' used in an assignment statement is not an operator, it is just a part of the syntax.|||There are few other operators supported by Euphoria Language.|||Any two objects may be concatenated using “&” operator. The result is a sequence with a length equal to the sum of the lengths of the concatenated objects.|||For example −|||This produces the following result −|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.|||For example, x = 7 + 3 * 2|||Here, x is assigned 13, not 20 because operator * has higher precedence than +.|||Hence it first starts with 3*2 and then adds into 7.|||Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators is evaluated first.",Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Assignment Operators@@@Misc Operators,,"Operator@@@Description@@@Example|||+@@@Addition - Adds values on either side of the operator@@@A + B will give 30|||-@@@Subtraction - Subtracts right hand operand from left hand operand@@@A - B will give -10|||*@@@Multiplication - Multiplies values on either side of the operator@@@A * B will give 200|||/@@@Division - Divides left hand operand by right hand operand@@@B / A will give 2|||+@@@Unary plus - This has no impact on the variable value.@@@+B gives 20|||-@@@Unary minus - This creates a negative value of the given variable.@@@-B gives -20&&&Operator@@@Description@@@Example|||=@@@Checks if the value of two operands are equal or not, if yes then condition becomes true.@@@(A = B) is not true.|||!=@@@Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||and@@@Called Logical AND operator. If both the operands are non zero then then condition becomes true.@@@(A and B) is false.|||or@@@Called Logical OR Operator. If any of the two operands are non zero then then condition becomes true.@@@(A or B) is true.|||xor@@@Called Logical XOR Operator. Condition is true if one of them is true, if both operands are true or false then condition becomes false.@@@(A xor B) is true.|||not@@@Called Logical NOT Operator which negates the result. Using this operator, true becomes false and false becomes true@@@not(B) is true.&&&Operator@@@Description@@@Example|||=@@@Simple assignment operator, Assigns values from right side operands to left side operand@@@C = A + B will assigne value of A + B into C|||+=@@@Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand@@@C += A is equivalent to C = C + A|||-=@@@Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand@@@C -= A is equivalent to C = C - A|||*=@@@Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand@@@C *= A is equivalent to C = C * A|||/=@@@Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand@@@C /= A is equivalent to C = C / A|||&=@@@Concatenation operator@@@C &= {2} is same as  C = {C} & {2}&&&Category@@@Operator@@@Associativity|||Postfix@@@function/type calls@@@ |||Unary@@@+ - ! not@@@Right to left|||Multiplicative@@@*  /@@@Left to right|||Additive@@@+  -@@@Left to right|||Concatenation@@@&@@@Left to right|||Relational@@@> >=  < <=@@@Left to right|||Equality@@@=  !=@@@Left to right|||Logical AND@@@and@@@Left to right|||Logical OR@@@or@@@Left to right|||Logical XOR@@@xor@@@Left to right|||Comma@@@,@@@Left to right","#!/home/euphoria-4.0b2/bin/euisequence a, b, ca = {1, 2, 3}b = {4}c = {1, 2, 3} & {4}printf(1, ""Value of c[1] %d\n"", c[1] )printf(1, ""Value of c[2] %d\n"", c[2] )printf(1, ""Value of c[3] %d\n"", c[3] )printf(1, ""Value of c[4] %d\n"", c[4] )"
Learn Euphoria,Euphoria - Branching,Euphoria - Branching,"Branching is the most important aspect of any programming language. While writing your program, you may encounter a situation when you have to take a decision or you have to select one option out of the given many options.|||Following diagram shows a simple scenario where a program needs to take one of the two paths based on the given condition.|||Euphoria provides following three types of decision making (branching or conditional) statements −|||if statement|||switch statement|||ifdef statement|||Let us see the statements in detail −",if statement@@@switch statement@@@ifdef statement,,,
Learn Euphoria,Euphoria - Loop Types,Euphoria - Loop Types,"Looping is yet another most important aspect of any programming language. While writing your program, you may encounter a situation when you have to execute same statement many times and sometime may be infinite number of times.|||There are several ways to specify for how long the process should go on, and how to stop or otherwise alter it. An iterative block may be informally called a loop, and each execution of code in a loop is called an iteration of the loop.|||The following diagram shows a simple logical flow of a loop −|||Euphoria provides following three types of loop statements −|||while statement|||loop until statement|||for statement|||All the above statements provide you flexibility and ease of use based on different situations. Let us see them in detail one by one −",while statement@@@loop until statement@@@for statement,,,
Learn Euphoria,Euphoria - Flow Control,Euphoria - Flow Control|||The exit statement@@@The break statement@@@The continue statement@@@The retry statement@@@The goto statement|||Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example,"Program execution flow refers to the order in which program statements get executed. By default the statements get executed one after another.|||However; many times the order of execution needs to be altered from the default order, to get the task done.|||Euphoria has a number of flow control statements that you can use to arrange the execution order of statements.|||Exiting a loop is done with the keyword exit. This causes flow to immediately leave the current loop and recommence with the first statement after the end of the loop.|||The syntax of an exit statement is as follows −|||The exit statement terminates the latest and innermost loop until an optional label name or number is specified.|||A special form of exit N is exit 0. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.|||This produces the following result −|||The break statement works exactly like the exit statement, but applies to if statements or switch statements rather than to loop statements of any kind.|||The syntax of break statement is as follows −|||The break statement terminates the latest and innermost if or switch block until an optional label name or number is specified.|||A special form of break N is break 0. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.|||This produces the following result −|||The continue statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.|||Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.|||The syntax of continue statement is as follows −|||The continue statement would re-iterate the latest and inner most loop until an optional label name or number is specified.|||A special form of continue N is continue 0. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.|||The retry statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.|||The syntax of retry statement is as follows −|||The retry statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.|||A special form of retry N is retry 0. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.|||Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.|||Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.|||The goto statement instructs the computer to resume code execution at a labeled place.|||The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.|||The syntax of goto statement is as follows −|||The target of a goto statement can be any accessible label statement −|||Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.|||This produces the following result −",,,,"#!/home/euphoria-4.0b2/bin/euiinteger bfor a = 1 to 16 do   printf(1, ""value of a %d\n"", a)      if a = 10 then      b = a      exit   end ifend forprintf(1, ""value of b %d\n"", b)|||#!/home/euphoria-4.0b2/bin/euiinteger a, bsequence s = {'E','u', 'p'}if s[1] = 'E' then   a = 3      if s[2] = 'u' then      b = 1      if s[3] = 'p' then         break 0 -- leave topmost if block      end if      a = 2   else      b = 4   end ifelse   a = 0   b = 0end ifprintf(1, ""value of a %d\n"", a)printf(1, ""value of b %d\n"", b)|||#!/home/euphoria-4.0b2/bin/euifor a = 3 to 6 do   printf(1, ""value of a %d\n"", a)   if a = 4 then      puts(1,""(2)\n"")      continue   end if   printf(1, ""value of a %d\n"", a*a)end forThis would produce following result:value of a 3value of a 9value of a 4(2)value of a 5value of a 25value of a 6value of a 36|||#!/home/euphoria-4.0b2/bin/euiinteger errors = 0integer files_to_open = 10for i = 1 to length(files_to_open) do   fh = open(files_to_open[i], ""rb"")      if fh = -1 then      if errors > 5 then         exit      else         errors += 1         retry      end if   end if   file_handles[i] = fhend for|||label ""Label Name""|||#!/home/euphoria-4.0b2/bin/euiinteger a = 0label ""FIRST""printf(1, ""value of a %d\n"", a)a += 10if a < 50 then   goto ""FIRST""end if printf(1, ""Final value of a %d\n"", a)"
Learn Euphoria,Euphoria - Short Circuit Evaluation,Euphoria - Short Circuit Evaluation,"When a condition is tested by if, elsif, until, or while using and or or operators, a short-circuit evaluation is used. For example −|||If a < 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly −|||if a < 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.|||In General, whenever you have a condition of the following form −|||Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.|||Similarly, whenever you have a condition of the following form −|||Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.|||Short-circuit evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example −|||If short-circuiting were used here, you would set x to 1, and not even look at {1,2,3,4,5}, which would be wrong.|||Thus, short-circuiting can be used in if, elsif, until, or while conditions, because you need to only care if the result is true or false, and conditions are required to produce an atom as a result.",,,,"if a < 0 and b > 0 then   -- block of codeend if|||if a < 0 or b > 0 then   -- block of codeend if|||x = 1 or {1,2,3,4,5} -- x should be set to {1,1,1,1,1}"
Learn Euphoria,Euphoria - Sequences,Euphoria - Sequences|||Character String@@@String Arrays@@@Euphoria Structures@@@Urinary Operation@@@Arithmetic Operations@@@Command Line Options|||Example,"A sequence is represented by a list of objects in brace brackets { }, separated by commas. A sequence can contain both atoms and other sequences. For example −|||A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.|||For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.|||Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.|||Here, length() is the built-in function which returns length of the sequence. The above example produces the following result −|||A character string is just a sequence of characters. It may be entered in one of the two ways −|||(a) Using Double Quotes −|||(b) Using Raw String Notation −|||You can try the following example to understand the concept −|||This produces the following result −|||An array of strings can be implemented using Sequences as follows −|||This produces the following result −|||A structure can be implemented using Sequences as follows −|||This produces the following result −|||There are various operations which can be performed directly on sequences. Let us see them in detail −|||When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.|||This produces the following result −|||Almost all arithmetic operations can be performed on sequences as follows −|||This produces the following result −|||A user can pass command line options to a Euphoria script and it can be accessed as a sequence using command_line() function as follows −|||Here printf() is Euphoria's built-in function. Now if you run this script as follows −|||This produces the following result −",,,,"#!/home/euphoria-4.0b2/bin/euisequence xx = {1, 2, 3, 4}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %d\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence xx = ""ABCD""for a = 1 to length(x) do   printf(1, ""value of x[%d] = %s\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence x = {""Hello"", ""World"", ""Euphoria"", """", ""Last One""}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %s\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence employee = {   {""John"",""Smith""},      45000,      27,      185.5}printf(1, ""First Name = %s, Last Name = %s\n"", {employee[1][1],employee[1][2]} )|||#!/home/euphoria-4.0b2/bin/euisequence xx = -{1, 2, 3, 4}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %d\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence x, y, a, b, cx = {1, 2, 3}y = {10, 20, 30}a = x + yputs(1, ""Value of a = {"")for i = 1 to length(a) do   printf(1, ""%d,"", a[i])end forputs(1, ""}\n"")b = x - yputs(1, ""Value of b = {"")for i = 1 to length(a) do   printf(1, ""%d,"", b[i])end forputs(1, ""}\n"")c = x * 3puts(1, ""Value of c = {"")for i = 1 to length(c) do   printf(1, ""%d,"", c[i])end forputs(1, ""}\n"")|||#!/home/euphoria-4.0b2/bin/euisequence xx = command_line()printf(1, ""Interpeter Name: %s\n"", {x[1]} )printf(1, ""Script Name: %s\n"", {x[2]} )printf(1, ""First Argument: %s\n"", {x[3]})printf(1, ""Second Argument: %s\n"", {x[4]})"
Learn Euphoria,Euphoria - Date & Time,Euphoria - Date & Time|||The date() Method@@@The time() Method@@@Date & Time Related Methods,"Euphoria has a library routine that returns the date and time to your program.|||The date() method returns a sequence value composed of eight atom elements. The following example explains it in detail −|||This produces the following result on your standard screen −|||The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail −|||This produces the following result −|||Euphoria provides a list of methods which helps you in manipulating date and time. These methods are listed in  Euphoria Library Routines.",,,,"#!/home/euphoria-4.0b2/bin/eui integer curr_year, curr_day, curr_day_of_year, curr_hour, curr_minute, curr_secondsequence system_date, word_week, word_month, notation,    curr_day_of_week, curr_month   word_week = {""Sunday"",       ""Monday"",       ""Tuesday"",       ""Wednesday"",       ""Thursday"",       ""Friday"",       ""Saturday""}   word_month = {""January"", ""February"",       ""March"",       ""April"",       ""May"",       ""June"",       ""July"",       ""August"",       ""September"",       ""October"",       ""November"",       ""December""}-- Get current system date.system_date = date()-- Now take individual elementscurr_year = system_date[1] + 1900curr_month = word_month[system_date[2]]curr_day = system_date[3]curr_hour = system_date[4]curr_minute = system_date[5]curr_second = system_date[6]curr_day_of_week = word_week[system_date[7]]curr_day_of_year = system_date[8]if curr_hour >= 12 then    notation = ""p.m.""else    notation = ""a.m.""end ifif curr_hour > 12 then    curr_hour = curr_hour - 12end ifif curr_hour = 0 then    curr_hour = 12end ifputs(1, ""\nHello Euphoria!\n\n"")printf(1, ""Today is %s, %s %d, %d.\n"", {curr_day_of_week,    curr_month, curr_day, curr_year})printf(1, ""The time is %.2d:%.2d:%.2d %s\n"", {curr_hour,    curr_minute, curr_second, notation})printf(1, ""It is %3d days into the current year.\n"", {curr_day_of_year})|||#!/home/euphoria-4.0b2/bin/eui constant ITERATIONS = 100000000integer patom t0, t1, loop_overheadt0 = time()for i = 1 to ITERATIONS do   -- time an empty loopend forloop_overhead = time() - t0printf(1, ""Loop overhead:%d\n"", loop_overhead)t0 = time()for i = 1 to ITERATIONS do    p = power(2, 20)end fort1 = (time() - (t0 + loop_overhead))/ITERATIONSprintf(1, ""Time (in seconds) for one call to power:%d\n"", t1)"
Learn Euphoria,Euphoria - Procedures,Euphoria - Procedures|||Procedure Definition@@@Calling a Procedure@@@Procedure Parameters|||Example@@@Example,"A procedure is a group of reusable code which can be called from anywhere in your program. This eliminates the need of writing same code again and again. This helps programmers to write modular code.|||Like any other advance programming language, Euphoria also supports all the features necessary to write modular code using procedures.|||You must have seen procedures like printf() and length() in previous chapters. We are using these procedure again and again but they have been written in core Euphoria only once.|||Euphoria allows you to write your own procedures as well. This section explains how to write your own procedure in Euphoria.|||Before you use a procedure, you need to define it. The most common way to define a procedure in Euphoria is by using the procedure keyword, followed by a unique procedure name, a list of parameters (that might be empty), and a statement block which ends with end procedure statement. The basic syntax is as shown below −|||A simple procedure called sayHello that takes no parameters is defined here −|||To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows −|||This produces the following result −|||Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.|||A procedure can take multiple parameters separated by comma.|||Let us do a bit modification in our sayHello procedure. This time it takes two parameters −|||This produces the following result −",,,,"procedure  sayHello()   puts(1, ""Hello there"")end procedure|||#!/home/euphoria-4.0b2/bin/euiprocedure  sayHello()   puts(1, ""Hello there"")end procedure -- Call above defined procedure.sayHello()|||#!/home/euphoria-4.0b2/bin/euiprocedure sayHello(sequence name,atom  age)   printf(1, ""%s is %d years old."", {name, age})end procedure-- Call above defined procedure.sayHello(""zara"", 8)"
Learn Euphoria,Euphoria - Functions,Euphoria - Functions|||Function Definition@@@Calling a Function@@@Function Parameters@@@The return Statement|||Example@@@Example,"Euphoria functions are just like procedures, but they return a value, and can be used in an expression. This chapter explains how to write your own functions in Euphoria.|||Before we use a function we need to define it. The most common way to define a function in Euphoria is by using the function keyword, followed by a unique function name, a list of parameters (that might be empty), and a statement block which ends with end function statement. The basic syntax is shown here −|||A simple function called sayHello that takes no parameters is defined here −|||To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows −|||This produces the following result −|||Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.|||A function can take multiple parameters separated by comma.|||Let us do a bit modification in our sayHello function. This time it takes two parameters −|||This produces the following result −|||A Euphoria function must have return statement before closing statement end function. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example|||If you have nothing to return, then simply return 1 or 0. The return value 1 indicates success and 0 indicates failure",,,,"function functionname(parameter-list)   statements   ..........   return [Euphoria Object]end function|||function sayHello()   puts(1, ""Hello there"")   return 1end function|||#!/home/euphoria-4.0b2/bin/euifunction sayHello()   puts(1, ""Hello there"")   return 1end function-- Call above defined function.sayHello()|||#!/home/euphoria-4.0b2/bin/euifunction sayHello(sequence name,atom  age)   printf(1, ""%s is %d years old."", {name, age})   return 1end function-- Call above defined function.sayHello(""zara"", 8)|||return {x_pos, y_pos}"
Learn Euphoria,Euphoria - Files I/O,Euphoria - Files I/O|||Displaying on the Screen@@@Opening and Closing Files@@@The open Method@@@The close() Method@@@Reading and Writing Files@@@The printf() Method@@@The gets() Method|||Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example,"Using Euphoria programming language, you can write programs that read and change file data on your floppy drive or hard drive, or create new files as a form of output. You can even access devices on your computer such as the printer and modem.|||This chapter described all the basic I/O functions available in Euphoria. For information on more functions, please refer to standard Euphoria documentation.|||The simplest way to produce output is using the puts() statement where you can pass any string to be displayed on the screen. There is another method printf() which can also be used in case you have to format a string using dynamic values.|||These methods convert the expressions you pass them to a string and write the result to standard output as follows −|||This produces the following result on your standard screen −|||Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods −|||Before you can read or write a file, you have to open it using Euphoria's built-in open()method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.|||Above method returns -1 in case there is an error in opening the given file name. Here are the parameters −|||file_name − The file_name argument is a string value that contains the name of the file that you want to access.|||access_mode − The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table −|||r|||Opens a text file for reading only. The file pointer is placed at the beginning of the file.|||rb|||Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.|||w|||Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||wb|||Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||u|||Opens a file for both reading and writing. The file pointer is set at the beginning of the file.|||ub|||Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.|||a|||Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||ab|||Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||The following example creates a new text file in the current directory on your Linux system −|||If file opens successfully, then it ""myfile.txt"" is created in your current directory and produces the following result −|||The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.|||Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.|||Here the file descriptor received while opening a file is passed as a parameter.|||The following example creates a file as above and then closes it before existing the program −|||This produces the following result −|||Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use printf() and gets() methods to read and write files.|||The printf() method writes any string to an open file.|||Here are the parameters −|||fn − File descriptor received from open() method.|||st − Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.|||x − If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.|||The following example opens a file and writes the name and age of a person in this file −|||The above example creates myfile.txt file. Is writes given content in that file and finally closes. If you open this file, it would have the following content −|||The gets() method reads a string from an open file.|||Here passed parameter is file description return by the opend() method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.|||Let us take a file myfile.txt which is already created.|||This produces the following result −|||Euphoria provides a list of many methods which helps you in manipulating files. These methods are listed in  Euphoria Library Routines.","open()@@@close()@@@printf()@@@gets()@@@getc()|||file_name − The file_name argument is a string value that contains the name of the file that you want to access.@@@access_mode − The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table −|||fn − File descriptor received from open() method.@@@st − Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.@@@x − If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.",,"S.No@@@Modes & Description|||1@@@r
Opens a text file for reading only. The file pointer is placed at the beginning of the file.|||2@@@rb
Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.|||3@@@w
Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||4@@@wb
Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||5@@@u
Opens a file for both reading and writing. The file pointer is set at the beginning of the file.|||6@@@ub
Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.|||7@@@a
Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||8@@@ab
Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.","#!/home/euphoria-4.0b2/bin/eui puts(1, ""Euphoria is really a great language, isn't it?"" )|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile,txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifif file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifprintf(file_num, ""My name is %s and age is %d\n"", {""Zara"", 8})if file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numobject lineconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""r"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifline = gets(file_num)printf( STDOUT, ""Read content : %s\n"", {line})if file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if"
Learn Euphoria,Euphoria - Quick Guide,"Euphoria - Quick Guide@@@Euphoria - Overview@@@Euphoria - Environment@@@Euphoria - Basic Syntax@@@Euphoria - Variables@@@Euphoria - Constants@@@Euphoria - Data Types@@@Euphoria - Operators@@@Euphoria - Branching@@@Euphoria - Loop Types@@@Euphoria - Flow Control@@@Euphoria - Short Circuit Evaluation@@@Euphoria - Sequences@@@Euphoria - Date & Time@@@Euphoria - Procedures@@@Euphoria - Functions@@@Euphoria - Files I/O|||Euphoria Features@@@Platform Requirements@@@Euphoria Limitations@@@Euphoria Licensing@@@Linux, Free BSD Installation@@@WIN32, and DOS Installation@@@Euphoria Interpreters@@@First Euphoria Program@@@Euphoria Identifiers@@@Reserved Words@@@Expressions@@@Blocks of code@@@Multi-Line Statements@@@Escape Characters@@@Comments in Euphoria@@@Variable Declaration@@@Assigning Values@@@Identifier Scope@@@The enums@@@Integers@@@Atoms@@@Sequences@@@Objects@@@The Arithmetic Operators@@@The Relational Operators@@@The Logical Operators@@@The Assignment Operators@@@Miscellaneous Operators@@@Precedence of Euphoria Operators@@@The exit statement@@@The break statement@@@The continue statement@@@The retry statement@@@The goto statement@@@Character String@@@String Arrays@@@Euphoria Structures@@@Urinary Operation@@@Arithmetic Operations@@@Command Line Options@@@The date() Method@@@The time() Method@@@Date & Time Related Methods@@@Procedure Definition@@@Calling a Procedure@@@Procedure Parameters@@@Function Definition@@@Calling a Function@@@Function Parameters@@@The return Statement@@@Displaying on the Screen@@@Opening and Closing Files@@@The open Method@@@The close() Method@@@Reading and Writing Files@@@The printf() Method@@@The gets() Method|||Examples@@@Examples@@@Examples@@@The '&' Operator@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Example@@@Example@@@Example@@@Example@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example@@@Syntax@@@Example","Euphoria stands for End-User Programming with Hierarchical Objects for Robust Interpreted Applications. Euphoria's first incarnation was created by Robert Craig on an Atari Mega-ST and it was first released in 1993. It is now maintained by Rapid Deployment Software.|||It is a free, simple, flexible, easy to learn, and interpreted but extremely fast 32-bit high-level programming language for DOS, Windows, Linux, FreeBSD and more.|||Euphoria is being used to develop Windows GUI programs, high-speed DOS games, and Linux/FreeBSD X Windows programs. Euphoria can also be used for CGI (Webbased) programming.|||Here is the list of major features of Euphoria −|||It is a simple, flexible, powerful language definition that is easy to learn and use.|||It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.|||It is extremely faster than conventional interpreters such as Perl and Python.|||Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.|||Euphoria programs are not subject to any 640K memory limitations.|||It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.|||Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.|||Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.|||It supports run-time error-handling, subscript, and type checking.|||It is an open source language and comes completely free of cost.|||Euphoria is available on Windows, Linux, FreeBSD, and OSX. Here is the bare minimum version required with the following platforms −|||WIN32 version − You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.|||Linux version − You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.|||FreeBSD version − You need any reasonably up-to-date FreeBSD distribution.|||Mac OS X version − You need any reasonably up-to-date Intel based Mac.|||Here are some prominent limitations of Euphoria −|||Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.|||Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.|||But these days, the language is getting popular very fast and you can hope to have nice utilities and books available for the language very soon.|||This product is free and open source, and has benefited from the contributions of many people. You have complete royalty-free rights to distribute any Euphoria programs that you develop.|||Icon files, such as euphoria.ico and binaries available in euphoria\bin, may be distributed with or without your changes.|||You can shroud or bind your program and distribute the resulting files royalty-free. Some additional 3rd party legal restrictions might apply when you use the Euphoria- To-C translator.|||The generous
 Open Source License  allows Euphoria to use for both personal and commercial purposes. Unlike many other open source licenses, your changes do not have to be made open source.|||This chapter describes about the installation of Euphoria on various platforms. You can follow the steps to install Euphoria on Linux, FreeBSD, and 32-bit Windows. So you can choose the steps based on your working environment.|||Official website provides .tar.gz file to install Euphoria on your Linux or BSD OS. You can download your latest version of Euphoria from its official website − Download Euphoria.|||Once you have .tar.gz file, here are three simple steps to be performed to install Euphoria on your Linux or Free BSD machine −|||Step 1 − Installing Files|||Untar the downloaded file euphoria-4.0b2.tar.gz in a directory where you want to install Euphoria. If you want to install it in /home directory as follows, then −|||This creates a directory hierarchy inside /home/euphoria-4.0b2 directory as follows −|||NOTE − File name euphoria-4.0b2.tar.gz depends on latest version available. We are using 4.0b2 version of the language for this tutorial.|||Step 2 − Setting Up the Path|||After installing Euphoria, you need to set proper paths so that your shell can find required Euphoria binaries and utilities. Before proceeding, there are following three important environment variables you need to set up −|||Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.|||Set EUDIR environment variable to point to /home/euphoria-4.0b2.|||Set EUINC environment variable to point to /home/euphoria-4.0b2/include.|||These variables can be set as follows −|||NOTE − The above commands used to set environment variables may differ depending on your Shell. We used bash shell for executing these commands to set the variables.|||Step 3 − Confirmation Installation|||Confirm if you installed Euphoria successfully or not.|||Execute the following command −|||If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.|||That is it, Euphoria Programming Environment is ready on your UNIX machine, and you can start writing complex programs in easy steps.|||Official website provides .exe file to install Euphoria on your WIN32 or DOS OS. You can download your latest version of Euphoria from its official website − Download Euphoria.|||Once you have .exe file, here are three simple steps to follow for installing Euphoria Programming language on your WIN32 or DOS machine −|||Step 1 − Installing Files|||Double click on the downloaded .exe setup program to install all the files. We downloaded euphoria-40b2.exe file for installation.|||The filename euphoria-40b2.exe depends on latest version available. We use version 4 beta 2 of the language.|||By default Euphoria would be installed in C:\euphoria-40b2 directory but you can also select a desired location.|||Step 2 − Rebooting the Machine|||Re-boot your machine to complete the installation.|||Step 3 − Confirmation Installation|||Confirm if you installed Euphoria successfully or not.|||Execute the following command −|||If you get following result, then it means you have installed Euphoria successfully; otherwise you have to go back and check all the steps again.|||That is it, Euphoria Programming Environment is ready on your WIN32 machine, and you can start writing complex programs in easy steps.|||Depending on the platform you are using, Euphoria has multiple interpreters −|||The main interpreter is eui.|||On windows platforms, you have two choices. If you run eui then a console window is created. If you run euiw then no console is created, making it suitable for GUI applications.|||Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with .ex extension.|||GUI-based applications have .exw extension and the include files have .e extension.|||The Euphoria language has many similarities to Perl, C, and Java. However, there are some definite differences between the languages. This chapter is designed to quickly get you up to speed on the syntax that is expected in Euphoria.|||This tutorial assumes you are working with Linux and all the examples have been written on Linux platform. But it is observed that there is no any prominent difference in program syntax on Linux and WIN32. Hence you can follow the same steps on WIN32.|||Let us write a simple Euphoria program in a script. Type the following source code in test.ex file and save it.|||Let us say, Euphoria interpreter is available in /home/euphoria-4.0b2/bin/ directory. Now run this program as follows −|||This produces the following result −|||This script used a built-in function puts() which takes two arguments. First argument indicates file name or device number, and second argument indicates a string which you want to print. Here 1 indicates STDOUT device.|||A Euphoria identifier is a name used to identify a variable, function, class, module, or other object. An identifier starts with a letter A to Z or a to z and then followed by letters, digits, or underscores.|||Euphoria does not allow punctuation characters such as @, $, and % within identifiers.|||Euphoria is a case sensitive programming language. Thus Manpower and manpower are two different identifiers in Euphoria. For example, the valid identifiers are −|||The following list shows the reserved words in Euphoria. These reserved words may not be used as constant or variable or any other identifier names. Euphoria keywords contain lowercase letters only.|||Euphoria lets you calculate results by forming expressions. However, in Euphoria you can perform calculations on entire sequences of data with one expression.|||You can handle a sequence much as you would handle a single number. It can be copied, passed to a subroutine, or calculated upon as a unit. For example −|||This is an expression that adds the sequence {1, 2, 3} and the atom 5 to get the resulting sequence {6, 7, 8}. You would learn sequences in subsequent chapters.|||One of the first caveats programmers encounter when learning Euphoria is the fact that there are no braces to indicate blocks of code for procedure and function definitions or flow control. Blocks of code are denoted by associated keywords.|||The following example shows if...then...end if block −|||Statements in Euphoria typically end with a new line. Euphoria does however, allow to write a single statement in multiple lines. For example −|||Escape characters may be entered using a back-slash. For example −|||The following table is a list of escape or non-printable characters that can be represented with backslash notation.|||Any comments are ignored by the compiler and have no effect on execution speed. It is advisable to use more comments in your program to make it more readable.|||There are three forms of comment text −|||Comments start by two dashes and extend to the end of the current line.|||The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.|||You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.|||This produces the following result −|||Note − You can use a special comment beginning with “#!”. This informs the Linux shell that your file should be executed by the Euphoria interpreter.|||Variables are nothing but reserved memory locations to store values. This means when you create a variable, you reserve some space in memory.|||Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables. Euphoria data types are explained in different chapter.|||These memory locations are called variables because their value can be changed during their life time.|||Euphoria variables have to be explicitly declared to reserve memory space. Thus declaration of a variable is mandatory before you assign a value to a variable.|||Variable declarations have a type name followed by a list of the variables being declared. For example −|||When you declare a variable, you name the variable and you define which sort of values may legally be assigned to the variable during execution of your program.|||The simple act of declaring a variable does not assign any value to it. If you attempt to read it before assigning any value to it, Euphoria will issue a run-time error as ""variable xyz has never been assigned a value"".|||The equal sign (=) is used to assign values to variables. Variable can be assigned in the following manner −|||Variable_Name = Variable_Value|||For example −|||Here 100, 1000.0 and ""John"" are the values assigned to counter, miles and name variables, respectively. This program produces the following result −|||To guard against forgetting to initialize a variable, and also because it may make the code clearer to read, you can combine declaration and assignment −|||This is equivalent to the following −|||The scope of an identifier is a description of what code can access it. Code in the same scope of an identifier can access that identifier and code not in the same scope as identifier cannot access it.|||The scope of a variable depends upon where and how it is declared.|||If it is declared within a for, while, loop or switch, its scope starts at the declaration and ends at the respective end statement.|||In an if statement, the scope starts at the declaration and ends either at the next else, elsif or end if statement.|||If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.|||If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.|||The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||The scope of a enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||The scope of all procedures, functions and types, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.|||Constants, enums, module variables, procedures, functions and types, which do not have a scope modifier are referred to as locals. However, these identifiers can have a scope modifier preceding their declaration, which causes their scope to extend beyond the file they are declared in.|||If the keyword global precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.|||If the keyword public precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn public includes the file containing the public declaration.|||If the keyword export precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.|||When you include a Euphoria file in another file, only the identifiers declared using a scope modifier are accessible to the file doing the include. The other declarations in the included file are invisible to the file doing the include.|||Constants are also variables that are assigned an initial value that can never change in the program’s life. Euphoria allows to define constants using constant keyword as follows −|||The result of any expression can be assigned to a constant, even one involving calls to previously defined functions, but once the assignment is made, the value of the constant variable is ""locked in"".|||Constants may not be declared inside a subroutine. The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||This produces the following error −|||If you delete last two lines from the example, then it produces the following result −|||An enumerated value is a special type of constant where the first value defaults to the number 1 and each item after that is incremented by 1. Enums can only take numeric values.|||Enums may not be declared inside a subroutine. The scope of an enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.|||This will produce following result −|||You can change the value of any one item by assigning it a numeric value. Subsequent values are always the previous value plus one, unless they too are assigned a default value.|||This produce the following result −|||Sequences use integer indices, but with enum you may write code like this −|||The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters.|||Euphoria has some standard types that are used to define the operations possible on them and the storage method for each of them.|||Euphoria has following four standard data types −|||The understanding of atoms and sequences is the key to understanding Euphoria.|||Euphoria integer data types store numeric values. They are declared and defined as follows −|||The variables declared with type integer must be atoms with integer values from -1073741824 to +1073741823 inclusive. You can perform exact calculations on larger integer values, up to about 15 decimal digits, but declare them as atom, rather than integer.|||All data objects in Euphoria are either atoms or sequences. An atom is a single numeric value. Atoms can have any integer or double-precision floating point value. Euphoria atoms are declared and defined as follows−|||The atoms can range from approximately -1e300 to +1e300 with 15 decimal digits of accuracy. An individual character is an atom which must may be entered using single quotes. For example, all the following statements are legal −|||A sequence is a collection of numeric values which can be accessed through their index. All data objects in Euphoria are either atoms or sequences.|||Sequence index starts from 1 unlike other programming languages where array index starts from 0. Euphoria sequences are declared and defined as follows −|||A character string is just a sequence of characters which may be entered using double quotes. For example, all the following statements are legal −|||Character strings may be manipulated and operated upon just like any other sequences. For example, the above string is entirely equivalent to the sequence −|||You will learn more about sequence in Euphoria − Sequences.|||This is a super data type in Euphoria which may take on any value including atoms, sequences, or integers. Euphoria objects are declared and defined as follows −|||An object may have one of the following values −|||a sequence|||an atom|||an integer|||an integer used as a file number|||a string sequence, or single-character atom|||Euphoria provides a rich set of operators to manipulate variables. We can divide all the Euphoria operators into the following groups −|||Arithmetic operators are used in mathematical expressions in the same way that they are used in Algebra. The following table lists the arithmetic operators. Assume integer variable A holds 10 and variable B holds 20 then −|||Show Examples|||There are following relational operators supported by Euphoria language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||The following table lists the logical operators. Assume boolean variables A holds 1 and variable B holds 0 then −|||Show Examples|||You can also apply these operators to numbers other than 1 or 0. The convention is: zero means false and non-zero means true.|||There are following assignment operators supported by Euphoria language −|||Show Examples|||Note − The equals symbol '=' used in an assignment statement is not an operator, it is just a part of the syntax.|||There are few other operators supported by Euphoria Language.|||Any two objects may be concatenated using “&” operator. The result is a sequence with a length equal to the sum of the lengths of the concatenated objects.|||For example −|||This produces the following result −|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.|||For example, x = 7 + 3 * 2|||Here, x is assigned 13, not 20 because operator * has higher precedence than +.|||Hence it first starts with 3*2 and then adds into 7.|||Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators is evaluated first.|||Branching is the most important aspect of any programming language. While writing your program, you may encounter a situation when you have to take a decision or you have to select one option out of the given many options.|||Following diagram shows a simple scenario where a program needs to take one of the two paths based on the given condition.|||Euphoria provides following three types of decision making (branching or conditional) statements −|||if statement|||switch statement|||ifdef statement|||Let us see the statements in detail −|||Looping is yet another most important aspect of any programming language. While writing your program, you may encounter a situation when you have to execute same statement many times and sometime may be infinite number of times.|||There are several ways to specify for how long the process should go on, and how to stop or otherwise alter it. An iterative block may be informally called a loop, and each execution of code in a loop is called an iteration of the loop.|||The following diagram shows a simple logical flow of a loop −|||Euphoria provides following three types of loop statements −|||while statement|||loop until statement|||for statement|||All the above statements provide you flexibility and ease of use based on different situations. Let us see them in detail one by one −|||Program execution flow refers to the order in which program statements get executed. By default the statements get executed one after another.|||However; many times the order of execution needs to be altered from the default order, to get the task done.|||Euphoria has a number of flow control statements that you can use to arrange the execution order of statements.|||Exiting a loop is done with the keyword exit. This causes flow to immediately leave the current loop and recommence with the first statement after the end of the loop.|||The syntax of an exit statement is as follows −|||The exit statement terminates the latest and innermost loop until an optional label name or number is specified.|||A special form of exit N is exit 0. This leaves all levels of loop, regardless of the depth. Control continues after the outermost loop block. Likewise, exit -1 exits the second outermost loop, and so on.|||This produces the following result −|||The break statement works exactly like the exit statement, but applies to if statements or switch statements rather than to loop statements of any kind.|||The syntax of break statement is as follows −|||The break statement terminates the latest and innermost if or switch block until an optional label name or number is specified.|||A special form of break N is break 0. This leaves the outer most if or switch block, regardless of the depth. Control continues after the outermost block. Likewise, break -1 breaks the second outermost if or switch block, and so on.|||This produces the following result −|||The continue statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.|||Going to the next iteration means testing a condition variable index and checking whether it is still within bounds.|||The syntax of continue statement is as follows −|||The continue statement would re-iterate the latest and inner most loop until an optional label name or number is specified.|||A special form of continue N is continue 0. This re-iterate the outer most loop, regardless of the depth. Likewise, continue -1 starts from the second outermost loop, and so on.|||The retry statement continues execution of the loop it applies to by going to the next iteration and skipping the rest of an iteration.|||The syntax of retry statement is as follows −|||The retry statement retries executing the current iteration of the loop it applies to. The statement branches to the first statement of the designated loop neither testing anything nor incrementing the for loop index.|||A special form of retry N is retry 0. This retries executing the outer most loop, regardless of the depth. Likewise, retry -1 retries the second outermost loop, and so on.|||Normally, a sub-block which contains a retry statement also contains another flow control keyword like exit, continue, or break. Otherwise, the iteration would be endlessly executed.|||Since retry does not change the value of i and tries again opening the same file, there has to be a way to break from the loop, which the exit statement provides.|||The goto statement instructs the computer to resume code execution at a labeled place.|||The place to resume execution is called the target of the statement. It is restricted to lie in the current routine, or the current file if outside any routine.|||The syntax of goto statement is as follows −|||The target of a goto statement can be any accessible label statement −|||Label names must be double quoted constant strings. Characters that are illegal in Euphoria identifiers may appear in a label name, since it is a regular string.|||This produces the following result −|||When a condition is tested by if, elsif, until, or while using and or or operators, a short-circuit evaluation is used. For example −|||If a < 0 is false, then Euphoria does not bother to test if b is greater than 0. It knows that the overall result is false regardless. Similarly −|||if a < 0 is true, then Euphoria immediately decides that the result true, without testing the value of b, since the result of this test is irrelevant.|||In General, whenever you have a condition of the following form −|||Where A and B can be any two expressions, Euphoria takes a short-cut when A is false and immediately makes the overall result false, without even looking at expression B.|||Similarly, whenever you have a condition of the following form −|||Where A is true, Euphoria skips the evaluation of expression B, and declares the result to be true.|||Short-circuit evaluation of and and or takes place for if, elsif, until, and while conditions only. It is not used in other contexts. For example −|||If short-circuiting were used here, you would set x to 1, and not even look at {1,2,3,4,5}, which would be wrong.|||Thus, short-circuiting can be used in if, elsif, until, or while conditions, because you need to only care if the result is true or false, and conditions are required to produce an atom as a result.|||A sequence is represented by a list of objects in brace brackets { }, separated by commas. A sequence can contain both atoms and other sequences. For example −|||A single element of a sequence may be selected by giving the element number in square brackets. Element numbers start at 1.|||For example, if x contains {5, 7.2, 9, 0.5, 13} then x[2] is 7.2.|||Suppose x[2] contains {11,22,33}, Now if you ask for x[2] you get {11,22,33} and if you ask for x[2][3], you get the atom 33.|||Here, length() is the built-in function which returns length of the sequence. The above example produces the following result −|||A character string is just a sequence of characters. It may be entered in one of the two ways −|||(a) Using Double Quotes −|||(b) Using Raw String Notation −|||You can try the following example to understand the concept −|||This produces the following result −|||An array of strings can be implemented using Sequences as follows −|||This produces the following result −|||A structure can be implemented using Sequences as follows −|||This produces the following result −|||There are various operations which can be performed directly on sequences. Let us see them in detail −|||When applied to a sequence, a unary operator is actually applied to each element in the sequence to yield a sequence of results of the same length.|||This produces the following result −|||Almost all arithmetic operations can be performed on sequences as follows −|||This produces the following result −|||A user can pass command line options to a Euphoria script and it can be accessed as a sequence using command_line() function as follows −|||Here printf() is Euphoria's built-in function. Now if you run this script as follows −|||This produces the following result −|||Euphoria has a library routine that returns the date and time to your program.|||The date() method returns a sequence value composed of eight atom elements. The following example explains it in detail −|||This produces the following result on your standard screen −|||The time() method returns an atom value, representing the number of seconds elapsed since a fixed point in time. The following example explains it in detail −|||This produces the following result −|||Euphoria provides a list of methods which helps you in manipulating date and time. These methods are listed in  Euphoria Library Routines.|||A procedure is a group of reusable code which can be called from anywhere in your program. This eliminates the need of writing same code again and again. This helps programmers to write modular code.|||Like any other advance programming language, Euphoria also supports all the features necessary to write modular code using procedures.|||You must have seen procedures like printf() and length() in previous chapters. We are using these procedure again and again but they have been written in core Euphoria only once.|||Euphoria allows you to write your own procedures as well. This section explains how to write your own procedure in Euphoria.|||Before you use a procedure, you need to define it. The most common way to define a procedure in Euphoria is by using the procedure keyword, followed by a unique procedure name, a list of parameters (that might be empty), and a statement block which ends with end procedure statement. The basic syntax is as shown below −|||A simple procedure called sayHello that takes no parameters is defined here −|||To invoke a procedure somewhere later in the script, you simply need to write the name of that procedure as follows −|||This produces the following result −|||Till now you have seen procedure without a parameter. But there is a facility to pass different parameters while calling a procedure. These passed parameters can be captured inside the procedure and any manipulation can be done over those parameters.|||A procedure can take multiple parameters separated by comma.|||Let us do a bit modification in our sayHello procedure. This time it takes two parameters −|||This produces the following result −|||Euphoria functions are just like procedures, but they return a value, and can be used in an expression. This chapter explains how to write your own functions in Euphoria.|||Before we use a function we need to define it. The most common way to define a function in Euphoria is by using the function keyword, followed by a unique function name, a list of parameters (that might be empty), and a statement block which ends with end function statement. The basic syntax is shown here −|||A simple function called sayHello that takes no parameters is defined here −|||To invoke a function somewhere later in the script, you would simple need to write the name of that function as follows −|||This produces the following result −|||Till now we have seen function without a parameters. But there is a facility to pass different parameters while calling a function. These passed parameters can be captured inside the function and any manipulation can be done over those parameters.|||A function can take multiple parameters separated by comma.|||Let us do a bit modification in our sayHello function. This time it takes two parameters −|||This produces the following result −|||A Euphoria function must have return statement before closing statement end function. Any Euphoria object can be returned. You can, in effect, have multiple return values, by returning a sequence of objects. For example|||If you have nothing to return, then simply return 1 or 0. The return value 1 indicates success and 0 indicates failure|||Using Euphoria programming language, you can write programs that read and change file data on your floppy drive or hard drive, or create new files as a form of output. You can even access devices on your computer such as the printer and modem.|||This chapter described all the basic I/O functions available in Euphoria. For information on more functions, please refer to standard Euphoria documentation.|||The simplest way to produce output is using the puts() statement where you can pass any string to be displayed on the screen. There is another method printf() which can also be used in case you have to format a string using dynamic values.|||These methods convert the expressions you pass them to a string and write the result to standard output as follows −|||This produces the following result on your standard screen −|||Euphoria provides basic methods necessary to manipulate files by default. You can do your most of the file manipulation using the following methods −|||Before you can read or write a file, you have to open it using Euphoria's built-in open()method. This function creates a file descriptor which is utilized to call other supporting methods associated with it.|||Above method returns -1 in case there is an error in opening the given file name. Here are the parameters −|||file_name − The file_name argument is a string value that contains the name of the file that you want to access.|||access_mode − The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table −|||r|||Opens a text file for reading only. The file pointer is placed at the beginning of the file.|||rb|||Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.|||w|||Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||wb|||Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||u|||Opens a file for both reading and writing. The file pointer is set at the beginning of the file.|||ub|||Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.|||a|||Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||ab|||Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||The following example creates a new text file in the current directory on your Linux system −|||If file opens successfully, then it ""myfile.txt"" is created in your current directory and produces the following result −|||The close() method flushes any unwritten information and closes the file, after which no more reading or writing can be done on the file.|||Euphoria automatically closes a file when the reference object of a file is reassigned to another file. It is a good practice to use the close() method to close a file.|||Here the file descriptor received while opening a file is passed as a parameter.|||The following example creates a file as above and then closes it before existing the program −|||This produces the following result −|||Euphoria provides a set of access methods to make our lives easier while reading or writing a file either in text mode or binary mode. Let us see how to use printf() and gets() methods to read and write files.|||The printf() method writes any string to an open file.|||Here are the parameters −|||fn − File descriptor received from open() method.|||st − Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.|||x − If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.|||The following example opens a file and writes the name and age of a person in this file −|||The above example creates myfile.txt file. Is writes given content in that file and finally closes. If you open this file, it would have the following content −|||The gets() method reads a string from an open file.|||Here passed parameter is file description return by the opend() method. This method starts reading from the beginning of the file line by line. The characters have values from 0 to 255. The atom -1 is returned on end of file.|||Let us take a file myfile.txt which is already created.|||This produces the following result −|||Euphoria provides a list of many methods which helps you in manipulating files. These methods are listed in  Euphoria Library Routines.","It is a simple, flexible, powerful language definition that is easy to learn and use.@@@It supports dynamic storage allocation which means variables grow or shrink without the programmer having to worry about allocating and freeing the memory. It takes care of garbage collection automatically.@@@It is extremely faster than conventional interpreters such as Perl and Python.@@@Euphoria programs run under Linux, FreeBSD, 32-bit Windows, and any DOS environment.@@@Euphoria programs are not subject to any 640K memory limitations.@@@It provides an optimizing Euphoria-To-C translator which you can use to translate your Euphoria program into C and then compile it with a C compiler to get an executable (.exe) file. This can boost your program speed by 2 to 5 times.@@@Underlying hardware are completely hidden which means programs are not aware of word-lengths, underlying bit-level representation of values, byte-order etc.@@@Euphoria installation comes along with a full-screen source debugger, an execution profiler, and a full-screen multi-file editor.@@@It supports run-time error-handling, subscript, and type checking.@@@It is an open source language and comes completely free of cost.|||WIN32 version − You need Windows 95 or any later version of Windows. It runs fine on XP and Vista.@@@Linux version − You need any reasonably up-to-date Linux distribution, that has libc6 or later. For example, Red Hat 5.2 or later works fine.@@@FreeBSD version − You need any reasonably up-to-date FreeBSD distribution.@@@Mac OS X version − You need any reasonably up-to-date Intel based Mac.|||Even though Euphoria is simple, fast, and flexible enough for the programmers; it does not provide call support for many important functionalities. For example, network programming.@@@Euphoria was invented in 1993, and still you would not find any book written on this language. There is also not much documentation available for the language.|||Set PATH environment variable to point /home/euphoria-4.0b2/bin directory.@@@Set EUDIR environment variable to point to /home/euphoria-4.0b2.@@@Set EUINC environment variable to point to /home/euphoria-4.0b2/include.|||The main interpreter is eui.@@@On windows platforms, you have two choices. If you run eui then a console window is created. If you run euiw then no console is created, making it suitable for GUI applications.@@@Euphoria does not care about your choice of file extensions. By convention however; the console-based applications come with .ex extension.@@@GUI-based applications have .exw extension and the include files have .e extension.|||n@@@color26@@@ShellSort@@@quick_sort@@@a_very_long_indentifier|||Comments start by two dashes and extend to the end of the current line.@@@The multi-line format comment is kept inside /*...*/, even if that occurs on a different line.@@@You can use a special comment beginning with the two character sequence “#!” only on the first line of the program.|||If it is declared within a for, while, loop or switch, its scope starts at the declaration and ends at the respective end statement.@@@In an if statement, the scope starts at the declaration and ends either at the next else, elsif or end if statement.@@@If a variable is declared within a routine, the scope of the variable starts at the declaration and ends at the routine's end statement. This is knows as a private variable.@@@If a variable is declared outside of a routine, its scope starts at the declaration and ends and the end of the file it is declared in. This is known as a module variable.@@@The scope of a constant that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.@@@The scope of a enum that does not have a scope modifier, starts at the declaration and ends and the end of the file it is declared in.@@@The scope of all procedures, functions and types, which do not have a scope modifier, starts at the beginning of the source file and ends at the end of the source file in which they are declared.|||If the keyword global precedes the declaration, the scope of these identifiers extends to the whole application. They can be accessed by code anywhere in the application files.@@@If the keyword public precedes the declaration, the scope extends to any file that explicitly includes the file in which the identifier is declared, or to any file that includes a file that in turn public includes the file containing the public declaration.@@@If the keyword export precedes the declaration, the scope only extends to any file that directly includes the file in which the identifier is declared.|||integer@@@atom@@@sequence@@@object|||a sequence@@@an atom@@@an integer@@@an integer used as a file number@@@a string sequence, or single-character atom|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Assignment Operators@@@Misc Operators|||if statement@@@switch statement@@@ifdef statement|||while statement@@@loop until statement@@@for statement|||open()@@@close()@@@printf()@@@gets()@@@getc()|||file_name − The file_name argument is a string value that contains the name of the file that you want to access.@@@access_mode − The access_mode determines the mode in which the file has to be opened. For example, read, write append, etc. A complete list of possible values for file opening modes is given in the following table −|||fn − File descriptor received from open() method.@@@st − Format string where decimal or atom is formatted using %d and string or sequence is formatted using %s.@@@x − If x is a sequence, then format specifiers from st are matched with corresponding elements of x. If x is an atom, then normally st contains just one format specifier and it is applied to x. However; if st contains multiple format specifiers, then each one is applied to the same value x.",,"and@@@exit@@@override|||as@@@export@@@procedure|||break@@@fallthru@@@public|||by@@@for@@@retry|||case@@@function@@@return|||constant@@@global@@@routine|||continue@@@goto@@@switch|||do@@@if@@@then|||else@@@ifdef@@@to|||elsedef@@@include@@@type|||elsif@@@label@@@until|||elsifdef@@@loop@@@while|||end@@@namespace@@@with|||entry@@@not@@@without|||enum@@@or@@@xor&&&Backslash notation@@@Description|||\n@@@Newline|||\r@@@Carriage return|||\t@@@Tab|||\\@@@Backslash|||\""@@@Double quote|||\'@@@Single quote&&&Operator@@@Description@@@Example|||+@@@Addition - Adds values on either side of the operator@@@A + B will give 30|||-@@@Subtraction - Subtracts right hand operand from left hand operand@@@A - B will give -10|||*@@@Multiplication - Multiplies values on either side of the operator@@@A * B will give 200|||/@@@Division - Divides left hand operand by right hand operand@@@B / A will give 2|||+@@@Unary plus - This has no impact on the variable value.@@@+B gives 20|||-@@@Unary minus - This creates a negative value of the given variable.@@@-B gives -20&&&Operator@@@Description@@@Example|||=@@@Checks if the value of two operands are equal or not, if yes then condition becomes true.@@@(A = B) is not true.|||!=@@@Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.@@@(A != B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||and@@@Called Logical AND operator. If both the operands are non zero then then condition becomes true.@@@(A and B) is false.|||or@@@Called Logical OR Operator. If any of the two operands are non zero then then condition becomes true.@@@(A or B) is true.|||xor@@@Called Logical XOR Operator. Condition is true if one of them is true, if both operands are true or false then condition becomes false.@@@(A xor B) is true.|||not@@@Called Logical NOT Operator which negates the result. Using this operator, true becomes false and false becomes true@@@not(B) is true.&&&Operator@@@Description@@@Example|||=@@@Simple assignment operator, Assigns values from right side operands to left side operand@@@C = A + B will assigne value of A + B into C|||+=@@@Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand@@@C += A is equivalent to C = C + A|||-=@@@Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand@@@C -= A is equivalent to C = C - A|||*=@@@Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand@@@C *= A is equivalent to C = C * A|||/=@@@Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand@@@C /= A is equivalent to C = C / A|||&=@@@Concatenation operator@@@C &= {2} is same as  C = {C} & {2}&&&Category@@@Operator@@@Associativity|||Postfix@@@function/type calls@@@ |||Unary@@@+ - ! not@@@Right to left|||Multiplicative@@@*  /@@@Left to right|||Additive@@@+  -@@@Left to right|||Concatenation@@@&@@@Left to right|||Relational@@@> >=  < <=@@@Left to right|||Equality@@@=  !=@@@Left to right|||Logical AND@@@and@@@Left to right|||Logical OR@@@or@@@Left to right|||Logical XOR@@@xor@@@Left to right|||Comma@@@,@@@Left to right&&&S.No@@@Modes & Description|||1@@@r
Opens a text file for reading only. The file pointer is placed at the beginning of the file.|||2@@@rb
Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file.|||3@@@w
Opens a text file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||4@@@wb
Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.|||5@@@u
Opens a file for both reading and writing. The file pointer is set at the beginning of the file.|||6@@@ub
Opens a file for both reading and writing in binary format. The file pointer is placed at the beginning of the file.|||7@@@a
Opens a file for appending. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.|||8@@@ab
Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists (append mode). If the file does not exist, it creates a new file for writing.","#!/home/euphoria-4.0b2/bin/euiputs(1, ""Hello, Euphoria!\n"")|||$ chmod +x test.ex    # This is to make file executable$ ./test.ex|||if condition then   code block comes hereend if|||total = item_one +    item_two +    item_three|||#!/home/euphoria-4.0b2/bin/eui-- First commentputs(1, ""Hello, Euphoria!\n"") -- second comment/* This is a comment which extends over a number   of text lines and has no impact on the program*/|||#!/home/euphoria/bin/eui-- Here is the declaration of the variables.integer counterinteger milessequence namecounter = 100 -- An integer assignmentmiles = 1000.0 -- A floating pointname = ""John"" -- A string ( sequence )printf(1, ""Value of counter %d\n"", counter )printf(1, ""Value of miles %f\n"", miles )printf(1, ""Value of name %s\n"", {name} )|||constant MAX = 100constant Upper = MAX - 10, Lower = 5constant name_list = {""Fred"", ""George"", ""Larry""}|||#!/home/euphoria-4.0b2/bin/euiconstant MAX = 100constant Upper = MAX - 10, Lower = 5printf(1, ""Value of MAX %d\n"", MAX )printf(1, ""Value of Upper %d\n"", Upper )printf(1, ""Value of Lower %d\n"", Lower )MAX = MAX + 1printf(1, ""Value of MAX %d\n"", MAX )|||#!/home/euphoria-4.0b2/bin/euienum ONE, TWO, THREE, FOURprintf(1, ""Value of ONE %d\n"", ONE )printf(1, ""Value of TWO %d\n"", TWO )printf(1, ""Value of THREE %d\n"", THREE )printf(1, ""Value of FOUR %d\n"", FOUR )|||#!/home/euphoria-4.0b2/bin/euienum ONE, TWO, THREE, ABC=10, XYZprintf(1, ""Value of ONE %d\n"", ONE )printf(1, ""Value of TWO %d\n"", TWO )printf(1, ""Value of THREE %d\n"", THREE )printf(1, ""Value of ABC %d\n"", ABC )printf(1, ""Value of XYZ %d\n"", XYZ )|||enum X, Ysequence point = { 0,0 }point[X] = 3point[Y] = 4|||integer var1, var2var1 = 1var2 = 100|||atom var1, var2, var3var1 = 1000var2 = 198.6121324234var3 = 'E'       |||sequence var1, var2, var3, var4var1 = {2, 3, 5, 7, 11, 13, 17, 19}var2 = {1, 2, {3, 3, 3}, 4, {5, {6}}}var3 = {{""zara"", ""ali""}, 52389, 97.25}     var4 = {} -- the 0 element sequence|||word = 'word'sentence = ""ABCDEFG""|||sentence = {65, 66, 67, 68, 69, 70, 71}|||object var1, var2, var3var1 = {2, 3, 5, 7, 11, 13, 17, 19}var2 = 100var3 = 'E'     |||#!/home/euphoria-4.0b2/bin/euisequence a, b, ca = {1, 2, 3}b = {4}c = {1, 2, 3} & {4}printf(1, ""Value of c[1] %d\n"", c[1] )printf(1, ""Value of c[2] %d\n"", c[2] )printf(1, ""Value of c[3] %d\n"", c[3] )printf(1, ""Value of c[4] %d\n"", c[4] )|||#!/home/euphoria-4.0b2/bin/euiinteger bfor a = 1 to 16 do   printf(1, ""value of a %d\n"", a)      if a = 10 then      b = a      exit   end ifend forprintf(1, ""value of b %d\n"", b)|||#!/home/euphoria-4.0b2/bin/euiinteger a, bsequence s = {'E','u', 'p'}if s[1] = 'E' then   a = 3      if s[2] = 'u' then      b = 1      if s[3] = 'p' then         break 0 -- leave topmost if block      end if      a = 2   else      b = 4   end ifelse   a = 0   b = 0end ifprintf(1, ""value of a %d\n"", a)printf(1, ""value of b %d\n"", b)|||#!/home/euphoria-4.0b2/bin/euifor a = 3 to 6 do   printf(1, ""value of a %d\n"", a)   if a = 4 then      puts(1,""(2)\n"")      continue   end if   printf(1, ""value of a %d\n"", a*a)end forThis would produce following result:value of a 3value of a 9value of a 4(2)value of a 5value of a 25value of a 6value of a 36|||#!/home/euphoria-4.0b2/bin/euiinteger errors = 0integer files_to_open = 10for i = 1 to length(files_to_open) do   fh = open(files_to_open[i], ""rb"")      if fh = -1 then      if errors > 5 then         exit      else         errors += 1         retry      end if   end if   file_handles[i] = fhend for|||label ""Label Name""|||#!/home/euphoria-4.0b2/bin/euiinteger a = 0label ""FIRST""printf(1, ""value of a %d\n"", a)a += 10if a < 50 then   goto ""FIRST""end if printf(1, ""Final value of a %d\n"", a)|||if a < 0 and b > 0 then   -- block of codeend if|||if a < 0 or b > 0 then   -- block of codeend if|||x = 1 or {1,2,3,4,5} -- x should be set to {1,1,1,1,1}|||#!/home/euphoria-4.0b2/bin/euisequence xx = {1, 2, 3, 4}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %d\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence xx = ""ABCD""for a = 1 to length(x) do   printf(1, ""value of x[%d] = %s\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence x = {""Hello"", ""World"", ""Euphoria"", """", ""Last One""}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %s\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence employee = {   {""John"",""Smith""},      45000,      27,      185.5}printf(1, ""First Name = %s, Last Name = %s\n"", {employee[1][1],employee[1][2]} )|||#!/home/euphoria-4.0b2/bin/euisequence xx = -{1, 2, 3, 4}for a = 1 to length(x) do   printf(1, ""value of x[%d] = %d\n"", {a, x[a]})end for|||#!/home/euphoria-4.0b2/bin/euisequence x, y, a, b, cx = {1, 2, 3}y = {10, 20, 30}a = x + yputs(1, ""Value of a = {"")for i = 1 to length(a) do   printf(1, ""%d,"", a[i])end forputs(1, ""}\n"")b = x - yputs(1, ""Value of b = {"")for i = 1 to length(a) do   printf(1, ""%d,"", b[i])end forputs(1, ""}\n"")c = x * 3puts(1, ""Value of c = {"")for i = 1 to length(c) do   printf(1, ""%d,"", c[i])end forputs(1, ""}\n"")|||#!/home/euphoria-4.0b2/bin/euisequence xx = command_line()printf(1, ""Interpeter Name: %s\n"", {x[1]} )printf(1, ""Script Name: %s\n"", {x[2]} )printf(1, ""First Argument: %s\n"", {x[3]})printf(1, ""Second Argument: %s\n"", {x[4]})|||#!/home/euphoria-4.0b2/bin/eui integer curr_year, curr_day, curr_day_of_year, curr_hour, curr_minute, curr_secondsequence system_date, word_week, word_month, notation,    curr_day_of_week, curr_month   word_week = {""Sunday"",       ""Monday"",       ""Tuesday"",       ""Wednesday"",       ""Thursday"",       ""Friday"",       ""Saturday""}   word_month = {""January"", ""February"",       ""March"",       ""April"",       ""May"",       ""June"",       ""July"",       ""August"",       ""September"",       ""October"",       ""November"",       ""December""}-- Get current system date.system_date = date()-- Now take individual elementscurr_year = system_date[1] + 1900curr_month = word_month[system_date[2]]curr_day = system_date[3]curr_hour = system_date[4]curr_minute = system_date[5]curr_second = system_date[6]curr_day_of_week = word_week[system_date[7]]curr_day_of_year = system_date[8]if curr_hour >= 12 then    notation = ""p.m.""else    notation = ""a.m.""end ifif curr_hour > 12 then    curr_hour = curr_hour - 12end ifif curr_hour = 0 then    curr_hour = 12end ifputs(1, ""\nHello Euphoria!\n\n"")printf(1, ""Today is %s, %s %d, %d.\n"", {curr_day_of_week,    curr_month, curr_day, curr_year})printf(1, ""The time is %.2d:%.2d:%.2d %s\n"", {curr_hour,    curr_minute, curr_second, notation})printf(1, ""It is %3d days into the current year.\n"", {curr_day_of_year})|||#!/home/euphoria-4.0b2/bin/eui constant ITERATIONS = 100000000integer patom t0, t1, loop_overheadt0 = time()for i = 1 to ITERATIONS do   -- time an empty loopend forloop_overhead = time() - t0printf(1, ""Loop overhead:%d\n"", loop_overhead)t0 = time()for i = 1 to ITERATIONS do    p = power(2, 20)end fort1 = (time() - (t0 + loop_overhead))/ITERATIONSprintf(1, ""Time (in seconds) for one call to power:%d\n"", t1)|||procedure  sayHello()   puts(1, ""Hello there"")end procedure|||#!/home/euphoria-4.0b2/bin/euiprocedure  sayHello()   puts(1, ""Hello there"")end procedure -- Call above defined procedure.sayHello()|||#!/home/euphoria-4.0b2/bin/euiprocedure sayHello(sequence name,atom  age)   printf(1, ""%s is %d years old."", {name, age})end procedure-- Call above defined procedure.sayHello(""zara"", 8)|||function functionname(parameter-list)   statements   ..........   return [Euphoria Object]end function|||function sayHello()   puts(1, ""Hello there"")   return 1end function|||#!/home/euphoria-4.0b2/bin/euifunction sayHello()   puts(1, ""Hello there"")   return 1end function-- Call above defined function.sayHello()|||#!/home/euphoria-4.0b2/bin/euifunction sayHello(sequence name,atom  age)   printf(1, ""%s is %d years old."", {name, age})   return 1end function-- Call above defined function.sayHello(""zara"", 8)|||return {x_pos, y_pos}|||#!/home/euphoria-4.0b2/bin/eui puts(1, ""Euphoria is really a great language, isn't it?"" )|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile,txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifif file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""w"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifprintf(file_num, ""My name is %s and age is %d\n"", {""Zara"", 8})if file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if|||#!/home/euphoria-4.0b2/bin/euiinteger file_numobject lineconstant ERROR = 2constant STDOUT = 1file_num = open(""myfile.txt"", ""r"")if file_num = -1 then   puts(ERROR, ""couldn't open myfile\n"")else   puts(STDOUT, ""File opend successfully\n"")end ifline = gets(file_num)printf( STDOUT, ""Read content : %s\n"", {line})if file_num = -1 then   puts(ERROR, ""No need to close the file\n"")else   close( file_num )   puts(STDOUT, ""File closed successfully\n"")end if"
Learn Euphoria,Euphoria - Library Routines,Euphoria - Library Routines|||Predefined Types@@@Sequence Manipulation@@@Searching and Sorting@@@Pattern Matching@@@Math@@@Bitwise Logical Operations@@@File and Device I/O@@@Mouse Support (DOS32 and Linux)@@@Operating System@@@Special Machine-Dependent Routines@@@Debugging@@@Graphics & Sound@@@Multitasking,"A large number of library routines are provided. Some are built right into the interpreter, ex.exe, exw.exe or exu. Others are written in Euphoria and you must include one of the .e files in euphoria\include directory to use them.|||To indicate what kind of object may be passed in and returned, the following prefixes are used −|||x|||a general object (atom or sequence)|||s|||a sequence|||a|||an atom|||i|||an integer|||fn|||an integer used as a file number|||st|||a string sequence, or single-character atom|||As well as declaring variables with these types, you can also call them just like ordinary functions, in order to test if a value is a certain type.|||These routines can be applied to individual atoms or to sequences of values.|||These routines treat numbers as collections of binary bits, and logical operations are performed on corresponding  bits in the binary representation of the numbers.|||There are no routines for shifting bits left or right, but you can  achieve the same effect by multiplying or dividing by powers of 2.|||To do input or output on a file or device you must first open the file or device, then use the routines below to read or write to it, then close the file or device. open() will give you  a file number to use as the first argument of the other I/O routines. Certain files/devices are opened for you automatically (as text files) −|||On Windows XP, if you want the DOS mouse to work in a (non-full-screen) window, you must disable QuickEdit mode in the Properties for the DOS Window.|||The following routines let you display information on the screen. In DOS, the PC screen can be placed into one of many graphics modes.|||The following routines work in all text and pixel-graphics modes.|||The following routines work in text in modes only|||The following routines work in pixel-graphics modes only (DOS32)",0 - standard input@@@1 - standard output@@@2 - standard error,,"S.No@@@Prefix & Description|||1@@@x
a general object (atom or sequence)|||2@@@s
a sequence|||3@@@a
an atom|||4@@@i
an integer|||5@@@fn
an integer used as a file number|||6@@@st
a string sequence, or single-character atom&&&integer@@@−@@@test if an object is an integer|||atom@@@−@@@test if an object is an atom|||sequence@@@−@@@test if an object is a sequence|||object@@@−@@@test if an object is an object (always true)&&&length@@@−@@@return the length of a sequence|||repeat@@@−@@@repeat an object n times to form a sequence of length n|||reverse@@@−@@@reverse a sequence|||append@@@−@@@add a new element to the end of a sequence|||prepend@@@−@@@add a new element to the beginning of a sequence&&&compare@@@−@@@compare two objects|||equal@@@−@@@test if two objects are identical|||find@@@−@@@find an object in a sequence - start searching from element number 1|||find_from@@@−@@@find an object in a sequence - start searching from any element number|||match@@@−@@@find a sequence as a slice of another sequence - start searching from element number 1|||match_from@@@−@@@find a sequence as a slice of another sequence - start searching from any element number|||sort@@@−@@@sort the elements of a sequence into ascending order|||custom_sort@@@−@@@sort the elements of a sequence based on a compare function that you supply&&&lower@@@−@@@convert an atom or sequence to lower case|||upper@@@−@@@convert an atom or sequence to upper case|||wildcard_match@@@−@@@match a pattern containing ? and * wildcards|||wildcard_file@@@−@@@match a file name against a wildcard specification&&&sqrt@@@−@@@calculate the square root of an object|||rand@@@−@@@generate random numbers|||sin@@@−@@@calculate the sine of an angle|||arcsin@@@−@@@calculate the angle with a given sine|||cos@@@−@@@calculate the cosine of an angle|||arccos@@@−@@@calculate the angle with a given cosine|||tan@@@−@@@calculate the tangent of an angle|||arctan@@@−@@@calculate the arc tangent of a number|||log@@@−@@@calculate the natural logarithm|||floor@@@−@@@round down to the nearest integer|||remainder@@@−@@@calculate the remainder when a number is divided by another|||power@@@−@@@calculate a number raised to a power|||PI@@@−@@@the mathematical value PI (3.14159...)&&&and_bits@@@−@@@perform logical AND on corresponding bits|||or_bits@@@−@@@perform logical OR on corresponding bits|||xor_bits@@@−@@@perform logical XOR on corresponding bits|||not_bits@@@−@@@perform logical NOT on all bits&&&open@@@−@@@open a file or device|||close@@@−@@@close a file or device|||flush@@@−@@@flush out buffered data to a file or device|||lock_file@@@−@@@lock a file or device|||unlock_file@@@−@@@unlock a file or device|||print@@@−@@@print a Euphoria object on one line, with braces and commas {,,} to show the structure|||pretty_print@@@−@@@print a Euphoria object in a nice readable form, using multiple lines and appropriate indentation|||? x@@@−@@@shorthand for print(1, x)|||sprint@@@−@@@return a printed Euphoria object as a string sequence|||printf@@@−@@@formatted print to a file or device|||sprintf@@@−@@@formatted print returned as a string sequence|||puts@@@−@@@output a string sequence to a file or device|||getc@@@−@@@read the next character from a file or device|||gets@@@−@@@read the next line from a file or device|||get_bytes@@@−@@@read the next n bytes from a file or device|||prompt_string@@@−@@@prompt the user to enter a string|||get_key@@@−@@@check for key pressed by the user, don't wait|||wait_key@@@−@@@wait for user to press a key|||get@@@−@@@read the representation of any Euphoria object from a file|||prompt_number@@@−@@@prompt the user to enter a number|||value@@@−@@@read the representation of any Euphoria object from a string|||seek@@@−@@@move to any byte position within an open file|||where@@@−@@@report the current byte position in an open file|||current_dir
@@@−@@@return the name of the current directory|||chdir@@@−@@@change to a new current directory|||dir@@@−@@@return complete info on all files in a directory|||walk_dir@@@−@@@recursively walk through all files in a directory|||allow_break@@@−@@@allow control-c/control-Break to terminate your program or not|||check_break@@@−@@@check if user has pressed control-c or control-Break&&&get_mouse@@@−@@@return mouse ""events"" (clicks, movements)|||mouse_events@@@−@@@select mouse events to watch for|||mouse_pointer@@@−@@@display or hide the mouse pointer&&&time@@@−@@@number of seconds since a fixed point in the past|||tick_rate@@@−@@@set the number of clock ticks per second (DOS32)|||date@@@−@@@current year, month, day, hour, minute, second etc.|||command_line@@@−@@@command-line used to run this program|||getenv@@@−@@@get value of an environment variable|||system@@@−@@@execute an operating system command line|||system_exec@@@−@@@execute a program and get its exit code|||abort@@@−@@@terminate execution|||sleep
@@@−@@@suspend execution for a period of time|||platform@@@−@@@find out which operating system are we running on&&&machine_func@@@−@@@specialized internal operations with a return value|||machine_proc@@@−@@@specialized internal operations with no return value&&&trace@@@−@@@dynamically turns tracing on or off|||profile@@@−@@@dynamically turns profiling on or off&&&clear_screen@@@−@@@clear the screen|||position@@@−@@@set cursor line and column|||get_position@@@−@@@return cursor line and column|||graphics_mode@@@−@@@select a new pixel-graphics or text mode (DOS32)|||video_config@@@−@@@return parameters of current mode|||scroll@@@−@@@scroll text up or down|||wrap@@@−@@@control line wrap at right edge of screen|||text_color@@@−@@@set foreground text color|||bk_color@@@−@@@set background color|||palette@@@−@@@change color for one color number (DOS32)|||all_palette@@@−@@@change color for all color numbers (DOS32)|||get_all_palette@@@−@@@get the palette values for all colors (DOS32)|||read_bitmap@@@−@@@read a bitmap (.bmp) file and return a palette and a 2-d sequence of pixels|||save_bitmap@@@−@@@create a bitmap (.bmp) file, given a palette and a 2-d sequence of pixels|||get_active_page@@@−@@@return the page currently being written to (DOS32)|||set_active_page@@@−@@@change the page currently being written to (DOS32)|||get_display_page@@@−@@@return the page currently being displayed (DOS32)|||set_display_page@@@−@@@change the page currently being displayed (DOS32)|||sound@@@−@@@make a sound on the PC speaker (DOS32)&&&cursor@@@−@@@select cursor shape|||text_rows@@@−@@@set number of lines on text screen|||get_screen_char@@@−@@@get one character from the screen|||put_screen_char@@@−@@@put one or more characters on the screen|||save_text_image@@@−@@@save a rectangular region from a text screen|||display_text_image@@@−@@@display an image on the text screen&&&pixel@@@−@@@set color of a pixel or set of pixels|||get_pixel@@@−@@@read color of a pixel or set of pixels|||draw_line@@@−@@@connect a series of graphics points with a line|||polygon@@@−@@@draw an n-sided figure|||ellipse@@@−@@@draw an ellipse or circle|||save_screen@@@−@@@save the screen to a bitmap (.bmp) file|||save_image@@@−@@@save a rectangular region from a pixel-graphics screen|||display_image@@@−@@@display an image on the pixel-graphics screen&&&task_clock_start@@@−@@@restart the scheduler's clock|||task_clock_stop@@@−@@@stop the scheduler's clock|||task_create@@@−@@@create a new task|||task_list@@@−@@@get a list of all tasks|||task_schedule@@@−@@@schedule a task for execution|||task_self@@@−@@@return the task id of the current task|||task_status@@@−@@@the current status (active, suspended, terminated) of a task|||task_suspend@@@−@@@Suspend a task.|||task_yield@@@−@@@Yield control, so the scheduler can pick a new task to run.",
Learn Euphoria,Euphoria - Useful Resources,Euphoria - Useful Resources|||Useful Links on Euphoria@@@Useful Books on Euphoria,"The following resources contain additional information on Euphoria. Please use them to get more in-depth knowledge on this topic.|||Euphoria − Official website for Euphoria. Learn about the Euphoria language and discover the latest happenings in Euphoria arena.|||Euphoria Download page − Download latest version of Euphoria from sourceforge.|||Euphoria @ Wiki − Euphoria at Wikipedia, the free encyclopedia|||OpenEuphoria.org − Latest news about Euphoria, Community and much more....|||To enlist your site on this page, please drop an email to contact@tutorialspoint.com","Euphoria − Official website for Euphoria. Learn about the Euphoria language and discover the latest happenings in Euphoria arena.@@@Euphoria Download page − Download latest version of Euphoria from sourceforge.@@@Euphoria @ Wiki − Euphoria at Wikipedia, the free encyclopedia@@@OpenEuphoria.org − Latest news about Euphoria, Community and much more....",,,
Learn Euphoria,Discuss Euphoria,Discuss Euphoria,"This tutorial gives you basic understanding of Euphoria programming language. Euphoria is simple, flexible, easy to learn, and interpreted high-level programming language for DOS, Windows, Linux, FreeBSD, and more. This tutorial describes everything a programmer needs to know such as its environment, data types, syntax and operators, file handling, and controlling the flow of program.",,,,
