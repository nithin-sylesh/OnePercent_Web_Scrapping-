Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Lua,Lua Tutorial,Lua Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,Lua is an open source language built on top of C programming language. Lua has its value across multiple platforms ranging from large server systems to small mobile applications. This tutorial covers various topics ranging from the basics of Lua to its scope in various applications.|||This tutorial is designed for all those readers who are looking for a starting point to learn Lua. It has topics suitable for both beginners as well as advanced users.|||It is a self-contained tutorial and you should be able to grasp the concepts easily even if you are a total beginner. However it would help if you have a basic understanding of working with a simple text editor and command line.,,,,
Learn Lua,Lua - Overview,Lua - Overview|||Features@@@How Lua is Implemented?@@@Learning Lua@@@Some Uses of Lua@@@Useful Video Courses|||Example Code|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua is an extensible, lightweight programming language written in C. It started as an in-house project in 1993 by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes.|||It was designed from the beginning to be a software that can be integrated with the code written in C and other conventional languages. This integration brings many benefits. It does not try to do what C can already do but aims at offering what C is not good at: a good distance from the hardware, dynamic structures, no redundancies, ease of testing and debugging. For this, Lua has a safe environment, automatic memory management, and good facilities for handling strings and other kinds of data with dynamic size.|||Lua provides a set of unique features that makes it distinct from other languages. These include −|||Lua consists of two parts - the Lua interpreter part and the functioning software system. The functioning software system is an actual computer application that can interpret programs written in the Lua programming language. The Lua interpreter is written in ANSI C, hence it is highly portable and can run on a vast spectrum of devices from high-end network servers to small devices.|||Both Lua's language and its interpreter are mature, small, and fast. It has evolved from other programming languages and top software standards. Being small in size makes it possible for it to run on small devices with low memory.|||The most important point while learning Lua is to focus on the concepts without getting lost in its technical details.|||The purpose of learning a programming language is to become a better programmer; that is, to become more effective in designing and implementing new systems and at maintaining old ones.|||Game Programming|||Scripting in Standalone Applications|||Scripting in Web|||Extensions and add-ons for databases like MySQL Proxy and MySQL WorkBench|||Security systems like Intrusion Detection System.",Extensible@@@Simple@@@Efficient@@@Portable@@@Free and open|||Game Programming@@@Scripting in Standalone Applications@@@Scripting in Web@@@Extensions and add-ons for databases like MySQL Proxy and MySQL WorkBench@@@Security systems like Intrusion Detection System.,,,"print(""Hello World!"")"
Learn Lua,Lua - Environment,Lua - Environment|||Local Environment Setup@@@Text Editor@@@The Lua Interpreter@@@The Lua Compiler@@@Installation on Windows@@@Installation on Linux@@@Installation on Mac OS X@@@Lua IDE@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"If you are still willing to set up your environment for Lua programming language, you need the following softwares available on your computer - (a) Text Editor, (b) The Lua Interpreter, and (c) Lua Compiler.|||You need a text editor to type your program. Examples of a few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.|||The files you create with your editor are called source files and these files contain the program source code. The source files for Lua programs are typically named with the extension "".lua"".|||It is just a small program that enables you to type Lua commands and have them executed immediately. It stops the execution of a Lua file in case it encounters an error unlike a compiler that executes fully.|||When we extend Lua to other languages/applications, we need a Software Development Kit with a compiler that is compatible with the Lua Application Program Interface.|||There is a separate IDE named ""SciTE"" developed for the windows environment, which can be downloaded from https://code.google.com/p/luaforwindows/ download section.|||Run the downloaded executable to install the Lua IDE.|||Since it’s an IDE, you can both create and build the Lua code using the same.|||In case, you are interested in installing Lua in command line mode, you need to install MinGW or Cygwin and then compile and install Lua in windows.|||To download and build Lua, use the following command −|||In order to install on other platforms like aix, ansi, bsd, generic linux, mingw, posix, solaris by replacing Linux in make Linux, test with the corresponding platform name.|||We have a helloWorld.lua, in Lua as follows −|||Now, we can build and run a Lua file say helloWorld.lua, by switching to the folder containing the file using cd, and then using the following command −|||We can see the following output.|||To build/test Lua in the Mac OS X, use the following command −|||In certain cases, you may not have installed the Xcode and command line tools. In such cases, you won’t be able to use the make command. Install Xcode from mac app store. Then go to Preferences of Xcode, and then switch to Downloads and install the component named ""Command Line Tools"". Once the process is completed, make command will be available to you.|||It is not mandatory for you to execute the ""make macosx test"" statement. Even without executing this command, you can still use Lua in Mac OS X.|||We have a helloWorld.lua, in Lua, as follows −|||Now, we can build and run a Lua file say helloWorld.lua by switching to the folder containing the file using cd and then using the following command −|||We can see the following output −|||As mentioned earlier, for Windows SciTE, Lua IDE is the default IDE provided by the Lua creator team. The alternate IDE available is from ZeroBrane Studio, which is available across multiple platforms like Windows, Mac and Linux.|||There are also plugins for eclipse that enable the Lua development. Using IDE makes it easier for development with features like code completion and is highly recommended. The IDE also provides interactive mode programming similar to the command line version of Lua.",,,,"print(""Hello World!"")|||print(""Hello World!"")"
Learn Lua,Lua - Basic Syntax,Lua - Basic Syntax|||First Lua Program@@@Tokens in Lua@@@Comments@@@Identifiers@@@Keywords@@@Whitespace in Lua@@@Useful Video Courses|||Interactive Mode Programming@@@Default Mode Programming|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Let us start creating our first Lua program!|||Lua provides a mode called interactive mode. In this mode, you can type in instructions one after the other and get instant results. This can be invoked in the shell by using the lua -i or just the lua command. Once you type in this, press Enter and the interactive mode will be started as shown below.|||You can print something using the following statement −|||Once you press enter, you will get the following output −|||Invoking the interpreter with a Lua file name parameter begins execution of the file and continues until the script is finished. When the script is finished, the interpreter is no longer active.|||Let us write a simple Lua program. All Lua files will have extension .lua. So put the following source code in a test.lua file.|||Assuming, lua environment is setup correctly, let’s run the program using the following code −|||We will get the following output −|||Let's try another way to execute a Lua program. Below is the modified test.lua file −|||Here, we have assumed that you have Lua interpreter available in your /usr/local/bin directory. The first line is ignored by the interpreter, if it starts with # sign. Now, try to run this program as follows −|||We will get the following output.|||Let us now see the basic structure of Lua program, so that it will be easy for you to understand the basic building blocks of the Lua programming language.|||A Lua program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Lua statement consists of three tokens −|||The individual tokens are −|||Comments are like helping text in your Lua program and they are ignored by the interpreter. They start with --[[ and terminates with the characters --]] as shown below −|||A Lua identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter ‘A to Z’ or ‘a to z’ or an underscore ‘_’ followed by zero or more letters, underscores, and digits (0 to 9).|||Lua does not allow punctuation characters such as @, $, and % within identifiers. Lua is a case sensitive programming language. Thus Manpower and manpower are two different identifiers in Lua. Here are some examples of the acceptable identifiers −|||The following list shows few of the reserved words in Lua. These reserved words may not be used as constants or variables or any other identifier names.|||A line containing only whitespace, possibly with a comment, is known as a blank line, and a Lua interpreter totally ignores it.|||Whitespace is the term used in Lua to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the interpreter to identify where one element in a statement, such as int ends, and the next element begins. Therefore, in the following statement −|||There must be at least one whitespace character (usually a space) between local and age for the interpreter to be able to distinguish them. On the other hand, in the following statement −|||No whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.",,,and@@@break@@@do@@@else|||elseif@@@end@@@false@@@for|||function@@@if@@@in@@@local|||nil@@@not@@@or@@@repeat|||return@@@then@@@true@@@until|||while@@@@@@@@@,"print(""test"")|||print(""test"")|||#!/usr/local/bin/luaprint(""test"")"
Learn Lua,Lua - Variables,Lua - Variables|||Variable Definition in Lua@@@Variable Declaration in Lua@@@Lvalues and Rvalues in Lua@@@Useful Video Courses|||Example|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"A variable is nothing but a name given to a storage area that our programs can manipulate. It can hold different types of values including functions and tables.|||The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Lua is case-sensitive. There are eight basic types of values in Lua −|||In Lua, though we don't have variable data types, we have three types based on the scope of the variable.|||Global variables − All variables are considered global unless explicitly declared as a local.|||Local variables − When the type is specified as local for a variable then its scope is limited with the functions inside their scope.|||Table fields − This is a special type of variable that can hold anything except nil including functions.|||A variable definition means to tell the interpreter where and how much to create the storage for the variable. A variable definition have an optional type and contains a list of one or more variables of that type as follows −|||Here, type is optionally local or type specified making it global, and variable_list may consist of one or more identifier names separated by commas. Some valid declarations are shown here −|||The line local  i, j both declares and defines the variables i and j; which instructs the interpreter to create variables named i, j and limits the scope to be local.|||Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows −|||Some examples are −|||For definition without an initializer: variables with static storage duration are implicitly initialized with nil.|||As you can see in the above examples, assignments for multiples variables follows a variable_list and value_list format. In the above example local d, f = 5,10 we have d and f in variable_list and 5 and 10 in values list.|||Value assigning in Lua takes place like first variable in the variable_list with first value in the value_list and so on. Hence, the value of d is 5 and the value of f is 10.|||Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function −|||When the above code is built and executed, it produces the following result −|||There are two kinds of expressions in Lua −|||lvalue − Expressions that refer to a memory location is called ""lvalue"" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.|||rvalue − The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it, which means an rvalue may appear on the right-hand side, but not on the left-hand side of an assignment.|||Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and cannot appear on the left-hand side. Following is a valid statement −|||But following is not a valid statement and would generate a build-time error −|||In Lua programming language, apart from the above types of assignment, it is possible to have multiple lvalues and rvalues in the same single statement. It is shown below.|||In the above statement, 20 is assigned to g and 30 is assigned to l.","Global variables − All variables are considered global unless explicitly declared as a local.@@@Local variables − When the type is specified as local for a variable then its scope is limited with the functions inside their scope.@@@Table fields − This is a special type of variable that can hold anything except nil including functions.|||lvalue − Expressions that refer to a memory location is called ""lvalue"" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.@@@rvalue − The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it, which means an rvalue may appear on the right-hand side, but not on the left-hand side of an assignment.",,,"-- Variable definition:local a, b-- Initializationa = 10b = 30print(""value of a:"", a)print(""value of b:"", b)-- Swapping of variablesb, a = a, bprint(""value of a:"", a)print(""value of b:"", b)f = 70.0/3.0print(""value of f"", f)"
Learn Lua,Lua - Data Types,Lua - Data Types|||Type Function@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua is a dynamically typed language, so the variables don't have types, only the values have types. Values can be stored in variables, passed as parameters and returned as results.|||In Lua, though we don't have variable data types, but we have types for the values. The list of data types for values are given below.|||nil|||Used to differentiate the value from having some data or no(nil) data.|||boolean|||Includes true and false as values. Generally used for condition checking.|||number|||Represents real(double precision floating point) numbers.|||string|||Represents array of characters.|||function|||Represents a method that is written in C or Lua.|||userdata|||Represents arbitrary C data.|||thread|||Represents independent threads of execution and it is used to implement coroutines.|||table|||Represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc., and implements associative arrays. It can hold any value (except nil).|||In Lua, there is a function called ‘type’ that enables us to know the type of the variable. Some examples are given in the following code.|||When you build and execute the above program, it produces the following result on Linux −|||By default, all the variables will point to nil until they are assigned a value or initialized. In Lua, zero and empty strings are considered to be true in case of condition checks. Hence, you have to be careful when using Boolean operations. We will know more using these types in the next chapters.",,,"Sr.No@@@Value Type & Description|||1@@@nil
Used to differentiate the value from having some data or no(nil) data.|||2@@@boolean
Includes true and false as values. Generally used for condition checking.|||3@@@number
Represents real(double precision floating point) numbers.|||4@@@string
Represents array of characters.|||5@@@function
Represents a method that is written in C or Lua.|||6@@@userdata
Represents arbitrary C data.|||7@@@thread
Represents independent threads of execution and it is used to implement coroutines.|||8@@@table
Represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc., and implements associative arrays. It can hold any value (except nil).","print(type(""What is my type""))   --> stringt = 10print(type(5.8*t))               --> numberprint(type(true))                --> booleanprint(type(print))               --> functionprint(type(nil))                 --> nilprint(type(type(ABC)))           --> string"
Learn Lua,Lua - Operators,Lua - Operators|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Misc Operators@@@Operators Precedence in Lua@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"An operator is a symbol that tells the interpreter to perform specific mathematical or logical manipulations. Lua language is rich in built-in operators and provides the following type of operators −|||This tutorial will explain the arithmetic, relational, logical, and other miscellaneous operators one by one.|||Following table shows all the arithmetic operators supported by Lua language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||Following table shows all the relational operators supported by Lua language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||Following table shows all the logical operators supported by Lua language. Assume variable A holds true and variable B holds false then −|||Show Examples|||Miscellaneous operators supported by Lua Language include concatenation and length.|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator −|||For example, x = 7 + 3 * 2;  Here  x is assigned 13, not 20 because operator * has higher precedence than + so it first get multiplied with 3*2 and then adds into 7.|||Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.|||Show Examples",Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Misc Operators,,"Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiply both operands@@@A * B will give 200|||/@@@Divide numerator by de-numerator@@@B / A will give 2|||%@@@Modulus Operator and remainder of after an integer division@@@B % A will give 0|||^@@@Exponent Operator takes the exponents@@@A^2 will give 100|||-@@@Unary - operator acts as negation@@@-A will give -10&&&Operator@@@Description@@@Example|||==@@@Checks if the value of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||~=@@@Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.@@@(A ~= B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||and@@@Called Logical AND  operator. If both the operands are non zero then condition becomes true.@@@(A and B) is false.|||or@@@Called Logical OR Operator. If any of the two operands is non zero then condition becomes true.@@@(A or B) is true.|||not@@@Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A and B) is true.&&&Operator@@@Description@@@Example|||..@@@Concatenates two strings.@@@a..b where a is ""Hello "" and b is ""World"", will return ""Hello World"".|||#@@@An unary operator that return the length of the a string or a table.@@@#""Hello"" will return 5&&&Category@@@Operator@@@Associativity|||Unary@@@not # -@@@Right to left|||Concatenation@@@..@@@Right to left|||Multiplicative@@@* / %@@@Left to right|||Additive@@@+ -@@@Left to right|||Relational@@@< > <=  >= ==  ~= @@@Left to right|||Equality@@@== ~=@@@Left to right|||Logical AND@@@and@@@Left to right|||Logical OR@@@or@@@Left to right",
Learn Lua,Lua - Loops,Lua - Loops|||Loop Control Statement@@@The Infinite Loop@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: the first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times. Following is the general form of a loop statement in most of the programming languages −|||Lua provides the following types of loops to handle looping requirements.|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||Repeats the operation of group of statements till the until condition is met.|||You can use one or more loop inside any another while, for or do..while loop.|||Loop control statement changes execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.|||Lua supports the following control statements.|||Terminates the loop and transfers execution to the statement immediately following the loop or switch.|||A loop becomes infinite loop if a condition never becomes false. The while loop is often used for this purpose. Since we directly give true for the condition, it keeps executing forever. We can use the break statement to break this loop.",,,"Sr.No.@@@Loop Type & Description|||1@@@while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||2@@@for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||3@@@repeat...until loop
Repeats the operation of group of statements till the until condition is met.|||4@@@nested loops
You can use one or more loop inside any another while, for or do..while loop.&&&Sr.No.@@@Control Statement & Description|||1@@@break statement
Terminates the loop and transfers execution to the statement immediately following the loop or switch.","while( true )do   print(""This loop will run forever."")end"
Learn Lua,Lua - Decision Making,Lua - Decision Making|||Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed, if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.|||Following is the general form of a typical decision making structure found in most of the programming languages −|||Lua programming language assumes any combination of Boolean true and non-nil values as true, and if it is either boolean false or nil, then it is assumed as false value. It is to be noted that in Lua, zero will be considered as true.|||Lua programming language provides the following types of decision making statements.|||An if statement consists of a boolean expression followed by one or more statements.|||An if statement can be followed by an optional else statement, which executes when the boolean expression is false.|||You can use one if or else if statement inside another if or else if statement(s).",,,"Sr.No.@@@Statement & Description|||1@@@if statement
An if statement consists of a boolean expression followed by one or more statements.|||2@@@if...else statement
An if statement can be followed by an optional else statement, which executes when the boolean expression is false.|||3@@@nested if statements
You can use one if or else if statement inside another if or else if statement(s).",
Learn Lua,Lua - Functions,Lua - Functions|||Defining a Function@@@Example@@@Function Arguments@@@Calling a Function@@@Assigning and Passing Functions@@@Function with Variable Argument@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"A function is a group of statements that together perform a task. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually unique, is so each function performs a specific task.|||The Lua language provides numerous built-in methods that your program can call. For example, method print() to print the argument passed as input in console.|||A function is known with various names like a method or a sub-routine or a procedure etc.|||The general form of a method definition in Lua programming language is as follows −|||A method definition in Lua programming language consists of a method header and a method body. Here are all the parts of a method −|||Optional Function Scope − You can use keyword local to limit the scope of the function or ignore the scope section, which will make it a global function.|||Function Name − This is the actual name of the function. The function name and the parameter list together constitute the function signature.|||Arguments − An argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as the actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.|||Function Body − The method body contains a collection of statements that define what the method does.|||Return − In Lua, it is possible to return multiple values by following the return keyword with the comma separated return values.|||Following is the source code for a function called max(). This function takes two parameters num1 and num2 and returns the maximum between the two −|||If a function is to use arguments, it must declare the variables that accept the values of the arguments. These variables are called the formal parameters of the function.|||The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.|||While creating a Lua function, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.|||When a program calls a function, program control is transferred to the called function. A called function performs the defined task and when its return statement is executed or when its function's end is reached, it returns program control back to the main program.|||To call a method, you simply need to pass the required parameters along with the method name and if the method returns a value, then you can store the returned value. For example −|||When we run the above code, we will get the following output.|||In Lua, we can assign the function to variables and also can pass them as parameters of another function. Here is a simple example for assigning and passing a function as parameter in Lua.|||When we run the above code, we will get the following output.|||It is possible to create functions with variable arguments in Lua using '...' as its parameter. We can get a grasp of this by seeing an example in which the function will return the average and it can take variable arguments.|||When we run the above code, we will get the following output.","Optional Function Scope − You can use keyword local to limit the scope of the function or ignore the scope section, which will make it a global function.@@@Function Name − This is the actual name of the function. The function name and the parameter list together constitute the function signature.@@@Arguments − An argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as the actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.@@@Function Body − The method body contains a collection of statements that define what the method does.@@@Return − In Lua, it is possible to return multiple values by following the return keyword with the comma separated return values.",,,"--[[ function returning the max between two numbers --]]function max(num1, num2)   if (num1 > num2) then      result = num1;   else      result = num2;   end   return result; end|||function max(num1, num2)   if (num1 > num2) then      result = num1;   else      result = num2;   end   return result; end-- calling a functionprint(""The maximum of the two numbers is "",max(10,4))print(""The maximum of the two numbers is "",max(5,6))|||myprint = function(param)   print(""This is my print function -   ##"",param,""##"")endfunction add(num1,num2,functionPrint)   result = num1 + num2   functionPrint(result)endmyprint(10)add(2,5,myprint)|||function average(...)   result = 0   local arg = {...}   for i,v in ipairs(arg) do      result = result + v   end   return result/#argendprint(""The average is"",average(10,5,3,4,5,6))"
Learn Lua,Lua - Strings,Lua - Strings|||String Manipulation@@@Case Manipulation@@@Replacing a Substring@@@Finding and Reversing@@@Formatting Strings@@@Character and Byte Representations@@@Other Common Functions@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"String is a sequence of characters as well as control characters like form feed. String can be initialized with three forms which includes −|||An example for the above three forms are shown below.|||When we run the above program, we will get the following output.|||Escape sequence characters are used in string to change the normal interpretation of characters. For example, to print double inverted commas (""""), we have used \"" in the above example. The escape sequence and its use is listed below in the table.|||Lua supports string to manipulate strings −|||string.upper(argument)|||Returns a capitalized representation of the argument.|||string.lower(argument)|||Returns a lower case representation of the argument.|||string.gsub(mainString,findString,replaceString)|||Returns a string by replacing occurrences of findString with replaceString.|||string.find(mainString,findString,|||optionalStartIndex,optionalEndIndex)|||Returns the start index and end index of the findString in the main string and nil if not found.|||string.reverse(arg)|||Returns a string by reversing the characters of the passed string.|||string.format(...)|||Returns a formatted string.|||string.char(arg) and string.byte(arg)|||Returns internal numeric and character representations of input argument.|||string.len(arg)|||Returns a length of the passed string.|||string.rep(string, n))|||Returns a string by repeating the same string n number times.|||..|||Thus operator concatenates two strings.|||Now, let's dive into a few examples to exactly see how these string manipulation functions behave.|||A sample code for manipulating the strings to upper and lower case is given below.|||When we run the above program, we will get the following output.|||A sample code for replacing occurrences of one string with another is given below.|||When we run the above program, we will get the following output.|||A sample code for finding the index of substring and reversing string is given below.|||When we run the above program, we will get the following output.|||Many times in our programming, we may need to print strings in a formatted way. You can use the string.format function to format the output as shown below.|||When we run the above program, we will get the following output.|||A sample code for character and byte representation, which is used for converting the string from string to internal representation and vice versa.|||When we run the above program, we will get the following output.|||The common string manipulations include string concatenation, finding length of string and at times repeating the same string multiple times. The example for these operations is given below.|||When we run the above program, we will get the following output.",Characters between single quotes@@@Characters between double quotes@@@Characters between [[ and  ]],,"Escape Sequence@@@Use|||\a@@@Bell|||\b@@@Backspace|||\f@@@Formfeed|||\n@@@New line|||\r@@@Carriage return |||\t@@@Tab|||\v@@@Vertical tab|||\\@@@Backslash|||\""@@@Double quotes|||\'@@@Single quotes|||\[@@@Left square bracket|||\]@@@Right square bracket&&&Sr.No.@@@Method & Purpose|||1@@@string.upper(argument)
Returns a capitalized representation of the argument.|||2@@@string.lower(argument)
Returns a lower case representation of the argument.|||3@@@string.gsub(mainString,findString,replaceString)
Returns a string by replacing occurrences of findString with replaceString.|||4@@@string.find(mainString,findString,
optionalStartIndex,optionalEndIndex)
Returns the start index and end index of the findString in the main string and nil if not found.|||5@@@string.reverse(arg)
Returns a string by reversing the characters of the passed string.|||6@@@string.format(...)
Returns a formatted string.|||7@@@string.char(arg) and string.byte(arg)
Returns internal numeric and character representations of input argument.|||8@@@string.len(arg)
Returns a length of the passed string.|||9@@@string.rep(string, n))
Returns a string by repeating the same string n number times.|||10@@@..
Thus operator concatenates two strings.","string1 = ""Lua""print(""\""String 1 is\"""",string1)string2 = 'Tutorial'print(""String 2 is"",string2)string3 = [[""Lua Tutorial""]]print(""String 3 is"",string3)|||string1 = ""Lua"";print(string.upper(string1))print(string.lower(string1))|||string = ""Lua Tutorial""-- replacing stringsnewstring = string.gsub(string,""Tutorial"",""Language"")print(""The new string is ""..newstring)|||string = ""Lua Tutorial""-- replacing stringsprint(string.find(string,""Tutorial""))reversedString = string.reverse(string)print(""The new string is"",reversedString)|||string1 = ""Lua""string2 = ""Tutorial""number1 = 10number2 = 20-- Basic string formattingprint(string.format(""Basic formatting %s %s"",string1,string2))-- Date formattingdate = 2; month = 1; year = 2014print(string.format(""Date formatting %02d/%02d/%03d"", date, month, year))-- Decimal formattingprint(string.format(""%.4f"",1/3))|||-- Byte conversion-- First characterprint(string.byte(""Lua""))-- Third characterprint(string.byte(""Lua"",3))-- first character from lastprint(string.byte(""Lua"",-1))-- Second characterprint(string.byte(""Lua"",2))-- Second character from lastprint(string.byte(""Lua"",-2))-- Internal Numeric ASCII Conversionprint(string.char(97))|||string1 = ""Lua""string2 = ""Tutorial""-- String Concatenations using ..print(""Concatenated string"",string1..string2)-- Length of stringprint(""Length of string1 is "",string.len(string1))-- Repeating stringsrepeatedString = string.rep(string1,3)print(repeatedString)"
Learn Lua,Lua - Arrays,Lua - Arrays|||One-Dimensional Array@@@Multi-Dimensional Array@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Arrays are ordered arrangement of objects, which may be a one-dimensional array containing a collection of rows or a multi-dimensional array containing multiple rows and columns.|||In Lua, arrays are implemented using indexing tables with integers. The size of an array is not fixed and it can grow based on our requirements, subject to memory constraints.|||A one-dimensional array can be represented using a simple table structure and can be initialized and read using a simple for loop. An example is shown below.|||When we run the above code, we wil get the following output.|||As you can see in the above code, when we are trying to access an element in an index that is not there in the array, it returns nil. In Lua, indexing generally starts at index 1. But it is possible to create objects at index 0 and below 0 as well. Array using negative indices is shown below where we initialize the array using a for loop.|||When we run the above code, we will get the following output.|||Multi-dimensional arrays can be implemented in two ways.|||An example for multidimensional array of 3. 3 is shown below using array of arrays.|||When we run the above code, we will get the following output.|||An example for multidimensional array is shown below using manipulating indices.|||When we run the above code, we will get the following output.|||As you can see in the above example, data is stored based on indices. It is possible to place the elements in a sparse way and it is the way Lua implementation of a matrix works. Since it does not store nil values in Lua, it is possible to save lots of memory without any special technique in Lua as compared to special techniques used in other programming languages.",Array of arrays@@@Single dimensional array by manipulating indices,,,"array = {""Lua"", ""Tutorial""}for i = 0, 2 do   print(array[i])end|||array = {}for i= -2, 2 do   array[i] = i *2endfor i = -2,2 do   print(array[i])end|||-- Initializing the arrayarray = {}for i=1,3 do   array[i] = {}	   for j=1,3 do      array[i][j] = i*j   end	end-- Accessing the arrayfor i=1,3 do   for j=1,3 do      print(array[i][j])   end	end|||-- Initializing the arrayarray = {}maxRows = 3maxColumns = 3for row=1,maxRows do   for col=1,maxColumns do      array[row*maxColumns +col] = row*col   end	end-- Accessing the arrayfor row=1,maxRows do   for col=1,maxColumns do      print(array[row*maxColumns +col])   end	end"
Learn Lua,Lua - Iterators,Lua - Iterators|||Generic For Iterator@@@Stateless Iterators@@@Stateful Iterators@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Iterator is a construct that enables you to traverse through the elements of the so called collection or container. In Lua, these collections often refer to tables, which are used to create various data structures like array.|||A generic for iterator provides the key value pairs of each element in the collection. A simple example is given below.|||When we run the above code, we will get the following output −|||The above example uses the default ipairs iterator function provided by Lua.|||In Lua we use functions to represent iterators. Based on the state maintenance in these iterator functions, we have two main types −|||By the name itself we can understand that this type of iterator function does not retain any state.|||Let us now see an example of creating our own iterator using a simple function that prints the squares of n numbers.|||When we run the above program, we will get the following output.|||The above code can be modified slightly to mimic the way ipairs function of iterators work. It is shown below.|||When we run the above program, we will get the following output.|||The previous example of iteration using function does not retain the state. Each time the function is called, it returns the next element of the collection based on a second variable sent to the function. To hold the state of the current element, closures are used. Closure retain variables values across functions calls. To create a new closure, we create two functions including the closure itself and a factory, the function that creates the closure.|||Let us now see an example of creating our own iterator in which we will be using closures.|||When we run the above program, we will get the following output.|||In the above example, we can see that elementIterator has another method inside that uses the local external variables index and count to return each of the element in the collection by incrementing the index each time the function is called.|||We can create our own function iterators using closure as shown above and it can return multiple elements for each of the time we iterate through the collection.",Stateless Iterators@@@Stateful Iterators,,,"array = {""Lua"", ""Tutorial""}for key,value in ipairs(array) do   print(key, value)end|||function square(iteratorMaxCount,currentNumber)   if currentNumber<iteratorMaxCount   then      currentNumber = currentNumber+1      return currentNumber, currentNumber*currentNumber   end	endfor i,n in square,3,0do   print(i,n)end|||function square(iteratorMaxCount,currentNumber)   if currentNumber<iteratorMaxCount   then      currentNumber = currentNumber+1      return currentNumber, currentNumber*currentNumber   end	endfunction squares(iteratorMaxCount)   return square,iteratorMaxCount,0end  for i,n in squares(3)do    print(i,n)end|||array = {""Lua"", ""Tutorial""}function elementIterator (collection)   local index = 0   local count = #collection	   -- The closure function is returned	   return function ()      index = index + 1		      if index <= count      then         -- return the current element of the iterator         return collection[index]      end		   end	endfor element in elementIterator(array)do   print(element)end"
Learn Lua,Lua - Tables,Lua - Tables|||Introduction@@@Representation and Usage@@@Table Manipulation@@@Table Concatenation@@@Insert and Remove@@@Sorting Tables@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Tables are the only data structure available in Lua that helps us create different types like arrays and dictionaries. Lua uses associative arrays and which can be indexed with not only numbers but also with strings except nil. Tables have no fixed size and can grow based on our need.|||Lua uses tables in all representations including representation of packages. When we access a method string.format, it means, we are accessing the format function available in the string package.|||Tables are called objects and they are neither values nor variables. Lua uses a constructor expression {} to create an empty table. It is to be known that there is no fixed relationship between a variable that holds reference of table and the table itself.|||When we have a table a with set of elements and if we assign it to b, both a and b refer to the same memory. No separate memory is allocated separately for b. When a is set to nil, table will be still accessible to b. When there are no reference to a table, then garbage collection in Lua takes care of cleaning up process to make these unreferenced memory to be reused again.|||An example is shown below for explaining the above mentioned features of tables.|||When we run the above program we will get the following output −|||There are in built functions for table manipulation and they are listed in the following table.|||table.concat (table [, sep [, i [, j]]])|||Concatenates the strings in the tables based on the parameters given. See example for detail.|||table.insert (table, [pos,] value)|||Inserts a value into the table at specified position.|||table.maxn (table)|||Returns the largest numeric index.|||table.remove (table [, pos])|||Removes the value from the table.|||table.sort (table [, comp])|||Sorts the table based on optional comparator argument.|||Let us see some samples of the above functions.|||We can use the concat function to concatenate two tables as shown below −|||When we run the above program we will get the following output −|||Insertion and removal of items in tables is most common in table manipulation. It is explained below.|||When we run the above program, we will get the following output −|||We often require to sort a table in a particular order. The sort functions sort the elements in a table alphabetically. A sample for this is shown below.|||When we run the above program we will get the following output −",,,"Sr.No.@@@Method & Purpose|||1@@@table.concat (table [, sep [, i [, j]]])
Concatenates the strings in the tables based on the parameters given. See example for detail.|||2@@@table.insert (table, [pos,] value)
Inserts a value into the table at specified position.|||3@@@table.maxn (table)
Returns the largest numeric index.|||4@@@table.remove (table [, pos])
Removes the value from the table.|||5@@@table.sort (table [, comp])
Sorts the table based on optional comparator argument.","-- Simple empty tablemytable = {}print(""Type of mytable is "",type(mytable))mytable[1]= ""Lua""mytable[""wow""] = ""Tutorial""print(""mytable Element at index 1 is "", mytable[1])print(""mytable Element at index wow is "", mytable[""wow""])-- alternatetable and mytable refers to same tablealternatetable = mytableprint(""alternatetable Element at index 1 is "", alternatetable[1])print(""alternatetable Element at index wow is "", alternatetable[""wow""])alternatetable[""wow""] = ""I changed it""print(""mytable Element at index wow is "", mytable[""wow""])-- only variable released and and not tablealternatetable = nilprint(""alternatetable is "", alternatetable)-- mytable is still accessibleprint(""mytable Element at index wow is "", mytable[""wow""])mytable = nilprint(""mytable is "", mytable)|||fruits = {""banana"",""orange"",""apple""}-- returns concatenated string of tableprint(""Concatenated string "",table.concat(fruits))--concatenate with a characterprint(""Concatenated string "",table.concat(fruits,"", ""))--concatenate fruits based on indexprint(""Concatenated string "",table.concat(fruits,"", "", 2,3))|||fruits = {""banana"",""orange"",""apple""}-- insert a fruit at the endtable.insert(fruits,""mango"")print(""Fruit at index 4 is "",fruits[4])--insert fruit at index 2table.insert(fruits,2,""grapes"")print(""Fruit at index 2 is "",fruits[2])print(""The maximum elements in table is"",table.maxn(fruits))print(""The last element is"",fruits[5])table.remove(fruits)print(""The previous last element is"",fruits[5])|||fruits = {""banana"",""orange"",""apple"",""grapes""}for k,v in ipairs(fruits) do   print(k,v)endtable.sort(fruits)print(""sorted table"")for k,v in ipairs(fruits) do   print(k,v)end"
Learn Lua,Lua - Modules,Lua - Modules|||What is a Module?@@@Specialty of Lua Modules@@@The require Function@@@Things to Remember@@@Old Way of Implementing Modules@@@Useful Video Courses|||Example|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Module is like a library that can be loaded using require and has a single global name containing a table. This module can consist of a number of functions and variables. All these functions and variables are wrapped in to the table, which acts as a namespace. Also, a well behaved module has necessary provisions to return this table on require.|||The usage of tables in modules helps us in numerous ways and enables us to manipulate the modules in the same way we manipulate any other Lua table. As a result of the ability to manipulate modules, it provides extra features for which other languages need special mechanisms. Due to this free mechanism of modules in Lua, a user can call the functions in Lua in multiple ways. A few of them are shown below.|||In the above sample code, you can see how flexible programming in Lua is, without any special additional code.|||Lua has provided a high level function called require to load all the necessary modules. It is kept as simple as possible to avoid having too much information on module to load it. The require function just assumes the modules as a chunk of code that defines some values, which is actually functions or tables containing functions.|||Let us consider a simple example, where one function has the math functions. Let's call this module as mymath and filename being mymath.lua. The file content is as follows −|||Now, in order to access this Lua module in another file, say, moduletutorial.lua, you need to use the following code segment.|||In order to run this code, we need to place the two Lua files in the same directory or alternatively, you can place the module file in the package path and it needs additional setup. When we run the above program, we will get the following output.|||Place both the modules and the file you run in the same directory.|||Module name and its file name should be the same.|||It is a best practice to return modules for require function and hence the module should be preferably implemented as shown above eventhough you can find other types of implementations elsewhere.|||Let me now rewrite the same example in the older way, which uses package.seeall type of implementation. This was used in Lua versions 5.1 and 5.0. The mymath module is shown below.|||The usage of modules in moduletutorial.lua is shown below.|||When we run the above, we will get the same output. But it is advised on to use the older version of the code and it is assumed to less secure. Many SDKs that use Lua for programming like Corona SDK has deprecated the use of this.",Place both the modules and the file you run in the same directory.@@@Module name and its file name should be the same.@@@It is a best practice to return modules for require function and hence the module should be preferably implemented as shown above eventhough you can find other types of implementations elsewhere.,,,"-- Assuming we have a module printFormatter-- Also printFormatter has a funtion simpleFormat(arg)-- Method 1require ""printFormatter""printFormatter.simpleFormat(""test"")-- Method 2local formatter = require ""printFormatter""formatter.simpleFormat(""test"")-- Method 3require ""printFormatter""local formatterFunction = printFormatter.simpleFormatformatterFunction(""test"")|||local mymath =  {}function mymath.add(a,b)   print(a+b)endfunction mymath.sub(a,b)   print(a-b)endfunction mymath.mul(a,b)   print(a*b)endfunction mymath.div(a,b)   print(a/b)endreturn mymath	|||mymathmodule = require(""mymath"")mymathmodule.add(10,20)mymathmodule.sub(30,20)mymathmodule.mul(10,20)mymathmodule.div(30,20)|||module(""mymath"", package.seeall)function mymath.add(a,b)   print(a+b)endfunction mymath.sub(a,b)   print(a-b)endfunction mymath.mul(a,b)   print(a*b)endfunction mymath.div(a,b)   print(a/b)end|||require(""mymath"")mymath.add(10,20)mymath.sub(30,20)mymath.mul(10,20)mymath.div(30,20)"
Learn Lua,Lua - Metatables,Lua - Metatables|||_index@@@__newindex@@@Adding Operator Behavior to Tables@@@__call@@@__tostring@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"A metatable is a table that helps in modifying the behavior of a table it is attached to with the help of a key set and related meta methods. These meta methods are powerful Lua functionality that enables features like −|||Changing/adding functionalities to operators on tables.|||Looking up metatables when the key is not available in the table using __index in metatable.|||There are two important methods that are used in handling metatables which includes −|||setmetatable(table,metatable) − This method is used to set metatable for a table.|||getmetatable(table) − This method is used to get metatable of a table.|||Let's first look at how to set one table as metatable of another. It is shown below.|||The above code can be represented in a single line as shown below.|||A simple example of metatable for looking up the meta table when it's not available in table is shown below.|||When we run the above program, we will get the following output.|||Let us explain what happened in the above example in steps.|||The table mytable here is {key1 = ""value1""}.|||Metatable is set for mytable that contains a function for __index, which we call as a metamethod.|||The metamethod does a simple job of looking up for an index ""key2"", if it's found, it returns ""metatablevalue"", otherwise returns mytable's value for corresponding index.|||We can have a simplified version of the above program as shown below.|||When we add __newindex to metatable, if keys are not available in the table, the behavior of new keys will be defined by meta methods. A simple example where metatable's index is set when index is not available in the main table is given below.|||When you run the above program, you get the following output.|||You can see in the above program, if a key exists in the main table, it just updates it. When a key is not available in the maintable, it adds that key to the metatable.|||Another example that updates the same table using rawset function is shown below.|||When we run the above program we will get the following output.|||rawset sets value without using __newindex of metatable. Similarly there is rawget that gets value without using __index.|||A simple example to combine two tables using + operator is shown below −|||When we run the above program, we will get the following output.|||The __add key is included in the metatable to add behavior of operator +. The table of keys and corresponding operator is shown below.|||__add|||Changes the behavior of operator '+'.|||__sub|||Changes the behavior of operator '-'.|||__mul|||Changes the behavior of operator '*'.|||__div|||Changes the behavior of operator '/'.|||__mod|||Changes the behavior of operator '%'.|||__unm|||Changes the behavior of operator '-'.|||__concat|||Changes the behavior of operator '..'.|||__eq|||Changes the behavior of operator '=='.|||__lt|||Changes the behavior of operator '<'.|||__le|||Changes the behavior of operator '<='.|||Adding behavior of method call is done using __call statement. A simple example that returns the sum of values in main table with the passed table.|||When we run the above program, we will get the following output.|||To change the behavior of the print statement, we can use the __tostring metamethod. A simple example is shown below.|||When we run the above program, we will get the following output.|||If you know the capabilities of meta table fully, you can really perform a lot of operations that would be very complex without using it. So, try to work more on using metatables with different options available in meta tables as explained in the samples and also create your own samples.","Changing/adding functionalities to operators on tables.@@@Looking up metatables when the key is not available in the table using __index in metatable.|||setmetatable(table,metatable) − This method is used to set metatable for a table.@@@getmetatable(table) − This method is used to get metatable of a table.|||The table mytable here is {key1 = ""value1""}.@@@Metatable is set for mytable that contains a function for __index, which we call as a metamethod.@@@The metamethod does a simple job of looking up for an index ""key2"", if it's found, it returns ""metatablevalue"", otherwise returns mytable's value for corresponding index.",,"Sr.No.@@@Mode & Description|||1@@@__add
Changes the behavior of operator '+'.|||2@@@__sub
Changes the behavior of operator '-'.|||3@@@__mul
Changes the behavior of operator '*'.|||4@@@__div
Changes the behavior of operator '/'.|||5@@@__mod
Changes the behavior of operator '%'.|||6@@@__unm
Changes the behavior of operator '-'.|||7@@@__concat
Changes the behavior of operator '..'.|||8@@@__eq
Changes the behavior of operator '=='.|||9@@@__lt
Changes the behavior of operator '<'.|||10@@@__le
Changes the behavior of operator '<='.","mytable = setmetatable({key1 = ""value1""}, {   __index = function(mytable, key)	      if key == ""key2"" then         return ""metatablevalue""      else         return mytable[key]      end   end})print(mytable.key1,mytable.key2)|||mytable = setmetatable({key1 = ""value1""},    { __index = { key2 = ""metatablevalue"" } })print(mytable.key1,mytable.key2)|||mymetatable = {}mytable = setmetatable({key1 = ""value1""}, { __newindex = mymetatable })print(mytable.key1)mytable.newkey = ""new value 2""print(mytable.newkey,mymetatable.newkey)mytable.key1 = ""new  value 1""print(mytable.key1,mymetatable.newkey1)|||mytable = setmetatable({key1 = ""value1""}, {   __newindex = function(mytable, key, value)      rawset(mytable, key, ""\""""..value..""\"""")   end})mytable.key1 = ""new value""mytable.key2 = 4print(mytable.key1,mytable.key2)|||mytable = setmetatable({ 1, 2, 3 }, {   __add = function(mytable, newtable)	      for i = 1, table.maxn(newtable) do         table.insert(mytable, table.maxn(mytable)+1,newtable[i])      end      return mytable   end})secondtable = {4,5,6}mytable = mytable + secondtablefor k,v in ipairs(mytable) do   print(k,v)end|||mytable = setmetatable({10}, {   __call = function(mytable, newtable)   sum = 0	      for i = 1, table.maxn(mytable) do         sum = sum + mytable[i]      end	      for i = 1, table.maxn(newtable) do         sum = sum + newtable[i]      end	      return sum   end})newtable = {10,20,30}print(mytable(newtable))|||mytable = setmetatable({ 10, 20, 30 }, {   __tostring = function(mytable)   sum = 0	      for k, v in pairs(mytable) do         sum = sum + v      end		      return ""The sum of values in the table is "" .. sum   end})print(mytable)"
Learn Lua,Lua - Coroutines,Lua - Coroutines|||Introduction@@@Functions Available in Coroutines@@@Example@@@What Does the Above Example Do?@@@Another Coroutine Example@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Coroutines are collaborative in nature, which allows two or more methods to execute in a controlled manner. With coroutines, at any given time, only one coroutine runs and this running coroutine only suspends its execution when it explicitly requests to be suspended.|||The above definition may look vague. Let us assume we have two methods, one the main program method and a coroutine. When we call a coroutine using resume function, its starts executing and when we call yield function, it suspends executing. Again the same coroutine can continue executing with another resume function call from where it was suspended. This process can continue till the end of execution of the coroutine.|||The following table lists all the available functions for coroutines in Lua and their corresponding use.|||coroutine.create (f)|||Creates a new coroutine with a function f and returns an object of type ""thread"".|||coroutine.resume (co [, val1, ...])|||Resumes the coroutine co and passes the parameters if any. It returns the status of operation and optional other return values.|||coroutine.running ()|||Returns the running coroutine or nil if called in the main thread.|||coroutine.status (co)|||Returns one of the values from running, normal, suspended or dead based on the state of the coroutine.|||coroutine.wrap (f)|||Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine.|||coroutine.yield (...)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||Let's look at an example to understand the concept of coroutines.|||When we run the above program, we will get the following output.|||As mentioned before, we use the resume function to start the operation and yield function to stop the operation. Also, you can see that there are multiple return values received by resume function of coroutine.|||First, we create a coroutine and assign it to a variable name co and the coroutine takes in two variables as its parameters.|||When we call the first resume function, the values 3 and 2 are retained in the temporary variables value1 and value2 till the end of the coroutine.|||To make you understand this, we have used a tempvar3, which is 10 initially and it gets updated to 13 and 16 by the subsequent calls of the coroutines since value1 is retained as 3 throughout the execution of the coroutine.|||The first coroutine.yield returns two values 4 and 3 to the resume function, which we get by updating the input params 3 and 2 in the yield statement. It also receives the true/false status of coroutine execution.|||Another thing about coroutines is how the next params of resume call is taken care of, in the above example; you can see that the variable the coroutine.yield receives the next call params which provides a powerful way of doing new operation with the retentionship of existing param values.|||Finally, once all the statements in the coroutines are executed, the subsequent calls will return in false and ""cannot resume dead coroutine"" statement as response.|||Let us look at a simple coroutine that returns a number from 1 to 5 with the help of yield function and resume function. It creates coroutine if not available or else resumes the existing coroutine.|||When we run the above program, we will get the following output.|||There is often a comparison of coroutines with the threads of multiprogramming languages, but we need to understand that coroutines have similar features of thread but they execute only one at a time and never execute concurrently.|||We control the program execution sequence to meet the needs with the provision of retaining certain information temporarily. Using global variables with coroutines provides even more flexibility to coroutines.","First, we create a coroutine and assign it to a variable name co and the coroutine takes in two variables as its parameters.@@@When we call the first resume function, the values 3 and 2 are retained in the temporary variables value1 and value2 till the end of the coroutine.@@@To make you understand this, we have used a tempvar3, which is 10 initially and it gets updated to 13 and 16 by the subsequent calls of the coroutines since value1 is retained as 3 throughout the execution of the coroutine.@@@The first coroutine.yield returns two values 4 and 3 to the resume function, which we get by updating the input params 3 and 2 in the yield statement. It also receives the true/false status of coroutine execution.@@@Another thing about coroutines is how the next params of resume call is taken care of, in the above example; you can see that the variable the coroutine.yield receives the next call params which provides a powerful way of doing new operation with the retentionship of existing param values.@@@Finally, once all the statements in the coroutines are executed, the subsequent calls will return in false and ""cannot resume dead coroutine"" statement as response.",,"Sr.No.@@@Method & Purpose|||1@@@coroutine.create (f)
Creates a new coroutine with a function f and returns an object of type ""thread"".|||2@@@coroutine.resume (co [, val1, ...])
Resumes the coroutine co and passes the parameters if any. It returns the status of operation and optional other return values.|||3@@@coroutine.running ()
Returns the running coroutine or nil if called in the main thread.|||4@@@coroutine.status (co)
Returns one of the values from running, normal, suspended or dead based on the state of the coroutine.|||5@@@coroutine.wrap (f)
Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine.|||6@@@coroutine.yield (...)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.","co = coroutine.create(function (value1,value2)   local tempvar3 = 10   print(""coroutine section 1"", value1, value2, tempvar3)	   local tempvar1 = coroutine.yield(value1+1,value2+1)   tempvar3 = tempvar3 + value1   print(""coroutine section 2"",tempvar1 ,tempvar2, tempvar3)	   local tempvar1, tempvar2= coroutine.yield(value1+value2, value1-value2)   tempvar3 = tempvar3 + value1   print(""coroutine section 3"",tempvar1,tempvar2, tempvar3)   return value2, ""end""	end)print(""main"", coroutine.resume(co, 3, 2))print(""main"", coroutine.resume(co, 12,14))print(""main"", coroutine.resume(co, 5, 6))print(""main"", coroutine.resume(co, 10, 20))|||function getNumber()   local function getNumberHelper()      co = coroutine.create(function ()      coroutine.yield(1)      coroutine.yield(2)      coroutine.yield(3)      coroutine.yield(4)      coroutine.yield(5)      end)      return co   end	   if(numberHelper) then      status, number = coroutine.resume(numberHelper);		      if coroutine.status(numberHelper) == ""dead"" then         numberHelper = getNumberHelper()         status, number = coroutine.resume(numberHelper);      end		      return number   else      numberHelper = getNumberHelper()      status, number = coroutine.resume(numberHelper);      return number   end	endfor index = 1, 10 do   print(index, getNumber())end"
Learn Lua,Lua - File I/O,Lua - File I/O|||Implicit File Descriptors@@@Explicit File Descriptors@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"I/O library is used for reading and manipulating files in Lua. There are two kinds of file operations in Lua namely implicit file descriptors and explicit file descriptors.|||For the following examples, we will use a sample file test.lua as shown below.|||A simple file open operation uses the following statement.|||The various file modes are listed in the following table.|||""r""|||Read-only mode and is the default mode where an existing file is opened.|||""w""|||Write enabled mode that overwrites the existing file or creates a new file.|||""a""|||Append mode that opens an existing file or creates a new file for appending.|||""r+""|||Read and write mode for an existing file.|||""w+""|||All existing data is removed if file exists or new file is created with read write permissions.|||""a+""|||Append mode with read mode enabled that opens an existing file or creates a new file.|||Implicit file descriptors use the standard input/ output modes or using a single input and single output file. A sample of using implicit file descriptors is shown below.|||When you run the program, you will get an output of the first line of test.lua file. For our program, we got the following output.|||This was the first line of the statement in test.lua file for us. Also the line ""-- End of the test.lua file"" would be appended to the last line of the test.lua code.|||In the above example, you can see how the implicit descriptors work with file system using the io.""x"" methods. The above example uses io.read() without the optional parameter. The optional parameter can be any of the following.|||""*n""|||Reads from the current file position and returns a number if exists at the file position or returns nil.|||""*a""|||Returns all the contents of file from the current file position.|||""*l""|||Reads the line from the current file position, and moves file position to next line.|||number|||Reads number of bytes specified in the function.|||Other common I/O methods includes,|||io.tmpfile() − Returns a temporary file for reading and writing that will be removed once the program quits.|||io.type(file) − Returns whether file, closed file or nil based on the input file.|||io.flush() − Clears the default output buffer.|||io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||We often use explicit file descriptor which allows us to manipulate multiple files at a time. These functions are quite similar to implicit file descriptors. Here, we use file:function_name instead of io.function_name. The following example of the file version of the same implicit file descriptors example is shown below.|||When you run the program, you will get a similar output as the implicit descriptors example.|||All the modes of file open and params for read for external descriptors is same as implicit file descriptors.|||Other common file methods includes,|||file:seek(optional whence, optional offset) − Whence parameter is ""set"", ""cur"" or ""end"". Sets the new file pointer with the updated file position from the beginning of the file. The offsets are zero-based in this function. The offset is measured from the beginning of the file if the first argument is ""set""; from the current position in the file if it's ""cur""; or from the end of the file if it's ""end"". The default argument values are ""cur"" and 0, so the current file position can be obtained by calling this function without arguments.|||file:flush() − Clears the default output buffer.|||io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||An example to use the seek method is shown below. It offsets the cursor from the 25 positions prior to the end of file. The read function prints remainder of the file from seek position.|||You will get some output similar to the following.|||You can play around all the different modes and parameters to know the full ability of the Lua file operations.","io.tmpfile() − Returns a temporary file for reading and writing that will be removed once the program quits.@@@io.type(file) − Returns whether file, closed file or nil based on the input file.@@@io.flush() − Clears the default output buffer.@@@io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||file:seek(optional whence, optional offset) − Whence parameter is ""set"", ""cur"" or ""end"". Sets the new file pointer with the updated file position from the beginning of the file. The offsets are zero-based in this function. The offset is measured from the beginning of the file if the first argument is ""set""; from the current position in the file if it's ""cur""; or from the end of the file if it's ""end"". The default argument values are ""cur"" and 0, so the current file position can be obtained by calling this function without arguments.@@@file:flush() − Clears the default output buffer.@@@io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.",,"Sr.No.@@@Mode & Description|||1@@@""r""
Read-only mode and is the default mode where an existing file is opened.|||2@@@""w""
Write enabled mode that overwrites the existing file or creates a new file.|||3@@@""a""
Append mode that opens an existing file or creates a new file for appending.|||4@@@""r+""
Read and write mode for an existing file.|||5@@@""w+""
All existing data is removed if file exists or new file is created with read write permissions.|||6@@@""a+""
Append mode with read mode enabled that opens an existing file or creates a new file.&&&Sr.No.@@@Mode & Description|||1@@@""*n""
Reads from the current file position and returns a number if exists at the file position or returns nil.|||2@@@""*a""
Returns all the contents of file from the current file position.|||3@@@""*l""
Reads the line from the current file position, and moves file position to next line.|||4@@@number
Reads number of bytes specified in the function.","-- Opens a file in readfile = io.open(""test.lua"", ""r"")-- sets the default input file as test.luaio.input(file)-- prints the first line of the fileprint(io.read())-- closes the open fileio.close(file)-- Opens a file in append modefile = io.open(""test.lua"", ""a"")-- sets the default output file as test.luaio.output(file)-- appends a word test to the last line of the fileio.write(""-- End of the test.lua file"")-- closes the open fileio.close(file)|||-- Opens a file in read modefile = io.open(""test.lua"", ""r"")-- prints the first line of the fileprint(file:read())-- closes the opened filefile:close()-- Opens a file in append modefile = io.open(""test.lua"", ""a"")-- appends a word test to the last line of the filefile:write(""--test"")-- closes the open filefile:close()|||-- Opens a file in readfile = io.open(""test.lua"", ""r"")file:seek(""end"",-25)print(file:read(""*a""))-- closes the opened filefile:close()"
Learn Lua,Lua - Error Handling,Lua - Error Handling|||Need for Error Handling@@@Assert and Error Functions@@@pcall and xpcall@@@Useful Video Courses|||Syntax Errors@@@Run Time Errors|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Error handling is quite critical since real-world operations often require the use of complex operations, which includes file operations, database transactions and web service calls.|||In any programming, there is always a requirement for error handling. Errors can be of two types which includes,|||Syntax errors occur due to improper use of various program components like operators and expressions. A simple example for syntax error is shown below.|||As you know, there is a difference between the use of a single ""equal to"" and double ""equal to"". Using one instead of the other can lead to an error. One ""equal to"" refers to assignment while a double ""equal to"" refers to comparison. Similarly, we have expressions and functions having their predefined ways of implementation.|||Another example for syntax error is shown below −|||When we run the above program, we will get the following output −|||Syntax errors are much easier to handle than run time errors since, the Lua interpreter locates the error more clearly than in case of runtime error. From the above error, we can know easily that adding a do statement before print statement is required as per the Lua structure.|||In case of runtime errors, the program executes successfully, but it can result in runtime errors due to mistakes in input or mishandled functions. A simple example to show run time error is shown below.|||When we build the program, it will build successfully and run. Once it runs, shows a run time error.|||This is a runtime error, which had occurred due to not passing two variables. The b parameter is expected and here it is nil and produces an error.|||In order to handle errors, we often use two functions − assert and error. A simple example is shown below.|||When we run the above program, we will get the following error output.|||The error (message [, level]) terminates the last protected function called and returns message as the error message. This function error never returns. Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.|||In Lua programming, in order to avoid throwing these errors and handling errors, we need to use the functions pcall or xpcall.|||The pcall (f, arg1, ...) function calls the requested function in protected mode. If some error occurs in function f, it does not throw an error. It just returns the status of error. A simple example using pcall is shown below.|||When we run the above program, we will get the following output.|||The xpcall (f, err) function calls the requested function and also sets the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code.|||A simple example for xpcall is shown below.|||When we run the above program, we will get the following output.|||As a programmer, it is most important to ensure that you take care of proper error handling in the programs you write. Using error handling can ensure that unexpected conditions beyond the boundary conditions are handled without disturbing the user of the program.",Syntax errors@@@Run time errors,,,"for a= 1,10   print(a)end|||function add(a,b)   return a+bendadd(10)|||local function add(a,b)   assert(type(a) == ""number"", ""a is not a number"")   assert(type(b) == ""number"", ""b is not a number"")   return a+bendadd(10)|||function myfunction ()   n = n/nilendif pcall(myfunction) then   print(""Success"")else	print(""Failure"")end|||function myfunction ()   n = n/nilendfunction myerrorhandler( err )   print( ""ERROR:"", err )endstatus = xpcall( myfunction, myerrorhandler )print( status)"
Learn Lua,Lua - Debugging,Lua - Debugging|||Debugging - Example@@@Debugging Types@@@Useful Video Courses|||Command Line Debugging@@@Graphical Debugging|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua provides a debug library, which provides all the primitive functions for us to create our own debugger. Even though, there is no in-built Lua debugger, we have many debuggers for Lua, created by various developers with many being open source.|||The functions available in the Lua debug library are listed in the following table along with its uses.|||debug()|||Enters interactive mode for debugging, which remains active till we type in only cont in a line and press enter. User can inspect variables during this mode using other functions.|||getfenv(object)|||Returns the environment of object.|||gethook(optional thread)|||Returns the current hook settings of the thread, as three values − the current hook function, the current hook mask, and the current hook count.|||getinfo(optional thread, function or stack level, optional flag)|||Returns a table with info about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread − level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil.|||getlocal(optional thread, stack level, local index)|||Returns the name and the value of the local variable with index local of the function at level of the stack.Returns nil if there is no local variable with the given index, and raises an error when called with a level out of range.|||getmetatable(value)|||Returns the metatable of the given object or nil if it does not have a metatable.|||getregistry()|||Returns the registry table,a pre-defined table that can be used by any C code to store whatever Lua value it needs to store.|||getupvalue(function, upvalue index)|||This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index.|||setfenv(function or thread or userdata, environment table)|||Sets the environment of the given object to the given table. Returns object.|||sethook(optional thread, hook function, hook mask string with ""c"" and/or ""r"" and/or ""l"", optional instruction count)|||Sets the given function as a hook. The string mask and the number count describes when the hook will be called. Here, c, r and l are called every time Lua calls, returns, and enters every line of code in a function respectively.|||setlocal(optional thread, stack level, local index, value)|||Assigns the value to the local variable with index local of the function at level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. Otherwise, it returns the name of the local variable.|||setmetatable(value, metatable)|||Sets the metatable for the given object to the given table (which can be nil).|||setupvalue(function, upvalue index, value)|||This function assigns the value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.|||traceback(optional thread, optional message string, optional level argument)|||Builds an extended error message with a traceback.|||The above list is the complete list of debug functions in Lua and we often use a library that uses the above functions and provides easier debugging. Using these functions and creating our own debugger is quite complicated and is not preferable. Anyway, we will see an example of simple use of debugging functions.|||When we run the above program, we will get the stack trace as shown below.|||In the above sample program, the stack trace is printed by using the debug.trace function available in the debug library. The debug.getinfo gets the current table of the function.|||We often need to know the local variables of a function for debugging. For that purpose, we can use getupvalue and to set these local variables, we use setupvalue. A simple example for this is shown below.|||When we run the above program, we will get the following output.|||In this example, the counter updates by one each time it is called. We can see the current state of the local variable using the getupvalue function. We then set the local variable to a new value. Here, n is 2 before the set operation is called. Using setupvalue function, it is updated to 10. Now when we call the counter function, it will return 11 instead of 3.|||Command line debugging is the type of debugging that uses command line to debug with the help of commands and print statements. There are many command line debuggers available for Lua of which a few are listed below.|||RemDebug − RemDebug is a remote debugger for Lua 5.0 and 5.1. It lets you control the execution of another Lua program remotely, setting breakpoints and inspecting the current state of the program. RemDebug can also debug CGILua scripts.|||clidebugger − A simple command line interface debugger for Lua 5.1 written in pure Lua. It's not dependent on anything other than the standard Lua 5.1 libraries. It was inspired by RemDebug but does not have its remote facilities.|||ctrace − A tool for tracing Lua API calls.|||xdbLua − A simple Lua command line debugger for the Windows platform.|||LuaInterface - Debugger − This project is a debugger extension for LuaInterface. It raises the built in Lua debug interface to a higher level. Interaction with the debugger is done by events and method calls.|||Rldb − This is a remote Lua debugger via socket, available on both Windows and Linux. It can give you much more features than any existing one.|||ModDebug − This allows in controlling the execution of another Lua program remotely, set breakpoints, and inspect the current state of the program.|||Graphical debugging is available with the help of IDE where you are provided with visual debugging of various states like variable values, stack trace and other related information. There is a visual representation and step by step control of execution with the help of breakpoints, step into, step over and other buttons in the IDE.|||There are number of graphical debuggers for Lua and it includes the following.|||SciTE − The default windows IDE for Lua provides multiple debugging facilities like breakpoints, step, step into, step over, watch variables and so on.|||Decoda − This is a graphical debugger with remote debugging support.|||ZeroBrane Studio − Lua IDE with integrated remote debugger, stack view, watch view, remote console, static analyzer, and more. Works with LuaJIT, Love2d, Moai, and other Lua engines; Windows, OSX, and Linux. Open source.|||akdebugger − Debugger and editor Lua plugin for Eclipse.|||luaedit − This features remote debugging, local debugging, syntax highlighting, completion proposal list, parameter proposition engine, advance breakpoint management (including condition system on breakpoints and hit count), function listing, global and local variables listing, watches, solution oriented management.","Command line debugging@@@Graphical debugging|||RemDebug − RemDebug is a remote debugger for Lua 5.0 and 5.1. It lets you control the execution of another Lua program remotely, setting breakpoints and inspecting the current state of the program. RemDebug can also debug CGILua scripts.@@@clidebugger − A simple command line interface debugger for Lua 5.1 written in pure Lua. It's not dependent on anything other than the standard Lua 5.1 libraries. It was inspired by RemDebug but does not have its remote facilities.@@@ctrace − A tool for tracing Lua API calls.@@@xdbLua − A simple Lua command line debugger for the Windows platform.@@@LuaInterface - Debugger − This project is a debugger extension for LuaInterface. It raises the built in Lua debug interface to a higher level. Interaction with the debugger is done by events and method calls.@@@Rldb − This is a remote Lua debugger via socket, available on both Windows and Linux. It can give you much more features than any existing one.@@@ModDebug − This allows in controlling the execution of another Lua program remotely, set breakpoints, and inspect the current state of the program.|||SciTE − The default windows IDE for Lua provides multiple debugging facilities like breakpoints, step, step into, step over, watch variables and so on.@@@Decoda − This is a graphical debugger with remote debugging support.@@@ZeroBrane Studio − Lua IDE with integrated remote debugger, stack view, watch view, remote console, static analyzer, and more. Works with LuaJIT, Love2d, Moai, and other Lua engines; Windows, OSX, and Linux. Open source.@@@akdebugger − Debugger and editor Lua plugin for Eclipse.@@@luaedit − This features remote debugging, local debugging, syntax highlighting, completion proposal list, parameter proposition engine, advance breakpoint management (including condition system on breakpoints and hit count), function listing, global and local variables listing, watches, solution oriented management.",,"Sr.No.@@@Method & Purpose|||1@@@debug()
Enters interactive mode for debugging, which remains active till we type in only cont in a line and press enter. User can inspect variables during this mode using other functions.|||2@@@getfenv(object)
Returns the environment of object.|||3@@@gethook(optional thread)
Returns the current hook settings of the thread, as three values − the current hook function, the current hook mask, and the current hook count.|||4@@@getinfo(optional thread, function or stack level, optional flag)
Returns a table with info about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread − level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil.|||5@@@getlocal(optional thread, stack level, local index)
Returns the name and the value of the local variable with index local of the function at level of the stack.Returns nil if there is no local variable with the given index, and raises an error when called with a level out of range.|||6@@@getmetatable(value)
Returns the metatable of the given object or nil if it does not have a metatable.|||7@@@getregistry()
Returns the registry table,a pre-defined table that can be used by any C code to store whatever Lua value it needs to store.|||8@@@getupvalue(function, upvalue index)
This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index.|||9@@@setfenv(function or thread or userdata, environment table)
Sets the environment of the given object to the given table. Returns object.|||10@@@sethook(optional thread, hook function, hook mask string with ""c"" and/or ""r"" and/or ""l"", optional instruction count)
Sets the given function as a hook. The string mask and the number count describes when the hook will be called. Here, c, r and l are called every time Lua calls, returns, and enters every line of code in a function respectively.|||11@@@setlocal(optional thread, stack level, local index, value)
Assigns the value to the local variable with index local of the function at level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. Otherwise, it returns the name of the local variable.|||12@@@setmetatable(value, metatable)
Sets the metatable for the given object to the given table (which can be nil).|||13@@@setupvalue(function, upvalue index, value)
This function assigns the value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.|||14@@@traceback(optional thread, optional message string, optional level argument)
Builds an extended error message with a traceback.","function myfunction ()   print(debug.traceback(""Stack trace""))   print(debug.getinfo(1))   print(""Stack trace end"")   return 10endmyfunction ()print(debug.getinfo(1))|||function newCounter ()   local n = 0   local k = 0	   return function ()      k = n      n = n + 1      return n   end	endcounter = newCounter ()print(counter())print(counter())local i = 1repeat   name, val = debug.getupvalue(counter, i)	   if name then      print (""index"", i, name, ""="", val)		      if(name == ""n"") then         debug.setupvalue (counter,2,10)      end		      i = i + 1   end -- if	until not nameprint(counter())"
Learn Lua,Lua - Garbage Collection,Lua - Garbage Collection|||Garbage Collector Pause@@@Garbage Collector Step Multiplier@@@Garbage Collector Functions@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua uses automatic memory management that uses garbage collection based on certain algorithms that is in-built in Lua. As a result of automatic memory management, as a developer −|||Lua uses a garbage collector that runs from time to time to collect dead objects when they are no longer accessible from the Lua program.|||All objects including tables, userdata, functions, thread, string and so on are subject to automatic memory management. Lua uses incremental mark and sweep collector that uses two numbers to control its garbage collection cycles namely garbage collector pause and garbage collector step multiplier. These values are in percentage and value of 100 is often equal to 1 internally.|||Garbage collector pause is used for controlling how long the garbage collector needs to wait, before; it is called again by the Lua's automatic memory management. Values less than 100 would mean that Lua will not wait for the next cycle. Similarly, higher values of this value would result in the garbage collector being slow and less aggressive in nature. A value of 200, means that the collector waits for the total memory in use to double before starting a new cycle. Hence, depending on the nature and speed of application, there may be a requirement to alter this value to get best performance in Lua applications.|||This step multiplier controls the relative speed of garbage collector to that of memory allocation in Lua program. Larger step values will lead to garbage collector to be more aggressive and it also increases the step size of each incremental step of garbage collection. Values less than 100 could often lead to avoid the garbage collector not to complete its cycle and its not generally preferred. The default value is 200, which means the garbage collector runs twice as the speed of memory allocation.|||As developers, we do have some control over the automatic memory management in Lua. For this, we have the following methods.|||collectgarbage(""collect"") − Runs one complete cycle of garbage collection.|||collectgarbage(""count"") − Returns the amount of memory currently used by the program in Kilobytes.|||collectgarbage(""restart"") − If the garbage collector has been stopped, it restarts it.|||collectgarbage(""setpause"") − Sets the value given as second parameter divided by 100 to the garbage collector pause variable. Its uses are as discussed a little above.|||collectgarbage(""setstepmul"") − Sets the value given as second parameter divided by 100 to the garbage step multiplier variable. Its uses are as discussed a little above.|||collectgarbage(""step"") − Runs one step of garbage collection. The larger the second argument is, the larger this step will be. The collectgarbage will return true if the triggered step was the last step of a garbage-collection cycle.|||collectgarbage(""stop"") − Stops the garbage collector if its running.|||A simple example using the garbage collector example is shown below.|||When we run the above program, we will get the following output. Please note that this result will vary due to the difference in type of operating system and also the automatic memory management feature of Lua.|||You can see in the above program, once garbage collection is done, it reduced the memory used. But, it's not mandatory to call this. Even if we don't call them, it will be executed automatically at a later stage by Lua interpreter after the predefined period.|||Obviously, we can change the behavior of the garbage collector using these functions if required. These functions provide a bit of additional capability for the developer to handle complex situations. Depending on the type of memory need for the program, you may or may not use this feature. But it is very useful to know the memory usage in the applications and check it during the programming itself to avoid undesired results after deployment.","No need to worry about allocating memory for objects.@@@No need to free them when no longer needed except for setting it to nil.|||collectgarbage(""collect"") − Runs one complete cycle of garbage collection.@@@collectgarbage(""count"") − Returns the amount of memory currently used by the program in Kilobytes.@@@collectgarbage(""restart"") − If the garbage collector has been stopped, it restarts it.@@@collectgarbage(""setpause"") − Sets the value given as second parameter divided by 100 to the garbage collector pause variable. Its uses are as discussed a little above.@@@collectgarbage(""setstepmul"") − Sets the value given as second parameter divided by 100 to the garbage step multiplier variable. Its uses are as discussed a little above.@@@collectgarbage(""step"") − Runs one step of garbage collection. The larger the second argument is, the larger this step will be. The collectgarbage will return true if the triggered step was the last step of a garbage-collection cycle.@@@collectgarbage(""stop"") − Stops the garbage collector if its running.",,,"mytable = {""apple"", ""orange"", ""banana""}print(collectgarbage(""count""))mytable = nilprint(collectgarbage(""count""))print(collectgarbage(""collect""))print(collectgarbage(""count""))"
Learn Lua,Lua - Object Oriented,Lua - Object Oriented|||Introduction to OOP@@@Features of OOP@@@OOP in Lua@@@A Real World Example@@@Creating a Simple Class@@@Creating an Object@@@Accessing Properties@@@Accessing Member Function@@@Complete Example@@@Inheritance in Lua@@@Over-riding Base Functions@@@Inheritance Complete Example@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Object Oriented Programming (OOP), is one the most used programming technique that is used in the modern era of programming. There are a number of programming languages that support OOP which include,|||Class − A class is an extensible template for creating objects, providing initial values for state (member variables) and implementations of behavior.|||Objects − It is an instance of class and has separate memory allocated for itself.|||Inheritance − It is a concept by which variables and functions of one class is inherited by another class.|||Encapsulation − It is the process of combining the data and functions inside a class. Data can be accessed outside the class with the help of functions. It is also known as data abstraction.|||You can implement object orientation in Lua with the help of tables and first class functions of Lua. By placing functions and related data into a table, an object is formed. Inheritance can be implemented with the help of metatables, providing a look up mechanism for nonexistent functions(methods) and fields in parent object(s).|||Tables in Lua have the features of object like state and identity that is independent of its values. Two objects (tables) with the same value are different objects, whereas an object can have different values at different times, but it is always the same object. Like objects, tables have a life cycle that is independent of who created them or where they were created.|||The concept of object orientation is widely used but you need to understand it clearly for proper and maximum benefit.|||Let us consider a simple math example. We often encounter situations where we work on different shapes like circle, rectangle and square.|||The shapes can have a common property Area. So, we can extend other shapes from the base object shape with the common property area. Each of the shapes can have its own properties and functions like a rectangle can have properties length, breadth, area as its properties and printArea and calculateArea as its functions.|||A simple class implementation for a rectangle with three properties area, length, and breadth is shown below. It also has a printArea function to print the area calculated.|||Creating an object is the process of allocating memory for the class instance. Each of the objects has its own memory and share the common class data.|||We can access the properties in the class using the dot operator as shown below −|||You can access a member function using the colon operator with the object as shown below −|||The memory gets allocated and the initial values are set. The initialization process can be compared to constructors in other object oriented languages. It is nothing but a function that enables setting values as shown above.|||Lets look at a complete example using object orientation in Lua.|||When you run the above program, you will get the following output.|||Inheritance is the process of extending simple base objects like shape to rectangles, squares and so on. It is often used in the real world to share and extend the basic properties and functions.|||Let us see a simple class extension. We have a class as shown below.|||We can extend the shape to a square class as shown below.|||We can override the base class functions that is instead of using the function in the base class, derived class can have its own implementation as shown below −|||We can extend the simple class implementation in Lua as shown above with the help of another new method with the help of metatables. All the member variables and functions of base class are retained in the derived class.|||When we run the above program, we will get the following output −|||In the above example, we have created two derived classes − Rectangle and Square from the base class Square. It is possible to override the functions of the base class in derived class. In this example, the derived class overrides the function printArea.","C++@@@Java@@@Objective-C@@@Smalltalk@@@C#@@@Ruby|||Class − A class is an extensible template for creating objects, providing initial values for state (member variables) and implementations of behavior.@@@Objects − It is an instance of class and has separate memory allocated for itself.@@@Inheritance − It is a concept by which variables and functions of one class is inherited by another class.@@@Encapsulation − It is the process of combining the data and functions inside a class. Data can be accessed outside the class with the help of functions. It is also known as data abstraction.",,,"-- Meta classRectangle = {area = 0, length = 0, breadth = 0}-- Derived class method newfunction Rectangle:new (o,length,breadth)   o = o or {}   setmetatable(o, self)   self.__index = self   self.length = length or 0   self.breadth = breadth or 0   self.area = length*breadth;   return oend-- Derived class method printAreafunction Rectangle:printArea ()   print(""The area of Rectangle is "",self.area)end|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end-- Creating an objectmyshape = Shape:new(nil,10)myshape:printArea()|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end|||Square = Shape:new()-- Derived class method newfunction Square:new (o,side)   o = o or Shape:new(o,side)   setmetatable(o, self)   self.__index = self   return oend|||-- Derived class method printAreafunction Square:printArea ()   print(""The area of square is "",self.area)end|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end-- Creating an objectmyshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- Derived class method newfunction Square:new (o,side)   o = o or Shape:new(o,side)   setmetatable(o, self)   self.__index = self   return oend-- Derived class method printAreafunction Square:printArea ()   print(""The area of square is "",self.area)end-- Creating an objectmysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- Derived class method newfunction Rectangle:new (o,length,breadth)   o = o or Shape:new(o)   setmetatable(o, self)   self.__index = self   self.area = length * breadth   return oend-- Derived class method printAreafunction Rectangle:printArea ()    print(""The area of Rectangle is "",self.area)end-- Creating an objectmyrectangle = Rectangle:new(nil,10,20)myrectangle:printArea()"
Learn Lua,Lua - Web Programming,"Lua - Web Programming|||Applications and Frameworks@@@Orbit@@@Simple Example − Orbit@@@Creating Forms@@@WSAPI@@@Xavante@@@Lua Web Components@@@Ending Note@@@Useful Video Courses|||Installing Apache@@@Install LuaRocks@@@Install WSAPI, FCGI, Orbit, and Xavante@@@Setting up Apache2|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable","Lua is a highly flexible language and it is often used in multiple platforms including web applications. The Kepler community that was formed in 2004 to provide open source web components in Lua.|||Even though, there are other web frameworks using Lua that have been developed, we will be primarily focusing on the components provided by Kepler community.|||Orbit is an MVC web framework for Lua, based on WSAPI.|||WSAPI is the API that abstracts the web host server from Lua web applications and is the base for many projects.|||Xavante is a Lua Web server that offers a WSAPI interface.|||Sputnik is a wiki/CMS developed over WSAPI on Kepler Project used for humor and entertainment.|||CGILua offers LuaPages and LuaScripts web page creation, based on WSAPI but no longer supported. Use Orbit, Sputnik or WSAPI instead.|||In this tutorial, we will try to make you understand what Lua can do and to know more about its installation and usage, refer kepler the website|||Orbit is an MVC web framework for Lua. It completely abandons the CGILua model of ""scripts"" in favor of applications, where each Orbit application can fit in a single file, but you can split it into multiple files if you want.|||All Orbit applications follow the WSAPI protocol, so they currently work with Xavante, CGI and Fastcgi. It includes a launcher that makes it easy to launch a Xavante instance for development.|||The easiest way to install Orbit is using LuaRocks. Luarocks install orbit is the command for installing. For this, you need to install  LuaRocks first.|||If you haven't installed all the dependencies, here are the steps to be followed to setup Orbit in Unix/Linux environment.|||Connect to your server. Install Apache2, its support modules and enable required Apache2 modules using −|||Add this following section below the <Directory /var/www/> section of the config file. If this section has an 'AllowOverride None' then you need to change the 'None' to 'All' so that the .htaccess file can override the configuration locally.|||Restart the server to ensure the changes made comes into effect.|||To enable your application, you need to add +ExecCGI to an .htaccess file in the root of your Orbit application − in this case, /var/www.|||Now, you should be able to launch your web browser. Go to http://localhost:8080/ and you should see the following output −|||Orbit provides another option, i.e., Lua code can generate html.|||A simple form example is shown below −|||As mentioned earlier, WSAPI acts as the base for many projects and have multiple features embedded in it. You can use WSAPI and support the following platforms,|||The supported servers and interfaces by WSAPI includes,|||WSAPI provides a number of libraries, which makes it easier for us in web programming using Lua. Some of the supported features in Lua includes,|||A simple example of WSAPI is shown below −|||You can see in the above code a simple html page is formed and returned. You can see the usage of coroutines that makes it possible to return statement by statement to calling function. Finally, html status code(200), headers and html page is returned.|||Xavante is a Lua HTTP 1.1 Web server that uses a modular architecture based on URI mapped handlers. Xavante currently offers,|||File handler is used for general files. Redirect handler enables URI remapping and WSAPI handler for handing with WSAPI applications.|||A simple example is shown below.|||To use virtual hosts with Xavante, the call to xavante.HTTP would be changed to something like as follows −|||Copas, a dispatcher based on coroutines that can be used by TCP/IP servers.|||Cosmo, a ""safe templates"" engine that protects your application from arbitrary code in the templates.|||Coxpcall encapsulates Lua native pcall and xpcall with coroutine compatible ones.|||LuaFileSystem, a portable way to access the underlying directory structure and file attributes.|||Rings, a library which provides a way to create new Lua states from within Lua.|||There are so many Lua based web frameworks and components available for us and based on the need, it can be chosen. There are other web frameworks available which include the following −|||Moonstalk enables efficient development and hosting of dynamically generated web-based projects built with the Lua language; from basic pages to complex applications.|||Lapis, a framework for building web applications using MoonScript (or Lua) that runs inside of a customized version of Nginx called OpenResty.|||Lua Server Pages, a Lua scripting engine plug-in that blows away any other approach to embedded web development, offers a dramatic short cut to traditional C server pages.|||These web frameworks can leverage your web applications and help you in doing powerful operations.","Orbit is an MVC web framework for Lua, based on WSAPI.@@@WSAPI is the API that abstracts the web host server from Lua web applications and is the base for many projects.@@@Xavante is a Lua Web server that offers a WSAPI interface.@@@Sputnik is a wiki/CMS developed over WSAPI on Kepler Project used for humor and entertainment.@@@CGILua offers LuaPages and LuaScripts web page creation, based on WSAPI but no longer supported. Use Orbit, Sputnik or WSAPI instead.|||Windows@@@UNIX-based systems|||CGI@@@FastCGI@@@Xavante|||Request processing@@@Output buffering@@@Authentication@@@File uploads@@@Request isolation@@@Multiplexing|||File handler@@@Redirect handler@@@WSAPI handler|||Copas, a dispatcher based on coroutines that can be used by TCP/IP servers.@@@Cosmo, a ""safe templates"" engine that protects your application from arbitrary code in the templates.@@@Coxpcall encapsulates Lua native pcall and xpcall with coroutine compatible ones.@@@LuaFileSystem, a portable way to access the underlying directory structure and file attributes.@@@Rings, a library which provides a way to create new Lua states from within Lua.|||Moonstalk enables efficient development and hosting of dynamically generated web-based projects built with the Lua language; from basic pages to complex applications.@@@Lapis, a framework for building web applications using MoonScript (or Lua) that runs inside of a customized version of Nginx called OpenResty.@@@Lua Server Pages, a Lua scripting engine plug-in that blows away any other approach to embedded web development, offers a dramatic short cut to traditional C server pages.",,,"<IfModule mod_fcgid.c>   AddHandler fcgid-script .lua   AddHandler fcgid-script .ws   AddHandler fcgid-script .op	   FCGIWrapper ""/usr/local/bin/wsapi.fcgi"" .ws   FCGIWrapper ""/usr/local/bin/wsapi.fcgi"" .lua   FCGIWrapper ""/usr/local/bin/op.fcgi"" .op	   #FCGIServer ""/usr/local/bin/wsapi.fcgi"" -idle-timeout 60 -processes 1   #IdleTimeout 60   #ProcessLifeTime 60	</IfModule>|||#!/usr/bin/env index.lua-- index.luarequire""orbit""-- declarationmodule(""myorbit"", package.seeall, orbit.new)-- handlerfunction index(web)   return my_home_page()end-- dispatchmyorbit:dispatch_get(index, ""/"", ""/index"")-- Sample pagefunction my_home_page()   return [[      <head></head>      <html>         <h2>First Page</h2>      </html>   ]]	end|||#!/usr/bin/env index.lua-- index.luarequire""orbit""function generate()   return html {      head{title ""HTML Example""},		      body{         h2{""Here we go again!""}      }   }endorbit.htmlify(generate)print(generate())|||#!/usr/bin/env index.luarequire""orbit""function wrap (inner)   return html{ head(), body(inner) }endfunction test ()   return wrap(form (H'table' {      tr{td""First name"",td( input{type = 'text', name='first'})},      tr{td""Second name"",td(input{type = 'text', name='second'})},      tr{ td(input{type = 'submit', value = 'Submit!'}),         td(input{type = 'submit',value = 'Cancel'})      },   }))endorbit.htmlify(wrap,test)print(test())|||#!/usr/bin/env wsapi.cgimodule(..., package.seeall)function run(wsapi_env)   local headers = { [""Content-type""] = ""text/html"" }      local function hello_text()      coroutine.yield(""<html><body>"")      coroutine.yield(""<p&gtHello Wsapi!</p>"")      coroutine.yield(""<p&gtPATH_INFO: "" .. wsapi_env.PATH_INFO .. ""</p>"")      coroutine.yield(""<p&gtSCRIPT_NAME: "" .. wsapi_env.SCRIPT_NAME .. ""</p>"")      coroutine.yield(""</body></html>"")   end   return 200, headers, coroutine.wrap(hello_text)end|||require ""xavante.filehandler""require ""xavante.cgiluahandler""require ""xavante.redirecthandler""-- Define here where Xavante HTTP documents scripts are locatedlocal webDir = XAVANTE_WEBlocal simplerules = {   { -- URI remapping example      match = ""^[^%./]*/$"",      with = xavante.redirecthandler,      params = {""index.lp""}   },    { -- cgiluahandler example      match = {""%.lp$"", ""%.lp/.*$"", ""%.lua$"", ""%.lua/.*$"" },      with = xavante.cgiluahandler.makeHandler (webDir)   },       { -- filehandler example      match = ""."",      with = xavante.filehandler,      params = {baseDir = webDir}   },} xavante.HTTP{   server = {host = ""*"", port = 8080},       defaultHost = {      rules = simplerules   },}|||xavante.HTTP{   server = {host = ""*"", port = 8080},       defaultHost = {},       virtualhosts = {      [""www.sitename.com""] = simplerules   }}"
Learn Lua,Lua - Database Access,Lua - Database Access|||MySQL db Setup@@@Importing MySQL@@@Setting up Connection@@@Execute Function@@@Create Table Example@@@Insert Statement Example@@@Update Statement Example@@@Delete Statement Example@@@Select Statement Example@@@A Complete Example@@@Performing Transactions@@@Start Transaction@@@Rollback Transaction@@@Commit Transaction@@@Importing SQLite@@@Setting Up Connection@@@Execute Function@@@Create Table Example@@@Insert Statement Example@@@Select Statement Example@@@A Complete Example@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"For simple data operations, we may use files, but, sometimes, these file operations may not be efficient, scalable, and powerful. For this purpose, we may often switch to using databases. LuaSQL is a simple interface from Lua to a number of database management systems. LuaSQL is the library, which provides support for different types of SQL. This include,|||In this tutorial, we will be covering database handling of MySQL an SQLite in Lua. This uses a generic interface for both and should be possible to port this implementation to other types of databases as well. First let see how you can do the operations in MySQL.|||In order to use the following examples to work as expected, we need the initial db setup. The assumptions are listed below.|||You have installed and setup MySQL with default user as root and password as '123456'.|||You have created a database test.|||You have gone through MySQL tutorial to understand MySQL Basics.|||We can use a simple require statement to import the sqlite library assuming that your Lua implementation was done correctly.|||The variable mysql will provide access to the functions by referring to the main mysql table.|||We can set up the connection by initiating a MySQL environment and then creating a connection for the environment. It is shown below.|||The above connection will connect to an existing MySQL file and establishes the connection with the newly created file.|||There is a simple execute function available with the connection that will help us to do all the db operations from create, insert, delete, update and so on. The syntax is shown below −|||In the above syntax, we need to ensure that conn is open and existing MySQL connection and replace the 'MySQLSTATEMENT' with the correct statement.|||A simple create table example is shown below. It creates a table with two parameters id of type integer and name of type varchar.|||When you run the above program, a table named sample will be created with two columns namely, id and name.|||In case there is any error, you would be returned an error statement instead of nil. A simple error statement is shown below.|||An insert statement for MySQL is shown below.|||An update statement for MySQL is shown below.|||A delete statement for MySQL is shown below.|||As far as select statement is concerned, we need to loop through each of the rows and extract the required data. A simple select statement is shown below.|||In the above code, conn is an open MySQL connection. With the help of the cursor returned by the execute statement, you can loop through the table response and fetch the required select data.|||A complete example including all the above statements is given below.|||When you run the above program, you will get the following output.|||Transactions are a mechanism that ensures data consistency. Transactions should have the following four properties −|||Atomicity − Either a transaction completes or nothing happens at all.|||Consistency − A transaction must start in a consistent state and leave the system in a consistent state.|||Isolation − Intermediate results of a transaction are not visible outside the current transaction.|||Durability − Once a transaction was committed, the effects are persistent, even after a system failure.|||Transaction starts with START TRANSACTION; and ends with commit or rollback statement.|||In order to initiate a transaction, we need to execute the following statement in Lua, assuming conn is an open MySQL connection.|||We need to execute the following statement to rollback changes made after start transaction is executed.|||We need to execute the following statement to commit changes made after start transaction is executed.|||We have known about MySQL in the above and following section explains about basic SQL operations. Remember transactions, though not explained again for SQLite3 but the same statements should work for SQLite3 as well.|||We can use a simple require statement to import the SQLite library assuming that your Lua implementation was done correctly. During installation, a folder libsql that contains the database related files.|||The variable sqlite3 will provide access to the functions by referring to the main sqlite3 table.|||We can set up the connection by initiating an SQLite environment and then creating a connection for the environment. It is shown below.|||The above connection will connect to an existing SQLite file or creates a new SQLite file and establishes the connection with the newly created file.|||There is a simple execute function available with the connection that will help us to do all the db operations from create, insert, delete, update and so on. The syntax is shown below −|||In the above syntax we need to ensure that conn is open and existing sqlite3 connection and replace the 'SQLite3STATEMENT' with the correct statement.|||A simple create table example is shown below. It creates a table with two parameters id of type integer and name of type varchar.|||When you run the above program, a table named sample will be created with two columns namely, id and name.|||In case of an error, you would be returned a error statement instead of nil. A simple error statement is shown below.|||An insert statement for SQLite is shown below.|||As far as select statement is concerned, we need to loop through each of the rows and extract the required data. A simple select statement is shown below.|||In the above code, conn is an open sqlite3 connection. With the help of the cursor returned by the execute statement, you can loop through the table response and fetch the required select data.|||A complete example including all the above statements is given below.|||When you run the above program, you will get the following output.|||We can execute all the available queries with the help of this libsql library. So, please don't stop with these examples. Experiment various query statement available in respective MySQL, SQLite3 and other supported db in Lua.","SQLite@@@Mysql@@@ODBC|||You have installed and setup MySQL with default user as root and password as '123456'.@@@You have created a database test.@@@You have gone through MySQL tutorial to understand MySQL Basics.|||Atomicity − Either a transaction completes or nothing happens at all.@@@Consistency − A transaction must start in a consistent state and leave the system in a consistent state.@@@Isolation − Intermediate results of a transaction are not visible outside the current transaction.@@@Durability − Once a transaction was committed, the effects are persistent, even after a system failure.",,,"mysql = require ""luasql.mysql""local env  = mysql.mysql()local conn = env:connect('test','root','123456')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample2 (id INTEGER, name TEXT);]])print(status,errorString )|||cursor,errorString = conn:execute([[select * from sample]])row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   -- reusing the table of results   row = cursor:fetch (row, ""a"")end|||mysql = require ""luasql.mysql""local env  = mysql.mysql()local conn = env:connect('test','root','123456')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample3 (id INTEGER, name TEXT)]])print(status,errorString )status,errorString = conn:execute([[INSERT INTO sample3 values('12','Raj')]])print(status,errorString )cursor,errorString = conn:execute([[select * from sample3]])print(cursor,errorString)row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   row = cursor:fetch (row, ""a"")end-- close everythingcursor:close()conn:close()env:close()|||sqlite3 = require ""luasql.sqlite3""local env  = sqlite3.sqlite3()local conn = env:connect('mydb.sqlite')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample ('id' INTEGER, 'name' TEXT)]])print(status,errorString )|||cursor,errorString = conn:execute([[select * from sample]])row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   -- reusing the table of results   row = cursor:fetch (row, ""a"")end|||sqlite3 = require ""luasql.sqlite3""local env  = sqlite3.sqlite3()local conn = env:connect('mydb.sqlite')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample ('id' INTEGER, 'name' TEXT)]])print(status,errorString )status,errorString = conn:execute([[INSERT INTO sample values('1','Raj')]])print(status,errorString )cursor,errorString = conn:execute([[select * from sample]])print(cursor,errorString)row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   row = cursor:fetch (row, ""a"")end-- close everythingcursor:close()conn:close()env:close()"
Learn Lua,Lua - Game Programing,Lua - Game Programing|||Corona SDK@@@Gideros Mobile@@@ShiVa3D@@@Moai SDK@@@LOVE@@@CryEngine@@@An Ending Note@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua is used in a lot of game engines due to its simple language structure and syntax. The garbage collection feature is often quite useful in games which consume a lot of memory due to rich graphics that is used. Some game engines that use Lua includes −|||Each of these game engines are based on Lua and there is a rich set of API available in each of these engines. We will look at the capabilities of each in brief.|||Corona SDK is a cross platform mobile game engine that supports iPhone, iPad, and Android platforms. There is a free version of Corona SDK that can be used for small games with limited features. You can upgrade to other versions when needed.|||Corona SDK provides a number of features which includes the following −|||It is easier and faster to develop an application using the above APIs rather than using the native APIs separately for iOS and Android.|||Gideros provides the cross-platform SDK to create games for iOS and Android. It is free to use with a made with Gideros splash. Some of the striking advantages in Gideoros includes, the following −|||Development IDE − It provides its own IDE which makes it easier to develop Gideros apps.|||Instant testing − While developing your game, it can be tested on a real device through Wifi in only 1 second. You don't need to waste your time with an export or deploy process.|||Plugins − You can easily extend the core with plugins. Import your existing (C, C++, Java or Obj-C) code, bind to Lua and interpret them directly. Dozens of open-source plugins are already developed and ready to use.|||Clean OOP approach − Gideros provides its own class system with all the basic OOP standards, enabling you to write clean and reusable code for any of your future games.|||Native speed − Developed on top of C/C++ and OpenGL, your game runs at native speed and fully utilizes the power of CPUs and GPUs underneath.|||ShiVa3D is one of 3D game engines which provides a graphical editor designed to create applications and video games for the Web, Consoles and Mobile devices. It supports multiple platforms which includes, Windows, Mac, Linux, iOS, Android, BlackBerry, Palm OS, Wii and WebOS.|||Some of the major features include|||The web edition of Shiva3d is completely free and other editions you have subscribe.|||Moai SDK is a cross platform mobile game engine that supports iPhone, iPad, and Android platforms. Moai platform initially consisted of Moai SDK, an open source game engine, and Moai Cloud, a cloud platform as a service for the hosting and deployment of game services. Now the Moai Cloud is shutdown and only the game engine is available.|||Moai SDK runs on multiple platforms including iOS, Android, Chrome, Windows, Mac and Linux.|||LOVE is a framework that you can use to make 2D games. It is free and open-source. It supports Windows, Mac OS X and Linux platforms.|||It provides multiple features which include,|||CryEngine is a game engine developed by the German game developer Crytek. It has evolved from generation 1 to generation 4 and is an advanced development solution. It supports PC, Xbox 360, PlayStation3 and WiiU games.|||It provides multiple features which include,|||Visual effects like Natural Lighting & Dynamic Soft Shadows, Real-time Dynamic Global Illumination, Light Propagation Volume, Particle Shading, Tessellation and so on.|||Character Animation System and Character Individualization System.|||Parametric Skeletal Animation and Unique Dedicated Facial Animation Editor|||AI Systems like Multi-Layer Navigation Mesh and Tactical Point System. Also provides Designer-Friendly AI Editing System.|||In Game Mixing & Profiling, Data-driven Sound System Dynamic Sounds & Interactive Music and so on.|||Physics features like Procedural Deformation and Advanced Rope Physics.|||Each of these Game SDKs/frameworks have their own advantages and disadvantages. A proper choice between them makes your task easier and you can have a better time with it. So, before using it, you need to know the requirements for your game and then analyze which satisfies all your needs and then should use them.","Corona SDK@@@Gideros Mobile@@@ShiVa3D@@@Moai SDK@@@LOVE@@@CryEngine|||Physics and Collision handling APIs@@@Web and Network APIs@@@Game Network API@@@Ads API@@@Analytics API@@@Database and File System APIs@@@Crypto and Math APIs@@@Audio and Media APIs|||Development IDE − It provides its own IDE which makes it easier to develop Gideros apps.@@@Instant testing − While developing your game, it can be tested on a real device through Wifi in only 1 second. You don't need to waste your time with an export or deploy process.@@@Plugins − You can easily extend the core with plugins. Import your existing (C, C++, Java or Obj-C) code, bind to Lua and interpret them directly. Dozens of open-source plugins are already developed and ready to use.@@@Clean OOP approach − Gideros provides its own class system with all the basic OOP standards, enabling you to write clean and reusable code for any of your future games.@@@Native speed − Developed on top of C/C++ and OpenGL, your game runs at native speed and fully utilizes the power of CPUs and GPUs underneath.|||Standard plugins@@@Mesh modification API@@@IDE@@@Built-in Terrain, Ocean and animation editor@@@ODE physics engine support@@@Full lightmap control@@@Live preview for materials, particles, trails and HUDs@@@Collada exchange format support|||Audio API@@@File System API@@@Keyboard and Joystick APIs@@@Math API@@@Window and Mouse APIs@@@Physics API@@@System and timer APIs|||Visual effects like Natural Lighting & Dynamic Soft Shadows, Real-time Dynamic Global Illumination, Light Propagation Volume, Particle Shading, Tessellation and so on.@@@Character Animation System and Character Individualization System.@@@Parametric Skeletal Animation and Unique Dedicated Facial Animation Editor@@@AI Systems like Multi-Layer Navigation Mesh and Tactical Point System. Also provides Designer-Friendly AI Editing System.@@@In Game Mixing & Profiling, Data-driven Sound System Dynamic Sounds & Interactive Music and so on.@@@Physics features like Procedural Deformation and Advanced Rope Physics.",,,
Learn Lua,Lua - Standard Libraries,Lua - Standard Libraries|||Basic Library@@@Modules Library@@@String manipulation@@@Table manipulation@@@File Input and output@@@Debug facilities@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"Lua standard libraries provide a rich set of functions that is implemented directly with the C API and is in-built with Lua programming language. These libraries provide services within the Lua programming language and also outside services like file and db operations.|||These standard libraries built in official C API are provided as separate C modules. It includes the following −|||We have used the basic library throughout the tutorial under various topics. The following table provides links of related pages and lists the functions that are covered in various part of this Lua tutorial.|||Error Handling|||Includes error handling functions like assert, error as explained in Lua - Error Handling.|||Memory Management|||Includes the automatic memory management functions related to garbage collection as explained in Lua - Garbage Collection.|||dofile ([filename])|||It opens the file and executes the contents of the file as a chunk. If no parameter is passed, then this function executes the contents of standard input. The errors will be propagated to the caller.|||_G |||Thus is the global variable that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable.|||getfenv ([f])|||Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.|||getmetatable (object)|||If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a ""__metatable"" field, returns the associated value. Otherwise, returns the metatable of the given object.|||ipairs (t)|||This functions fetches the indices and values of tables.|||load (func [, chunkname])|||Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results.|||loadfile ([filename]))|||Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.|||loadstring (string [, chunkname])|||Similar to load, but gets the chunk from the given string.|||next (table [, index])|||Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value.|||pairs (t)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||print (...)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||rawequal (v1, v2)|||Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.|||rawget (table, index)|||Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.|||rawset (table, index, value)|||Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. This function returns table.|||select (index, ...)|||If index is a number, returns all arguments after argument number index. Otherwise, index must be the string ""#"", and select returns the total number of extra arguments it received.|||setfenv (f, table)|||Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling setfenv. setfenv returns the given function. As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values.|||setmetatable (table, metatable)|||Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a ""__metatable"" field, raises an error. This function returns table.|||tonumber (e [, base])|||Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.|||tostring (e)|||Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.|||type (v)|||Returns the type of its only argument, coded as a string. The possible results of this function are ""nil"" (a string, not the value nil), ""number"", ""string"", ""boolean"", ""table"", ""function"", ""thread"", and ""userdata"".|||unpack (list [, i [, j]])|||Returns the elements from the given table.|||_VERSION|||A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is ""Lua 5.1"".|||Coroutines|||Includes the coroutine manipulation functions as explained in Lua - Coroutines.|||The modules library provides the basic functions for loading modules in Lua. It exports one function directly in the global environment: require. Everything else is exported in a table package. The details about the modules library is explained in the earlier chapter Lua - Modules tutorial.|||Lua provides a rich set of string manipulation functions. The earlier Lua - Strings tutorial covers this in detail.|||Lua depends on tables in almost every bit of its operations. The earlier Lua - Tables tutorial covers this in detail.|||We often need data storage facility in programming and this is provided by standard library functions for file I/O in Lua. It is discussed in earlier Lua - File I/O tutorial.|||Lua provides a debug library which provides all the primitive functions for us to create our own debugger. It is discussed in earlier Lua - Debugging tutorial.","Basic library, which includes the coroutine sub-library@@@Modules library@@@String manipulation@@@Table manipulation@@@Math library@@@File Input and output@@@Operating system facilities@@@Debug facilities",,"Sr.No.@@@Library / Method & Purpose|||1@@@Error Handling
Includes error handling functions like assert, error as explained in Lua - Error Handling.|||2@@@Memory Management
Includes the automatic memory management functions related to garbage collection as explained in Lua - Garbage Collection.|||3@@@dofile ([filename])
It opens the file and executes the contents of the file as a chunk. If no parameter is passed, then this function executes the contents of standard input. The errors will be propagated to the caller.|||4@@@_G 
Thus is the global variable that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable.|||5@@@getfenv ([f])
Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.|||6@@@getmetatable (object)
If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a ""__metatable"" field, returns the associated value. Otherwise, returns the metatable of the given object.|||7@@@ipairs (t)
This functions fetches the indices and values of tables.|||8@@@load (func [, chunkname])
Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results.|||9@@@loadfile ([filename]))
Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.|||10@@@loadstring (string [, chunkname])
Similar to load, but gets the chunk from the given string.|||11@@@next (table [, index])
Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value.|||12@@@pairs (t)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||13@@@print (...)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||14@@@rawequal (v1, v2)
Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.|||15@@@rawget (table, index)
Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.|||16@@@rawset (table, index, value)
Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. This function returns table.|||17@@@select (index, ...)
If index is a number, returns all arguments after argument number index. Otherwise, index must be the string ""#"", and select returns the total number of extra arguments it received.|||18@@@setfenv (f, table)
Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling setfenv. setfenv returns the given function. As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values.|||19@@@setmetatable (table, metatable)
Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a ""__metatable"" field, raises an error. This function returns table.|||20@@@tonumber (e [, base])
Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.|||21@@@tostring (e)
Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.|||22@@@type (v)
Returns the type of its only argument, coded as a string. The possible results of this function are ""nil"" (a string, not the value nil), ""number"", ""string"", ""boolean"", ""table"", ""function"", ""thread"", and ""userdata"".|||23@@@unpack (list [, i [, j]])
Returns the elements from the given table.|||24@@@_VERSION
A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is ""Lua 5.1"".|||25@@@Coroutines
Includes the coroutine manipulation functions as explained in Lua - Coroutines.",
Learn Lua,Lua - Math library,Lua - Math library|||Trigonometric functions@@@Other common math functions@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"We often need math operations in scientific and engineering calculations and we can avail this using the standard Lua library math. The list of functions available in math library is shown in the following table.|||math.abs (x)|||Returns the absolute value of x.|||math.acos (x)|||Returns the arc cosine of x (in radians).|||math.asin (x)|||Returns the arc sine of x (in radians).|||math.atan (x)|||Returns the arc tangent of x (in radians).|||math.atan2 (y, x)|||Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)|||math.ceil (x)|||Returns the smallest integer larger than or equal to x.|||math.cos (x)|||Returns the cosine of x (assumed to be in radians).|||math.cosh (x)|||Returns the hyperbolic cosine of x.|||math.deg (x)|||Returns the angle x (given in radians) in degrees.|||math.exp (x)|||Returns the value e power x.|||math.floor (x)|||Returns the largest integer smaller than or equal to x.|||math.fmod (x, y)|||Returns the remainder of the division of x by y that rounds the quotient towards zero.|||math.frexp (x)|||Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).|||math.huge|||The value HUGE_VAL, a value larger than or equal to any other numerical valu.|||math.ldexp (m, e)|||Returns m2e (e should be an integer).|||math.log (x)|||Returns the natural logarithm of x.|||math.log10 (x)|||Returns the base-10 logarithm of x.|||math.max (x, ...)|||Returns the maximum value among its arguments.|||math.min (x, ...)|||Returns the minimum value among its arguments.|||math.modf (x)|||Returns two numbers, the integral part of x and the fractional part of x.|||math.pi|||The value of pi.|||math.pow (x, y)|||Returns xy. (You can also use the expression x^y to compute this value.)|||math.rad (x)|||Returns the angle x (given in degrees) in radians.|||math.random ([m [, n]])|||This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].|||math.randomseed (x)|||Sets x as the ""seed"" for the pseudo-random generator: equal seeds produce equal sequences of numbers.|||math.sin (x)|||Returns the sine of x (assumed to be in radians).|||math.sinh (x)|||Returns the hyperbolic sine of x.|||math.sqrt (x)|||Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)|||math.tan (x)|||Returns the tangent of x (assumed to be in radians).|||math.tanh (x)|||Returns the hyperbolic tangent of x.|||A simple example using trigonometric function is shown below.|||When we run the above program, we will get the following output.|||A simple example using common math functions is shown below.|||When we run the above program, we will get the following output.|||The above examples are just a few of the common examples, we can use math library based on our need, so try using all the functions to be more familiar.",,,"Sr.No.@@@Library / Method & Purpose|||1@@@math.abs (x)
Returns the absolute value of x.|||2@@@math.acos (x)
Returns the arc cosine of x (in radians).|||3@@@math.asin (x)
Returns the arc sine of x (in radians).|||4@@@math.atan (x)
Returns the arc tangent of x (in radians).|||5@@@math.atan2 (y, x)
Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)|||6@@@math.ceil (x)
Returns the smallest integer larger than or equal to x.|||7@@@math.cos (x)
Returns the cosine of x (assumed to be in radians).|||8@@@math.cosh (x)
Returns the hyperbolic cosine of x.|||9@@@math.deg (x)
Returns the angle x (given in radians) in degrees.|||10@@@math.exp (x)
Returns the value e power x.|||11@@@math.floor (x)
Returns the largest integer smaller than or equal to x.|||12@@@math.fmod (x, y)
Returns the remainder of the division of x by y that rounds the quotient towards zero.|||13@@@math.frexp (x)
Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).|||14@@@math.huge
The value HUGE_VAL, a value larger than or equal to any other numerical valu.|||15@@@math.ldexp (m, e)
Returns m2e (e should be an integer).|||16@@@math.log (x)
Returns the natural logarithm of x.|||17@@@math.log10 (x)
Returns the base-10 logarithm of x.|||18@@@math.max (x, ...)
Returns the maximum value among its arguments.|||19@@@math.min (x, ...)
Returns the minimum value among its arguments.|||20@@@math.modf (x)
Returns two numbers, the integral part of x and the fractional part of x.|||21@@@math.pi
The value of pi.|||22@@@math.pow (x, y)
Returns xy. (You can also use the expression x^y to compute this value.)|||23@@@math.rad (x)
Returns the angle x (given in degrees) in radians.|||24@@@math.random ([m [, n]])
This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].|||25@@@math.randomseed (x)
Sets x as the ""seed"" for the pseudo-random generator: equal seeds produce equal sequences of numbers.|||26@@@math.sin (x)
Returns the sine of x (assumed to be in radians).|||27@@@math.sinh (x)
Returns the hyperbolic sine of x.|||28@@@math.sqrt (x)
Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)|||29@@@math.tan (x)
Returns the tangent of x (assumed to be in radians).|||30@@@math.tanh (x)
Returns the hyperbolic tangent of x.","radianVal = math.rad(math.pi / 2)io.write(radianVal,""\n"")-- Sin value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.sin(radianVal)),""\n"")-- Cos value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.cos(radianVal)),""\n"")-- Tan value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.tan(radianVal)),""\n"")-- Cosh value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.cosh(radianVal)),""\n"")-- Pi Value in degreesio.write(math.deg(math.pi),""\n"")|||-- Floorio.write(""Floor of 10.5055 is "", math.floor(10.5055),""\n"")-- Ceilio.write(""Ceil of 10.5055 is "", math.ceil(10.5055),""\n"")-- Square rootio.write(""Square root of 16 is "",math.sqrt(16),""\n"")-- Powerio.write(""10 power 2 is "",math.pow(10,2),""\n"")io.write(""100 power 0.5 is "",math.pow(100,0.5),""\n"")-- Absoluteio.write(""Absolute value of -10 is "",math.abs(-10),""\n"")--Randommath.randomseed(os.time())io.write(""Random number between 1 and 100 is "",math.random(),""\n"")--Random between 1 to 100io.write(""Random number between 1 and 100 is "",math.random(1,100),""\n"")--Maxio.write(""Maximum in the input array is "",math.max(1,100,101,99,999),""\n"")--Minio.write(""Minimum in the input array is "",math.min(1,100,101,99,999),""\n"")"
Learn Lua,Lua - Operating System Facilities,Lua - Operating System Facilities|||Common OS functions@@@Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,"In any application, it is often required for to access Operating System level functions and it is made available with Operating System library. The list of functions available are listed in the following table.|||os.clock ()|||Returns an approximation of the amount in seconds of CPU time used by the program.|||os.date ([format [, time]])|||Returns a string or a table containing date and time, formatted according to the given string format.|||os.difftime (t2, t1)|||Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.|||os.execute ([command])|||This function is equivalent to the ANSI C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise.|||os.exit ([code [, close])|||Calls the ANSI C function exit to terminate the host program. If code is true, the returned status is EXIT_SUCCESS; if code is false, the returned status is EXIT_FAILURE; if code is a number, the returned status is this number.|||os.getenv (varname)|||Returns the value of the process environment variable varname, or nil if the variable is not defined.|||os.remove (filename)|||Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns nil, plus a string describing the error and the error code.|||os.rename (oldname, newname)||| Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error and the error code.|||os.setlocale (locale [, category])|||Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: ""all"", ""collate"", ""ctype"", ""monetary"", ""numeric"", or ""time""; the default category is ""all"". The function returns the name of the new locale, or nil if the request cannot be honored.|||os.time ([table])|||Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour (default is 12), min (default is 0), sec (default is 0), and isdst (default is nil). For a description of these fields, see the os.date function.|||os.tmpname ()|||Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.|||A simple example using common math functions is shown below.|||When we run the above program, we will get similar output to the following.|||The above examples are just a few of the common examples, we can use OS library based on our need, so try using all the functions to be more familiar. There are functions like remove which helps in removing file, execute that helps us executing OS commands as explained above.",,,"Sr.No.@@@Library / Method & Purpose|||1@@@os.clock ()
Returns an approximation of the amount in seconds of CPU time used by the program.|||2@@@os.date ([format [, time]])
Returns a string or a table containing date and time, formatted according to the given string format.|||3@@@os.difftime (t2, t1)
Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.|||4@@@os.execute ([command])
This function is equivalent to the ANSI C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise.|||5@@@os.exit ([code [, close])
Calls the ANSI C function exit to terminate the host program. If code is true, the returned status is EXIT_SUCCESS; if code is false, the returned status is EXIT_FAILURE; if code is a number, the returned status is this number.|||6@@@os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined.|||7@@@os.remove (filename)
Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns nil, plus a string describing the error and the error code.|||8@@@os.rename (oldname, newname)
 Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error and the error code.|||9@@@os.setlocale (locale [, category])
Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: ""all"", ""collate"", ""ctype"", ""monetary"", ""numeric"", or ""time""; the default category is ""all"". The function returns the name of the new locale, or nil if the request cannot be honored.|||10@@@os.time ([table])
Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour (default is 12), min (default is 0), sec (default is 0), and isdst (default is nil). For a description of these fields, see the os.date function.|||11@@@os.tmpname ()
Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.","-- Date with formatio.write(""The date is "", os.date(""%m/%d/%Y""),""\n"")-- Date and timeio.write(""The date and time is "", os.date(),""\n"")-- Timeio.write(""The OS time is "", os.time(),""\n"")-- Wait for some timefor i=1,1000000 doend-- Time since Lua startedio.write(""Lua started before "", os.clock(),""\n"")"
Learn Lua,Lua - Quick Guide,"Lua - Quick Guide@@@Lua - Overview@@@Lua - Environment@@@Lua - Basic Syntax@@@Lua - Variables@@@Lua - Data Types@@@Lua - Operators@@@Lua - Loops@@@Lua - Decision Making@@@Lua - Functions@@@Lua - Strings@@@Lua - Arrays@@@Lua - Iterators@@@Lua - Tables@@@Lua - Modules@@@Lua - Metatables@@@Lua - Coroutines@@@Lua - File I/O@@@Lua - Error Handling@@@Lua - Debugging@@@Lua - Garbage Collection@@@Lua - Object Oriented@@@Lua - Web Programming@@@Lua - Database Access@@@Lua - Game Programing@@@Lua - Standard Libraries@@@Lua - Math library@@@Lua - Operating System Facilities|||Features@@@How Lua is Implemented?@@@Learning Lua@@@Some Uses of Lua@@@Local Environment Setup@@@Text Editor@@@The Lua Interpreter@@@The Lua Compiler@@@Installation on Windows@@@Installation on Linux@@@Installation on Mac OS X@@@Lua IDE@@@First Lua Program@@@Tokens in Lua@@@Comments@@@Identifiers@@@Keywords@@@Whitespace in Lua@@@Variable Definition in Lua@@@Variable Declaration in Lua@@@Lvalues and Rvalues in Lua@@@Type Function@@@Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Misc Operators@@@Operators Precedence in Lua@@@Loop Control Statement@@@The Infinite Loop@@@Defining a Function@@@Example@@@Function Arguments@@@Calling a Function@@@Assigning and Passing Functions@@@Function with Variable Argument@@@String Manipulation@@@Case Manipulation@@@Replacing a Substring@@@Finding and Reversing@@@Formatting Strings@@@Character and Byte Representations@@@Other Common Functions@@@One-Dimensional Array@@@Multi-Dimensional Array@@@Generic For Iterator@@@Stateless Iterators@@@Stateful Iterators@@@Introduction@@@Representation and Usage@@@Table Manipulation@@@Table Concatenation@@@Insert and Remove@@@Sorting Tables@@@What is a Module?@@@Specialty of Lua Modules@@@The require Function@@@Things to Remember@@@Old Way of Implementing Modules@@@_index@@@__newindex@@@Adding Operator Behavior to Tables@@@__call@@@__tostring@@@Introduction@@@Functions Available in Coroutines@@@Example@@@What Does the Above Example Do?@@@Another Coroutine Example@@@Implicit File Descriptors@@@Explicit File Descriptors@@@Need for Error Handling@@@Assert and Error Functions@@@pcall and xpcall@@@Debugging - Example@@@Debugging Types@@@Garbage Collector Pause@@@Garbage Collector Step Multiplier@@@Garbage Collector Functions@@@Introduction to OOP@@@Features of OOP@@@OOP in Lua@@@A Real World Example@@@Creating a Simple Class@@@Creating an Object@@@Accessing Properties@@@Accessing Member Function@@@Complete Example@@@Inheritance in Lua@@@Over-riding Base Functions@@@Inheritance Complete Example@@@Applications and Frameworks@@@Orbit@@@Simple Example − Orbit@@@Creating Forms@@@WSAPI@@@Xavante@@@Lua Web Components@@@Ending Note@@@MySQL db Setup@@@Importing MySQL@@@Setting up Connection@@@Execute Function@@@Create Table Example@@@Insert Statement Example@@@Update Statement Example@@@Delete Statement Example@@@Select Statement Example@@@A Complete Example@@@Performing Transactions@@@Start Transaction@@@Rollback Transaction@@@Commit Transaction@@@Importing SQLite@@@Setting Up Connection@@@Execute Function@@@Create Table Example@@@Insert Statement Example@@@Select Statement Example@@@A Complete Example@@@Corona SDK@@@Gideros Mobile@@@ShiVa3D@@@Moai SDK@@@LOVE@@@CryEngine@@@An Ending Note@@@Basic Library@@@Modules Library@@@String manipulation@@@Table manipulation@@@File Input and output@@@Debug facilities@@@Trigonometric functions@@@Other common math functions@@@Common OS functions@@@Useful Video Courses|||Example Code@@@Interactive Mode Programming@@@Default Mode Programming@@@Example@@@Example@@@Syntax Errors@@@Run Time Errors@@@Command Line Debugging@@@Graphical Debugging@@@Installing Apache@@@Install LuaRocks@@@Install WSAPI, FCGI, Orbit, and Xavante@@@Setting up Apache2|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable","Lua is an extensible, lightweight programming language written in C. It started as an in-house project in 1993 by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes.|||It was designed from the beginning to be a software that can be integrated with the code written in C and other conventional languages. This integration brings many benefits. It does not try to do what C can already do but aims at offering what C is not good at: a good distance from the hardware, dynamic structures, no redundancies, ease of testing and debugging. For this, Lua has a safe environment, automatic memory management, and good facilities for handling strings and other kinds of data with dynamic size.|||Lua provides a set of unique features that makes it distinct from other languages. These include −|||Lua consists of two parts - the Lua interpreter part and the functioning software system. The functioning software system is an actual computer application that can interpret programs written in the Lua programming language. The Lua interpreter is written in ANSI C, hence it is highly portable and can run on a vast spectrum of devices from high-end network servers to small devices.|||Both Lua's language and its interpreter are mature, small, and fast. It has evolved from other programming languages and top software standards. Being small in size makes it possible for it to run on small devices with low memory.|||The most important point while learning Lua is to focus on the concepts without getting lost in its technical details.|||The purpose of learning a programming language is to become a better programmer; that is, to become more effective in designing and implementing new systems and at maintaining old ones.|||Game Programming|||Scripting in Standalone Applications|||Scripting in Web|||Extensions and add-ons for databases like MySQL Proxy and MySQL WorkBench|||Security systems like Intrusion Detection System.|||If you are still willing to set up your environment for Lua programming language, you need the following softwares available on your computer - (a) Text Editor, (b) The Lua Interpreter, and (c) Lua Compiler.|||You need a text editor to type your program. Examples of a few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of the text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on Windows as well as Linux or UNIX.|||The files you create with your editor are called source files and these files contain the program source code. The source files for Lua programs are typically named with the extension "".lua"".|||It is just a small program that enables you to type Lua commands and have them executed immediately. It stops the execution of a Lua file in case it encounters an error unlike a compiler that executes fully.|||When we extend Lua to other languages/applications, we need a Software Development Kit with a compiler that is compatible with the Lua Application Program Interface.|||There is a separate IDE named ""SciTE"" developed for the windows environment, which can be downloaded from https://code.google.com/p/luaforwindows/ download section.|||Run the downloaded executable to install the Lua IDE.|||Since it’s an IDE, you can both create and build the Lua code using the same.|||In case, you are interested in installing Lua in command line mode, you need to install MinGW or Cygwin and then compile and install Lua in windows.|||To download and build Lua, use the following command −|||In order to install on other platforms like aix, ansi, bsd, generic linux, mingw, posix, solaris by replacing Linux in make Linux, test with the corresponding platform name.|||We have a helloWorld.lua, in Lua as follows −|||Now, we can build and run a Lua file say helloWorld.lua, by switching to the folder containing the file using cd, and then using the following command −|||We can see the following output.|||To build/test Lua in the Mac OS X, use the following command −|||In certain cases, you may not have installed the Xcode and command line tools. In such cases, you won’t be able to use the make command. Install Xcode from mac app store. Then go to Preferences of Xcode, and then switch to Downloads and install the component named ""Command Line Tools"". Once the process is completed, make command will be available to you.|||It is not mandatory for you to execute the ""make macosx test"" statement. Even without executing this command, you can still use Lua in Mac OS X.|||We have a helloWorld.lua, in Lua, as follows −|||Now, we can build and run a Lua file say helloWorld.lua by switching to the folder containing the file using cd and then using the following command −|||We can see the following output −|||As mentioned earlier, for Windows SciTE, Lua IDE is the default IDE provided by the Lua creator team. The alternate IDE available is from ZeroBrane Studio, which is available across multiple platforms like Windows, Mac and Linux.|||There are also plugins for eclipse that enable the Lua development. Using IDE makes it easier for development with features like code completion and is highly recommended. The IDE also provides interactive mode programming similar to the command line version of Lua.|||Let us start creating our first Lua program!|||Lua provides a mode called interactive mode. In this mode, you can type in instructions one after the other and get instant results. This can be invoked in the shell by using the lua -i or just the lua command. Once you type in this, press Enter and the interactive mode will be started as shown below.|||You can print something using the following statement −|||Once you press enter, you will get the following output −|||Invoking the interpreter with a Lua file name parameter begins execution of the file and continues until the script is finished. When the script is finished, the interpreter is no longer active.|||Let us write a simple Lua program. All Lua files will have extension .lua. So put the following source code in a test.lua file.|||Assuming, lua environment is setup correctly, let’s run the program using the following code −|||We will get the following output −|||Let's try another way to execute a Lua program. Below is the modified test.lua file −|||Here, we have assumed that you have Lua interpreter available in your /usr/local/bin directory. The first line is ignored by the interpreter, if it starts with # sign. Now, try to run this program as follows −|||We will get the following output.|||Let us now see the basic structure of Lua program, so that it will be easy for you to understand the basic building blocks of the Lua programming language.|||A Lua program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Lua statement consists of three tokens −|||The individual tokens are −|||Comments are like helping text in your Lua program and they are ignored by the interpreter. They start with --[[ and terminates with the characters --]] as shown below −|||A Lua identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with a letter ‘A to Z’ or ‘a to z’ or an underscore ‘_’ followed by zero or more letters, underscores, and digits (0 to 9).|||Lua does not allow punctuation characters such as @, $, and % within identifiers. Lua is a case sensitive programming language. Thus Manpower and manpower are two different identifiers in Lua. Here are some examples of the acceptable identifiers −|||The following list shows few of the reserved words in Lua. These reserved words may not be used as constants or variables or any other identifier names.|||A line containing only whitespace, possibly with a comment, is known as a blank line, and a Lua interpreter totally ignores it.|||Whitespace is the term used in Lua to describe blanks, tabs, newline characters and comments. Whitespace separates one part of a statement from another and enables the interpreter to identify where one element in a statement, such as int ends, and the next element begins. Therefore, in the following statement −|||There must be at least one whitespace character (usually a space) between local and age for the interpreter to be able to distinguish them. On the other hand, in the following statement −|||No whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some if you wish for readability purpose.|||A variable is nothing but a name given to a storage area that our programs can manipulate. It can hold different types of values including functions and tables.|||The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Lua is case-sensitive. There are eight basic types of values in Lua −|||In Lua, though we don't have variable data types, we have three types based on the scope of the variable.|||Global variables − All variables are considered global unless explicitly declared as a local.|||Local variables − When the type is specified as local for a variable then its scope is limited with the functions inside their scope.|||Table fields − This is a special type of variable that can hold anything except nil including functions.|||A variable definition means to tell the interpreter where and how much to create the storage for the variable. A variable definition have an optional type and contains a list of one or more variables of that type as follows −|||Here, type is optionally local or type specified making it global, and variable_list may consist of one or more identifier names separated by commas. Some valid declarations are shown here −|||The line local  i, j both declares and defines the variables i and j; which instructs the interpreter to create variables named i, j and limits the scope to be local.|||Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as follows −|||Some examples are −|||For definition without an initializer: variables with static storage duration are implicitly initialized with nil.|||As you can see in the above examples, assignments for multiples variables follows a variable_list and value_list format. In the above example local d, f = 5,10 we have d and f in variable_list and 5 and 10 in values list.|||Value assigning in Lua takes place like first variable in the variable_list with first value in the value_list and so on. Hence, the value of d is 5 and the value of f is 10.|||Try the following example, where variables have been declared at the top, but they have been defined and initialized inside the main function −|||When the above code is built and executed, it produces the following result −|||There are two kinds of expressions in Lua −|||lvalue − Expressions that refer to a memory location is called ""lvalue"" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.|||rvalue − The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it, which means an rvalue may appear on the right-hand side, but not on the left-hand side of an assignment.|||Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and cannot appear on the left-hand side. Following is a valid statement −|||But following is not a valid statement and would generate a build-time error −|||In Lua programming language, apart from the above types of assignment, it is possible to have multiple lvalues and rvalues in the same single statement. It is shown below.|||In the above statement, 20 is assigned to g and 30 is assigned to l.|||Lua is a dynamically typed language, so the variables don't have types, only the values have types. Values can be stored in variables, passed as parameters and returned as results.|||In Lua, though we don't have variable data types, but we have types for the values. The list of data types for values are given below.|||nil|||Used to differentiate the value from having some data or no(nil) data.|||boolean|||Includes true and false as values. Generally used for condition checking.|||number|||Represents real(double precision floating point) numbers.|||string|||Represents array of characters.|||function|||Represents a method that is written in C or Lua.|||userdata|||Represents arbitrary C data.|||thread|||Represents independent threads of execution and it is used to implement coroutines.|||table|||Represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc., and implements associative arrays. It can hold any value (except nil).|||In Lua, there is a function called ‘type’ that enables us to know the type of the variable. Some examples are given in the following code.|||When you build and execute the above program, it produces the following result on Linux −|||By default, all the variables will point to nil until they are assigned a value or initialized. In Lua, zero and empty strings are considered to be true in case of condition checks. Hence, you have to be careful when using Boolean operations. We will know more using these types in the next chapters.|||An operator is a symbol that tells the interpreter to perform specific mathematical or logical manipulations. Lua language is rich in built-in operators and provides the following type of operators −|||This tutorial will explain the arithmetic, relational, logical, and other miscellaneous operators one by one.|||Following table shows all the arithmetic operators supported by Lua language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||Following table shows all the relational operators supported by Lua language. Assume variable A holds 10 and variable B holds 20 then −|||Show Examples|||Following table shows all the logical operators supported by Lua language. Assume variable A holds true and variable B holds false then −|||Show Examples|||Miscellaneous operators supported by Lua Language include concatenation and length.|||Show Examples|||Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator −|||For example, x = 7 + 3 * 2;  Here  x is assigned 13, not 20 because operator * has higher precedence than + so it first get multiplied with 3*2 and then adds into 7.|||Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.|||Show Examples|||There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: the first statement in a function is executed first, followed by the second, and so on.|||Programming languages provide various control structures that allow for more complicated execution paths.|||A loop statement allows us to execute a statement or group of statements multiple times. Following is the general form of a loop statement in most of the programming languages −|||Lua provides the following types of loops to handle looping requirements.|||Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||Repeats the operation of group of statements till the until condition is met.|||You can use one or more loop inside any another while, for or do..while loop.|||Loop control statement changes execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.|||Lua supports the following control statements.|||Terminates the loop and transfers execution to the statement immediately following the loop or switch.|||A loop becomes infinite loop if a condition never becomes false. The while loop is often used for this purpose. Since we directly give true for the condition, it keeps executing forever. We can use the break statement to break this loop.|||Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed, if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.|||Following is the general form of a typical decision making structure found in most of the programming languages −|||Lua programming language assumes any combination of Boolean true and non-nil values as true, and if it is either boolean false or nil, then it is assumed as false value. It is to be noted that in Lua, zero will be considered as true.|||Lua programming language provides the following types of decision making statements.|||An if statement consists of a boolean expression followed by one or more statements.|||An if statement can be followed by an optional else statement, which executes when the boolean expression is false.|||You can use one if or else if statement inside another if or else if statement(s).|||A function is a group of statements that together perform a task. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually unique, is so each function performs a specific task.|||The Lua language provides numerous built-in methods that your program can call. For example, method print() to print the argument passed as input in console.|||A function is known with various names like a method or a sub-routine or a procedure etc.|||The general form of a method definition in Lua programming language is as follows −|||A method definition in Lua programming language consists of a method header and a method body. Here are all the parts of a method −|||Optional Function Scope − You can use keyword local to limit the scope of the function or ignore the scope section, which will make it a global function.|||Function Name − This is the actual name of the function. The function name and the parameter list together constitute the function signature.|||Arguments − An argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as the actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.|||Function Body − The method body contains a collection of statements that define what the method does.|||Return − In Lua, it is possible to return multiple values by following the return keyword with the comma separated return values.|||Following is the source code for a function called max(). This function takes two parameters num1 and num2 and returns the maximum between the two −|||If a function is to use arguments, it must declare the variables that accept the values of the arguments. These variables are called the formal parameters of the function.|||The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.|||While creating a Lua function, you give a definition of what the function has to do. To use a method, you will have to call that function to perform the defined task.|||When a program calls a function, program control is transferred to the called function. A called function performs the defined task and when its return statement is executed or when its function's end is reached, it returns program control back to the main program.|||To call a method, you simply need to pass the required parameters along with the method name and if the method returns a value, then you can store the returned value. For example −|||When we run the above code, we will get the following output.|||In Lua, we can assign the function to variables and also can pass them as parameters of another function. Here is a simple example for assigning and passing a function as parameter in Lua.|||When we run the above code, we will get the following output.|||It is possible to create functions with variable arguments in Lua using '...' as its parameter. We can get a grasp of this by seeing an example in which the function will return the average and it can take variable arguments.|||When we run the above code, we will get the following output.|||String is a sequence of characters as well as control characters like form feed. String can be initialized with three forms which includes −|||An example for the above three forms are shown below.|||When we run the above program, we will get the following output.|||Escape sequence characters are used in string to change the normal interpretation of characters. For example, to print double inverted commas (""""), we have used \"" in the above example. The escape sequence and its use is listed below in the table.|||Lua supports string to manipulate strings −|||string.upper(argument)|||Returns a capitalized representation of the argument.|||string.lower(argument)|||Returns a lower case representation of the argument.|||string.gsub(mainString,findString,replaceString)|||Returns a string by replacing occurrences of findString with replaceString.|||string.find(mainString,findString,|||optionalStartIndex,optionalEndIndex)|||Returns the start index and end index of the findString in the main string and nil if not found.|||string.reverse(arg)|||Returns a string by reversing the characters of the passed string.|||string.format(...)|||Returns a formatted string.|||string.char(arg) and string.byte(arg)|||Returns internal numeric and character representations of input argument.|||string.len(arg)|||Returns a length of the passed string.|||string.rep(string, n))|||Returns a string by repeating the same string n number times.|||..|||Thus operator concatenates two strings.|||Now, let's dive into a few examples to exactly see how these string manipulation functions behave.|||A sample code for manipulating the strings to upper and lower case is given below.|||When we run the above program, we will get the following output.|||A sample code for replacing occurrences of one string with another is given below.|||When we run the above program, we will get the following output.|||A sample code for finding the index of substring and reversing string is given below.|||When we run the above program, we will get the following output.|||Many times in our programming, we may need to print strings in a formatted way. You can use the string.format function to format the output as shown below.|||When we run the above program, we will get the following output.|||A sample code for character and byte representation, which is used for converting the string from string to internal representation and vice versa.|||When we run the above program, we will get the following output.|||The common string manipulations include string concatenation, finding length of string and at times repeating the same string multiple times. The example for these operations is given below.|||When we run the above program, we will get the following output.|||Arrays are ordered arrangement of objects, which may be a one-dimensional array containing a collection of rows or a multi-dimensional array containing multiple rows and columns.|||In Lua, arrays are implemented using indexing tables with integers. The size of an array is not fixed and it can grow based on our requirements, subject to memory constraints.|||A one-dimensional array can be represented using a simple table structure and can be initialized and read using a simple for loop. An example is shown below.|||When we run the above code, we wil get the following output.|||As you can see in the above code, when we are trying to access an element in an index that is not there in the array, it returns nil. In Lua, indexing generally starts at index 1. But it is possible to create objects at index 0 and below 0 as well. Array using negative indices is shown below where we initialize the array using a for loop.|||When we run the above code, we will get the following output.|||Multi-dimensional arrays can be implemented in two ways.|||An example for multidimensional array of 3. 3 is shown below using array of arrays.|||When we run the above code, we will get the following output.|||An example for multidimensional array is shown below using manipulating indices.|||When we run the above code, we will get the following output.|||As you can see in the above example, data is stored based on indices. It is possible to place the elements in a sparse way and it is the way Lua implementation of a matrix works. Since it does not store nil values in Lua, it is possible to save lots of memory without any special technique in Lua as compared to special techniques used in other programming languages.|||Iterator is a construct that enables you to traverse through the elements of the so called collection or container. In Lua, these collections often refer to tables, which are used to create various data structures like array.|||A generic for iterator provides the key value pairs of each element in the collection. A simple example is given below.|||When we run the above code, we will get the following output −|||The above example uses the default ipairs iterator function provided by Lua.|||In Lua we use functions to represent iterators. Based on the state maintenance in these iterator functions, we have two main types −|||By the name itself we can understand that this type of iterator function does not retain any state.|||Let us now see an example of creating our own iterator using a simple function that prints the squares of n numbers.|||When we run the above program, we will get the following output.|||The above code can be modified slightly to mimic the way ipairs function of iterators work. It is shown below.|||When we run the above program, we will get the following output.|||The previous example of iteration using function does not retain the state. Each time the function is called, it returns the next element of the collection based on a second variable sent to the function. To hold the state of the current element, closures are used. Closure retain variables values across functions calls. To create a new closure, we create two functions including the closure itself and a factory, the function that creates the closure.|||Let us now see an example of creating our own iterator in which we will be using closures.|||When we run the above program, we will get the following output.|||In the above example, we can see that elementIterator has another method inside that uses the local external variables index and count to return each of the element in the collection by incrementing the index each time the function is called.|||We can create our own function iterators using closure as shown above and it can return multiple elements for each of the time we iterate through the collection.|||Tables are the only data structure available in Lua that helps us create different types like arrays and dictionaries. Lua uses associative arrays and which can be indexed with not only numbers but also with strings except nil. Tables have no fixed size and can grow based on our need.|||Lua uses tables in all representations including representation of packages. When we access a method string.format, it means, we are accessing the format function available in the string package.|||Tables are called objects and they are neither values nor variables. Lua uses a constructor expression {} to create an empty table. It is to be known that there is no fixed relationship between a variable that holds reference of table and the table itself.|||When we have a table a with set of elements and if we assign it to b, both a and b refer to the same memory. No separate memory is allocated separately for b. When a is set to nil, table will be still accessible to b. When there are no reference to a table, then garbage collection in Lua takes care of cleaning up process to make these unreferenced memory to be reused again.|||An example is shown below for explaining the above mentioned features of tables.|||When we run the above program we will get the following output −|||There are in built functions for table manipulation and they are listed in the following table.|||table.concat (table [, sep [, i [, j]]])|||Concatenates the strings in the tables based on the parameters given. See example for detail.|||table.insert (table, [pos,] value)|||Inserts a value into the table at specified position.|||table.maxn (table)|||Returns the largest numeric index.|||table.remove (table [, pos])|||Removes the value from the table.|||table.sort (table [, comp])|||Sorts the table based on optional comparator argument.|||Let us see some samples of the above functions.|||We can use the concat function to concatenate two tables as shown below −|||When we run the above program we will get the following output −|||Insertion and removal of items in tables is most common in table manipulation. It is explained below.|||When we run the above program, we will get the following output −|||We often require to sort a table in a particular order. The sort functions sort the elements in a table alphabetically. A sample for this is shown below.|||When we run the above program we will get the following output −|||Module is like a library that can be loaded using require and has a single global name containing a table. This module can consist of a number of functions and variables. All these functions and variables are wrapped in to the table, which acts as a namespace. Also, a well behaved module has necessary provisions to return this table on require.|||The usage of tables in modules helps us in numerous ways and enables us to manipulate the modules in the same way we manipulate any other Lua table. As a result of the ability to manipulate modules, it provides extra features for which other languages need special mechanisms. Due to this free mechanism of modules in Lua, a user can call the functions in Lua in multiple ways. A few of them are shown below.|||In the above sample code, you can see how flexible programming in Lua is, without any special additional code.|||Lua has provided a high level function called require to load all the necessary modules. It is kept as simple as possible to avoid having too much information on module to load it. The require function just assumes the modules as a chunk of code that defines some values, which is actually functions or tables containing functions.|||Let us consider a simple example, where one function has the math functions. Let's call this module as mymath and filename being mymath.lua. The file content is as follows −|||Now, in order to access this Lua module in another file, say, moduletutorial.lua, you need to use the following code segment.|||In order to run this code, we need to place the two Lua files in the same directory or alternatively, you can place the module file in the package path and it needs additional setup. When we run the above program, we will get the following output.|||Place both the modules and the file you run in the same directory.|||Module name and its file name should be the same.|||It is a best practice to return modules for require function and hence the module should be preferably implemented as shown above eventhough you can find other types of implementations elsewhere.|||Let me now rewrite the same example in the older way, which uses package.seeall type of implementation. This was used in Lua versions 5.1 and 5.0. The mymath module is shown below.|||The usage of modules in moduletutorial.lua is shown below.|||When we run the above, we will get the same output. But it is advised on to use the older version of the code and it is assumed to less secure. Many SDKs that use Lua for programming like Corona SDK has deprecated the use of this.|||A metatable is a table that helps in modifying the behavior of a table it is attached to with the help of a key set and related meta methods. These meta methods are powerful Lua functionality that enables features like −|||Changing/adding functionalities to operators on tables.|||Looking up metatables when the key is not available in the table using __index in metatable.|||There are two important methods that are used in handling metatables which includes −|||setmetatable(table,metatable) − This method is used to set metatable for a table.|||getmetatable(table) − This method is used to get metatable of a table.|||Let's first look at how to set one table as metatable of another. It is shown below.|||The above code can be represented in a single line as shown below.|||A simple example of metatable for looking up the meta table when it's not available in table is shown below.|||When we run the above program, we will get the following output.|||Let us explain what happened in the above example in steps.|||The table mytable here is {key1 = ""value1""}.|||Metatable is set for mytable that contains a function for __index, which we call as a metamethod.|||The metamethod does a simple job of looking up for an index ""key2"", if it's found, it returns ""metatablevalue"", otherwise returns mytable's value for corresponding index.|||We can have a simplified version of the above program as shown below.|||When we add __newindex to metatable, if keys are not available in the table, the behavior of new keys will be defined by meta methods. A simple example where metatable's index is set when index is not available in the main table is given below.|||When you run the above program, you get the following output.|||You can see in the above program, if a key exists in the main table, it just updates it. When a key is not available in the maintable, it adds that key to the metatable.|||Another example that updates the same table using rawset function is shown below.|||When we run the above program we will get the following output.|||rawset sets value without using __newindex of metatable. Similarly there is rawget that gets value without using __index.|||A simple example to combine two tables using + operator is shown below −|||When we run the above program, we will get the following output.|||The __add key is included in the metatable to add behavior of operator +. The table of keys and corresponding operator is shown below.|||__add|||Changes the behavior of operator '+'.|||__sub|||Changes the behavior of operator '-'.|||__mul|||Changes the behavior of operator '*'.|||__div|||Changes the behavior of operator '/'.|||__mod|||Changes the behavior of operator '%'.|||__unm|||Changes the behavior of operator '-'.|||__concat|||Changes the behavior of operator '..'.|||__eq|||Changes the behavior of operator '=='.|||__lt|||Changes the behavior of operator '<'.|||__le|||Changes the behavior of operator '<='.|||Adding behavior of method call is done using __call statement. A simple example that returns the sum of values in main table with the passed table.|||When we run the above program, we will get the following output.|||To change the behavior of the print statement, we can use the __tostring metamethod. A simple example is shown below.|||When we run the above program, we will get the following output.|||If you know the capabilities of meta table fully, you can really perform a lot of operations that would be very complex without using it. So, try to work more on using metatables with different options available in meta tables as explained in the samples and also create your own samples.|||Coroutines are collaborative in nature, which allows two or more methods to execute in a controlled manner. With coroutines, at any given time, only one coroutine runs and this running coroutine only suspends its execution when it explicitly requests to be suspended.|||The above definition may look vague. Let us assume we have two methods, one the main program method and a coroutine. When we call a coroutine using resume function, its starts executing and when we call yield function, it suspends executing. Again the same coroutine can continue executing with another resume function call from where it was suspended. This process can continue till the end of execution of the coroutine.|||The following table lists all the available functions for coroutines in Lua and their corresponding use.|||coroutine.create (f)|||Creates a new coroutine with a function f and returns an object of type ""thread"".|||coroutine.resume (co [, val1, ...])|||Resumes the coroutine co and passes the parameters if any. It returns the status of operation and optional other return values.|||coroutine.running ()|||Returns the running coroutine or nil if called in the main thread.|||coroutine.status (co)|||Returns one of the values from running, normal, suspended or dead based on the state of the coroutine.|||coroutine.wrap (f)|||Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine.|||coroutine.yield (...)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||Let's look at an example to understand the concept of coroutines.|||When we run the above program, we will get the following output.|||As mentioned before, we use the resume function to start the operation and yield function to stop the operation. Also, you can see that there are multiple return values received by resume function of coroutine.|||First, we create a coroutine and assign it to a variable name co and the coroutine takes in two variables as its parameters.|||When we call the first resume function, the values 3 and 2 are retained in the temporary variables value1 and value2 till the end of the coroutine.|||To make you understand this, we have used a tempvar3, which is 10 initially and it gets updated to 13 and 16 by the subsequent calls of the coroutines since value1 is retained as 3 throughout the execution of the coroutine.|||The first coroutine.yield returns two values 4 and 3 to the resume function, which we get by updating the input params 3 and 2 in the yield statement. It also receives the true/false status of coroutine execution.|||Another thing about coroutines is how the next params of resume call is taken care of, in the above example; you can see that the variable the coroutine.yield receives the next call params which provides a powerful way of doing new operation with the retentionship of existing param values.|||Finally, once all the statements in the coroutines are executed, the subsequent calls will return in false and ""cannot resume dead coroutine"" statement as response.|||Let us look at a simple coroutine that returns a number from 1 to 5 with the help of yield function and resume function. It creates coroutine if not available or else resumes the existing coroutine.|||When we run the above program, we will get the following output.|||There is often a comparison of coroutines with the threads of multiprogramming languages, but we need to understand that coroutines have similar features of thread but they execute only one at a time and never execute concurrently.|||We control the program execution sequence to meet the needs with the provision of retaining certain information temporarily. Using global variables with coroutines provides even more flexibility to coroutines.|||I/O library is used for reading and manipulating files in Lua. There are two kinds of file operations in Lua namely implicit file descriptors and explicit file descriptors.|||For the following examples, we will use a sample file test.lua as shown below.|||A simple file open operation uses the following statement.|||The various file modes are listed in the following table.|||""r""|||Read-only mode and is the default mode where an existing file is opened.|||""w""|||Write enabled mode that overwrites the existing file or creates a new file.|||""a""|||Append mode that opens an existing file or creates a new file for appending.|||""r+""|||Read and write mode for an existing file.|||""w+""|||All existing data is removed if file exists or new file is created with read write permissions.|||""a+""|||Append mode with read mode enabled that opens an existing file or creates a new file.|||Implicit file descriptors use the standard input/ output modes or using a single input and single output file. A sample of using implicit file descriptors is shown below.|||When you run the program, you will get an output of the first line of test.lua file. For our program, we got the following output.|||This was the first line of the statement in test.lua file for us. Also the line ""-- End of the test.lua file"" would be appended to the last line of the test.lua code.|||In the above example, you can see how the implicit descriptors work with file system using the io.""x"" methods. The above example uses io.read() without the optional parameter. The optional parameter can be any of the following.|||""*n""|||Reads from the current file position and returns a number if exists at the file position or returns nil.|||""*a""|||Returns all the contents of file from the current file position.|||""*l""|||Reads the line from the current file position, and moves file position to next line.|||number|||Reads number of bytes specified in the function.|||Other common I/O methods includes,|||io.tmpfile() − Returns a temporary file for reading and writing that will be removed once the program quits.|||io.type(file) − Returns whether file, closed file or nil based on the input file.|||io.flush() − Clears the default output buffer.|||io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||We often use explicit file descriptor which allows us to manipulate multiple files at a time. These functions are quite similar to implicit file descriptors. Here, we use file:function_name instead of io.function_name. The following example of the file version of the same implicit file descriptors example is shown below.|||When you run the program, you will get a similar output as the implicit descriptors example.|||All the modes of file open and params for read for external descriptors is same as implicit file descriptors.|||Other common file methods includes,|||file:seek(optional whence, optional offset) − Whence parameter is ""set"", ""cur"" or ""end"". Sets the new file pointer with the updated file position from the beginning of the file. The offsets are zero-based in this function. The offset is measured from the beginning of the file if the first argument is ""set""; from the current position in the file if it's ""cur""; or from the end of the file if it's ""end"". The default argument values are ""cur"" and 0, so the current file position can be obtained by calling this function without arguments.|||file:flush() − Clears the default output buffer.|||io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||An example to use the seek method is shown below. It offsets the cursor from the 25 positions prior to the end of file. The read function prints remainder of the file from seek position.|||You will get some output similar to the following.|||You can play around all the different modes and parameters to know the full ability of the Lua file operations.|||Error handling is quite critical since real-world operations often require the use of complex operations, which includes file operations, database transactions and web service calls.|||In any programming, there is always a requirement for error handling. Errors can be of two types which includes,|||Syntax errors occur due to improper use of various program components like operators and expressions. A simple example for syntax error is shown below.|||As you know, there is a difference between the use of a single ""equal to"" and double ""equal to"". Using one instead of the other can lead to an error. One ""equal to"" refers to assignment while a double ""equal to"" refers to comparison. Similarly, we have expressions and functions having their predefined ways of implementation.|||Another example for syntax error is shown below −|||When we run the above program, we will get the following output −|||Syntax errors are much easier to handle than run time errors since, the Lua interpreter locates the error more clearly than in case of runtime error. From the above error, we can know easily that adding a do statement before print statement is required as per the Lua structure.|||In case of runtime errors, the program executes successfully, but it can result in runtime errors due to mistakes in input or mishandled functions. A simple example to show run time error is shown below.|||When we build the program, it will build successfully and run. Once it runs, shows a run time error.|||This is a runtime error, which had occurred due to not passing two variables. The b parameter is expected and here it is nil and produces an error.|||In order to handle errors, we often use two functions − assert and error. A simple example is shown below.|||When we run the above program, we will get the following error output.|||The error (message [, level]) terminates the last protected function called and returns message as the error message. This function error never returns. Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.|||In Lua programming, in order to avoid throwing these errors and handling errors, we need to use the functions pcall or xpcall.|||The pcall (f, arg1, ...) function calls the requested function in protected mode. If some error occurs in function f, it does not throw an error. It just returns the status of error. A simple example using pcall is shown below.|||When we run the above program, we will get the following output.|||The xpcall (f, err) function calls the requested function and also sets the error handler. Any error inside f is not propagated; instead, xpcall catches the error, calls the err function with the original error object, and returns a status code.|||A simple example for xpcall is shown below.|||When we run the above program, we will get the following output.|||As a programmer, it is most important to ensure that you take care of proper error handling in the programs you write. Using error handling can ensure that unexpected conditions beyond the boundary conditions are handled without disturbing the user of the program.|||Lua provides a debug library, which provides all the primitive functions for us to create our own debugger. Even though, there is no in-built Lua debugger, we have many debuggers for Lua, created by various developers with many being open source.|||The functions available in the Lua debug library are listed in the following table along with its uses.|||debug()|||Enters interactive mode for debugging, which remains active till we type in only cont in a line and press enter. User can inspect variables during this mode using other functions.|||getfenv(object)|||Returns the environment of object.|||gethook(optional thread)|||Returns the current hook settings of the thread, as three values − the current hook function, the current hook mask, and the current hook count.|||getinfo(optional thread, function or stack level, optional flag)|||Returns a table with info about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread − level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil.|||getlocal(optional thread, stack level, local index)|||Returns the name and the value of the local variable with index local of the function at level of the stack.Returns nil if there is no local variable with the given index, and raises an error when called with a level out of range.|||getmetatable(value)|||Returns the metatable of the given object or nil if it does not have a metatable.|||getregistry()|||Returns the registry table,a pre-defined table that can be used by any C code to store whatever Lua value it needs to store.|||getupvalue(function, upvalue index)|||This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index.|||setfenv(function or thread or userdata, environment table)|||Sets the environment of the given object to the given table. Returns object.|||sethook(optional thread, hook function, hook mask string with ""c"" and/or ""r"" and/or ""l"", optional instruction count)|||Sets the given function as a hook. The string mask and the number count describes when the hook will be called. Here, c, r and l are called every time Lua calls, returns, and enters every line of code in a function respectively.|||setlocal(optional thread, stack level, local index, value)|||Assigns the value to the local variable with index local of the function at level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. Otherwise, it returns the name of the local variable.|||setmetatable(value, metatable)|||Sets the metatable for the given object to the given table (which can be nil).|||setupvalue(function, upvalue index, value)|||This function assigns the value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.|||traceback(optional thread, optional message string, optional level argument)|||Builds an extended error message with a traceback.|||The above list is the complete list of debug functions in Lua and we often use a library that uses the above functions and provides easier debugging. Using these functions and creating our own debugger is quite complicated and is not preferable. Anyway, we will see an example of simple use of debugging functions.|||When we run the above program, we will get the stack trace as shown below.|||In the above sample program, the stack trace is printed by using the debug.trace function available in the debug library. The debug.getinfo gets the current table of the function.|||We often need to know the local variables of a function for debugging. For that purpose, we can use getupvalue and to set these local variables, we use setupvalue. A simple example for this is shown below.|||When we run the above program, we will get the following output.|||In this example, the counter updates by one each time it is called. We can see the current state of the local variable using the getupvalue function. We then set the local variable to a new value. Here, n is 2 before the set operation is called. Using setupvalue function, it is updated to 10. Now when we call the counter function, it will return 11 instead of 3.|||Command line debugging is the type of debugging that uses command line to debug with the help of commands and print statements. There are many command line debuggers available for Lua of which a few are listed below.|||RemDebug − RemDebug is a remote debugger for Lua 5.0 and 5.1. It lets you control the execution of another Lua program remotely, setting breakpoints and inspecting the current state of the program. RemDebug can also debug CGILua scripts.|||clidebugger − A simple command line interface debugger for Lua 5.1 written in pure Lua. It's not dependent on anything other than the standard Lua 5.1 libraries. It was inspired by RemDebug but does not have its remote facilities.|||ctrace − A tool for tracing Lua API calls.|||xdbLua − A simple Lua command line debugger for the Windows platform.|||LuaInterface - Debugger − This project is a debugger extension for LuaInterface. It raises the built in Lua debug interface to a higher level. Interaction with the debugger is done by events and method calls.|||Rldb − This is a remote Lua debugger via socket, available on both Windows and Linux. It can give you much more features than any existing one.|||ModDebug − This allows in controlling the execution of another Lua program remotely, set breakpoints, and inspect the current state of the program.|||Graphical debugging is available with the help of IDE where you are provided with visual debugging of various states like variable values, stack trace and other related information. There is a visual representation and step by step control of execution with the help of breakpoints, step into, step over and other buttons in the IDE.|||There are number of graphical debuggers for Lua and it includes the following.|||SciTE − The default windows IDE for Lua provides multiple debugging facilities like breakpoints, step, step into, step over, watch variables and so on.|||Decoda − This is a graphical debugger with remote debugging support.|||ZeroBrane Studio − Lua IDE with integrated remote debugger, stack view, watch view, remote console, static analyzer, and more. Works with LuaJIT, Love2d, Moai, and other Lua engines; Windows, OSX, and Linux. Open source.|||akdebugger − Debugger and editor Lua plugin for Eclipse.|||luaedit − This features remote debugging, local debugging, syntax highlighting, completion proposal list, parameter proposition engine, advance breakpoint management (including condition system on breakpoints and hit count), function listing, global and local variables listing, watches, solution oriented management.|||Lua uses automatic memory management that uses garbage collection based on certain algorithms that is in-built in Lua. As a result of automatic memory management, as a developer −|||Lua uses a garbage collector that runs from time to time to collect dead objects when they are no longer accessible from the Lua program.|||All objects including tables, userdata, functions, thread, string and so on are subject to automatic memory management. Lua uses incremental mark and sweep collector that uses two numbers to control its garbage collection cycles namely garbage collector pause and garbage collector step multiplier. These values are in percentage and value of 100 is often equal to 1 internally.|||Garbage collector pause is used for controlling how long the garbage collector needs to wait, before; it is called again by the Lua's automatic memory management. Values less than 100 would mean that Lua will not wait for the next cycle. Similarly, higher values of this value would result in the garbage collector being slow and less aggressive in nature. A value of 200, means that the collector waits for the total memory in use to double before starting a new cycle. Hence, depending on the nature and speed of application, there may be a requirement to alter this value to get best performance in Lua applications.|||This step multiplier controls the relative speed of garbage collector to that of memory allocation in Lua program. Larger step values will lead to garbage collector to be more aggressive and it also increases the step size of each incremental step of garbage collection. Values less than 100 could often lead to avoid the garbage collector not to complete its cycle and its not generally preferred. The default value is 200, which means the garbage collector runs twice as the speed of memory allocation.|||As developers, we do have some control over the automatic memory management in Lua. For this, we have the following methods.|||collectgarbage(""collect"") − Runs one complete cycle of garbage collection.|||collectgarbage(""count"") − Returns the amount of memory currently used by the program in Kilobytes.|||collectgarbage(""restart"") − If the garbage collector has been stopped, it restarts it.|||collectgarbage(""setpause"") − Sets the value given as second parameter divided by 100 to the garbage collector pause variable. Its uses are as discussed a little above.|||collectgarbage(""setstepmul"") − Sets the value given as second parameter divided by 100 to the garbage step multiplier variable. Its uses are as discussed a little above.|||collectgarbage(""step"") − Runs one step of garbage collection. The larger the second argument is, the larger this step will be. The collectgarbage will return true if the triggered step was the last step of a garbage-collection cycle.|||collectgarbage(""stop"") − Stops the garbage collector if its running.|||A simple example using the garbage collector example is shown below.|||When we run the above program, we will get the following output. Please note that this result will vary due to the difference in type of operating system and also the automatic memory management feature of Lua.|||You can see in the above program, once garbage collection is done, it reduced the memory used. But, it's not mandatory to call this. Even if we don't call them, it will be executed automatically at a later stage by Lua interpreter after the predefined period.|||Obviously, we can change the behavior of the garbage collector using these functions if required. These functions provide a bit of additional capability for the developer to handle complex situations. Depending on the type of memory need for the program, you may or may not use this feature. But it is very useful to know the memory usage in the applications and check it during the programming itself to avoid undesired results after deployment.|||Object Oriented Programming (OOP), is one the most used programming technique that is used in the modern era of programming. There are a number of programming languages that support OOP which include,|||Class − A class is an extensible template for creating objects, providing initial values for state (member variables) and implementations of behavior.|||Objects − It is an instance of class and has separate memory allocated for itself.|||Inheritance − It is a concept by which variables and functions of one class is inherited by another class.|||Encapsulation − It is the process of combining the data and functions inside a class. Data can be accessed outside the class with the help of functions. It is also known as data abstraction.|||You can implement object orientation in Lua with the help of tables and first class functions of Lua. By placing functions and related data into a table, an object is formed. Inheritance can be implemented with the help of metatables, providing a look up mechanism for nonexistent functions(methods) and fields in parent object(s).|||Tables in Lua have the features of object like state and identity that is independent of its values. Two objects (tables) with the same value are different objects, whereas an object can have different values at different times, but it is always the same object. Like objects, tables have a life cycle that is independent of who created them or where they were created.|||The concept of object orientation is widely used but you need to understand it clearly for proper and maximum benefit.|||Let us consider a simple math example. We often encounter situations where we work on different shapes like circle, rectangle and square.|||The shapes can have a common property Area. So, we can extend other shapes from the base object shape with the common property area. Each of the shapes can have its own properties and functions like a rectangle can have properties length, breadth, area as its properties and printArea and calculateArea as its functions.|||A simple class implementation for a rectangle with three properties area, length, and breadth is shown below. It also has a printArea function to print the area calculated.|||Creating an object is the process of allocating memory for the class instance. Each of the objects has its own memory and share the common class data.|||We can access the properties in the class using the dot operator as shown below −|||You can access a member function using the colon operator with the object as shown below −|||The memory gets allocated and the initial values are set. The initialization process can be compared to constructors in other object oriented languages. It is nothing but a function that enables setting values as shown above.|||Lets look at a complete example using object orientation in Lua.|||When you run the above program, you will get the following output.|||Inheritance is the process of extending simple base objects like shape to rectangles, squares and so on. It is often used in the real world to share and extend the basic properties and functions.|||Let us see a simple class extension. We have a class as shown below.|||We can extend the shape to a square class as shown below.|||We can override the base class functions that is instead of using the function in the base class, derived class can have its own implementation as shown below −|||We can extend the simple class implementation in Lua as shown above with the help of another new method with the help of metatables. All the member variables and functions of base class are retained in the derived class.|||When we run the above program, we will get the following output −|||In the above example, we have created two derived classes − Rectangle and Square from the base class Square. It is possible to override the functions of the base class in derived class. In this example, the derived class overrides the function printArea.|||Lua is a highly flexible language and it is often used in multiple platforms including web applications. The Kepler community that was formed in 2004 to provide open source web components in Lua.|||Even though, there are other web frameworks using Lua that have been developed, we will be primarily focusing on the components provided by Kepler community.|||Orbit is an MVC web framework for Lua, based on WSAPI.|||WSAPI is the API that abstracts the web host server from Lua web applications and is the base for many projects.|||Xavante is a Lua Web server that offers a WSAPI interface.|||Sputnik is a wiki/CMS developed over WSAPI on Kepler Project used for humor and entertainment.|||CGILua offers LuaPages and LuaScripts web page creation, based on WSAPI but no longer supported. Use Orbit, Sputnik or WSAPI instead.|||In this tutorial, we will try to make you understand what Lua can do and to know more about its installation and usage, refer kepler the website|||Orbit is an MVC web framework for Lua. It completely abandons the CGILua model of ""scripts"" in favor of applications, where each Orbit application can fit in a single file, but you can split it into multiple files if you want.|||All Orbit applications follow the WSAPI protocol, so they currently work with Xavante, CGI and Fastcgi. It includes a launcher that makes it easy to launch a Xavante instance for development.|||The easiest way to install Orbit is using LuaRocks. Luarocks install orbit is the command for installing. For this, you need to install  LuaRocks first.|||If you haven't installed all the dependencies, here are the steps to be followed to setup Orbit in Unix/Linux environment.|||Connect to your server. Install Apache2, its support modules and enable required Apache2 modules using −|||Add this following section below the <Directory /var/www/> section of the config file. If this section has an 'AllowOverride None' then you need to change the 'None' to 'All' so that the .htaccess file can override the configuration locally.|||Restart the server to ensure the changes made comes into effect.|||To enable your application, you need to add +ExecCGI to an .htaccess file in the root of your Orbit application − in this case, /var/www.|||Now, you should be able to launch your web browser. Go to http://localhost:8080/ and you should see the following output −|||Orbit provides another option, i.e., Lua code can generate html.|||A simple form example is shown below −|||As mentioned earlier, WSAPI acts as the base for many projects and have multiple features embedded in it. You can use WSAPI and support the following platforms,|||The supported servers and interfaces by WSAPI includes,|||WSAPI provides a number of libraries, which makes it easier for us in web programming using Lua. Some of the supported features in Lua includes,|||A simple example of WSAPI is shown below −|||You can see in the above code a simple html page is formed and returned. You can see the usage of coroutines that makes it possible to return statement by statement to calling function. Finally, html status code(200), headers and html page is returned.|||Xavante is a Lua HTTP 1.1 Web server that uses a modular architecture based on URI mapped handlers. Xavante currently offers,|||File handler is used for general files. Redirect handler enables URI remapping and WSAPI handler for handing with WSAPI applications.|||A simple example is shown below.|||To use virtual hosts with Xavante, the call to xavante.HTTP would be changed to something like as follows −|||Copas, a dispatcher based on coroutines that can be used by TCP/IP servers.|||Cosmo, a ""safe templates"" engine that protects your application from arbitrary code in the templates.|||Coxpcall encapsulates Lua native pcall and xpcall with coroutine compatible ones.|||LuaFileSystem, a portable way to access the underlying directory structure and file attributes.|||Rings, a library which provides a way to create new Lua states from within Lua.|||There are so many Lua based web frameworks and components available for us and based on the need, it can be chosen. There are other web frameworks available which include the following −|||Moonstalk enables efficient development and hosting of dynamically generated web-based projects built with the Lua language; from basic pages to complex applications.|||Lapis, a framework for building web applications using MoonScript (or Lua) that runs inside of a customized version of Nginx called OpenResty.|||Lua Server Pages, a Lua scripting engine plug-in that blows away any other approach to embedded web development, offers a dramatic short cut to traditional C server pages.|||These web frameworks can leverage your web applications and help you in doing powerful operations.|||For simple data operations, we may use files, but, sometimes, these file operations may not be efficient, scalable, and powerful. For this purpose, we may often switch to using databases. LuaSQL is a simple interface from Lua to a number of database management systems. LuaSQL is the library, which provides support for different types of SQL. This include,|||In this tutorial, we will be covering database handling of MySQL an SQLite in Lua. This uses a generic interface for both and should be possible to port this implementation to other types of databases as well. First let see how you can do the operations in MySQL.|||In order to use the following examples to work as expected, we need the initial db setup. The assumptions are listed below.|||You have installed and setup MySQL with default user as root and password as '123456'.|||You have created a database test.|||You have gone through MySQL tutorial to understand MySQL Basics.|||We can use a simple require statement to import the sqlite library assuming that your Lua implementation was done correctly.|||The variable mysql will provide access to the functions by referring to the main mysql table.|||We can set up the connection by initiating a MySQL environment and then creating a connection for the environment. It is shown below.|||The above connection will connect to an existing MySQL file and establishes the connection with the newly created file.|||There is a simple execute function available with the connection that will help us to do all the db operations from create, insert, delete, update and so on. The syntax is shown below −|||In the above syntax, we need to ensure that conn is open and existing MySQL connection and replace the 'MySQLSTATEMENT' with the correct statement.|||A simple create table example is shown below. It creates a table with two parameters id of type integer and name of type varchar.|||When you run the above program, a table named sample will be created with two columns namely, id and name.|||In case there is any error, you would be returned an error statement instead of nil. A simple error statement is shown below.|||An insert statement for MySQL is shown below.|||An update statement for MySQL is shown below.|||A delete statement for MySQL is shown below.|||As far as select statement is concerned, we need to loop through each of the rows and extract the required data. A simple select statement is shown below.|||In the above code, conn is an open MySQL connection. With the help of the cursor returned by the execute statement, you can loop through the table response and fetch the required select data.|||A complete example including all the above statements is given below.|||When you run the above program, you will get the following output.|||Transactions are a mechanism that ensures data consistency. Transactions should have the following four properties −|||Atomicity − Either a transaction completes or nothing happens at all.|||Consistency − A transaction must start in a consistent state and leave the system in a consistent state.|||Isolation − Intermediate results of a transaction are not visible outside the current transaction.|||Durability − Once a transaction was committed, the effects are persistent, even after a system failure.|||Transaction starts with START TRANSACTION; and ends with commit or rollback statement.|||In order to initiate a transaction, we need to execute the following statement in Lua, assuming conn is an open MySQL connection.|||We need to execute the following statement to rollback changes made after start transaction is executed.|||We need to execute the following statement to commit changes made after start transaction is executed.|||We have known about MySQL in the above and following section explains about basic SQL operations. Remember transactions, though not explained again for SQLite3 but the same statements should work for SQLite3 as well.|||We can use a simple require statement to import the SQLite library assuming that your Lua implementation was done correctly. During installation, a folder libsql that contains the database related files.|||The variable sqlite3 will provide access to the functions by referring to the main sqlite3 table.|||We can set up the connection by initiating an SQLite environment and then creating a connection for the environment. It is shown below.|||The above connection will connect to an existing SQLite file or creates a new SQLite file and establishes the connection with the newly created file.|||There is a simple execute function available with the connection that will help us to do all the db operations from create, insert, delete, update and so on. The syntax is shown below −|||In the above syntax we need to ensure that conn is open and existing sqlite3 connection and replace the 'SQLite3STATEMENT' with the correct statement.|||A simple create table example is shown below. It creates a table with two parameters id of type integer and name of type varchar.|||When you run the above program, a table named sample will be created with two columns namely, id and name.|||In case of an error, you would be returned a error statement instead of nil. A simple error statement is shown below.|||An insert statement for SQLite is shown below.|||As far as select statement is concerned, we need to loop through each of the rows and extract the required data. A simple select statement is shown below.|||In the above code, conn is an open sqlite3 connection. With the help of the cursor returned by the execute statement, you can loop through the table response and fetch the required select data.|||A complete example including all the above statements is given below.|||When you run the above program, you will get the following output.|||We can execute all the available queries with the help of this libsql library. So, please don't stop with these examples. Experiment various query statement available in respective MySQL, SQLite3 and other supported db in Lua.|||Lua is used in a lot of game engines due to its simple language structure and syntax. The garbage collection feature is often quite useful in games which consume a lot of memory due to rich graphics that is used. Some game engines that use Lua includes −|||Each of these game engines are based on Lua and there is a rich set of API available in each of these engines. We will look at the capabilities of each in brief.|||Corona SDK is a cross platform mobile game engine that supports iPhone, iPad, and Android platforms. There is a free version of Corona SDK that can be used for small games with limited features. You can upgrade to other versions when needed.|||Corona SDK provides a number of features which includes the following −|||It is easier and faster to develop an application using the above APIs rather than using the native APIs separately for iOS and Android.|||Gideros provides the cross-platform SDK to create games for iOS and Android. It is free to use with a made with Gideros splash. Some of the striking advantages in Gideoros includes, the following −|||Development IDE − It provides its own IDE which makes it easier to develop Gideros apps.|||Instant testing − While developing your game, it can be tested on a real device through Wifi in only 1 second. You don't need to waste your time with an export or deploy process.|||Plugins − You can easily extend the core with plugins. Import your existing (C, C++, Java or Obj-C) code, bind to Lua and interpret them directly. Dozens of open-source plugins are already developed and ready to use.|||Clean OOP approach − Gideros provides its own class system with all the basic OOP standards, enabling you to write clean and reusable code for any of your future games.|||Native speed − Developed on top of C/C++ and OpenGL, your game runs at native speed and fully utilizes the power of CPUs and GPUs underneath.|||ShiVa3D is one of 3D game engines which provides a graphical editor designed to create applications and video games for the Web, Consoles and Mobile devices. It supports multiple platforms which includes, Windows, Mac, Linux, iOS, Android, BlackBerry, Palm OS, Wii and WebOS.|||Some of the major features include|||The web edition of Shiva3d is completely free and other editions you have subscribe.|||Moai SDK is a cross platform mobile game engine that supports iPhone, iPad, and Android platforms. Moai platform initially consisted of Moai SDK, an open source game engine, and Moai Cloud, a cloud platform as a service for the hosting and deployment of game services. Now the Moai Cloud is shutdown and only the game engine is available.|||Moai SDK runs on multiple platforms including iOS, Android, Chrome, Windows, Mac and Linux.|||LOVE is a framework that you can use to make 2D games. It is free and open-source. It supports Windows, Mac OS X and Linux platforms.|||It provides multiple features which include,|||CryEngine is a game engine developed by the German game developer Crytek. It has evolved from generation 1 to generation 4 and is an advanced development solution. It supports PC, Xbox 360, PlayStation3 and WiiU games.|||It provides multiple features which include,|||Visual effects like Natural Lighting & Dynamic Soft Shadows, Real-time Dynamic Global Illumination, Light Propagation Volume, Particle Shading, Tessellation and so on.|||Character Animation System and Character Individualization System.|||Parametric Skeletal Animation and Unique Dedicated Facial Animation Editor|||AI Systems like Multi-Layer Navigation Mesh and Tactical Point System. Also provides Designer-Friendly AI Editing System.|||In Game Mixing & Profiling, Data-driven Sound System Dynamic Sounds & Interactive Music and so on.|||Physics features like Procedural Deformation and Advanced Rope Physics.|||Each of these Game SDKs/frameworks have their own advantages and disadvantages. A proper choice between them makes your task easier and you can have a better time with it. So, before using it, you need to know the requirements for your game and then analyze which satisfies all your needs and then should use them.|||Lua standard libraries provide a rich set of functions that is implemented directly with the C API and is in-built with Lua programming language. These libraries provide services within the Lua programming language and also outside services like file and db operations.|||These standard libraries built in official C API are provided as separate C modules. It includes the following −|||We have used the basic library throughout the tutorial under various topics. The following table provides links of related pages and lists the functions that are covered in various part of this Lua tutorial.|||Error Handling|||Includes error handling functions like assert, error as explained in Lua - Error Handling.|||Memory Management|||Includes the automatic memory management functions related to garbage collection as explained in Lua - Garbage Collection.|||dofile ([filename])|||It opens the file and executes the contents of the file as a chunk. If no parameter is passed, then this function executes the contents of standard input. The errors will be propagated to the caller.|||_G |||Thus is the global variable that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable.|||getfenv ([f])|||Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.|||getmetatable (object)|||If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a ""__metatable"" field, returns the associated value. Otherwise, returns the metatable of the given object.|||ipairs (t)|||This functions fetches the indices and values of tables.|||load (func [, chunkname])|||Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results.|||loadfile ([filename]))|||Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.|||loadstring (string [, chunkname])|||Similar to load, but gets the chunk from the given string.|||next (table [, index])|||Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value.|||pairs (t)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||print (...)|||Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||rawequal (v1, v2)|||Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.|||rawget (table, index)|||Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.|||rawset (table, index, value)|||Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. This function returns table.|||select (index, ...)|||If index is a number, returns all arguments after argument number index. Otherwise, index must be the string ""#"", and select returns the total number of extra arguments it received.|||setfenv (f, table)|||Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling setfenv. setfenv returns the given function. As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values.|||setmetatable (table, metatable)|||Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a ""__metatable"" field, raises an error. This function returns table.|||tonumber (e [, base])|||Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.|||tostring (e)|||Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.|||type (v)|||Returns the type of its only argument, coded as a string. The possible results of this function are ""nil"" (a string, not the value nil), ""number"", ""string"", ""boolean"", ""table"", ""function"", ""thread"", and ""userdata"".|||unpack (list [, i [, j]])|||Returns the elements from the given table.|||_VERSION|||A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is ""Lua 5.1"".|||Coroutines|||Includes the coroutine manipulation functions as explained in Lua - Coroutines.|||The modules library provides the basic functions for loading modules in Lua. It exports one function directly in the global environment: require. Everything else is exported in a table package. The details about the modules library is explained in the earlier chapter Lua - Modules tutorial.|||Lua provides a rich set of string manipulation functions. The earlier Lua - Strings tutorial covers this in detail.|||Lua depends on tables in almost every bit of its operations. The earlier Lua - Tables tutorial covers this in detail.|||We often need data storage facility in programming and this is provided by standard library functions for file I/O in Lua. It is discussed in earlier Lua - File I/O tutorial.|||Lua provides a debug library which provides all the primitive functions for us to create our own debugger. It is discussed in earlier Lua - Debugging tutorial.|||We often need math operations in scientific and engineering calculations and we can avail this using the standard Lua library math. The list of functions available in math library is shown in the following table.|||math.abs (x)|||Returns the absolute value of x.|||math.acos (x)|||Returns the arc cosine of x (in radians).|||math.asin (x)|||Returns the arc sine of x (in radians).|||math.atan (x)|||Returns the arc tangent of x (in radians).|||math.atan2 (y, x)|||Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)|||math.ceil (x)|||Returns the smallest integer larger than or equal to x.|||math.cos (x)|||Returns the cosine of x (assumed to be in radians).|||math.cosh (x)|||Returns the hyperbolic cosine of x.|||math.deg (x)|||Returns the angle x (given in radians) in degrees.|||math.exp (x)|||Returns the value e power x.|||math.floor (x)|||Returns the largest integer smaller than or equal to x.|||math.fmod (x, y)|||Returns the remainder of the division of x by y that rounds the quotient towards zero.|||math.frexp (x)|||Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).|||math.huge|||The value HUGE_VAL, a value larger than or equal to any other numerical valu.|||math.ldexp (m, e)|||Returns m2e (e should be an integer).|||math.log (x)|||Returns the natural logarithm of x.|||math.log10 (x)|||Returns the base-10 logarithm of x.|||math.max (x, ...)|||Returns the maximum value among its arguments.|||math.min (x, ...)|||Returns the minimum value among its arguments.|||math.modf (x)|||Returns two numbers, the integral part of x and the fractional part of x.|||math.pi|||The value of pi.|||math.pow (x, y)|||Returns xy. (You can also use the expression x^y to compute this value.)|||math.rad (x)|||Returns the angle x (given in degrees) in radians.|||math.random ([m [, n]])|||This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].|||math.randomseed (x)|||Sets x as the ""seed"" for the pseudo-random generator: equal seeds produce equal sequences of numbers.|||math.sin (x)|||Returns the sine of x (assumed to be in radians).|||math.sinh (x)|||Returns the hyperbolic sine of x.|||math.sqrt (x)|||Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)|||math.tan (x)|||Returns the tangent of x (assumed to be in radians).|||math.tanh (x)|||Returns the hyperbolic tangent of x.|||A simple example using trigonometric function is shown below.|||When we run the above program, we will get the following output.|||A simple example using common math functions is shown below.|||When we run the above program, we will get the following output.|||The above examples are just a few of the common examples, we can use math library based on our need, so try using all the functions to be more familiar.|||In any application, it is often required for to access Operating System level functions and it is made available with Operating System library. The list of functions available are listed in the following table.|||os.clock ()|||Returns an approximation of the amount in seconds of CPU time used by the program.|||os.date ([format [, time]])|||Returns a string or a table containing date and time, formatted according to the given string format.|||os.difftime (t2, t1)|||Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.|||os.execute ([command])|||This function is equivalent to the ANSI C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise.|||os.exit ([code [, close])|||Calls the ANSI C function exit to terminate the host program. If code is true, the returned status is EXIT_SUCCESS; if code is false, the returned status is EXIT_FAILURE; if code is a number, the returned status is this number.|||os.getenv (varname)|||Returns the value of the process environment variable varname, or nil if the variable is not defined.|||os.remove (filename)|||Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns nil, plus a string describing the error and the error code.|||os.rename (oldname, newname)||| Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error and the error code.|||os.setlocale (locale [, category])|||Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: ""all"", ""collate"", ""ctype"", ""monetary"", ""numeric"", or ""time""; the default category is ""all"". The function returns the name of the new locale, or nil if the request cannot be honored.|||os.time ([table])|||Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour (default is 12), min (default is 0), sec (default is 0), and isdst (default is nil). For a description of these fields, see the os.date function.|||os.tmpname ()|||Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.|||A simple example using common math functions is shown below.|||When we run the above program, we will get similar output to the following.|||The above examples are just a few of the common examples, we can use OS library based on our need, so try using all the functions to be more familiar. There are functions like remove which helps in removing file, execute that helps us executing OS commands as explained above.","Extensible@@@Simple@@@Efficient@@@Portable@@@Free and open|||Game Programming@@@Scripting in Standalone Applications@@@Scripting in Web@@@Extensions and add-ons for databases like MySQL Proxy and MySQL WorkBench@@@Security systems like Intrusion Detection System.|||Global variables − All variables are considered global unless explicitly declared as a local.@@@Local variables − When the type is specified as local for a variable then its scope is limited with the functions inside their scope.@@@Table fields − This is a special type of variable that can hold anything except nil including functions.|||lvalue − Expressions that refer to a memory location is called ""lvalue"" expression. An lvalue may appear as either the left-hand or right-hand side of an assignment.@@@rvalue − The term rvalue refers to a data value that is stored at some address in memory. An rvalue is an expression that cannot have a value assigned to it, which means an rvalue may appear on the right-hand side, but not on the left-hand side of an assignment.|||Arithmetic Operators@@@Relational Operators@@@Logical Operators@@@Misc Operators|||Optional Function Scope − You can use keyword local to limit the scope of the function or ignore the scope section, which will make it a global function.@@@Function Name − This is the actual name of the function. The function name and the parameter list together constitute the function signature.@@@Arguments − An argument is like a placeholder. When a function is invoked, you pass a value to the argument. This value is referred to as the actual parameter or argument. The parameter list refers to the type, order, and number of the arguments of a method. Arguments are optional; that is, a method may contain no argument.@@@Function Body − The method body contains a collection of statements that define what the method does.@@@Return − In Lua, it is possible to return multiple values by following the return keyword with the comma separated return values.|||Characters between single quotes@@@Characters between double quotes@@@Characters between [[ and  ]]|||Array of arrays@@@Single dimensional array by manipulating indices|||Stateless Iterators@@@Stateful Iterators|||Place both the modules and the file you run in the same directory.@@@Module name and its file name should be the same.@@@It is a best practice to return modules for require function and hence the module should be preferably implemented as shown above eventhough you can find other types of implementations elsewhere.|||Changing/adding functionalities to operators on tables.@@@Looking up metatables when the key is not available in the table using __index in metatable.|||setmetatable(table,metatable) − This method is used to set metatable for a table.@@@getmetatable(table) − This method is used to get metatable of a table.|||The table mytable here is {key1 = ""value1""}.@@@Metatable is set for mytable that contains a function for __index, which we call as a metamethod.@@@The metamethod does a simple job of looking up for an index ""key2"", if it's found, it returns ""metatablevalue"", otherwise returns mytable's value for corresponding index.|||First, we create a coroutine and assign it to a variable name co and the coroutine takes in two variables as its parameters.@@@When we call the first resume function, the values 3 and 2 are retained in the temporary variables value1 and value2 till the end of the coroutine.@@@To make you understand this, we have used a tempvar3, which is 10 initially and it gets updated to 13 and 16 by the subsequent calls of the coroutines since value1 is retained as 3 throughout the execution of the coroutine.@@@The first coroutine.yield returns two values 4 and 3 to the resume function, which we get by updating the input params 3 and 2 in the yield statement. It also receives the true/false status of coroutine execution.@@@Another thing about coroutines is how the next params of resume call is taken care of, in the above example; you can see that the variable the coroutine.yield receives the next call params which provides a powerful way of doing new operation with the retentionship of existing param values.@@@Finally, once all the statements in the coroutines are executed, the subsequent calls will return in false and ""cannot resume dead coroutine"" statement as response.|||io.tmpfile() − Returns a temporary file for reading and writing that will be removed once the program quits.@@@io.type(file) − Returns whether file, closed file or nil based on the input file.@@@io.flush() − Clears the default output buffer.@@@io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||file:seek(optional whence, optional offset) − Whence parameter is ""set"", ""cur"" or ""end"". Sets the new file pointer with the updated file position from the beginning of the file. The offsets are zero-based in this function. The offset is measured from the beginning of the file if the first argument is ""set""; from the current position in the file if it's ""cur""; or from the end of the file if it's ""end"". The default argument values are ""cur"" and 0, so the current file position can be obtained by calling this function without arguments.@@@file:flush() − Clears the default output buffer.@@@io.lines(optional file name) − Provides a generic for loop iterator that loops through the file and closes the file in the end, in case the file name is provided or the default file is used and not closed in the end of the loop.|||Syntax errors@@@Run time errors|||Command line debugging@@@Graphical debugging|||RemDebug − RemDebug is a remote debugger for Lua 5.0 and 5.1. It lets you control the execution of another Lua program remotely, setting breakpoints and inspecting the current state of the program. RemDebug can also debug CGILua scripts.@@@clidebugger − A simple command line interface debugger for Lua 5.1 written in pure Lua. It's not dependent on anything other than the standard Lua 5.1 libraries. It was inspired by RemDebug but does not have its remote facilities.@@@ctrace − A tool for tracing Lua API calls.@@@xdbLua − A simple Lua command line debugger for the Windows platform.@@@LuaInterface - Debugger − This project is a debugger extension for LuaInterface. It raises the built in Lua debug interface to a higher level. Interaction with the debugger is done by events and method calls.@@@Rldb − This is a remote Lua debugger via socket, available on both Windows and Linux. It can give you much more features than any existing one.@@@ModDebug − This allows in controlling the execution of another Lua program remotely, set breakpoints, and inspect the current state of the program.|||SciTE − The default windows IDE for Lua provides multiple debugging facilities like breakpoints, step, step into, step over, watch variables and so on.@@@Decoda − This is a graphical debugger with remote debugging support.@@@ZeroBrane Studio − Lua IDE with integrated remote debugger, stack view, watch view, remote console, static analyzer, and more. Works with LuaJIT, Love2d, Moai, and other Lua engines; Windows, OSX, and Linux. Open source.@@@akdebugger − Debugger and editor Lua plugin for Eclipse.@@@luaedit − This features remote debugging, local debugging, syntax highlighting, completion proposal list, parameter proposition engine, advance breakpoint management (including condition system on breakpoints and hit count), function listing, global and local variables listing, watches, solution oriented management.|||No need to worry about allocating memory for objects.@@@No need to free them when no longer needed except for setting it to nil.|||collectgarbage(""collect"") − Runs one complete cycle of garbage collection.@@@collectgarbage(""count"") − Returns the amount of memory currently used by the program in Kilobytes.@@@collectgarbage(""restart"") − If the garbage collector has been stopped, it restarts it.@@@collectgarbage(""setpause"") − Sets the value given as second parameter divided by 100 to the garbage collector pause variable. Its uses are as discussed a little above.@@@collectgarbage(""setstepmul"") − Sets the value given as second parameter divided by 100 to the garbage step multiplier variable. Its uses are as discussed a little above.@@@collectgarbage(""step"") − Runs one step of garbage collection. The larger the second argument is, the larger this step will be. The collectgarbage will return true if the triggered step was the last step of a garbage-collection cycle.@@@collectgarbage(""stop"") − Stops the garbage collector if its running.|||C++@@@Java@@@Objective-C@@@Smalltalk@@@C#@@@Ruby|||Class − A class is an extensible template for creating objects, providing initial values for state (member variables) and implementations of behavior.@@@Objects − It is an instance of class and has separate memory allocated for itself.@@@Inheritance − It is a concept by which variables and functions of one class is inherited by another class.@@@Encapsulation − It is the process of combining the data and functions inside a class. Data can be accessed outside the class with the help of functions. It is also known as data abstraction.|||Orbit is an MVC web framework for Lua, based on WSAPI.@@@WSAPI is the API that abstracts the web host server from Lua web applications and is the base for many projects.@@@Xavante is a Lua Web server that offers a WSAPI interface.@@@Sputnik is a wiki/CMS developed over WSAPI on Kepler Project used for humor and entertainment.@@@CGILua offers LuaPages and LuaScripts web page creation, based on WSAPI but no longer supported. Use Orbit, Sputnik or WSAPI instead.|||Windows@@@UNIX-based systems|||CGI@@@FastCGI@@@Xavante|||Request processing@@@Output buffering@@@Authentication@@@File uploads@@@Request isolation@@@Multiplexing|||File handler@@@Redirect handler@@@WSAPI handler|||Copas, a dispatcher based on coroutines that can be used by TCP/IP servers.@@@Cosmo, a ""safe templates"" engine that protects your application from arbitrary code in the templates.@@@Coxpcall encapsulates Lua native pcall and xpcall with coroutine compatible ones.@@@LuaFileSystem, a portable way to access the underlying directory structure and file attributes.@@@Rings, a library which provides a way to create new Lua states from within Lua.|||Moonstalk enables efficient development and hosting of dynamically generated web-based projects built with the Lua language; from basic pages to complex applications.@@@Lapis, a framework for building web applications using MoonScript (or Lua) that runs inside of a customized version of Nginx called OpenResty.@@@Lua Server Pages, a Lua scripting engine plug-in that blows away any other approach to embedded web development, offers a dramatic short cut to traditional C server pages.|||SQLite@@@Mysql@@@ODBC|||You have installed and setup MySQL with default user as root and password as '123456'.@@@You have created a database test.@@@You have gone through MySQL tutorial to understand MySQL Basics.|||Atomicity − Either a transaction completes or nothing happens at all.@@@Consistency − A transaction must start in a consistent state and leave the system in a consistent state.@@@Isolation − Intermediate results of a transaction are not visible outside the current transaction.@@@Durability − Once a transaction was committed, the effects are persistent, even after a system failure.|||Corona SDK@@@Gideros Mobile@@@ShiVa3D@@@Moai SDK@@@LOVE@@@CryEngine|||Physics and Collision handling APIs@@@Web and Network APIs@@@Game Network API@@@Ads API@@@Analytics API@@@Database and File System APIs@@@Crypto and Math APIs@@@Audio and Media APIs|||Development IDE − It provides its own IDE which makes it easier to develop Gideros apps.@@@Instant testing − While developing your game, it can be tested on a real device through Wifi in only 1 second. You don't need to waste your time with an export or deploy process.@@@Plugins − You can easily extend the core with plugins. Import your existing (C, C++, Java or Obj-C) code, bind to Lua and interpret them directly. Dozens of open-source plugins are already developed and ready to use.@@@Clean OOP approach − Gideros provides its own class system with all the basic OOP standards, enabling you to write clean and reusable code for any of your future games.@@@Native speed − Developed on top of C/C++ and OpenGL, your game runs at native speed and fully utilizes the power of CPUs and GPUs underneath.|||Standard plugins@@@Mesh modification API@@@IDE@@@Built-in Terrain, Ocean and animation editor@@@ODE physics engine support@@@Full lightmap control@@@Live preview for materials, particles, trails and HUDs@@@Collada exchange format support|||Audio API@@@File System API@@@Keyboard and Joystick APIs@@@Math API@@@Window and Mouse APIs@@@Physics API@@@System and timer APIs|||Visual effects like Natural Lighting & Dynamic Soft Shadows, Real-time Dynamic Global Illumination, Light Propagation Volume, Particle Shading, Tessellation and so on.@@@Character Animation System and Character Individualization System.@@@Parametric Skeletal Animation and Unique Dedicated Facial Animation Editor@@@AI Systems like Multi-Layer Navigation Mesh and Tactical Point System. Also provides Designer-Friendly AI Editing System.@@@In Game Mixing & Profiling, Data-driven Sound System Dynamic Sounds & Interactive Music and so on.@@@Physics features like Procedural Deformation and Advanced Rope Physics.|||Basic library, which includes the coroutine sub-library@@@Modules library@@@String manipulation@@@Table manipulation@@@Math library@@@File Input and output@@@Operating system facilities@@@Debug facilities",,"and@@@break@@@do@@@else|||elseif@@@end@@@false@@@for|||function@@@if@@@in@@@local|||nil@@@not@@@or@@@repeat|||return@@@then@@@true@@@until|||while@@@@@@@@@&&&Sr.No@@@Value Type & Description|||1@@@nil
Used to differentiate the value from having some data or no(nil) data.|||2@@@boolean
Includes true and false as values. Generally used for condition checking.|||3@@@number
Represents real(double precision floating point) numbers.|||4@@@string
Represents array of characters.|||5@@@function
Represents a method that is written in C or Lua.|||6@@@userdata
Represents arbitrary C data.|||7@@@thread
Represents independent threads of execution and it is used to implement coroutines.|||8@@@table
Represent ordinary arrays, symbol tables, sets, records, graphs, trees, etc., and implements associative arrays. It can hold any value (except nil).&&&Operator@@@Description@@@Example|||+@@@Adds two operands@@@A + B will give 30|||-@@@Subtracts second operand from the first@@@A - B will give -10|||*@@@Multiply both operands@@@A * B will give 200|||/@@@Divide numerator by de-numerator@@@B / A will give 2|||%@@@Modulus Operator and remainder of after an integer division@@@B % A will give 0|||^@@@Exponent Operator takes the exponents@@@A^2 will give 100|||-@@@Unary - operator acts as negation@@@-A will give -10&&&Operator@@@Description@@@Example|||==@@@Checks if the value of two operands are equal or not, if yes then condition becomes true.@@@(A == B) is not true.|||~=@@@Checks if the value of two operands are equal or not, if values are not equal then condition becomes true.@@@(A ~= B) is true.|||>@@@Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.@@@(A > B) is not true.|||<@@@Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.@@@(A < B) is true.|||>=@@@Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.@@@(A >= B) is not true.|||<=@@@Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.@@@(A <= B) is true.&&&Operator@@@Description@@@Example|||and@@@Called Logical AND  operator. If both the operands are non zero then condition becomes true.@@@(A and B) is false.|||or@@@Called Logical OR Operator. If any of the two operands is non zero then condition becomes true.@@@(A or B) is true.|||not@@@Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.@@@!(A and B) is true.&&&Operator@@@Description@@@Example|||..@@@Concatenates two strings.@@@a..b where a is ""Hello "" and b is ""World"", will return ""Hello World"".|||#@@@An unary operator that return the length of the a string or a table.@@@#""Hello"" will return 5&&&Category@@@Operator@@@Associativity|||Unary@@@not # -@@@Right to left|||Concatenation@@@..@@@Right to left|||Multiplicative@@@* / %@@@Left to right|||Additive@@@+ -@@@Left to right|||Relational@@@< > <=  >= ==  ~= @@@Left to right|||Equality@@@== ~=@@@Left to right|||Logical AND@@@and@@@Left to right|||Logical OR@@@or@@@Left to right&&&Sr.No.@@@Loop Type & Description|||1@@@while loop
Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.|||2@@@for loop
Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.|||3@@@repeat...until loop
Repeats the operation of group of statements till the until condition is met.|||4@@@nested loops
You can use one or more loop inside any another while, for or do..while loop.&&&Sr.No.@@@Control Statement & Description|||1@@@break statement
Terminates the loop and transfers execution to the statement immediately following the loop or switch.&&&Sr.No.@@@Statement & Description|||1@@@if statement
An if statement consists of a boolean expression followed by one or more statements.|||2@@@if...else statement
An if statement can be followed by an optional else statement, which executes when the boolean expression is false.|||3@@@nested if statements
You can use one if or else if statement inside another if or else if statement(s).&&&Escape Sequence@@@Use|||\a@@@Bell|||\b@@@Backspace|||\f@@@Formfeed|||\n@@@New line|||\r@@@Carriage return |||\t@@@Tab|||\v@@@Vertical tab|||\\@@@Backslash|||\""@@@Double quotes|||\'@@@Single quotes|||\[@@@Left square bracket|||\]@@@Right square bracket&&&Sr.No.@@@Method & Purpose|||1@@@string.upper(argument)
Returns a capitalized representation of the argument.|||2@@@string.lower(argument)
Returns a lower case representation of the argument.|||3@@@string.gsub(mainString,findString,replaceString)
Returns a string by replacing occurrences of findString with replaceString.|||4@@@string.find(mainString,findString,
optionalStartIndex,optionalEndIndex)
Returns the start index and end index of the findString in the main string and nil if not found.|||5@@@string.reverse(arg)
Returns a string by reversing the characters of the passed string.|||6@@@string.format(...)
Returns a formatted string.|||7@@@string.char(arg) and string.byte(arg)
Returns internal numeric and character representations of input argument.|||8@@@string.len(arg)
Returns a length of the passed string.|||9@@@string.rep(string, n))
Returns a string by repeating the same string n number times.|||10@@@..
Thus operator concatenates two strings.&&&Sr.No.@@@Method & Purpose|||1@@@table.concat (table [, sep [, i [, j]]])
Concatenates the strings in the tables based on the parameters given. See example for detail.|||2@@@table.insert (table, [pos,] value)
Inserts a value into the table at specified position.|||3@@@table.maxn (table)
Returns the largest numeric index.|||4@@@table.remove (table [, pos])
Removes the value from the table.|||5@@@table.sort (table [, comp])
Sorts the table based on optional comparator argument.&&&Sr.No.@@@Mode & Description|||1@@@__add
Changes the behavior of operator '+'.|||2@@@__sub
Changes the behavior of operator '-'.|||3@@@__mul
Changes the behavior of operator '*'.|||4@@@__div
Changes the behavior of operator '/'.|||5@@@__mod
Changes the behavior of operator '%'.|||6@@@__unm
Changes the behavior of operator '-'.|||7@@@__concat
Changes the behavior of operator '..'.|||8@@@__eq
Changes the behavior of operator '=='.|||9@@@__lt
Changes the behavior of operator '<'.|||10@@@__le
Changes the behavior of operator '<='.&&&Sr.No.@@@Method & Purpose|||1@@@coroutine.create (f)
Creates a new coroutine with a function f and returns an object of type ""thread"".|||2@@@coroutine.resume (co [, val1, ...])
Resumes the coroutine co and passes the parameters if any. It returns the status of operation and optional other return values.|||3@@@coroutine.running ()
Returns the running coroutine or nil if called in the main thread.|||4@@@coroutine.status (co)
Returns one of the values from running, normal, suspended or dead based on the state of the coroutine.|||5@@@coroutine.wrap (f)
Like coroutine.create, the coroutine.wrap function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine.|||6@@@coroutine.yield (...)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.&&&Sr.No.@@@Mode & Description|||1@@@""r""
Read-only mode and is the default mode where an existing file is opened.|||2@@@""w""
Write enabled mode that overwrites the existing file or creates a new file.|||3@@@""a""
Append mode that opens an existing file or creates a new file for appending.|||4@@@""r+""
Read and write mode for an existing file.|||5@@@""w+""
All existing data is removed if file exists or new file is created with read write permissions.|||6@@@""a+""
Append mode with read mode enabled that opens an existing file or creates a new file.&&&Sr.No.@@@Mode & Description|||1@@@""*n""
Reads from the current file position and returns a number if exists at the file position or returns nil.|||2@@@""*a""
Returns all the contents of file from the current file position.|||3@@@""*l""
Reads the line from the current file position, and moves file position to next line.|||4@@@number
Reads number of bytes specified in the function.&&&Sr.No.@@@Method & Purpose|||1@@@debug()
Enters interactive mode for debugging, which remains active till we type in only cont in a line and press enter. User can inspect variables during this mode using other functions.|||2@@@getfenv(object)
Returns the environment of object.|||3@@@gethook(optional thread)
Returns the current hook settings of the thread, as three values − the current hook function, the current hook mask, and the current hook count.|||4@@@getinfo(optional thread, function or stack level, optional flag)
Returns a table with info about a function. You can give the function directly, or you can give a number as the value of function, which means the function running at level function of the call stack of the given thread − level 0 is the current function (getinfo itself); level 1 is the function that called getinfo; and so on. If function is a number larger than the number of active functions, then getinfo returns nil.|||5@@@getlocal(optional thread, stack level, local index)
Returns the name and the value of the local variable with index local of the function at level of the stack.Returns nil if there is no local variable with the given index, and raises an error when called with a level out of range.|||6@@@getmetatable(value)
Returns the metatable of the given object or nil if it does not have a metatable.|||7@@@getregistry()
Returns the registry table,a pre-defined table that can be used by any C code to store whatever Lua value it needs to store.|||8@@@getupvalue(function, upvalue index)
This function returns the name and the value of the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index.|||9@@@setfenv(function or thread or userdata, environment table)
Sets the environment of the given object to the given table. Returns object.|||10@@@sethook(optional thread, hook function, hook mask string with ""c"" and/or ""r"" and/or ""l"", optional instruction count)
Sets the given function as a hook. The string mask and the number count describes when the hook will be called. Here, c, r and l are called every time Lua calls, returns, and enters every line of code in a function respectively.|||11@@@setlocal(optional thread, stack level, local index, value)
Assigns the value to the local variable with index local of the function at level of the stack. The function returns nil if there is no local variable with the given index, and raises an error when called with a level out of range. Otherwise, it returns the name of the local variable.|||12@@@setmetatable(value, metatable)
Sets the metatable for the given object to the given table (which can be nil).|||13@@@setupvalue(function, upvalue index, value)
This function assigns the value to the upvalue with index up of the function func. The function returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.|||14@@@traceback(optional thread, optional message string, optional level argument)
Builds an extended error message with a traceback.&&&Sr.No.@@@Library / Method & Purpose|||1@@@Error Handling
Includes error handling functions like assert, error as explained in Lua - Error Handling.|||2@@@Memory Management
Includes the automatic memory management functions related to garbage collection as explained in Lua - Garbage Collection.|||3@@@dofile ([filename])
It opens the file and executes the contents of the file as a chunk. If no parameter is passed, then this function executes the contents of standard input. The errors will be propagated to the caller.|||4@@@_G 
Thus is the global variable that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable.|||5@@@getfenv ([f])
Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.|||6@@@getmetatable (object)
If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a ""__metatable"" field, returns the associated value. Otherwise, returns the metatable of the given object.|||7@@@ipairs (t)
This functions fetches the indices and values of tables.|||8@@@load (func [, chunkname])
Loads a chunk using function func to get its pieces. Each call to func must return a string that concatenates with previous results.|||9@@@loadfile ([filename]))
Similar to load, but gets the chunk from file filename or from the standard input, if no file name is given.|||10@@@loadstring (string [, chunkname])
Similar to load, but gets the chunk from the given string.|||11@@@next (table [, index])
Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value.|||12@@@pairs (t)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||13@@@print (...)
Suspends the running coroutine. The parameter passed to this method acts as additional return values to the resume function.|||14@@@rawequal (v1, v2)
Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.|||15@@@rawget (table, index)
Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.|||16@@@rawset (table, index, value)
Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value. This function returns table.|||17@@@select (index, ...)
If index is a number, returns all arguments after argument number index. Otherwise, index must be the string ""#"", and select returns the total number of extra arguments it received.|||18@@@setfenv (f, table)
Sets the environment to be used by the given function. f can be a Lua function or a number that specifies the function at that stack level − Level 1 is the function calling setfenv. setfenv returns the given function. As a special case, when f is 0 setfenv changes the environment of the running thread. In this case, setfenv returns no values.|||19@@@setmetatable (table, metatable)
Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a ""__metatable"" field, raises an error. This function returns table.|||20@@@tonumber (e [, base])
Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.|||21@@@tostring (e)
Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use string.format.|||22@@@type (v)
Returns the type of its only argument, coded as a string. The possible results of this function are ""nil"" (a string, not the value nil), ""number"", ""string"", ""boolean"", ""table"", ""function"", ""thread"", and ""userdata"".|||23@@@unpack (list [, i [, j]])
Returns the elements from the given table.|||24@@@_VERSION
A global variable (not a function) that holds a string containing the current interpreter version. The current contents of this variable is ""Lua 5.1"".|||25@@@Coroutines
Includes the coroutine manipulation functions as explained in Lua - Coroutines.&&&Sr.No.@@@Library / Method & Purpose|||1@@@math.abs (x)
Returns the absolute value of x.|||2@@@math.acos (x)
Returns the arc cosine of x (in radians).|||3@@@math.asin (x)
Returns the arc sine of x (in radians).|||4@@@math.atan (x)
Returns the arc tangent of x (in radians).|||5@@@math.atan2 (y, x)
Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)|||6@@@math.ceil (x)
Returns the smallest integer larger than or equal to x.|||7@@@math.cos (x)
Returns the cosine of x (assumed to be in radians).|||8@@@math.cosh (x)
Returns the hyperbolic cosine of x.|||9@@@math.deg (x)
Returns the angle x (given in radians) in degrees.|||10@@@math.exp (x)
Returns the value e power x.|||11@@@math.floor (x)
Returns the largest integer smaller than or equal to x.|||12@@@math.fmod (x, y)
Returns the remainder of the division of x by y that rounds the quotient towards zero.|||13@@@math.frexp (x)
Returns m and e such that x = m2e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).|||14@@@math.huge
The value HUGE_VAL, a value larger than or equal to any other numerical valu.|||15@@@math.ldexp (m, e)
Returns m2e (e should be an integer).|||16@@@math.log (x)
Returns the natural logarithm of x.|||17@@@math.log10 (x)
Returns the base-10 logarithm of x.|||18@@@math.max (x, ...)
Returns the maximum value among its arguments.|||19@@@math.min (x, ...)
Returns the minimum value among its arguments.|||20@@@math.modf (x)
Returns two numbers, the integral part of x and the fractional part of x.|||21@@@math.pi
The value of pi.|||22@@@math.pow (x, y)
Returns xy. (You can also use the expression x^y to compute this value.)|||23@@@math.rad (x)
Returns the angle x (given in degrees) in radians.|||24@@@math.random ([m [, n]])
This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.When called without arguments, returns a uniform pseudo-random real number in the range [0,1). When called with an integer number m, math.random returns a uniform pseudo-random integer in the range [1, m]. When called with two integer numbers m and n, math.random returns a uniform pseudo-random integer in the range [m, n].|||25@@@math.randomseed (x)
Sets x as the ""seed"" for the pseudo-random generator: equal seeds produce equal sequences of numbers.|||26@@@math.sin (x)
Returns the sine of x (assumed to be in radians).|||27@@@math.sinh (x)
Returns the hyperbolic sine of x.|||28@@@math.sqrt (x)
Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)|||29@@@math.tan (x)
Returns the tangent of x (assumed to be in radians).|||30@@@math.tanh (x)
Returns the hyperbolic tangent of x.&&&Sr.No.@@@Library / Method & Purpose|||1@@@os.clock ()
Returns an approximation of the amount in seconds of CPU time used by the program.|||2@@@os.date ([format [, time]])
Returns a string or a table containing date and time, formatted according to the given string format.|||3@@@os.difftime (t2, t1)
Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.|||4@@@os.execute ([command])
This function is equivalent to the ANSI C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise.|||5@@@os.exit ([code [, close])
Calls the ANSI C function exit to terminate the host program. If code is true, the returned status is EXIT_SUCCESS; if code is false, the returned status is EXIT_FAILURE; if code is a number, the returned status is this number.|||6@@@os.getenv (varname)
Returns the value of the process environment variable varname, or nil if the variable is not defined.|||7@@@os.remove (filename)
Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns nil, plus a string describing the error and the error code.|||8@@@os.rename (oldname, newname)
 Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a string describing the error and the error code.|||9@@@os.setlocale (locale [, category])
Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: ""all"", ""collate"", ""ctype"", ""monetary"", ""numeric"", or ""time""; the default category is ""all"". The function returns the name of the new locale, or nil if the request cannot be honored.|||10@@@os.time ([table])
Returns the current time when called without arguments, or a time representing the date and time specified by the given table. This table must have fields year, month, and day, and may have fields hour (default is 12), min (default is 0), sec (default is 0), and isdst (default is nil). For a description of these fields, see the os.date function.|||11@@@os.tmpname ()
Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.","print(""Hello World!"")|||print(""Hello World!"")|||print(""Hello World!"")|||print(""test"")|||print(""test"")|||#!/usr/local/bin/luaprint(""test"")|||-- Variable definition:local a, b-- Initializationa = 10b = 30print(""value of a:"", a)print(""value of b:"", b)-- Swapping of variablesb, a = a, bprint(""value of a:"", a)print(""value of b:"", b)f = 70.0/3.0print(""value of f"", f)|||print(type(""What is my type""))   --> stringt = 10print(type(5.8*t))               --> numberprint(type(true))                --> booleanprint(type(print))               --> functionprint(type(nil))                 --> nilprint(type(type(ABC)))           --> string|||while( true )do   print(""This loop will run forever."")end|||--[[ function returning the max between two numbers --]]function max(num1, num2)   if (num1 > num2) then      result = num1;   else      result = num2;   end   return result; end|||function max(num1, num2)   if (num1 > num2) then      result = num1;   else      result = num2;   end   return result; end-- calling a functionprint(""The maximum of the two numbers is "",max(10,4))print(""The maximum of the two numbers is "",max(5,6))|||myprint = function(param)   print(""This is my print function -   ##"",param,""##"")endfunction add(num1,num2,functionPrint)   result = num1 + num2   functionPrint(result)endmyprint(10)add(2,5,myprint)|||function average(...)   result = 0   local arg = {...}   for i,v in ipairs(arg) do      result = result + v   end   return result/#argendprint(""The average is"",average(10,5,3,4,5,6))|||string1 = ""Lua""print(""\""String 1 is\"""",string1)string2 = 'Tutorial'print(""String 2 is"",string2)string3 = [[""Lua Tutorial""]]print(""String 3 is"",string3)|||string1 = ""Lua"";print(string.upper(string1))print(string.lower(string1))|||string = ""Lua Tutorial""-- replacing stringsnewstring = string.gsub(string,""Tutorial"",""Language"")print(""The new string is ""..newstring)|||string = ""Lua Tutorial""-- replacing stringsprint(string.find(string,""Tutorial""))reversedString = string.reverse(string)print(""The new string is"",reversedString)|||string1 = ""Lua""string2 = ""Tutorial""number1 = 10number2 = 20-- Basic string formattingprint(string.format(""Basic formatting %s %s"",string1,string2))-- Date formattingdate = 2; month = 1; year = 2014print(string.format(""Date formatting %02d/%02d/%03d"", date, month, year))-- Decimal formattingprint(string.format(""%.4f"",1/3))|||-- Byte conversion-- First characterprint(string.byte(""Lua""))-- Third characterprint(string.byte(""Lua"",3))-- first character from lastprint(string.byte(""Lua"",-1))-- Second characterprint(string.byte(""Lua"",2))-- Second character from lastprint(string.byte(""Lua"",-2))-- Internal Numeric ASCII Conversionprint(string.char(97))|||string1 = ""Lua""string2 = ""Tutorial""-- String Concatenations using ..print(""Concatenated string"",string1..string2)-- Length of stringprint(""Length of string1 is "",string.len(string1))-- Repeating stringsrepeatedString = string.rep(string1,3)print(repeatedString)|||array = {""Lua"", ""Tutorial""}for i = 0, 2 do   print(array[i])end|||array = {}for i= -2, 2 do   array[i] = i *2endfor i = -2,2 do   print(array[i])end|||-- Initializing the arrayarray = {}for i=1,3 do   array[i] = {}	   for j=1,3 do      array[i][j] = i*j   end	end-- Accessing the arrayfor i=1,3 do   for j=1,3 do      print(array[i][j])   end	end|||-- Initializing the arrayarray = {}maxRows = 3maxColumns = 3for row=1,maxRows do   for col=1,maxColumns do      array[row*maxColumns +col] = row*col   end	end-- Accessing the arrayfor row=1,maxRows do   for col=1,maxColumns do      print(array[row*maxColumns +col])   end	end|||array = {""Lua"", ""Tutorial""}for key,value in ipairs(array) do   print(key, value)end|||function square(iteratorMaxCount,currentNumber)   if currentNumber<iteratorMaxCount   then      currentNumber = currentNumber+1      return currentNumber, currentNumber*currentNumber   end	endfor i,n in square,3,0do   print(i,n)end|||function square(iteratorMaxCount,currentNumber)   if currentNumber<iteratorMaxCount   then      currentNumber = currentNumber+1      return currentNumber, currentNumber*currentNumber   end	endfunction squares(iteratorMaxCount)   return square,iteratorMaxCount,0end  for i,n in squares(3)do    print(i,n)end|||array = {""Lua"", ""Tutorial""}function elementIterator (collection)   local index = 0   local count = #collection	   -- The closure function is returned	   return function ()      index = index + 1		      if index <= count      then         -- return the current element of the iterator         return collection[index]      end		   end	endfor element in elementIterator(array)do   print(element)end|||-- Simple empty tablemytable = {}print(""Type of mytable is "",type(mytable))mytable[1]= ""Lua""mytable[""wow""] = ""Tutorial""print(""mytable Element at index 1 is "", mytable[1])print(""mytable Element at index wow is "", mytable[""wow""])-- alternatetable and mytable refers to same tablealternatetable = mytableprint(""alternatetable Element at index 1 is "", alternatetable[1])print(""alternatetable Element at index wow is "", alternatetable[""wow""])alternatetable[""wow""] = ""I changed it""print(""mytable Element at index wow is "", mytable[""wow""])-- only variable released and and not tablealternatetable = nilprint(""alternatetable is "", alternatetable)-- mytable is still accessibleprint(""mytable Element at index wow is "", mytable[""wow""])mytable = nilprint(""mytable is "", mytable)|||fruits = {""banana"",""orange"",""apple""}-- returns concatenated string of tableprint(""Concatenated string "",table.concat(fruits))--concatenate with a characterprint(""Concatenated string "",table.concat(fruits,"", ""))--concatenate fruits based on indexprint(""Concatenated string "",table.concat(fruits,"", "", 2,3))|||fruits = {""banana"",""orange"",""apple""}-- insert a fruit at the endtable.insert(fruits,""mango"")print(""Fruit at index 4 is "",fruits[4])--insert fruit at index 2table.insert(fruits,2,""grapes"")print(""Fruit at index 2 is "",fruits[2])print(""The maximum elements in table is"",table.maxn(fruits))print(""The last element is"",fruits[5])table.remove(fruits)print(""The previous last element is"",fruits[5])|||fruits = {""banana"",""orange"",""apple"",""grapes""}for k,v in ipairs(fruits) do   print(k,v)endtable.sort(fruits)print(""sorted table"")for k,v in ipairs(fruits) do   print(k,v)end|||-- Assuming we have a module printFormatter-- Also printFormatter has a funtion simpleFormat(arg)-- Method 1require ""printFormatter""printFormatter.simpleFormat(""test"")-- Method 2local formatter = require ""printFormatter""formatter.simpleFormat(""test"")-- Method 3require ""printFormatter""local formatterFunction = printFormatter.simpleFormatformatterFunction(""test"")|||local mymath =  {}function mymath.add(a,b)   print(a+b)endfunction mymath.sub(a,b)   print(a-b)endfunction mymath.mul(a,b)   print(a*b)endfunction mymath.div(a,b)   print(a/b)endreturn mymath	|||mymathmodule = require(""mymath"")mymathmodule.add(10,20)mymathmodule.sub(30,20)mymathmodule.mul(10,20)mymathmodule.div(30,20)|||module(""mymath"", package.seeall)function mymath.add(a,b)   print(a+b)endfunction mymath.sub(a,b)   print(a-b)endfunction mymath.mul(a,b)   print(a*b)endfunction mymath.div(a,b)   print(a/b)end|||require(""mymath"")mymath.add(10,20)mymath.sub(30,20)mymath.mul(10,20)mymath.div(30,20)|||mytable = setmetatable({key1 = ""value1""}, {   __index = function(mytable, key)	      if key == ""key2"" then         return ""metatablevalue""      else         return mytable[key]      end   end})print(mytable.key1,mytable.key2)|||mytable = setmetatable({key1 = ""value1""},    { __index = { key2 = ""metatablevalue"" } })print(mytable.key1,mytable.key2)|||mymetatable = {}mytable = setmetatable({key1 = ""value1""}, { __newindex = mymetatable })print(mytable.key1)mytable.newkey = ""new value 2""print(mytable.newkey,mymetatable.newkey)mytable.key1 = ""new  value 1""print(mytable.key1,mymetatable.newkey1)|||mytable = setmetatable({key1 = ""value1""}, {   __newindex = function(mytable, key, value)      rawset(mytable, key, ""\""""..value..""\"""")   end})mytable.key1 = ""new value""mytable.key2 = 4print(mytable.key1,mytable.key2)|||mytable = setmetatable({ 1, 2, 3 }, {   __add = function(mytable, newtable)	      for i = 1, table.maxn(newtable) do         table.insert(mytable, table.maxn(mytable)+1,newtable[i])      end      return mytable   end})secondtable = {4,5,6}mytable = mytable + secondtablefor k,v in ipairs(mytable) do   print(k,v)end|||mytable = setmetatable({10}, {   __call = function(mytable, newtable)   sum = 0	      for i = 1, table.maxn(mytable) do         sum = sum + mytable[i]      end	      for i = 1, table.maxn(newtable) do         sum = sum + newtable[i]      end	      return sum   end})newtable = {10,20,30}print(mytable(newtable))|||mytable = setmetatable({ 10, 20, 30 }, {   __tostring = function(mytable)   sum = 0	      for k, v in pairs(mytable) do         sum = sum + v      end		      return ""The sum of values in the table is "" .. sum   end})print(mytable)|||co = coroutine.create(function (value1,value2)   local tempvar3 = 10   print(""coroutine section 1"", value1, value2, tempvar3)	   local tempvar1 = coroutine.yield(value1+1,value2+1)   tempvar3 = tempvar3 + value1   print(""coroutine section 2"",tempvar1 ,tempvar2, tempvar3)	   local tempvar1, tempvar2= coroutine.yield(value1+value2, value1-value2)   tempvar3 = tempvar3 + value1   print(""coroutine section 3"",tempvar1,tempvar2, tempvar3)   return value2, ""end""	end)print(""main"", coroutine.resume(co, 3, 2))print(""main"", coroutine.resume(co, 12,14))print(""main"", coroutine.resume(co, 5, 6))print(""main"", coroutine.resume(co, 10, 20))|||function getNumber()   local function getNumberHelper()      co = coroutine.create(function ()      coroutine.yield(1)      coroutine.yield(2)      coroutine.yield(3)      coroutine.yield(4)      coroutine.yield(5)      end)      return co   end	   if(numberHelper) then      status, number = coroutine.resume(numberHelper);		      if coroutine.status(numberHelper) == ""dead"" then         numberHelper = getNumberHelper()         status, number = coroutine.resume(numberHelper);      end		      return number   else      numberHelper = getNumberHelper()      status, number = coroutine.resume(numberHelper);      return number   end	endfor index = 1, 10 do   print(index, getNumber())end|||-- Opens a file in readfile = io.open(""test.lua"", ""r"")-- sets the default input file as test.luaio.input(file)-- prints the first line of the fileprint(io.read())-- closes the open fileio.close(file)-- Opens a file in append modefile = io.open(""test.lua"", ""a"")-- sets the default output file as test.luaio.output(file)-- appends a word test to the last line of the fileio.write(""-- End of the test.lua file"")-- closes the open fileio.close(file)|||-- Opens a file in read modefile = io.open(""test.lua"", ""r"")-- prints the first line of the fileprint(file:read())-- closes the opened filefile:close()-- Opens a file in append modefile = io.open(""test.lua"", ""a"")-- appends a word test to the last line of the filefile:write(""--test"")-- closes the open filefile:close()|||-- Opens a file in readfile = io.open(""test.lua"", ""r"")file:seek(""end"",-25)print(file:read(""*a""))-- closes the opened filefile:close()|||for a= 1,10   print(a)end|||function add(a,b)   return a+bendadd(10)|||local function add(a,b)   assert(type(a) == ""number"", ""a is not a number"")   assert(type(b) == ""number"", ""b is not a number"")   return a+bendadd(10)|||function myfunction ()   n = n/nilendif pcall(myfunction) then   print(""Success"")else	print(""Failure"")end|||function myfunction ()   n = n/nilendfunction myerrorhandler( err )   print( ""ERROR:"", err )endstatus = xpcall( myfunction, myerrorhandler )print( status)|||function myfunction ()   print(debug.traceback(""Stack trace""))   print(debug.getinfo(1))   print(""Stack trace end"")   return 10endmyfunction ()print(debug.getinfo(1))|||function newCounter ()   local n = 0   local k = 0	   return function ()      k = n      n = n + 1      return n   end	endcounter = newCounter ()print(counter())print(counter())local i = 1repeat   name, val = debug.getupvalue(counter, i)	   if name then      print (""index"", i, name, ""="", val)		      if(name == ""n"") then         debug.setupvalue (counter,2,10)      end		      i = i + 1   end -- if	until not nameprint(counter())|||mytable = {""apple"", ""orange"", ""banana""}print(collectgarbage(""count""))mytable = nilprint(collectgarbage(""count""))print(collectgarbage(""collect""))print(collectgarbage(""count""))|||-- Meta classRectangle = {area = 0, length = 0, breadth = 0}-- Derived class method newfunction Rectangle:new (o,length,breadth)   o = o or {}   setmetatable(o, self)   self.__index = self   self.length = length or 0   self.breadth = breadth or 0   self.area = length*breadth;   return oend-- Derived class method printAreafunction Rectangle:printArea ()   print(""The area of Rectangle is "",self.area)end|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end-- Creating an objectmyshape = Shape:new(nil,10)myshape:printArea()|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end|||Square = Shape:new()-- Derived class method newfunction Square:new (o,side)   o = o or Shape:new(o,side)   setmetatable(o, self)   self.__index = self   return oend|||-- Derived class method printAreafunction Square:printArea ()   print(""The area of square is "",self.area)end|||-- Meta classShape = {area = 0}-- Base class method newfunction Shape:new (o,side)   o = o or {}   setmetatable(o, self)   self.__index = self   side = side or 0   self.area = side*side;   return oend-- Base class method printAreafunction Shape:printArea ()   print(""The area is "",self.area)end-- Creating an objectmyshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- Derived class method newfunction Square:new (o,side)   o = o or Shape:new(o,side)   setmetatable(o, self)   self.__index = self   return oend-- Derived class method printAreafunction Square:printArea ()   print(""The area of square is "",self.area)end-- Creating an objectmysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- Derived class method newfunction Rectangle:new (o,length,breadth)   o = o or Shape:new(o)   setmetatable(o, self)   self.__index = self   self.area = length * breadth   return oend-- Derived class method printAreafunction Rectangle:printArea ()    print(""The area of Rectangle is "",self.area)end-- Creating an objectmyrectangle = Rectangle:new(nil,10,20)myrectangle:printArea()|||<IfModule mod_fcgid.c>   AddHandler fcgid-script .lua   AddHandler fcgid-script .ws   AddHandler fcgid-script .op	   FCGIWrapper ""/usr/local/bin/wsapi.fcgi"" .ws   FCGIWrapper ""/usr/local/bin/wsapi.fcgi"" .lua   FCGIWrapper ""/usr/local/bin/op.fcgi"" .op	   #FCGIServer ""/usr/local/bin/wsapi.fcgi"" -idle-timeout 60 -processes 1   #IdleTimeout 60   #ProcessLifeTime 60	</IfModule>|||#!/usr/bin/env index.lua-- index.luarequire""orbit""-- declarationmodule(""myorbit"", package.seeall, orbit.new)-- handlerfunction index(web)   return my_home_page()end-- dispatchmyorbit:dispatch_get(index, ""/"", ""/index"")-- Sample pagefunction my_home_page()   return [[      <head></head>      <html>         <h2>First Page</h2>      </html>   ]]	end|||#!/usr/bin/env index.lua-- index.luarequire""orbit""function generate()   return html {      head{title ""HTML Example""},		      body{         h2{""Here we go again!""}      }   }endorbit.htmlify(generate)print(generate())|||#!/usr/bin/env index.luarequire""orbit""function wrap (inner)   return html{ head(), body(inner) }endfunction test ()   return wrap(form (H'table' {      tr{td""First name"",td( input{type = 'text', name='first'})},      tr{td""Second name"",td(input{type = 'text', name='second'})},      tr{ td(input{type = 'submit', value = 'Submit!'}),         td(input{type = 'submit',value = 'Cancel'})      },   }))endorbit.htmlify(wrap,test)print(test())|||#!/usr/bin/env wsapi.cgimodule(..., package.seeall)function run(wsapi_env)   local headers = { [""Content-type""] = ""text/html"" }      local function hello_text()      coroutine.yield(""<html><body>"")      coroutine.yield(""<p&gtHello Wsapi!</p>"")      coroutine.yield(""<p&gtPATH_INFO: "" .. wsapi_env.PATH_INFO .. ""</p>"")      coroutine.yield(""<p&gtSCRIPT_NAME: "" .. wsapi_env.SCRIPT_NAME .. ""</p>"")      coroutine.yield(""</body></html>"")   end   return 200, headers, coroutine.wrap(hello_text)end|||require ""xavante.filehandler""require ""xavante.cgiluahandler""require ""xavante.redirecthandler""-- Define here where Xavante HTTP documents scripts are locatedlocal webDir = XAVANTE_WEBlocal simplerules = {   { -- URI remapping example      match = ""^[^%./]*/$"",      with = xavante.redirecthandler,      params = {""index.lp""}   },    { -- cgiluahandler example      match = {""%.lp$"", ""%.lp/.*$"", ""%.lua$"", ""%.lua/.*$"" },      with = xavante.cgiluahandler.makeHandler (webDir)   },       { -- filehandler example      match = ""."",      with = xavante.filehandler,      params = {baseDir = webDir}   },} xavante.HTTP{   server = {host = ""*"", port = 8080},       defaultHost = {      rules = simplerules   },}|||xavante.HTTP{   server = {host = ""*"", port = 8080},       defaultHost = {},       virtualhosts = {      [""www.sitename.com""] = simplerules   }}|||mysql = require ""luasql.mysql""local env  = mysql.mysql()local conn = env:connect('test','root','123456')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample2 (id INTEGER, name TEXT);]])print(status,errorString )|||cursor,errorString = conn:execute([[select * from sample]])row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   -- reusing the table of results   row = cursor:fetch (row, ""a"")end|||mysql = require ""luasql.mysql""local env  = mysql.mysql()local conn = env:connect('test','root','123456')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample3 (id INTEGER, name TEXT)]])print(status,errorString )status,errorString = conn:execute([[INSERT INTO sample3 values('12','Raj')]])print(status,errorString )cursor,errorString = conn:execute([[select * from sample3]])print(cursor,errorString)row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   row = cursor:fetch (row, ""a"")end-- close everythingcursor:close()conn:close()env:close()|||sqlite3 = require ""luasql.sqlite3""local env  = sqlite3.sqlite3()local conn = env:connect('mydb.sqlite')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample ('id' INTEGER, 'name' TEXT)]])print(status,errorString )|||cursor,errorString = conn:execute([[select * from sample]])row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   -- reusing the table of results   row = cursor:fetch (row, ""a"")end|||sqlite3 = require ""luasql.sqlite3""local env  = sqlite3.sqlite3()local conn = env:connect('mydb.sqlite')print(env,conn)status,errorString = conn:execute([[CREATE TABLE sample ('id' INTEGER, 'name' TEXT)]])print(status,errorString )status,errorString = conn:execute([[INSERT INTO sample values('1','Raj')]])print(status,errorString )cursor,errorString = conn:execute([[select * from sample]])print(cursor,errorString)row = cursor:fetch ({}, ""a"")while row do   print(string.format(""Id: %s, Name: %s"", row.id, row.name))   row = cursor:fetch (row, ""a"")end-- close everythingcursor:close()conn:close()env:close()|||radianVal = math.rad(math.pi / 2)io.write(radianVal,""\n"")-- Sin value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.sin(radianVal)),""\n"")-- Cos value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.cos(radianVal)),""\n"")-- Tan value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.tan(radianVal)),""\n"")-- Cosh value of 90(math.pi / 2) degreesio.write(string.format(""%.1f "", math.cosh(radianVal)),""\n"")-- Pi Value in degreesio.write(math.deg(math.pi),""\n"")|||-- Floorio.write(""Floor of 10.5055 is "", math.floor(10.5055),""\n"")-- Ceilio.write(""Ceil of 10.5055 is "", math.ceil(10.5055),""\n"")-- Square rootio.write(""Square root of 16 is "",math.sqrt(16),""\n"")-- Powerio.write(""10 power 2 is "",math.pow(10,2),""\n"")io.write(""100 power 0.5 is "",math.pow(100,0.5),""\n"")-- Absoluteio.write(""Absolute value of -10 is "",math.abs(-10),""\n"")--Randommath.randomseed(os.time())io.write(""Random number between 1 and 100 is "",math.random(),""\n"")--Random between 1 to 100io.write(""Random number between 1 and 100 is "",math.random(1,100),""\n"")--Maxio.write(""Maximum in the input array is "",math.max(1,100,101,99,999),""\n"")--Minio.write(""Minimum in the input array is "",math.min(1,100,101,99,999),""\n"")|||-- Date with formatio.write(""The date is "", os.date(""%m/%d/%Y""),""\n"")-- Date and timeio.write(""The date and time is "", os.date(),""\n"")-- Timeio.write(""The OS time is "", os.time(),""\n"")-- Wait for some timefor i=1,1000000 doend-- Time since Lua startedio.write(""Lua started before "", os.clock(),""\n"")"
Learn Lua,Lua - Useful Resources,Lua - Useful Resources|||Useful Video Courses@@@Useful eBooks|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable@@@Lua Tutorial,The following resources contain additional information on Lua. Please use them to get more in-depth knowledge on this topic.,,,,
Learn Lua,Discuss Lua,Discuss Lua|||Useful Video Courses|||Basics of Raising Finance for startup & Business Valuation@@@Practical Real Company's Financial Modeling + Valuation 2021@@@SAP ABAP Full Training / Time is Valuable,Lua is an open source language built on top of C programming language. Lua has its value across multiple platforms ranging from large server systems to small mobile applications. This tutorial covers various topics ranging from the basics of Lua to its scope in various applications.,,,,
