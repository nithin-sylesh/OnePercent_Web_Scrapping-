Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Node.js,Node.js Tutorial,Node.js Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node.js is a very powerful JavaScript-based platform built on Google Chrome's JavaScript V8 Engine. It is used to develop I/O intensive web applications like video streaming sites, single-page applications, and other web applications. Node.js is open source, completely free, and used by thousands of developers around the world.|||This tutorial is designed for software programmers who want to learn the basics of Node.js and its architectural concepts. This tutorial will give you enough understanding on all the necessary components of Node.js with suitable examples.|||Before proceeding with this tutorial, you should have a basic understanding of JavaScript. As we are going to develop web-based applications using Node.js, it will be good if you have some understanding of other web technologies such as HTML, CSS, AJAX, etc.",,,,
Learn Node.js,Node.js - Introduction,Node.js - Introduction|||What is Node.js?@@@Features of Node.js@@@Who Uses Node.js?@@@Concepts@@@Where to Use Node.js?@@@Where Not to Use Node.js?@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node.js is a server-side platform built on Google Chrome's JavaScript Engine (V8 Engine). Node.js was developed by Ryan Dahl in 2009 and its latest version is v0.10.36. The definition of Node.js as supplied by its official documentation is as follows −|||Node.js is a platform built on Chrome's JavaScript runtime for easily building fast and scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.|||Node.js is an open source, cross-platform runtime environment for developing server-side and networking applications. Node.js applications are written in JavaScript, and can be run within the Node.js runtime on OS X, Microsoft Windows, and Linux.|||Node.js also provides a rich library of various JavaScript modules which simplifies the development of web applications using Node.js to a great extent.|||Following are some of the important features that make Node.js the first choice of software architects.|||Asynchronous and Event Driven − All APIs of Node.js library are asynchronous, that is, non-blocking. It essentially means a Node.js based server never waits for an API to return data. The server moves to the next API after calling it and a notification mechanism of Events of Node.js helps the server to get a response from the previous API call.|||Very Fast − Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.|||Single Threaded but Highly Scalable − Node.js uses a single threaded model with event looping. Event mechanism helps the server to respond in a non-blocking way and makes the server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and the same program can provide service to a much larger number of requests than traditional servers like Apache HTTP Server.|||No Buffering − Node.js applications never buffer any data. These applications simply output the data in chunks.|||License − Node.js is released under the MIT license.|||Following is the link on github wiki containing an exhaustive list of projects, application and companies which are using Node.js. This list includes eBay, General Electric, GoDaddy, Microsoft, PayPal, Uber, Wikipins, Yahoo!, and Yammer to name a few.|||Projects, Applications, and Companies Using Node|||The following diagram depicts some important parts of Node.js which we will discuss in detail in the subsequent chapters.|||Following are the areas where Node.js is proving itself as a perfect technology partner.|||It is not advisable to use Node.js for CPU intensive applications.","Asynchronous and Event Driven − All APIs of Node.js library are asynchronous, that is, non-blocking. It essentially means a Node.js based server never waits for an API to return data. The server moves to the next API after calling it and a notification mechanism of Events of Node.js helps the server to get a response from the previous API call.@@@Very Fast − Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.@@@Single Threaded but Highly Scalable − Node.js uses a single threaded model with event looping. Event mechanism helps the server to respond in a non-blocking way and makes the server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and the same program can provide service to a much larger number of requests than traditional servers like Apache HTTP Server.@@@No Buffering − Node.js applications never buffer any data. These applications simply output the data in chunks.@@@License − Node.js is released under the MIT license.|||Projects, Applications, and Companies Using Node|||I/O bound Applications@@@Data Streaming Applications@@@Data Intensive Real-time Applications (DIRT)@@@JSON APIs based Applications@@@Single Page Applications",,,
Learn Node.js,Node.js - Environment Setup,"Node.js - Environment Setup|||Try it Option Online@@@Local Environment Setup@@@Text Editor@@@The Node.js Runtime@@@Download Node.js archive@@@Installation on UNIX/Linux/Mac OS X, and SunOS@@@Installation on Windows@@@Verify installation: Executing a File@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS","You really do not need to set up your own environment to start learning Node.js. Reason is very simple, we already have set up Node.js environment online, so that you can execute all the available examples online and learn through practice. Feel free to modify any example and check the results with different options.|||Try the following example using the Live Demo option available at the top right corner of the below sample code box (on our website) −|||For most of the examples given in this tutorial, you will find a Try it option, so just make use of it and enjoy your learning.|||If you are still willing to set up your environment for Node.js, you need the following two softwares available on your computer, (a) Text Editor and (b) The Node.js binary installables.|||This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.|||The files you create with your editor are called source files and contain program source code. The source files for Node.js programs are typically named with the extension "".js"".|||Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, and finally execute it.|||The source code written in source file is simply javascript. The Node.js interpreter will be used to interpret and execute your javascript code.|||Node.js distribution comes as a binary installable for SunOS , Linux, Mac OS X, and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. |||Following section guides you on how to install Node.js binary distribution on various OS.|||Download latest version of Node.js installable archive file  from Node.js Downloads. At the time of writing this tutorial, following are the versions available on different OS.|||Based on your OS architecture, download and extract the archive node-v6.3.1-osname.tar.gz into /tmp, and then finally move extracted files into /usr/local/nodejs directory. For example:|||Add /usr/local/nodejs/bin to the PATH environment variable.|||Use the MSI file and follow the prompts to install the Node.js. By default, the installer uses the Node.js distribution in C:\Program Files\nodejs. The installer should set the C:\Program Files\nodejs\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.|||Create a js file named main.js on your machine (Windows or Linux) having the following code.|||Now execute main.js file using Node.js interpreter to see the result −|||If everything is fine with your installation, this should produce the following result −",,,OS@@@Archive name|||Windows@@@node-v6.3.1-x64.msi|||Linux@@@node-v6.3.1-linux-x86.tar.gz|||Mac@@@node-v6.3.1-darwin-x86.tar.gz|||SunOS@@@node-v6.3.1-sunos-x86.tar.gz&&&OS@@@Output|||Linux@@@export PATH=$PATH:/usr/local/nodejs/bin|||Mac@@@export PATH=$PATH:/usr/local/nodejs/bin|||FreeBSD@@@export PATH=$PATH:/usr/local/nodejs/bin,"/* Hello World! program in Node.js */console.log(""Hello World!"");|||/* Hello, World! program in node.js */console.log(""Hello, World!"")|||$ node main.js"
Learn Node.js,Node.js - First Application,Node.js - First Application|||Creating Node.js Application@@@Make a Request to the Node.js Server@@@Useful Video Courses|||Step 1 - Import Required Module@@@Step 2 - Create Server@@@Step 3 - Testing Request & Response|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Before creating an actual ""Hello, World!"" application using Node.js, let us see the components of a Node.js application. A Node.js application consists of the following three important components −|||Import required modules − We use the require directive to load Node.js modules.|||Create server − A server which will listen to client's requests similar to Apache HTTP Server.|||Read request and return response − The server created in an earlier step will read the HTTP request made by the client which can be a browser or a console and return the response.|||We use the require directive to load the http module and store the returned HTTP instance into an http variable as follows −|||We use the created http instance and call http.createServer() method to create a server instance and then we bind it at port 8081 using the listen method associated with the server instance. Pass it a function with parameters request and response. Write the sample implementation to always return ""Hello World"".|||The above code is enough to create an HTTP server which listens, i.e., waits for a request over 8081 port on the local machine.|||Let's put step 1 and 2 together in a file called main.js and start our HTTP server as shown below −|||Now execute the main.js to start the server as follows −|||Verify the Output. Server has started.|||Open http://127.0.0.1:8081/ in any browser and observe the following result.|||Congratulations, you have your first HTTP server up and running which is responding to all the HTTP requests at port 8081.",Import required modules − We use the require directive to load Node.js modules.@@@Create server − A server which will listen to client's requests similar to Apache HTTP Server.@@@Read request and return response − The server created in an earlier step will read the HTTP request made by the client which can be a browser or a console and return the response.,,,"http.createServer(function (request, response) {   // Send the HTTP header    // HTTP Status: 200 : OK   // Content Type: text/plain   response.writeHead(200, {'Content-Type': 'text/plain'});      // Send the response body as ""Hello World""   response.end('Hello World\n');}).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||var http = require(""http"");http.createServer(function (request, response) {   // Send the HTTP header    // HTTP Status: 200 : OK   // Content Type: text/plain   response.writeHead(200, {'Content-Type': 'text/plain'});      // Send the response body as ""Hello World""   response.end('Hello World\n');}).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||$ node main.js"
Learn Node.js,Node.js - REPL Terminal,Node.js - REPL Terminal|||Online REPL Terminal@@@REPL Commands@@@Stopping REPL@@@Useful Video Courses|||Starting REPL@@@Simple Expression@@@Use Variables@@@Multiline Expression@@@Underscore Variable|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"REPL stands for Read Eval Print Loop and it represents a computer environment like a Windows console or Unix/Linux shell where a command is entered and the system responds with an output in an interactive mode. Node.js or Node comes bundled with a REPL environment. It performs the following tasks −|||Read − Reads user's input, parses the input into JavaScript data-structure, and stores in memory.|||Eval − Takes and evaluates the data structure.|||Print − Prints the result.|||Loop − Loops the above command until the user presses ctrl-c twice.|||The REPL feature of Node is very useful in experimenting with Node.js codes and to debug JavaScript codes.|||To simplify your learning, we have set up an easy to use Node.js REPL environment online, where you can practice Node.js syntax − Launch Node.js REPL Terminal |||REPL can be started by simply running node on shell/console without any arguments as follows.|||You will see the REPL Command prompt > where you can type any Node.js command −|||Let's try a simple mathematics at the Node.js REPL command prompt −|||You can make use variables to store values and print later like any conventional script. If var keyword is not used, then the value is stored in the variable and printed. Whereas if var keyword is used, then the value is stored but not printed. You can print variables using console.log().|||Node REPL supports multiline expression similar to JavaScript. Let's check the following do-while loop in action −|||... comes automatically when you press Enter after the opening bracket. Node automatically checks the continuity of expressions.|||You can use underscore (_) to get the last result −|||ctrl + c − terminate the current command.|||ctrl + c twice − terminate the Node REPL.|||ctrl + d − terminate the Node REPL.|||Up/Down Keys − see command history and modify previous commands.|||tab Keys − list of current commands.|||.help − list of all commands.|||.break − exit from multiline expression.|||.clear − exit from multiline expression.|||.save filename − save the current Node REPL session to a file.|||.load filename − load file content in current Node REPL session.|||As mentioned above, you will need to use ctrl-c twice to come out of Node.js REPL.","Read − Reads user's input, parses the input into JavaScript data-structure, and stores in memory.@@@Eval − Takes and evaluates the data structure.@@@Print − Prints the result.@@@Loop − Loops the above command until the user presses ctrl-c twice.|||ctrl + c − terminate the current command.@@@ctrl + c twice − terminate the Node REPL.@@@ctrl + d − terminate the Node REPL.@@@Up/Down Keys − see command history and modify previous commands.@@@tab Keys − list of current commands.@@@.help − list of all commands.@@@.break − exit from multiline expression.@@@.clear − exit from multiline expression.@@@.save filename − save the current Node REPL session to a file.@@@.load filename − load file content in current Node REPL session.",,,
Learn Node.js,Node.js - NPM,Node.js - NPM|||Installing Modules using NPM@@@Global vs Local Installation@@@Using package.json@@@Attributes of Package.json@@@Uninstalling a Module@@@Updating a Module@@@Search a Module@@@Create a Module@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node Package Manager (NPM) provides two main functionalities −|||Online repositories for node.js packages/modules which are searchable on search.nodejs.org|||Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.|||NPM comes bundled with Node.js installables after v0.6.3 version. To verify the same, open console and type the following command and see the result −|||If you are running an old version of NPM then it is quite easy to update it to the latest version. Just use the following command from root −|||There is a simple syntax to install any Node.js module −|||For example, following is the command to install a famous Node.js web framework module called express −|||Now you can use this module in your js file as following −|||By default, NPM installs any dependency in the local mode. Here local mode refers to the package installation in node_modules directory lying in the folder where Node application is present. Locally deployed packages are accessible via require() method. For example, when we installed express module, it created node_modules directory in the current directory where it installed the express module.|||Alternatively, you can use npm ls command to list down all the locally installed modules.|||Globally installed packages/dependencies are stored in system directory. Such dependencies can be used in CLI (Command Line Interface) function of any node.js but cannot be imported using require() in Node application directly. Now let's try installing the express module using global installation.|||This will produce a similar result but the module will be installed globally. Here, the first line shows the module version and the location where it is getting installed.|||You can use the following command to check all the modules installed globally −|||package.json is present in the root directory of any Node application/module and is used to define the properties of a package. Let's open package.json of express package present in node_modules/express/|||name − name of the package|||version − version of the package|||description − description of the package|||homepage − homepage of the package|||author − author of the package|||contributors − name of the contributors to the package|||dependencies − list of dependencies. NPM automatically installs all the dependencies mentioned here in the node_module folder of the package.|||repository − repository type and URL of the package|||main − entry point of the package|||keywords − keywords|||Use the following command to uninstall a Node.js module.|||Once NPM uninstalls the package, you can verify it by looking at the content of /node_modules/ directory or type the following command −|||Update package.json and change the version of the dependency to be updated and run the following command.|||Search a package name using NPM.|||Creating a module requires package.json to be generated. Let's generate package.json using NPM, which will generate the basic skeleton of the package.json.|||You will need to provide all the required information about your module. You can take help from the above-mentioned package.json file to understand the meanings of various information demanded. Once package.json is generated, use the following command to register yourself with NPM repository site using a valid email address.|||It is time now to publish your module −|||If everything is fine with your module, then it will be published in the repository and will be accessible to install using NPM like any other Node.js module.","Online repositories for node.js packages/modules which are searchable on search.nodejs.org@@@Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.|||name − name of the package@@@version − version of the package@@@description − description of the package@@@homepage − homepage of the package@@@author − author of the package@@@contributors − name of the contributors to the package@@@dependencies − list of dependencies. NPM automatically installs all the dependencies mentioned here in the node_module folder of the package.@@@repository − repository type and URL of the package@@@main − entry point of the package@@@keywords − keywords",,,"{   ""name"": ""express"",      ""description"": ""Fast, unopinionated, minimalist web framework"",      ""version"": ""4.11.2"",      ""author"": {               ""name"": ""TJ Holowaychuk"",         ""email"": ""tj@vision-media.ca""      },      ""contributors"": [{      ""name"": ""Aaron Heckmann"",      ""email"": ""aaron.heckmann+github@gmail.com""   },       {      ""name"": ""Ciaran Jessup"",      ""email"": ""ciaranj@gmail.com""   },      {      ""name"": ""Douglas Christopher Wilson"",      ""email"": ""doug@somethingdoug.com""   },      {      ""name"": ""Guillermo Rauch"",      ""email"": ""rauchg@gmail.com""   },      {      ""name"": ""Jonathan Ong"",      ""email"": ""me@jongleberry.com""   },      {      ""name"": ""Roman Shtylman"",      ""email"": ""shtylman+expressjs@gmail.com""   },      {      ""name"": ""Young Jae Sim"",      ""email"": ""hanul@hanul.me""   } ],      ""license"": ""MIT"", ""repository"": {      ""type"": ""git"",      ""url"": ""https://github.com/strongloop/express""   },      ""homepage"": ""https://expressjs.com/"", ""keywords"": [      ""express"",      ""framework"",      ""sinatra"",      ""web"",      ""rest"",      ""restful"",      ""router"",      ""app"",      ""api""   ],      ""dependencies"": {      ""accepts"": ""~1.2.3"",      ""content-disposition"": ""0.5.0"",      ""cookie-signature"": ""1.0.5"",      ""debug"": ""~2.1.1"",      ""depd"": ""~1.0.0"",      ""escape-html"": ""1.0.1"",      ""etag"": ""~1.5.1"",      ""finalhandler"": ""0.3.3"",      ""fresh"": ""0.2.4"",      ""media-typer"": ""0.3.0"",      ""methods"": ""~1.1.1"",      ""on-finished"": ""~2.2.0"",      ""parseurl"": ""~1.3.0"",      ""path-to-regexp"": ""0.1.3"",      ""proxy-addr"": ""~1.0.6"",      ""qs"": ""2.3.3"",      ""range-parser"": ""~1.0.2"",      ""send"": ""0.11.1"",      ""serve-static"": ""~1.8.1"",      ""type-is"": ""~1.5.6"",      ""vary"": ""~1.0.0"",      ""cookie"": ""0.1.2"",      ""merge-descriptors"": ""0.0.2"",      ""utils-merge"": ""1.0.0""   },      ""devDependencies"": {      ""after"": ""0.8.1"",      ""ejs"": ""2.1.4"",      ""istanbul"": ""0.3.5"",      ""marked"": ""0.3.3"",      ""mocha"": ""~2.1.0"",      ""should"": ""~4.6.2"",      ""supertest"": ""~0.15.0"",      ""hjs"": ""~0.0.6"",      ""body-parser"": ""~1.11.0"",      ""connect-redis"": ""~2.2.0"",      ""cookie-parser"": ""~1.3.3"",      ""express-session"": ""~1.10.2"",      ""jade"": ""~1.9.1"",      ""method-override"": ""~2.3.1"",      ""morgan"": ""~1.5.1"",      ""multiparty"": ""~4.1.1"",      ""vhost"": ""~3.0.0""   },      ""engines"": {      ""node"": "">= 0.10.0""   },      ""files"": [      ""LICENSE"",      ""History.md"",      ""Readme.md"",      ""index.js"",      ""lib/""   ],      ""scripts"": {      ""test"": ""mocha --require test/support/env          --reporter spec --bail --check-leaks test/ test/acceptance/"",      ""test-cov"": ""istanbul cover node_modules/mocha/bin/_mocha          -- --require test/support/env --reporter dot --check-leaks test/ test/acceptance/"",      ""test-tap"": ""mocha --require test/support/env          --reporter tap --check-leaks test/ test/acceptance/"",      ""test-travis"": ""istanbul cover node_modules/mocha/bin/_mocha          --report lcovonly -- --require test/support/env          --reporter spec --check-leaks test/ test/acceptance/""   },      ""gitHead"": ""63ab25579bda70b4927a179b580a9c580b6c7ada"",   ""bugs"": {      ""url"": ""https://github.com/strongloop/express/issues""   },      ""_id"": ""express@4.11.2"",   ""_shasum"": ""8df3d5a9ac848585f00a0777601823faecd3b148"",   ""_from"": ""express@*"",   ""_npmVersion"": ""1.4.28"",   ""_npmUser"": {      ""name"": ""dougwilson"",      ""email"": ""doug@somethingdoug.com""   },      ""maintainers"": [{      ""name"": ""tjholowaychuk"",      ""email"": ""tj@vision-media.ca""   },      {      ""name"": ""jongleberry"",      ""email"": ""jonathanrichardong@gmail.com""   },      {      ""name"": ""shtylman"",      ""email"": ""shtylman@gmail.com""   },      {      ""name"": ""dougwilson"",      ""email"": ""doug@somethingdoug.com""   },      {      ""name"": ""aredridel"",      ""email"": ""aredridel@nbtsc.org""   },      {      ""name"": ""strongloop"",      ""email"": ""callback@strongloop.com""   },      {      ""name"": ""rfeng"",      ""email"": ""enjoyjava@gmail.com""   }],      ""dist"": {      ""shasum"": ""8df3d5a9ac848585f00a0777601823faecd3b148"",      ""tarball"": ""https://registry.npmjs.org/express/-/express-4.11.2.tgz""   },      ""directories"": {},      ""_resolved"": ""https://registry.npmjs.org/express/-/express-4.11.2.tgz"",      ""readme"": ""ERROR: No README data found!""}"
Learn Node.js,Node.js - Callbacks Concept,Node.js - Callbacks Concept|||What is Callback?@@@Blocking Code Example@@@Non-Blocking Code Example@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Callback is an asynchronous equivalent for a function. A callback function is called at the completion of a given task. Node makes heavy use of callbacks. All the APIs of Node are written in such a way that they support callbacks.|||For example, a function to read a file may start reading file and return the control to the execution environment immediately so that the next instruction can be executed. Once file I/O is complete, it will call the callback function while passing the callback function, the content of the file as a parameter. So there is no blocking or wait for File I/O. This makes Node.js highly scalable, as it can process a high number of requests without waiting for any function to return results.|||Create a text file named input.txt with the following content −|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Create a text file named input.txt with the following content.|||Update main.js to have the following code −|||Now run the main.js to see the result −|||Verify the Output.|||These two examples explain the concept of blocking and non-blocking calls.|||The first example shows that the program blocks until it reads the file and then only it proceeds to end the program.|||The second example shows that the program does not wait for file reading and proceeds to print ""Program Ended"" and at the same time, the program without blocking continues reading the file.|||Thus, a blocking program executes very much in sequence. From the programming point of view, it is easier to implement the logic but non-blocking programs do not execute in sequence. In case a program needs to use any data to be processed, it should be kept within the same block to make it sequential execution.","The first example shows that the program blocks until it reads the file and then only it proceeds to end the program.@@@The second example shows that the program does not wait for file reading and proceeds to print ""Program Ended"" and at the same time, the program without blocking continues reading the file.",,,"var fs = require(""fs"");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(""Program Ended"");|||Tutorials Point is giving self learning contentto teach the world in simple and easy way!!!!!|||var fs = require(""fs"");fs.readFile('input.txt', function (err, data) {   if (err) return console.error(err);   console.log(data.toString());});console.log(""Program Ended"");"
Learn Node.js,Node.js - Event Loop,Node.js - Event Loop|||Event-Driven Programming@@@Example@@@How Node Applications Work?@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node.js is a single-threaded application, but it can support concurrency via the concept of event and callbacks. Every API of Node.js is asynchronous and being single-threaded, they use async function calls to maintain concurrency. Node uses observer pattern. Node thread keeps an event loop and whenever a task gets completed, it fires the corresponding event which signals the event-listener function to execute.|||Node.js uses events heavily and it is also one of the reasons why Node.js is pretty fast compared to other similar technologies. As soon as Node starts its server, it simply initiates its variables, declares functions and then simply waits for the event to occur. |||In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected.|||Although events look quite similar to callbacks, the difference lies in the fact that callback functions are called when an asynchronous function returns its result, whereas event handling works on the observer pattern. The functions that listen to events act as Observers. Whenever an event gets fired, its listener function starts executing. Node.js has multiple in-built events available through events module and EventEmitter class which are used to bind events and event-listeners as follows −|||Following is the syntax to bind an event handler with an event −|||We can fire an event programmatically as follows −|||Create a js file named main.js with the following code −|||Now let's try to run the above program and check its output −|||IT should produce the following result −|||In Node Application, any async function accepts a callback as the last parameter and a callback function accepts an error as the first parameter. Let's revisit the previous example again. Create a text file named input.txt with the following content.|||Create a js file named main.js having the following code −|||Here fs.readFile() is a async function whose purpose is to read a file. If an error occurs during the read operation, then the err object will contain the corresponding error, else data will contain the contents of the file. readFile passes err and data to the callback function after the read operation is complete, which finally prints the content.",,,,"// Import events modulevar events = require('events');// Create an eventEmitter objectvar eventEmitter = new events.EventEmitter();// Create an event handler as followsvar connectHandler = function connected() {   console.log('connection succesful.');     // Fire the data_received event    eventEmitter.emit('data_received');}// Bind the connection event with the handlereventEmitter.on('connection', connectHandler); // Bind the data_received event with the anonymous functioneventEmitter.on('data_received', function() {   console.log('data received succesfully.');});// Fire the connection event eventEmitter.emit('connection');console.log(""Program Ended."");|||Tutorials Point is giving self learning contentto teach the world in simple and easy way!!!!!|||var fs = require(""fs"");fs.readFile('input.txt', function (err, data) {   if (err) {      console.log(err.stack);      return;   }   console.log(data.toString());});console.log(""Program Ended"");"
Learn Node.js,Node.js - Event Emitter,Node.js - Event Emitter|||EventEmitter Class@@@Methods@@@Class Methods@@@Events@@@Example@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Many objects in a Node emit events, for example, a net.Server emits an event each time a peer connects to it, an fs.readStream emits an event when the file is opened. All objects which emit events are the instances of events.EventEmitter.|||As we have seen in the previous section, EventEmitter class lies in the events module. It is accessible via the following code −|||When an EventEmitter instance faces any error, it emits an 'error' event. When a new listener is added, 'newListener' event is fired and when a listener is removed, 'removeListener' event is fired.|||EventEmitter provides multiple properties like on and emit. on property is used to bind a function with the event and emit is used to fire an event.|||addListener(event, listener)|||Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.|||on(event, listener)|||Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.|||once(event, listener)|||Adds a one time listener to the event. This listener is invoked only the next time the event is fired, after which it is removed. Returns emitter, so calls can be chained.|||removeListener(event, listener)|||Removes a listener from the listener array for the specified event. Caution − It changes the array indices in the listener array behind the listener. removeListener will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified event, then removeListener must be called multiple times to remove each instance. Returns emitter, so calls can be chained.|||removeAllListeners([event])|||Removes all listeners, or those of the specified event. It's not a good idea to remove listeners that were added elsewhere in the code, especially when it's on an emitter that you didn't create (e.g. sockets or file streams). Returns emitter, so calls can be chained.|||setMaxListeners(n)|||By default, EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.|||listeners(event)|||Returns an array of listeners for the specified event.|||emit(event, [arg1], [arg2], [...])|||Execute each of the listeners in order with the supplied arguments. Returns true if the event had listeners, false otherwise.|||listenerCount(emitter, event)|||Returns the number of listeners for a given event.|||newListener|||event − String: the event name|||listener − Function: the event handler function|||This event is emitted any time a listener is added. When this event is triggered, the listener may not yet have been added to the array of listeners for the event.|||removeListener|||event − String The event name|||listener − Function The event handler function|||This event is emitted any time someone removes a listener. When this event is triggered, the listener may not yet have been removed from the array of listeners for the event.|||Create a js file named main.js with the following Node.js code −|||Now run the main.js to see the result −|||Verify the Output.",,,"Sr.No.@@@Method & Description|||1@@@
addListener(event, listener)
Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.
|||2@@@
on(event, listener)
Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.
|||3@@@once(event, listener)
Adds a one time listener to the event. This listener is invoked only the next time the event is fired, after which it is removed. Returns emitter, so calls can be chained.
|||4@@@
removeListener(event, listener)
Removes a listener from the listener array for the specified event. Caution − It changes the array indices in the listener array behind the listener. removeListener will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified event, then removeListener must be called multiple times to remove each instance. Returns emitter, so calls can be chained.
|||5@@@
removeAllListeners([event])
Removes all listeners, or those of the specified event. It's not a good idea to remove listeners that were added elsewhere in the code, especially when it's on an emitter that you didn't create (e.g. sockets or file streams). Returns emitter, so calls can be chained.
|||6@@@
setMaxListeners(n)
By default, EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.
|||7@@@
listeners(event)
Returns an array of listeners for the specified event.
|||8@@@
emit(event, [arg1], [arg2], [...])
Execute each of the listeners in order with the supplied arguments. Returns true if the event had listeners, false otherwise.
&&&Sr.No.@@@Method & Description|||1@@@
listenerCount(emitter, event)
Returns the number of listeners for a given event.
&&&Sr.No.@@@Events & Description|||1@@@newListener

event − String: the event name
listener − Function: the event handler function

This event is emitted any time a listener is added. When this event is triggered, the listener may not yet have been added to the array of listeners for the event.
|||2@@@
removeListener

event − String The event name
listener − Function The event handler function

This event is emitted any time someone removes a listener. When this event is triggered, the listener may not yet have been removed from the array of listeners for the event.
","var events = require('events');var eventEmitter = new events.EventEmitter();// listener #1var listner1 = function listner1() {   console.log('listner1 executed.');}// listener #2var listner2 = function listner2() {   console.log('listner2 executed.');}// Bind the connection event with the listner1 functioneventEmitter.addListener('connection', listner1);// Bind the connection event with the listner2 functioneventEmitter.on('connection', listner2);var eventListeners = require('events').EventEmitter.listenerCount   (eventEmitter,'connection');console.log(eventListeners + "" Listner(s) listening to connection event"");// Fire the connection event eventEmitter.emit('connection');// Remove the binding of listner1 functioneventEmitter.removeListener('connection', listner1);console.log(""Listner1 will not listen now."");// Fire the connection event eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + "" Listner(s) listening to connection event"");console.log(""Program Ended."");"
Learn Node.js,Node.js - Buffers,Node.js - Buffers|||Creating Buffers@@@Writing to Buffers@@@Reading from Buffers@@@Convert Buffer to JSON@@@Concatenate Buffers@@@Compare Buffers@@@Copy Buffer@@@Slice Buffer@@@Buffer Length@@@Methods Reference@@@Class Methods@@@Useful Video Courses|||Method 1@@@Method 2@@@Method 3@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Return Value@@@Example|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Pure JavaScript is Unicode friendly, but it is not so for binary data. While dealing with TCP streams or the file system, it's necessary to handle octet streams. Node provides Buffer class which provides instances to store raw data similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.|||Buffer class is a global class that can be accessed in an application without importing the buffer module.|||Node Buffer can be constructed in a variety of ways.|||Following is the syntax to create an uninitiated Buffer of 10 octets −|||Following is the syntax to create a Buffer from a given array −|||Following is the syntax to create a Buffer from a given string and optionally encoding type −|||Though ""utf8"" is the default encoding, you can use any of the following encodings ""ascii"", ""utf8"", ""utf16le"", ""ucs2"", ""base64"" or ""hex"".|||Following is the syntax of the method to write into a Node Buffer −|||Here is the description of the parameters used −|||string − This is the string data to be written to buffer.|||offset − This is the index of the buffer to start writing at. Default value is 0.|||length − This is the number of bytes to write. Defaults to buffer.length.|||encoding − Encoding to use. 'utf8' is the default encoding.|||This method returns the number of octets written. If there is not enough space in the buffer to fit the entire string, it will write a part of the string.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to read data from a Node Buffer −|||Here is the description of the parameters used −|||encoding − Encoding to use. 'utf8' is the default encoding.|||start − Beginning index to start reading, defaults to 0.|||end − End index to end reading, defaults is complete buffer.|||This method decodes and returns a string from buffer data encoded using the specified character set encoding.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to convert a Node Buffer into JSON object −|||This method returns a JSON-representation of the Buffer instance.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to concatenate Node buffers to a single Node Buffer −|||Here is the description of the parameters used −|||list − Array List of Buffer objects to be concatenated.|||totalLength − This is the total length of the buffers when concatenated.|||This method returns a Buffer instance.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to compare two Node buffers −|||Here is the description of the parameters used −|||otherBuffer − This is the other buffer which will be compared with buf|||Returns a number indicating whether it comes before or after or is the same as the otherBuffer in sort order.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to copy a node buffer −|||Here is the description of the parameters used −|||targetBuffer − Buffer object where buffer will be copied.|||targetStart − Number, Optional, Default: 0|||sourceStart − Number, Optional, Default: 0|||sourceEnd − Number, Optional, Default: buffer.length|||No return value. Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to get a sub-buffer of a node buffer −|||Here is the description of the parameters used −|||start − Number, Optional, Default: 0|||end − Number, Optional, Default: buffer.length|||Returns a new buffer which references the same memory as the old one, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to get a size of a node buffer in bytes −|||Returns the size of a buffer in bytes.|||When the above program is executed, it produces following result −|||new Buffer(size)|||Allocates a new buffer of size octets. Note that the size must be no more than kMaxLength. Otherwise, a RangeError will be thrown here.|||new Buffer(buffer)|||Copies the passed buffer data onto a new Buffer instance.|||new Buffer(str[, encoding])|||Allocates a new buffer containing the given str. encoding defaults to 'utf8'.|||buf.length|||Returns the size of the buffer in bytes. Note that this is not necessarily the size of the contents. length refers to the amount of memory allocated for the buffer object. It does not change when the contents of the buffer are changed.|||buf.write(string[, offset][, length][, encoding])|||Writes a string to the buffer at offset using the given encoding. offset defaults to 0, encoding defaults to 'utf8'. length is the number of bytes to write. Returns the number of octets written.|||buf.writeUIntLE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeUIntBE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeIntLE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeIntBE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.readUIntLE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUIntBE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readIntLE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readIntBE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.toString([encoding][, start][, end])|||Decodes and returns a string from buffer data encoded using the specified character set encoding.|||buf.toJSON()|||Returns a JSON-representation of the Buffer instance. JSON.stringify implicitly calls this function when stringifying a Buffer instance.|||buf[index]|||Get and set the octet at index. The values refer to individual bytes, so the legal range is between 0x00 and 0xFF hex or 0 and 255.|||buf.equals(otherBuffer)|||Returns a boolean if this buffer and otherBuffer have the same bytes.|||buf.compare(otherBuffer)|||Returns a number indicating whether this buffer comes before or after or is the same as the otherBuffer in sort order.|||buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])|||Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.|||buf.slice([start][, end])|||Returns a new buffer which references the same memory as the old, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.|||buf.readUInt8(offset[, noAssert])|||Reads an unsigned 8 bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt16LE(offset[, noAssert])|||Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt16BE(offset[, noAssert])|||Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt32LE(offset[, noAssert])|||Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt32BE(offset[, noAssert])|||Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt8(offset[, noAssert])|||Reads a signed 8-bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt16LE(offset[, noAssert])|||Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt16BE(offset[, noAssert])|||Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt32LE(offset[, noAssert])|||Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt32BE(offset[, noAssert])|||Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readFloatLE(offset[, noAssert])|||Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readFloatBE(offset[, noAssert])|||Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readDoubleLE(offset[, noAssert])|||Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readDoubleBE(offset[, noAssert])|||Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.writeUInt8(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset. Note that the value must be a valid unsigned 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt16LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.|||buf.writeUInt16BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt32LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt32BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt8(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt16LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt16BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt32LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt32BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.|||buf.writeFloatLE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means that the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeFloatBE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeDoubleLE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means that value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeDoubleBE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.fill(value[, offset][, end])|||Fills the buffer with the specified value. If the offset (defaults to 0) and end (defaults to buffer.length) are not given, it will fill the entire buffer.|||Buffer.isEncoding(encoding)|||Returns true if the encoding is a valid encoding argument, false otherwise.|||Buffer.isBuffer(obj)|||Tests if obj is a Buffer.|||Buffer.byteLength(string[, encoding])|||Gives the actual byte length of a string. encoding defaults to 'utf8'. It is not the same as String.prototype.length, since String.prototype.length returns the number of characters in a string.|||Buffer.concat(list[, totalLength])|||Returns a buffer which is the result of concatenating all the buffers in the list together.|||Buffer.compare(buf1, buf2)|||The same as buf1.compare(buf2). Useful for sorting an array of buffers.","string − This is the string data to be written to buffer.@@@offset − This is the index of the buffer to start writing at. Default value is 0.@@@length − This is the number of bytes to write. Defaults to buffer.length.@@@encoding − Encoding to use. 'utf8' is the default encoding.|||encoding − Encoding to use. 'utf8' is the default encoding.@@@start − Beginning index to start reading, defaults to 0.@@@end − End index to end reading, defaults is complete buffer.|||list − Array List of Buffer objects to be concatenated.@@@totalLength − This is the total length of the buffers when concatenated.|||otherBuffer − This is the other buffer which will be compared with buf|||targetBuffer − Buffer object where buffer will be copied.@@@targetStart − Number, Optional, Default: 0@@@sourceStart − Number, Optional, Default: 0@@@sourceEnd − Number, Optional, Default: buffer.length|||start − Number, Optional, Default: 0@@@end − Number, Optional, Default: buffer.length",,"Sr.No.@@@Method & Description|||1@@@
new Buffer(size)
Allocates a new buffer of size octets. Note that the size must be no more than kMaxLength. Otherwise, a RangeError will be thrown here.
|||2@@@
new Buffer(buffer)
Copies the passed buffer data onto a new Buffer instance.
|||3@@@
new Buffer(str[, encoding])
Allocates a new buffer containing the given str. encoding defaults to 'utf8'.
|||4@@@
buf.length
Returns the size of the buffer in bytes. Note that this is not necessarily the size of the contents. length refers to the amount of memory allocated for the buffer object. It does not change when the contents of the buffer are changed.
|||5@@@
buf.write(string[, offset][, length][, encoding])
Writes a string to the buffer at offset using the given encoding. offset defaults to 0, encoding defaults to 'utf8'. length is the number of bytes to write. Returns the number of octets written.
|||6@@@
buf.writeUIntLE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||7@@@
buf.writeUIntBE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||8@@@
buf.writeIntLE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||9@@@
buf.writeIntBE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||10@@@
buf.readUIntLE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||11@@@
buf.readUIntBE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||12@@@
buf.readIntLE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||13@@@
buf.readIntBE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||14@@@
buf.toString([encoding][, start][, end])
Decodes and returns a string from buffer data encoded using the specified character set encoding.
|||15@@@
buf.toJSON()
Returns a JSON-representation of the Buffer instance. JSON.stringify implicitly calls this function when stringifying a Buffer instance.
|||16@@@
buf[index]
Get and set the octet at index. The values refer to individual bytes, so the legal range is between 0x00 and 0xFF hex or 0 and 255.
|||17@@@
buf.equals(otherBuffer)
Returns a boolean if this buffer and otherBuffer have the same bytes.
|||18@@@
buf.compare(otherBuffer)
Returns a number indicating whether this buffer comes before or after or is the same as the otherBuffer in sort order.
|||19@@@
buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])
Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.
|||20@@@
buf.slice([start][, end])
Returns a new buffer which references the same memory as the old, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.
|||21@@@
buf.readUInt8(offset[, noAssert])
Reads an unsigned 8 bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||22@@@
buf.readUInt16LE(offset[, noAssert])
Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||23@@@
buf.readUInt16BE(offset[, noAssert])
Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||24@@@
buf.readUInt32LE(offset[, noAssert])
Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||25@@@
buf.readUInt32BE(offset[, noAssert])
Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||26@@@
buf.readInt8(offset[, noAssert])
Reads a signed 8-bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||27@@@
buf.readInt16LE(offset[, noAssert])
Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||28@@@
buf.readInt16BE(offset[, noAssert])
Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||29@@@
buf.readInt32LE(offset[, noAssert])
Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||30@@@
buf.readInt32BE(offset[, noAssert])
Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||31@@@
buf.readFloatLE(offset[, noAssert])
Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||32@@@
buf.readFloatBE(offset[, noAssert])
Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||33@@@
buf.readDoubleLE(offset[, noAssert])
Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||34@@@
buf.readDoubleBE(offset[, noAssert])
Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||35@@@
buf.writeUInt8(value, offset[, noAssert])
Writes a value to the buffer at the specified offset. Note that the value must be a valid unsigned 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||36@@@
buf.writeUInt16LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.
|||37@@@
buf.writeUInt16BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||38@@@
buf.writeUInt32LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||39@@@
buf.writeUInt32BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||40@@@
buf.writeInt8(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||41@@@
buf.writeInt16LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||42@@@
buf.writeInt16BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||43@@@
buf.writeInt32LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||44@@@
buf.writeInt32BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.
|||45@@@
buf.writeFloatLE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means that the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||46@@@
buf.writeFloatBE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||47@@@
buf.writeDoubleLE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means that value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||48@@@
buf.writeDoubleBE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||49@@@
buf.fill(value[, offset][, end])
Fills the buffer with the specified value. If the offset (defaults to 0) and end (defaults to buffer.length) are not given, it will fill the entire buffer.
&&&Sr.No.@@@Method & Description|||1@@@
Buffer.isEncoding(encoding)
Returns true if the encoding is a valid encoding argument, false otherwise.
|||2@@@
Buffer.isBuffer(obj)
Tests if obj is a Buffer.
|||3@@@
Buffer.byteLength(string[, encoding])
Gives the actual byte length of a string. encoding defaults to 'utf8'. It is not the same as String.prototype.length, since String.prototype.length returns the number of characters in a string.
|||4@@@
Buffer.concat(list[, totalLength])
Returns a buffer which is the result of concatenating all the buffers in the list together.
|||5@@@
Buffer.compare(buf1, buf2)
The same as buf1.compare(buf2). Useful for sorting an array of buffers.
","buf = new Buffer(256);len = buf.write(""Simply Easy Learning"");console.log(""Octets written : ""+  len);|||buf = new Buffer(26);for (var i = 0 ; i < 26 ; i++) {  buf[i] = i + 97;}console.log( buf.toString('ascii'));       // outputs: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5));   // outputs: abcdeconsole.log( buf.toString('utf8',0,5));    // outputs: abcdeconsole.log( buf.toString(undefined,0,5)); // encoding defaults to 'utf8', outputs abcde|||var buf = new Buffer('Simply Easy Learning');var json = buf.toJSON(buf);console.log(json);|||var buffer1 = new Buffer('TutorialsPoint ');var buffer2 = new Buffer('Simply Easy Learning');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(""buffer3 content: "" + buffer3.toString());|||var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result < 0) {   console.log(buffer1 +"" comes before "" + buffer2);} else if(result === 0) {   console.log(buffer1 +"" is same as "" + buffer2);} else {   console.log(buffer1 +"" comes after "" + buffer2);}|||var buffer1 = new Buffer('ABC');//copy a buffervar buffer2 = new Buffer(3);buffer1.copy(buffer2);console.log(""buffer2 content: "" + buffer2.toString());|||var buffer1 = new Buffer('TutorialsPoint');//slicing a buffervar buffer2 = buffer1.slice(0,9);console.log(""buffer2 content: "" + buffer2.toString());|||var buffer = new Buffer('TutorialsPoint');//length of the bufferconsole.log(""buffer length: "" + buffer.length);"
Learn Node.js,Node.js - Streams,Node.js - Streams|||What are Streams?@@@Reading from a Stream@@@Writing to a Stream@@@Piping the Streams@@@Chaining the Streams@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Streams are objects that let you read data from a source or write data to a destination in continuous fashion. In Node.js, there are four types of streams −|||Readable − Stream which is used for read operation.|||Writable − Stream which is used for write operation.|||Duplex − Stream which can be used for both read and write operation.|||Transform − A type of duplex stream where the output is computed based on input.|||Each type of Stream is an EventEmitter instance and throws several events at different instance of times. For example, some of the commonly used events are −|||data − This event is fired when there is data is available to read.|||end − This event is fired when there is no more data to read.|||error − This event is fired when there is any error receiving or writing data.|||finish − This event is fired when all the data has been flushed to underlying system.|||This tutorial provides a basic understanding of the commonly used operations on Streams.|||Create a text file named input.txt having the following content −|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Now open output.txt created in your current directory; it should contain the following −|||Piping is a mechanism where we provide the output of one stream as the input to another stream. It is normally used to get data from one stream and to pass the output of that stream to another stream. There is no limit on piping operations. Now we'll show a piping example for reading from one file and writing it to another file.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Open output.txt created in your current directory; it should contain the following −|||Chaining is a mechanism to connect the output of one stream to another stream and create a chain of multiple stream operations. It is normally used with piping operations. Now we'll use piping and chaining to first compress a file and then decompress the same.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||You will find that input.txt has been compressed and it created a file input.txt.gz in the current directory. Now let's try to decompress the same file using the following code −|||Now run the main.js to see the result −|||Verify the Output.",Readable − Stream which is used for read operation.@@@Writable − Stream which is used for write operation.@@@Duplex − Stream which can be used for both read and write operation.@@@Transform − A type of duplex stream where the output is computed based on input.|||data − This event is fired when there is data is available to read.@@@end − This event is fired when there is no more data to read.@@@error − This event is fired when there is any error receiving or writing data.@@@finish − This event is fired when all the data has been flushed to underlying system.,,,"var fs = require(""fs"");var data = '';// Create a readable streamvar readerStream = fs.createReadStream('input.txt');// Set the encoding to be utf8. readerStream.setEncoding('UTF8');// Handle stream events --> data, end, and errorreaderStream.on('data', function(chunk) {   data += chunk;});readerStream.on('end',function() {   console.log(data);});readerStream.on('error', function(err) {   console.log(err.stack);});console.log(""Program Ended"");|||var fs = require(""fs"");var data = 'Simply Easy Learning';// Create a writable streamvar writerStream = fs.createWriteStream('output.txt');// Write the data to stream with encoding to be utf8writerStream.write(data,'UTF8');// Mark the end of filewriterStream.end();// Handle stream events --> finish, and errorwriterStream.on('finish', function() {   console.log(""Write completed."");});writerStream.on('error', function(err) {   console.log(err.stack);});console.log(""Program Ended"");|||var fs = require(""fs"");// Create a readable streamvar readerStream = fs.createReadStream('input.txt');// Create a writable streamvar writerStream = fs.createWriteStream('output.txt');// Pipe the read and write operations// read input.txt and write data to output.txtreaderStream.pipe(writerStream);console.log(""Program Ended"");|||var fs = require(""fs"");var zlib = require('zlib');// Compress the file input.txt to input.txt.gzfs.createReadStream('input.txt')   .pipe(zlib.createGzip())   .pipe(fs.createWriteStream('input.txt.gz'));  console.log(""File Compressed."");|||var fs = require(""fs"");var zlib = require('zlib');// Decompress the file input.txt.gz to input.txtfs.createReadStream('input.txt.gz')   .pipe(zlib.createGunzip())   .pipe(fs.createWriteStream('input.txt'));  console.log(""File Decompressed."");"
Learn Node.js,Node.js - File System,Node.js - File System|||Synchronous vs Asynchronous@@@Open a File@@@Flags@@@Get File Information@@@Writing a File@@@Reading a File@@@Closing a File@@@Truncate a File@@@Delete a File@@@Create a Directory@@@Read a Directory@@@Remove a Directory@@@Methods Reference@@@Useful Video Courses|||Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node implements File I/O using simple wrappers around standard POSIX functions. The Node File System (fs) module can be imported using the following syntax −|||Every method in the fs module has synchronous as well as asynchronous forms. Asynchronous methods take the last parameter as the completion function callback and the first parameter of the callback function as error. It is better to use an asynchronous method instead of a synchronous method, as the former never blocks a program during its execution, whereas the second one does.|||Create a text file named input.txt with the following content −|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||The following sections in this chapter provide a set of good examples on major File I/O methods.|||Following is the syntax of the method to open a file in asynchronous mode −|||Here is the description of the parameters used −|||path − This is the string having file name including path.|||flags − Flags indicate the behavior of the file to be opened. All possible values have been mentioned below.|||mode − It sets the file mode (permission and sticky bits), but only if the file was created. It defaults to 0666, readable and writeable.|||callback − This is the callback function which gets two arguments (err, fd).|||Flags for read/write operations are −|||r|||Open file for reading. An exception occurs if the file does not exist.|||r+|||Open file for reading and writing. An exception occurs if the file does not exist.|||rs|||Open file for reading in synchronous mode.|||rs+|||Open file for reading and writing, asking the OS to open it synchronously. See notes for 'rs' about using this with caution.|||w|||Open file for writing. The file is created (if it does not exist) or truncated (if it exists).|||wx|||Like 'w' but fails if the path exists.|||w+|||Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).|||wx+|||Like 'w+' but fails if path exists.|||a|||Open file for appending. The file is created if it does not exist.|||ax|||Like 'a' but fails if the path exists.|||a+|||Open file for reading and appending. The file is created if it does not exist.|||ax+|||Like 'a+' but fails if the the path exists.|||Let us create a js file named main.js having the following code to open a file input.txt for reading and writing.|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to get the information about a file −|||Here is the description of the parameters used −|||path − This is the string having file name including path.|||callback − This is the callback function which gets two arguments (err, stats) where stats is an object of fs.Stats type which is printed below in the example.|||Apart from the important attributes which are printed below in the example, there are several useful methods available in fs.Stats class which can be used to check file type. These methods are  given in the following table.|||stats.isFile()|||Returns true if file type of a simple file.|||stats.isDirectory()|||Returns true if file type of a directory.|||stats.isBlockDevice()|||Returns true if file type of a block device.|||stats.isCharacterDevice()|||Returns true if file type of a character device.|||stats.isSymbolicLink()|||Returns true if file type of a symbolic link.|||stats.isFIFO()|||Returns true if file type of a FIFO.|||stats.isSocket()|||Returns true if file type of asocket.|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of one of the methods to write into a file −|||This method will over-write the file if the file already exists. If you want to write into an existing file then you should use another method available.|||Here is the description of the parameters used −|||path − This is the string having the file name including path.|||data − This is the  String or Buffer to be written into the file.|||options − The third parameter is an object which will hold {encoding, mode, flag}. By default. encoding is utf8, mode is octal value 0666. and flag is 'w'|||callback − This is the callback function which gets a single parameter err that returns an error in case of any writing error.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of one of the methods to read from a file −|||This method will use file descriptor to read the file. If you want to read the file directly using the file name, then you should use another method available.|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by fs.open().|||buffer − This is the buffer that the data will be written to.|||offset − This is the offset in the buffer to start writing at.|||length − This is an integer specifying the number of bytes to read.|||position − This is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.|||callback − This is the callback function which gets the three arguments, (err, bytesRead, buffer).|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax to close an opened file −|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by file fs.open() method.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to truncate an opened file −|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by fs.open().|||len − This is the length of the file after which the file will be truncated.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to delete a file −|||Here is the description of the parameters used −|||path − This is the file name including path.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to create a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||mode − This is the directory permission to be set. Defaults to 0777.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to read a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||callback − This is the callback function which gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to remove a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||fs.rename(oldPath, newPath, callback)|||Asynchronous rename(). No arguments other than a possible exception are given to the completion callback.|||fs.ftruncate(fd, len, callback)|||Asynchronous ftruncate(). No arguments other than a possible exception are given to the completion callback.|||fs.ftruncateSync(fd, len)|||Synchronous ftruncate().|||fs.truncate(path, len, callback)|||Asynchronous truncate(). No arguments other than a possible exception are given to the completion callback.|||fs.truncateSync(path, len)|||Synchronous truncate().|||fs.chown(path, uid, gid, callback)|||Asynchronous chown(). No arguments other than a possible exception are given to the completion callback.|||fs.chownSync(path, uid, gid)|||Synchronous chown().|||fs.fchown(fd, uid, gid, callback)|||Asynchronous fchown(). No arguments other than a possible exception are given to the completion callback.|||fs.fchownSync(fd, uid, gid)|||Synchronous fchown().|||fs.lchown(path, uid, gid, callback)|||Asynchronous lchown(). No arguments other than a possible exception are given to the completion callback.|||fs.lchownSync(path, uid, gid)|||Synchronous lchown().|||fs.chmod(path, mode, callback)|||Asynchronous chmod(). No arguments other than a possible exception are given to the completion callback.|||fs.chmodSync(path, mode)|||Synchronous chmod().|||fs.fchmod(fd, mode, callback)|||Asynchronous fchmod(). No arguments other than a possible exception are given to the completion callback.|||fs.fchmodSync(fd, mode)|||Synchronous fchmod().|||fs.lchmod(path, mode, callback)|||Asynchronous lchmod(). No arguments other than a possible exception are given to the completion callback. Only available on Mac OS X.|||fs.lchmodSync(path, mode)|||Synchronous lchmod().|||fs.stat(path, callback)|||Asynchronous stat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object.|||fs.lstat(path, callback)|||Asynchronous lstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.|||fs.fstat(fd, callback)|||Asynchronous fstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd.|||fs.statSync(path)|||Synchronous stat(). Returns an instance of fs.Stats.|||fs.lstatSync(path)|||Synchronous lstat(). Returns an instance of fs.Stats.|||fs.fstatSync(fd)|||Synchronous fstat(). Returns an instance of fs.Stats.|||fs.link(srcpath, dstpath, callback)|||Asynchronous link(). No arguments other than a possible exception are given to the completion callback.|||fs.linkSync(srcpath, dstpath)|||Synchronous link().|||fs.symlink(srcpath, dstpath[, type], callback)|||Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.|||fs.symlinkSync(srcpath, dstpath[, type])|||Synchronous symlink().|||fs.readlink(path, callback)|||Asynchronous readlink(). The callback gets two arguments (err, linkString).|||fs.realpath(path[, cache], callback)|||Asynchronous realpath(). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths.|||fs.realpathSync(path[, cache])|||Synchronous realpath(). Returns the resolved path.|||fs.unlink(path, callback)|||Asynchronous unlink(). No arguments other than a possible exception are given to the completion callback.|||fs.unlinkSync(path)|||Synchronous unlink().|||fs.rmdir(path, callback)|||Asynchronous rmdir(). No arguments other than a possible exception are given to the completion callback.|||fs.rmdirSync(path)|||Synchronous rmdir().|||fs.mkdir(path[, mode], callback)|||Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777.|||fs.mkdirSync(path[, mode])|||Synchronous mkdir().|||fs.readdir(path, callback)|||Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||fs.readdirSync(path)|||Synchronous readdir(). Returns an array of filenames excluding '.' and '..'.|||fs.close(fd, callback)|||Asynchronous close(). No arguments other than a possible exception are given to the completion callback.|||fs.closeSync(fd)|||Synchronous close().|||fs.open(path, flags[, mode], callback)|||Asynchronous file open.|||fs.openSync(path, flags[, mode])|||Synchronous version of fs.open().|||fs.utimes(path, atime, mtime, callback)||| |||fs.utimesSync(path, atime, mtime)|||Change file timestamps of the file referenced by the supplied path.|||fs.futimes(fd, atime, mtime, callback)||| |||fs.futimesSync(fd, atime, mtime)|||Change the file timestamps of a file referenced by the supplied file descriptor.|||fs.fsync(fd, callback)|||Asynchronous fsync. No arguments other than a possible exception are given to the completion callback.|||fs.fsyncSync(fd)|||Synchronous fsync.|||fs.write(fd, buffer, offset, length[, position], callback)|||Write buffer to the file specified by fd.|||fs.write(fd, data[, position[, encoding]], callback)|||Write data to the file specified by fd. If data is not a Buffer instance then the value will be coerced to a string.|||fs.writeSync(fd, buffer, offset, length[, position])|||Synchronous versions of fs.write(). Returns the number of bytes written.|||fs.writeSync(fd, data[, position[, encoding]])|||Synchronous versions of fs.write(). Returns the number of bytes written.|||fs.read(fd, buffer, offset, length, position, callback)|||Read data from the file specified by fd.|||fs.readSync(fd, buffer, offset, length, position)|||Synchronous version of fs.read. Returns the number of bytesRead.|||fs.readFile(filename[, options], callback)|||Asynchronously reads the entire contents of a file.|||fs.readFileSync(filename[, options])|||Synchronous version of fs.readFile. Returns the contents of the filename.|||fs.writeFile(filename, data[, options], callback)|||Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.|||fs.writeFileSync(filename, data[, options])|||The synchronous version of fs.writeFile.|||fs.appendFile(filename, data[, options], callback)|||Asynchronously append data to a file, creating the file if it does not exist. data can be a string or a buffer.|||fs.appendFileSync(filename, data[, options])|||The synchronous version of fs.appendFile.|||fs.watchFile(filename[, options], listener)|||Watch for changes on filename. The callback listener will be called each time the file is accessed.|||fs.unwatchFile(filename[, listener])|||Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename.|||fs.watch(filename[, options][, listener])|||Watch for changes on filename, where filename is either a file or an directory. The returned object is an fs.FSWatcher.|||fs.exists(path, callback)|||Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false.|||fs.existsSync(path)|||Synchronous version of fs.exists.|||fs.access(path[, mode], callback)|||Tests a user's permissions for the file specified by path. mode is an optional integer that specifies the accessibility checks to be performed.|||fs.accessSync(path[, mode])|||Synchronous version of fs.access. It throws if any accessibility checks fail, and does nothing otherwise.|||fs.createReadStream(path[, options])|||Returns a new ReadStream object.|||fs.createWriteStream(path[, options])|||Returns a new WriteStream object.|||fs.symlink(srcpath, dstpath[, type], callback)|||Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.","path − This is the string having file name including path.@@@flags − Flags indicate the behavior of the file to be opened. All possible values have been mentioned below.@@@mode − It sets the file mode (permission and sticky bits), but only if the file was created. It defaults to 0666, readable and writeable.@@@callback − This is the callback function which gets two arguments (err, fd).|||path − This is the string having file name including path.@@@callback − This is the callback function which gets two arguments (err, stats) where stats is an object of fs.Stats type which is printed below in the example.|||path − This is the string having the file name including path.@@@data − This is the  String or Buffer to be written into the file.@@@options − The third parameter is an object which will hold {encoding, mode, flag}. By default. encoding is utf8, mode is octal value 0666. and flag is 'w'@@@callback − This is the callback function which gets a single parameter err that returns an error in case of any writing error.|||fd − This is the file descriptor returned by fs.open().@@@buffer − This is the buffer that the data will be written to.@@@offset − This is the offset in the buffer to start writing at.@@@length − This is an integer specifying the number of bytes to read.@@@position − This is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.@@@callback − This is the callback function which gets the three arguments, (err, bytesRead, buffer).|||fd − This is the file descriptor returned by file fs.open() method.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||fd − This is the file descriptor returned by fs.open().@@@len − This is the length of the file after which the file will be truncated.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the file name including path.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the directory name including path.@@@mode − This is the directory permission to be set. Defaults to 0777.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the directory name including path.@@@callback − This is the callback function which gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||path − This is the directory name including path.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.",,"Sr.No.@@@Flag & Description|||1@@@
r
Open file for reading. An exception occurs if the file does not exist.|||2@@@
r+
Open file for reading and writing. An exception occurs if the file does not exist.|||3@@@
rs
Open file for reading in synchronous mode.|||4@@@
rs+
Open file for reading and writing, asking the OS to open it synchronously. See notes for 'rs' about using this with caution.|||5@@@
w
Open file for writing. The file is created (if it does not exist) or truncated (if it exists).|||6@@@
wx
Like 'w' but fails if the path exists.|||7@@@
w+
Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).|||8@@@
wx+
Like 'w+' but fails if path exists.|||9@@@
a
Open file for appending. The file is created if it does not exist.|||10@@@
ax
Like 'a' but fails if the path exists.|||11@@@
a+
Open file for reading and appending. The file is created if it does not exist.|||12@@@
ax+
Like 'a+' but fails if the the path exists.&&&Sr.No.@@@Method & Description|||1@@@
stats.isFile()
Returns true if file type of a simple file.|||2@@@
stats.isDirectory()
Returns true if file type of a directory.|||3@@@
stats.isBlockDevice()
Returns true if file type of a block device.|||4@@@
stats.isCharacterDevice()
Returns true if file type of a character device.|||5@@@
stats.isSymbolicLink()
Returns true if file type of a symbolic link.|||6@@@
stats.isFIFO()
Returns true if file type of a FIFO.|||7@@@
stats.isSocket()
Returns true if file type of asocket.&&&Sr.No@@@Method & Description|||1@@@
fs.rename(oldPath, newPath, callback)
Asynchronous rename(). No arguments other than a possible exception are given to the completion callback.
|||2@@@
fs.ftruncate(fd, len, callback)
Asynchronous ftruncate(). No arguments other than a possible exception are given to the completion callback.
|||3@@@
fs.ftruncateSync(fd, len)
Synchronous ftruncate().
|||4@@@
fs.truncate(path, len, callback)
Asynchronous truncate(). No arguments other than a possible exception are given to the completion callback.
|||5@@@
fs.truncateSync(path, len)
Synchronous truncate().
|||6@@@
fs.chown(path, uid, gid, callback)
Asynchronous chown(). No arguments other than a possible exception are given to the completion callback.
|||7@@@
fs.chownSync(path, uid, gid)
Synchronous chown().
|||8@@@
fs.fchown(fd, uid, gid, callback)
Asynchronous fchown(). No arguments other than a possible exception are given to the completion callback.
|||9@@@
fs.fchownSync(fd, uid, gid)
Synchronous fchown().
|||10@@@
fs.lchown(path, uid, gid, callback)
Asynchronous lchown(). No arguments other than a possible exception are given to the completion callback.
|||11@@@
fs.lchownSync(path, uid, gid)
Synchronous lchown().
|||12@@@
fs.chmod(path, mode, callback)
Asynchronous chmod(). No arguments other than a possible exception are given to the completion callback.
|||13@@@
fs.chmodSync(path, mode)
Synchronous chmod().
|||14@@@
fs.fchmod(fd, mode, callback)
Asynchronous fchmod(). No arguments other than a possible exception are given to the completion callback.
|||15@@@
fs.fchmodSync(fd, mode)
Synchronous fchmod().
|||16@@@
fs.lchmod(path, mode, callback)
Asynchronous lchmod(). No arguments other than a possible exception are given to the completion callback. Only available on Mac OS X.
|||17@@@
fs.lchmodSync(path, mode)
Synchronous lchmod().
|||18@@@
fs.stat(path, callback)
Asynchronous stat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object.
|||19@@@
fs.lstat(path, callback)
Asynchronous lstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.
|||20@@@
fs.fstat(fd, callback)
Asynchronous fstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd.
|||21@@@
fs.statSync(path)
Synchronous stat(). Returns an instance of fs.Stats.
|||22@@@
fs.lstatSync(path)
Synchronous lstat(). Returns an instance of fs.Stats.
|||23@@@
fs.fstatSync(fd)
Synchronous fstat(). Returns an instance of fs.Stats.
|||24@@@
fs.link(srcpath, dstpath, callback)
Asynchronous link(). No arguments other than a possible exception are given to the completion callback.
|||25@@@
fs.linkSync(srcpath, dstpath)
Synchronous link().
|||26@@@
fs.symlink(srcpath, dstpath[, type], callback)
Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.
|||27@@@
fs.symlinkSync(srcpath, dstpath[, type])
Synchronous symlink().
|||28@@@
fs.readlink(path, callback)
Asynchronous readlink(). The callback gets two arguments (err, linkString).
|||29@@@
fs.realpath(path[, cache], callback)
Asynchronous realpath(). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths.
|||30@@@
fs.realpathSync(path[, cache])
Synchronous realpath(). Returns the resolved path.
|||31@@@
fs.unlink(path, callback)
Asynchronous unlink(). No arguments other than a possible exception are given to the completion callback.
|||32@@@
fs.unlinkSync(path)
Synchronous unlink().
|||33@@@
fs.rmdir(path, callback)
Asynchronous rmdir(). No arguments other than a possible exception are given to the completion callback.
|||34@@@
fs.rmdirSync(path)
Synchronous rmdir().
|||35@@@
fs.mkdir(path[, mode], callback)
Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777.
|||36@@@
fs.mkdirSync(path[, mode])
Synchronous mkdir().
|||37@@@
fs.readdir(path, callback)
Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.
|||38@@@
fs.readdirSync(path)
Synchronous readdir(). Returns an array of filenames excluding '.' and '..'.
|||39@@@
fs.close(fd, callback)
Asynchronous close(). No arguments other than a possible exception are given to the completion callback.
|||40@@@
fs.closeSync(fd)
Synchronous close().
|||41@@@
fs.open(path, flags[, mode], callback)
Asynchronous file open.
|||42@@@
fs.openSync(path, flags[, mode])
Synchronous version of fs.open().
|||43@@@
fs.utimes(path, atime, mtime, callback)
 
|||44@@@
fs.utimesSync(path, atime, mtime)
Change file timestamps of the file referenced by the supplied path.
|||45@@@
fs.futimes(fd, atime, mtime, callback)
 
|||46@@@
fs.futimesSync(fd, atime, mtime)
Change the file timestamps of a file referenced by the supplied file descriptor.
|||47@@@
fs.fsync(fd, callback)
Asynchronous fsync. No arguments other than a possible exception are given to the completion callback.
|||48@@@
fs.fsyncSync(fd)
Synchronous fsync.
|||49@@@
fs.write(fd, buffer, offset, length[, position], callback)
Write buffer to the file specified by fd.
|||50@@@
fs.write(fd, data[, position[, encoding]], callback)
Write data to the file specified by fd. If data is not a Buffer instance then the value will be coerced to a string.
|||51@@@
fs.writeSync(fd, buffer, offset, length[, position])
Synchronous versions of fs.write(). Returns the number of bytes written.
|||52@@@
fs.writeSync(fd, data[, position[, encoding]])
Synchronous versions of fs.write(). Returns the number of bytes written.
|||53@@@
fs.read(fd, buffer, offset, length, position, callback)
Read data from the file specified by fd.
|||54@@@
fs.readSync(fd, buffer, offset, length, position)
Synchronous version of fs.read. Returns the number of bytesRead.
|||55@@@
fs.readFile(filename[, options], callback)
Asynchronously reads the entire contents of a file.
|||56@@@
fs.readFileSync(filename[, options])
Synchronous version of fs.readFile. Returns the contents of the filename.
|||57@@@
fs.writeFile(filename, data[, options], callback)
Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.
|||58@@@
fs.writeFileSync(filename, data[, options])
The synchronous version of fs.writeFile.
|||59@@@
fs.appendFile(filename, data[, options], callback)
Asynchronously append data to a file, creating the file if it does not exist. data can be a string or a buffer.
|||60@@@
fs.appendFileSync(filename, data[, options])
The synchronous version of fs.appendFile.
|||61@@@
fs.watchFile(filename[, options], listener)
Watch for changes on filename. The callback listener will be called each time the file is accessed.
|||62@@@
fs.unwatchFile(filename[, listener])
Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename.
|||63@@@
fs.watch(filename[, options][, listener])
Watch for changes on filename, where filename is either a file or an directory. The returned object is an fs.FSWatcher.
|||64@@@
fs.exists(path, callback)
Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false.
|||65@@@
fs.existsSync(path)
Synchronous version of fs.exists.
|||66@@@
fs.access(path[, mode], callback)
Tests a user's permissions for the file specified by path. mode is an optional integer that specifies the accessibility checks to be performed.
|||67@@@
fs.accessSync(path[, mode])
Synchronous version of fs.access. It throws if any accessibility checks fail, and does nothing otherwise.
|||68@@@
fs.createReadStream(path[, options])
Returns a new ReadStream object.
|||69@@@
fs.createWriteStream(path[, options])
Returns a new WriteStream object.
|||70@@@
fs.symlink(srcpath, dstpath[, type], callback)
Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.
","var fs = require(""fs"");// Asynchronous readfs.readFile('input.txt', function (err, data) {   if (err) {      return console.error(err);   }   console.log(""Asynchronous read: "" + data.toString());});// Synchronous readvar data = fs.readFileSync('input.txt');console.log(""Synchronous read: "" + data.toString());console.log(""Program Ended"");|||var fs = require(""fs"");// Asynchronous - Opening Fileconsole.log(""Going to open file!"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");     });|||var fs = require(""fs"");console.log(""Going to get file info!"");fs.stat('input.txt', function (err, stats) {   if (err) {      return console.error(err);   }   console.log(stats);   console.log(""Got file info successfully!"");      // Check file type   console.log(""isFile ? "" + stats.isFile());   console.log(""isDirectory ? "" + stats.isDirectory());    });|||var fs = require(""fs"");console.log(""Going to write into existing file"");fs.writeFile('input.txt', 'Simply Easy Learning!', function(err) {   if (err) {      return console.error(err);   }      console.log(""Data written successfully!"");   console.log(""Let's read newly written data"");      fs.readFile('input.txt', function (err, data) {      if (err) {         return console.error(err);      }      console.log(""Asynchronous read: "" + data.toString());   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to read the file"");      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){      if (err){         console.log(err);      }      console.log(bytes + "" bytes read"");            // Print only read bytes to avoid junk.      if(bytes > 0){         console.log(buf.slice(0, bytes).toString());      }   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to read the file"");      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes) {      if (err) {         console.log(err);      }      // Print only read bytes to avoid junk.      if(bytes > 0) {         console.log(buf.slice(0, bytes).toString());      }      // Close the opened file.      fs.close(fd, function(err) {         if (err) {            console.log(err);         }          console.log(""File closed successfully."");      });   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to truncate the file after 10 bytes"");      // Truncate the opened file.   fs.ftruncate(fd, 10, function(err) {      if (err) {         console.log(err);      }       console.log(""File truncated successfully."");      console.log(""Going to read the same file"");             fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){         if (err) {            console.log(err);         }         // Print only read bytes to avoid junk.         if(bytes > 0) {            console.log(buf.slice(0, bytes).toString());         }         // Close the opened file.         fs.close(fd, function(err) {            if (err) {               console.log(err);            }             console.log(""File closed successfully."");         });      });   });});|||var fs = require(""fs"");console.log(""Going to delete an existing file"");fs.unlink('input.txt', function(err) {   if (err) {      return console.error(err);   }   console.log(""File deleted successfully!"");});|||var fs = require(""fs"");console.log(""Going to create directory /tmp/test"");fs.mkdir('/tmp/test',function(err) {   if (err) {      return console.error(err);   }   console.log(""Directory created successfully!"");});|||var fs = require(""fs"");console.log(""Going to read directory /tmp"");fs.readdir(""/tmp/"",function(err, files) {   if (err) {      return console.error(err);   }   files.forEach( function (file) {      console.log( file );   });});|||var fs = require(""fs"");console.log(""Going to delete directory /tmp/test"");fs.rmdir(""/tmp/test"",function(err) {   if (err) {      return console.error(err);   }   console.log(""Going to read directory /tmp"");      fs.readdir(""/tmp/"",function(err, files) {      if (err) {         return console.error(err);      }      files.forEach( function (file) {         console.log( file );      });   });});"
Learn Node.js,Node.js - Global Objects,"Node.js - Global Objects|||__filename@@@__dirname@@@setTimeout(cb, ms)@@@clearTimeout(t)@@@setInterval(cb, ms)@@@Global Objects@@@Useful Video Courses|||Example@@@Example@@@Example@@@Example@@@Example|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS","Node.js global objects are global in nature and they are available in all modules. We do not need to include these objects in our application, rather we can use them directly. These objects are modules, functions, strings and object itself as explained below.|||The __filename represents the filename of the code being executed. This is the resolved absolute path of this code file. For a main program, this is not necessarily the same filename used in the command line. The value inside a module is the path to that module file.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Based on the location of your program, it will print the main file name as follows −|||The __dirname represents the name of the directory that the currently executing script resides in.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Based on the location of your program, it will print current directory name as follows −|||The setTimeout(cb, ms) global function is used to run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load. A timer cannot span more than 24.8 days.|||This function returns an opaque value that represents the timer which can be used to clear the timer.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the output is printed after a little delay.|||The clearTimeout(t) global function is used to stop a timer that was previously created with setTimeout(). Here t is the timer returned by the setTimeout() function.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the output where you will not find anything printed.|||The setInterval(cb, ms) global function is used to run callback cb repeatedly after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load. A timer cannot span more than 24.8 days.|||This function returns an opaque value that represents the timer which can be used to clear the timer using the function clearInterval(t).|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||The above program will execute printHello() after every 2 second. Due to system limitation.|||The following table provides a list of other objects which we use frequently in our applications. For a more detail, you can refer to the official documentation.||| Used to print information on stdout and stderr.|||Used to get information on current process. Provides multiple events related to process activities.",,,"Sr.No.@@@Module Name & Description|||1@@@Console
 Used to print information on stdout and stderr.
|||2@@@Process
Used to get information on current process. Provides multiple events related to process activities.
","// Let's try to print the value of __filenameconsole.log( __filename );|||// Let's try to print the value of __dirnameconsole.log( __dirname );|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondssetTimeout(printHello, 2000);|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondsvar t = setTimeout(printHello, 2000);// Now clear the timerclearTimeout(t);|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondssetInterval(printHello, 2000);"
Learn Node.js,Node.js - Utility Modules,Node.js - Utility Modules|||Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,There are several utility modules available in Node.js module library. These modules are very common and are frequently used while developing any Node based application.|||Provides basic operating-system related utility functions.|||Provides utilities for handling and transforming file paths.|||Provides both servers and clients as streams. Acts as a network wrapper.|||Provides functions to do actual DNS lookup as well as to use underlying operating system name resolution functionalities.|||Provides ways to handle multiple different I/O operations as a single group.,,,"Sr.No.@@@Module Name & Description|||1@@@OS Module
Provides basic operating-system related utility functions.
|||2@@@Path Module
Provides utilities for handling and transforming file paths.
|||3@@@Net Module
Provides both servers and clients as streams. Acts as a network wrapper.
|||4@@@DNS Module
Provides functions to do actual DNS lookup as well as to use underlying operating system name resolution functionalities.
|||5@@@Domain Module
Provides ways to handle multiple different I/O operations as a single group.
",
Learn Node.js,Node.js - Web Module,Node.js - Web Module|||What is a Web Server?@@@Web Application Architecture@@@Creating a Web Server using Node@@@Make a request to Node.js server@@@Creating Web client using Node@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"A Web Server is a software application which handles HTTP requests sent by the HTTP client, like web browsers, and returns web pages in response to the clients. Web servers usually deliver html documents along with images, style sheets, and scripts.|||Most of the web servers support server-side scripts, using scripting languages or redirecting the task to an application server which retrieves data from a database and performs complex logic and then sends a result to the HTTP client through the Web server.|||Apache web server is one of the most commonly used web servers. It is an open source project.|||A Web application is usually divided into four layers −|||Client − This layer consists of web browsers, mobile browsers or applications which can make HTTP requests to the web server.|||Server − This layer has the Web server which can intercept the requests made by the clients and pass them the response.|||Business − This layer contains the application server which is utilized by the web server to do the required processing. This layer interacts with the data layer via the database or some external programs.|||Data − This layer contains the databases or any other source of data.|||Node.js provides an http module which can be used to create an HTTP client of a server. Following is the bare minimum structure of the HTTP server which listens at 8081 port.|||Create a js file named server.js −|||File: server.js|||Next let's create the following html file named index.htm in the same directory where you created server.js.|||File: index.htm|||Now let us run the server.js to see the result −|||Verify the Output.|||Open http://127.0.0.1:8081/index.htm in any browser to see the following result.|||Verify the Output at server end.|||A web client can be created using http module. Let's check the following example.|||Create a js file named client.js −|||File: client.js|||Now run the client.js from a different command terminal other than server.js to see the result −|||Verify the Output.|||Verify the Output at server end.","Client − This layer consists of web browsers, mobile browsers or applications which can make HTTP requests to the web server.@@@Server − This layer has the Web server which can intercept the requests made by the clients and pass them the response.@@@Business − This layer contains the application server which is utilized by the web server to do the required processing. This layer interacts with the data layer via the database or some external programs.@@@Data − This layer contains the databases or any other source of data.",,,"var http = require('http');var fs = require('fs');var url = require('url');// Create a serverhttp.createServer( function (request, response) {     // Parse the request containing file name   var pathname = url.parse(request.url).pathname;      // Print the name of the file for which request is made.   console.log(""Request for "" + pathname + "" received."");      // Read the requested file content from file system   fs.readFile(pathname.substr(1), function (err, data) {      if (err) {         console.log(err);                  // HTTP Status: 404 : NOT FOUND         // Content Type: text/plain         response.writeHead(404, {'Content-Type': 'text/html'});      } else {	         //Page found	           // HTTP Status: 200 : OK         // Content Type: text/plain         response.writeHead(200, {'Content-Type': 'text/html'});	                  // Write the content of the file to response body         response.write(data.toString());		      }            // Send the response body       response.end();   });   }).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||<html>   <head>      <title>Sample Page</title>   </head>      <body>      Hello World!   </body></html>|||var http = require('http');// Options to be used by request var options = {   host: 'localhost',   port: '8081',   path: '/index.htm'  };// Callback function is used to deal with responsevar callback = function(response) {   // Continuously update stream with data   var body = '';   response.on('data', function(data) {      body += data;   });      response.on('end', function() {      // Data received completely.      console.log(body);   });}// Make a request to the servervar req = http.request(options, callback);req.end();"
Learn Node.js,Node.js - Express Framework,Node.js - Express Framework|||Express Overview@@@Installing Express@@@Hello world Example@@@Request & Response@@@Basic Routing@@@Serving Static Files@@@GET Method@@@POST Method@@@File Upload@@@Cookies Management@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Express is a minimal and flexible Node.js web application framework that provides a robust set of features to develop web and mobile applications. It facilitates the rapid development of Node based Web applications. Following are some of the core features of Express framework −|||Allows to set up middlewares to respond to HTTP Requests.|||Defines a routing table which is used to perform different actions based on HTTP Method and URL.|||Allows to dynamically render HTML Pages based on passing arguments to templates.|||Firstly, install the Express framework globally using NPM so that it can be used to create a web application using node terminal.|||The above command saves the installation locally in the node_modules directory and creates a directory express inside node_modules. You should install the following important modules along with express −|||body-parser − This is a node.js middleware for handling JSON, Raw, Text and URL encoded form data.|||cookie-parser − Parse Cookie header and populate req.cookies with an object keyed by the cookie names.|||multer − This is a node.js middleware for handling multipart/form-data.|||Following is a very basic Express app which starts a server and listens on port 8081 for connection. This app responds with Hello World! for requests to the homepage. For every other path, it will respond with a 404 Not Found.|||Save the above code in a file named server.js and run it with the following command.|||You will see the following output −|||Open http://127.0.0.1:8081/ in any browser to see the following result.|||Express application uses a callback function whose parameters are request and response objects.|||Request Object − The request object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.|||Response Object − The response object represents the HTTP response that an Express app sends when it gets an HTTP request.|||You can print req and res objects which provide a lot of information related to HTTP request and response including cookies, sessions, URL, etc.|||We have seen a basic application which serves HTTP request for the homepage. Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).|||We will extend our Hello World program to handle more types of HTTP requests.|||Save the above code in a file named server.js and run it with the following command.|||You will see the following output −|||Now you can try different requests at http://127.0.0.1:8081 to see the output generated by server.js. Following are a few screens shots showing different responses for different URLs.|||Screen showing again http://127.0.0.1:8081/list_user|||Screen showing again http://127.0.0.1:8081/abcd|||Screen showing again http://127.0.0.1:8081/abcdefg|||Express provides a built-in middleware express.static to serve static files, such as images, CSS, JavaScript, etc.|||You simply need to pass the name of the directory where you keep your static assets, to the express.static middleware to start serving the files directly. For example, if you keep your images, CSS, and JavaScript files in a directory named public, you can do this −|||We will keep a few images in public/images sub-directory as follows −|||Let's modify ""Hello Word"" app to add the functionality to handle static files.|||Save the above code in a file named server.js and run it with the following command.|||Now open http://127.0.0.1:8081/images/logo.png in any browser and see observe following result.|||Here is a simple example which passes two values using HTML FORM GET method. We are going to use process_get router inside server.js to handle this input.|||Let's save above code in index.htm and modify server.js to handle home page requests as well as the input sent by the HTML form.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||Now you can enter the First and Last Name and then click submit button to see the result and it should return the following result −|||Here is a simple example which passes two values using HTML FORM POST method. We are going to use process_get router inside server.js to handle this input.|||Let's save the above code in index.htm and modify server.js to handle home page requests as well as the input sent by the HTML form.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||Now you can enter the First and Last Name and then click the submit button to see the following result −|||The following HTML code creates a file uploader form. This form has method attribute set to POST and enctype attribute is set to multipart/form-data|||Let's save above code in index.htm and modify server.js to handle home page requests as well as file upload.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||You can send cookies to a Node.js server which can handle the same using the following middleware option. Following is a simple example to print all the cookies sent by the client.","Allows to set up middlewares to respond to HTTP Requests.@@@Defines a routing table which is used to perform different actions based on HTTP Method and URL.@@@Allows to dynamically render HTML Pages based on passing arguments to templates.|||body-parser − This is a node.js middleware for handling JSON, Raw, Text and URL encoded form data.@@@cookie-parser − Parse Cookie header and populate req.cookies with an object keyed by the cookie names.@@@multer − This is a node.js middleware for handling multipart/form-data.|||Request Object − The request object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.@@@Response Object − The response object represents the HTTP response that an Express app sends when it gets an HTTP request.",,,"var express = require('express');var app = express();app.get('/', function (req, res) {   res.send('Hello World');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();// This responds with ""Hello World"" on the homepageapp.get('/', function (req, res) {   console.log(""Got a GET request for the homepage"");   res.send('Hello GET');})// This responds a POST request for the homepageapp.post('/', function (req, res) {   console.log(""Got a POST request for the homepage"");   res.send('Hello POST');})// This responds a DELETE request for the /del_user page.app.delete('/del_user', function (req, res) {   console.log(""Got a DELETE request for /del_user"");   res.send('Hello DELETE');})// This responds a GET request for the /list_user page.app.get('/list_user', function (req, res) {   console.log(""Got a GET request for /list_user"");   res.send('Page Listing');})// This responds a GET request for abcd, abxcd, ab123cd, and so onapp.get('/ab*cd', function(req, res) {      console.log(""Got a GET request for /ab*cd"");   res.send('Page Pattern Match');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res) {   res.send('Hello World');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <body>            <form action = ""http://127.0.0.1:8081/process_get"" method = ""GET"">         First Name: <input type = ""text"" name = ""first_name"">  <br>         Last Name: <input type = ""text"" name = ""last_name"">         <input type = ""submit"" value = ""Submit"">      </form>         </body></html>|||var express = require('express');var app = express();app.use(express.static('public'));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.get('/process_get', function (req, res) {   // Prepare output in JSON format   response = {      first_name:req.query.first_name,      last_name:req.query.last_name   };   console.log(response);   res.end(JSON.stringify(response));})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <body>            <form action = ""http://127.0.0.1:8081/process_post"" method = ""POST"">         First Name: <input type = ""text"" name = ""first_name""> <br>         Last Name: <input type = ""text"" name = ""last_name"">         <input type = ""submit"" value = ""Submit"">      </form>         </body></html>|||var express = require('express');var app = express();var bodyParser = require('body-parser');// Create application/x-www-form-urlencoded parservar urlencodedParser = bodyParser.urlencoded({ extended: false })app.use(express.static('public'));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.post('/process_post', urlencodedParser, function (req, res) {   // Prepare output in JSON format   response = {      first_name:req.body.first_name,      last_name:req.body.last_name   };   console.log(response);   res.end(JSON.stringify(response));})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <head>      <title>File Uploading Form</title>   </head>   <body>      <h3>File Upload:</h3>      Select a file to upload: <br />            <form action = ""http://127.0.0.1:8081/file_upload"" method = ""POST""          enctype = ""multipart/form-data"">         <input type=""file"" name=""file"" size=""50"" />         <br />         <input type = ""submit"" value = ""Upload File"" />      </form>         </body></html>|||var express = require('express');var app = express();var fs = require(""fs"");var bodyParser = require('body-parser');var multer  = require('multer');app.use(express.static('public'));app.use(bodyParser.urlencoded({ extended: false }));app.use(multer({ dest: '/tmp/'}));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.post('/file_upload', function (req, res) {   console.log(req.files.file.name);   console.log(req.files.file.path);   console.log(req.files.file.type);   var file = __dirname + ""/"" + req.files.file.name;      fs.readFile( req.files.file.path, function (err, data) {      fs.writeFile(file, data, function (err) {         if( err ) {            console.log( err );            } else {               response = {                  message:'File uploaded successfully',                  filename:req.files.file.name               };            }                  console.log( response );         res.end( JSON.stringify( response ) );      });   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express      = require('express')var cookieParser = require('cookie-parser')var app = express()app.use(cookieParser())app.get('/', function(req, res) {   console.log(""Cookies: "", req.cookies)})app.listen(8081)"
Learn Node.js,Node.js - RESTful API,Node.js - RESTful API|||What is REST architecture?@@@HTTP methods@@@RESTful Web Services@@@Creating RESTful for A Library@@@List Users@@@Add User@@@Show Detail@@@Delete User@@@Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"REST stands for REpresentational State Transfer. REST is web standards based architecture and uses HTTP Protocol. It revolves around resource where every component is a resource and a resource is accessed by a common interface using HTTP standard methods. REST was first introduced by Roy Fielding in 2000.|||A REST Server simply provides access to resources and REST client accesses and modifies the resources using HTTP protocol. Here each resource is identified by URIs/ global IDs. REST uses various representation to represent a resource like text, JSON, XML but JSON is the most popular one.|||Following four HTTP methods are commonly used in REST based architecture.|||GET − This is used to provide a read only access to a resource.|||PUT − This is used to create a new resource.|||DELETE − This is used to remove a resource.|||POST − This is used to update a existing resource or create a new resource.|||A web service is a collection of open protocols and standards used for exchanging data between applications or systems. Software applications written in various programming languages and running on various platforms can use web services to exchange data over computer networks like the Internet in a manner similar to inter-process communication on a single computer. This interoperability (e.g., communication between Java and Python, or Windows and Linux applications) is due to the use of open standards.|||Web services based on REST Architecture are known as RESTful web services. These webservices uses HTTP methods to implement the concept of REST architecture. A RESTful web service usually defines a URI, Uniform Resource Identifier a service, which provides resource representation such as JSON and set of HTTP Methods.|||Consider we have a JSON based database of users having the following users in a file users.json:|||Based on this information we are going to provide following RESTful APIs.|||I'm keeping most of the part of all the examples in the form of hard coding assuming you already know how to pass values from front end using Ajax or simple form data and how to process them using express Request object.|||Let's implement our first RESTful API listUsers using the following code in a server.js file −|||server.js|||Now try to access defined API using  URL: http://127.0.0.1:8081/listUsers and HTTP Method : GET on local machine using any REST client. This should produce following result −|||You can change given IP address when you will put the solution in production environment.|||Following API will show you how to add new user in the list. Following is the detail of the new user −|||You can accept the same input in the form of JSON using Ajax call but for teaching point of view, we are making it hard coded here. Following is the addUser API to a new user in the database −|||server.js|||Now try to access defined API using  URL: http://127.0.0.1:8081/addUser and HTTP Method : POST on local machine using any REST client. This should produce following result −|||Now we will implement an API which will be called using user ID and it will display the detail of the corresponding user.|||server.js|||Now try to access defined API using URL: http://127.0.0.1:8081/2 and HTTP Method : GET on local machine using any REST client. This should produce following result −|||This API is very similar to addUser API where we receive input data through req.body and then based on user ID we delete that user from the database. To keep our program simple we assume we are going to delete user with ID 2.|||server.js|||Now try to access defined API using URL: http://127.0.0.1:8081/deleteUser and HTTP Method : DELETE on local machine using any REST client. This should produce following result −",GET − This is used to provide a read only access to a resource.@@@PUT − This is used to create a new resource.@@@DELETE − This is used to remove a resource.@@@POST − This is used to update a existing resource or create a new resource.,,Sr.No.@@@URI@@@HTTP Method@@@POST body@@@Result|||1@@@listUsers@@@GET@@@empty@@@Show list of all the users.|||2@@@addUser@@@POST@@@JSON String@@@Add details of new user.|||3@@@deleteUser@@@DELETE@@@JSON String@@@Delete an existing user.|||4@@@:id@@@GET@@@empty@@@Show details of a user.,"{   ""user1"" : {      ""name"" : ""mahesh"",      ""password"" : ""password1"",      ""profession"" : ""teacher"",      ""id"": 1   },      ""user2"" : {      ""name"" : ""suresh"",      ""password"" : ""password2"",      ""profession"" : ""librarian"",      ""id"": 2   },      ""user3"" : {      ""name"" : ""ramesh"",      ""password"" : ""password3"",      ""profession"" : ""clerk"",      ""id"": 3   }}|||var express = require('express');var app = express();var fs = require(""fs"");app.get('/listUsers', function (req, res) {   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      console.log( data );      res.end( data );   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||{   ""user1"" : {      ""name"" : ""mahesh"",      ""password"" : ""password1"",      ""profession"" : ""teacher"",      ""id"": 1   },      ""user2"" : {      ""name"" : ""suresh"",      ""password"" : ""password2"",      ""profession"" : ""librarian"",      ""id"": 2   },      ""user3"" : {      ""name"" : ""ramesh"",      ""password"" : ""password3"",      ""profession"" : ""clerk"",      ""id"": 3   }}|||user = {   ""user4"" : {      ""name"" : ""mohit"",      ""password"" : ""password4"",      ""profession"" : ""teacher"",      ""id"": 4   }}|||var express = require('express');var app = express();var fs = require(""fs"");var user = {   ""user4"" : {      ""name"" : ""mohit"",      ""password"" : ""password4"",      ""profession"" : ""teacher"",      ""id"": 4   }}app.post('/addUser', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      data = JSON.parse( data );      data[""user4""] = user[""user4""];      console.log( data );      res.end( JSON.stringify(data));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||{   ""user1"":{""name"":""mahesh"",""password"":""password1"",""profession"":""teacher"",""id"":1},   ""user2"":{""name"":""suresh"",""password"":""password2"",""profession"":""librarian"",""id"":2},   ""user3"":{""name"":""ramesh"",""password"":""password3"",""profession"":""clerk"",""id"":3},   ""user4"":{""name"":""mohit"",""password"":""password4"",""profession"":""teacher"",""id"":4}}|||var express = require('express');var app = express();var fs = require(""fs"");app.get('/:id', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      var users = JSON.parse( data );      var user = users[""user"" + req.params.id]       console.log( user );      res.end( JSON.stringify(user));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();var fs = require(""fs"");var id = 2;app.delete('/deleteUser', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      data = JSON.parse( data );      delete data[""user"" + 2];             console.log( data );      res.end( JSON.stringify(data));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})"
Learn Node.js,Node.js - Scaling Application,Node.js - Scaling Application|||The exec() method@@@Example@@@The spawn() Method@@@Example@@@The fork() Method@@@Example@@@Useful Video Courses|||Parameters@@@Parameters@@@Parameters|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node.js runs in a single-thread mode, but it uses an event-driven paradigm to handle concurrency. It also facilitates creation of child processes to leverage parallel processing on multi-core CPU based systems.|||Child processes always have three streams child.stdin, child.stdout, and child.stderr which may be shared with the stdio streams of the parent process.|||Node provides child_process module which has the following three major ways to create a child process.|||exec − child_process.exec method runs a command in a shell/console and buffers the output.|||spawn − child_process.spawn launches a new process with a given command.|||fork − The child_process.fork method is a special case of the spawn() to create child processes.|||child_process.exec method runs a command in a shell and buffers the output. It has the following signature −|||Here is the description of the parameters used −|||command (String) The command to run, with space-separated arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process|||env (Object) Environment key-value pairs|||encoding (String) (Default: 'utf8')|||shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)|||timeout (Number) (Default: 0)|||maxBuffer (Number) (Default: 200*1024)|||killSignal (String) (Default: 'SIGTERM')|||uid (Number) Sets the user identity of the process. |||gid (Number) Sets the group identity of the process.|||callback The function gets three arguments error, stdout, and stderr which are called with the output when the process terminates.|||The exec() method returns a buffer with a max size and waits for the process to end and tries to return all the buffered data at once.|||Let us create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');

for(var i=0; i<3; i++) {
   var workerProcess = child_process.exec('node support.js '+i,function 
      (error, stdout, stderr) {
      
      if (error) {
         console.log(error.stack);
         console.log('Error code: '+error.code);
         console.log('Signal received: '+error.signal);
      }
      console.log('stdout: ' + stdout);
      console.log('stderr: ' + stderr);
   });

   workerProcess.on('exit', function (code) {
      console.log('Child process exited with exit code '+code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started.

Child process exited with exit code 0
stdout: Child Process 1 executed.

stderr:
Child process exited with exit code 0
stdout: Child Process 0 executed.

stderr:
Child process exited with exit code 0
stdout: Child Process 2 executed.

The spawn() Method
child_process.spawn method launches a new process with a given command. It has the following signature −

child_process.spawn(command[, args][, options])

Parameters
Here is the description of the parameters used −

command (String) The command to run
args (Array) List of string arguments
options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
stdio (Array) String Child's stdio configuration.
customFds (Array) Deprecated File descriptors for the child to use for stdio.
detached (Boolean) The child will be a process group leader.
uid (Number) Sets the user identity of the process.
gid (Number) Sets the group identity of the process.



The spawn() method returns streams (stdout &stderr) and it should be used when the process returns a volume amount of data. spawn() starts receiving the response as soon as the process starts executing.
Example
Create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');
 
for(var i = 0; i<3; i++) {
   var workerProcess = child_process.spawn('node', ['support.js', i]);

   workerProcess.stdout.on('data', function (data) {
      console.log('stdout: ' + data);
   });

   workerProcess.stderr.on('data', function (data) {
      console.log('stderr: ' + data);
   });

   workerProcess.on('close', function (code) {
      console.log('child process exited with code ' + code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started

stdout: Child Process 0 executed.

child process exited with code 0
stdout: Child Process 1 executed.

stdout: Child Process 2 executed.

child process exited with code 0
child process exited with code 0

The fork() Method
child_process.fork method is a special case of spawn() to create Node processes. It has the following signature −

child_process.fork(modulePath[, args][, options])

Parameters
Here is the description of the parameters used −

modulePath (String) The module to run in the child.
args (Array) List of string arguments
options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
execPath (String) Executable used to create the child process.
execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).
silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.



The fork method returns an object with a built-in communication channel in addition to having all the methods in a normal ChildProcess instance.
Example
Create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');
 
for(var i=0; i<3; i++) {
   var worker_process = child_process.fork(""support.js"", [i]);	

   worker_process.on('close', function (code) {
      console.log('child process exited with code ' + code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started.

Child Process 0 executed.
Child Process 1 executed.
Child Process 2 executed.
child process exited with code 0
child process exited with code 0
child process exited with code 0





Useful Video Courses








 
Video 
Serverless Development with AWS Lambda and NodeJS

    44 Lectures 
     7.5 hours 
  Eduonix Learning Solutions
 



More Detail













 
Video 
Learn Nodejs by building 10 projects

    88 Lectures 
     17 hours 
  Eduonix Learning Solutions
 



More Detail













 
Video 
Unit Testing and Test Driven Development in NodeJS

    32 Lectures 
     1.5 hours 
  Richard Wells
 



More Detail













 
Video 
Nodejs Crash Course : For Backend Development

    8 Lectures 
     33 mins
  Anant Rungta
 



More Detail













 
Video 
Learn NodeJS Step by Step

    9 Lectures 
     2.5 hours 
  SHIVPRASAD KOIRALA
 



More Detail













 
Video 
Master NodeJs : A Practical Approach To Node JS Most Popular

    97 Lectures 
     6 hours 
  Skillbakerystudios
 



More Detail















 Previous Page
 Print Page


Next Page  




Advertisements






|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started.|||child_process.spawn method launches a new process with a given command. It has the following signature −|||Here is the description of the parameters used −|||command (String) The command to run|||args (Array) List of string arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process.|||env (Object) Environment key-value pairs.|||stdio (Array) String Child's stdio configuration.|||customFds (Array) Deprecated File descriptors for the child to use for stdio.|||detached (Boolean) The child will be a process group leader.|||uid (Number) Sets the user identity of the process.|||gid (Number) Sets the group identity of the process.|||The spawn() method returns streams (stdout &stderr) and it should be used when the process returns a volume amount of data. spawn() starts receiving the response as soon as the process starts executing.|||Create two js files named support.js and master.js −|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started|||child_process.fork method is a special case of spawn() to create Node processes. It has the following signature −|||Here is the description of the parameters used −|||modulePath (String) The module to run in the child.|||args (Array) List of string arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process.|||env (Object) Environment key-value pairs.|||execPath (String) Executable used to create the child process.|||execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).|||silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).|||uid (Number) Sets the user identity of the process. |||gid (Number) Sets the group identity of the process.|||The fork method returns an object with a built-in communication channel in addition to having all the methods in a normal ChildProcess instance.|||Create two js files named support.js and master.js −|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started.","exec − child_process.exec method runs a command in a shell/console and buffers the output.@@@spawn − child_process.spawn launches a new process with a given command.@@@fork − The child_process.fork method is a special case of the spawn() to create child processes.|||command (String) The command to run, with space-separated arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process
env (Object) Environment key-value pairs
encoding (String) (Default: 'utf8')
shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)
timeout (Number) (Default: 0)
maxBuffer (Number) (Default: 200*1024)
killSignal (String) (Default: 'SIGTERM')
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process@@@env (Object) Environment key-value pairs@@@encoding (String) (Default: 'utf8')@@@shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)@@@timeout (Number) (Default: 0)@@@maxBuffer (Number) (Default: 200*1024)@@@killSignal (String) (Default: 'SIGTERM')@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.@@@callback The function gets three arguments error, stdout, and stderr which are called with the output when the process terminates.|||cwd (String) Current working directory of the child process@@@env (Object) Environment key-value pairs@@@encoding (String) (Default: 'utf8')@@@shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)@@@timeout (Number) (Default: 0)@@@maxBuffer (Number) (Default: 200*1024)@@@killSignal (String) (Default: 'SIGTERM')@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.|||command (String) The command to run@@@args (Array) List of string arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
stdio (Array) String Child's stdio configuration.
customFds (Array) Deprecated File descriptors for the child to use for stdio.
detached (Boolean) The child will be a process group leader.
uid (Number) Sets the user identity of the process.
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@stdio (Array) String Child's stdio configuration.@@@customFds (Array) Deprecated File descriptors for the child to use for stdio.@@@detached (Boolean) The child will be a process group leader.@@@uid (Number) Sets the user identity of the process.@@@gid (Number) Sets the group identity of the process.|||cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@stdio (Array) String Child's stdio configuration.@@@customFds (Array) Deprecated File descriptors for the child to use for stdio.@@@detached (Boolean) The child will be a process group leader.@@@uid (Number) Sets the user identity of the process.@@@gid (Number) Sets the group identity of the process.|||modulePath (String) The module to run in the child.@@@args (Array) List of string arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
execPath (String) Executable used to create the child process.
execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).
silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@execPath (String) Executable used to create the child process.@@@execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).@@@silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.|||cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@execPath (String) Executable used to create the child process.@@@execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).@@@silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.",,,"const fs = require('fs');const child_process = require('child_process');for(var i=0; i<3; i++) {   var workerProcess = child_process.exec('node support.js '+i,function       (error, stdout, stderr) {            if (error) {         console.log(error.stack);         console.log('Error code: '+error.code);         console.log('Signal received: '+error.signal);      }      console.log('stdout: ' + stdout);      console.log('stderr: ' + stderr);   });   workerProcess.on('exit', function (code) {      console.log('Child process exited with exit code '+code);   });}|||const fs = require('fs');const child_process = require('child_process'); for(var i = 0; i<3; i++) {   var workerProcess = child_process.spawn('node', ['support.js', i]);   workerProcess.stdout.on('data', function (data) {      console.log('stdout: ' + data);   });   workerProcess.stderr.on('data', function (data) {      console.log('stderr: ' + data);   });   workerProcess.on('close', function (code) {      console.log('child process exited with code ' + code);   });}|||const fs = require('fs');const child_process = require('child_process'); for(var i=0; i<3; i++) {   var worker_process = child_process.fork(""support.js"", [i]);	   worker_process.on('close', function (code) {      console.log('child process exited with code ' + code);   });}"
Learn Node.js,Node.js - Packaging,Node.js - Packaging|||JXcore Installation@@@Packaging the Code@@@Launching JX File@@@Useful Video Courses|||Step 1@@@Step 2@@@Step 3@@@Step 4|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"JXcore, which is an open source project, introduces a unique feature for packaging and encryption of source files and other assets into JX packages.|||Consider you have a large project consisting of many files. JXcore can pack them all into a single file to simplify the distribution. This chapter provides a quick overview of the whole process starting from installing JXcore.|||Installing JXcore is quite simple. Here we have provided step-by-step instructions on how to install JXcore on your system. Follow the steps given below −|||Download the JXcore package from https://github.com/jxcore/jxcore, as per your operating system and machine architecture. We downloaded a package for Cenots running on 64-bit machine.|||Unpack the downloaded file jx_rh64.zipand copy the jx binary into /usr/bin or may be in any other directory based on your system setup.|||Set your PATH variable appropriately to run jx from anywhere you like.|||You can verify your installation by issuing a simple command as shown below. You should find it working and printing its version number as follows −|||Consider you have a project with the following directories where you kept all your files including Node.js, main file, index.js, and all the modules installed locally.|||To package the above project, you simply need to go inside this directory and issue the following jx command. Assuming index.js is the entry file for your Node.js project −|||Here you could have used any other package name instead of index. We have used index because we wanted to keep our main file name as index.jx. However, the above command will pack everything and will create the following two files −|||index.jxp This is an intermediate file which contains the complete project detail needed to compile the project.|||index.jx This is the binary file having the complete package that is ready to be shipped to your client or to your production environment.|||Consider your original Node.js project was running as follows −|||After compiling your package using JXcore, it can be started as follows −|||To know more on JXcore, you can check its official website.",index.jxp This is an intermediate file which contains the complete project detail needed to compile the project.@@@index.jx This is the binary file having the complete package that is ready to be shipped to your client or to your production environment.,,,
Learn Node.js,Node.js - Quick Guide,"Node.js - Quick Guide@@@Node.js - Introduction@@@Node.js - Environment Setup@@@Node.js - First Application@@@Node.js - REPL Terminal@@@Node.js - NPM@@@Node.js - Callbacks Concept@@@Node.js - Event Loop@@@Node.js - Event Emitter@@@Node.js - Buffers@@@Node.js - Streams@@@Node.js - File System@@@Node.js - Global Objects@@@Node.js - Utility Modules@@@Node.js - Web Module@@@Node.js - Express Framework@@@Node.js - RESTful API@@@Node.js - Scaling Application@@@Node.js - Packaging|||What is Node.js?@@@Features of Node.js@@@Who Uses Node.js?@@@Concepts@@@Where to Use Node.js?@@@Where Not to Use Node.js?@@@Try it Option Online@@@Local Environment Setup@@@Text Editor@@@The Node.js Runtime@@@Download Node.js archive@@@Installation on UNIX/Linux/Mac OS X, and SunOS@@@Installation on Windows@@@Verify installation: Executing a File@@@Creating Node.js Application@@@Make a Request to the Node.js Server@@@Online REPL Terminal@@@REPL Commands@@@Stopping REPL@@@Installing Modules using NPM@@@Global vs Local Installation@@@Using package.json@@@Attributes of Package.json@@@Uninstalling a Module@@@Updating a Module@@@Search a Module@@@Create a Module@@@What is Callback?@@@Blocking Code Example@@@Non-Blocking Code Example@@@Event-Driven Programming@@@Example@@@How Node Applications Work?@@@EventEmitter Class@@@Methods@@@Class Methods@@@Events@@@Example@@@Creating Buffers@@@Writing to Buffers@@@Reading from Buffers@@@Convert Buffer to JSON@@@Concatenate Buffers@@@Compare Buffers@@@Copy Buffer@@@Slice Buffer@@@Buffer Length@@@Methods Reference@@@Class Methods@@@What are Streams?@@@Reading from a Stream@@@Writing to a Stream@@@Piping the Streams@@@Chaining the Streams@@@Synchronous vs Asynchronous@@@Open a File@@@Flags@@@Get File Information@@@Writing a File@@@Reading a File@@@Closing a File@@@Truncate a File@@@Delete a File@@@Create a Directory@@@Read a Directory@@@Remove a Directory@@@Methods Reference@@@__filename@@@__dirname@@@setTimeout(cb, ms)@@@clearTimeout(t)@@@setInterval(cb, ms)@@@Global Objects@@@What is a Web Server?@@@Web Application Architecture@@@Creating a Web Server using Node@@@Make a request to Node.js server@@@Creating Web client using Node@@@Express Overview@@@Installing Express@@@Hello world Example@@@Request & Response@@@Basic Routing@@@Serving Static Files@@@GET Method@@@POST Method@@@File Upload@@@Cookies Management@@@What is REST architecture?@@@HTTP methods@@@RESTful Web Services@@@Creating RESTful for A Library@@@List Users@@@Add User@@@Show Detail@@@Delete User@@@The exec() method@@@Example@@@The spawn() Method@@@Example@@@The fork() Method@@@Example@@@JXcore Installation@@@Packaging the Code@@@Launching JX File@@@Useful Video Courses|||Step 1 - Import Required Module@@@Step 2 - Create Server@@@Step 3 - Testing Request & Response@@@Starting REPL@@@Simple Expression@@@Use Variables@@@Multiline Expression@@@Underscore Variable@@@Method 1@@@Method 2@@@Method 3@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Parameters@@@Return Value@@@Example@@@Syntax@@@Return Value@@@Example@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Syntax@@@Parameters@@@Example@@@Example@@@Example@@@Example@@@Example@@@Example@@@Parameters@@@Parameters@@@Parameters@@@Step 1@@@Step 2@@@Step 3@@@Step 4|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS","Node.js is a server-side platform built on Google Chrome's JavaScript Engine (V8 Engine). Node.js was developed by Ryan Dahl in 2009 and its latest version is v0.10.36. The definition of Node.js as supplied by its official documentation is as follows −|||Node.js is a platform built on Chrome's JavaScript runtime for easily building fast and scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.|||Node.js is an open source, cross-platform runtime environment for developing server-side and networking applications. Node.js applications are written in JavaScript, and can be run within the Node.js runtime on OS X, Microsoft Windows, and Linux.|||Node.js also provides a rich library of various JavaScript modules which simplifies the development of web applications using Node.js to a great extent.|||Following are some of the important features that make Node.js the first choice of software architects.|||Asynchronous and Event Driven − All APIs of Node.js library are asynchronous, that is, non-blocking. It essentially means a Node.js based server never waits for an API to return data. The server moves to the next API after calling it and a notification mechanism of Events of Node.js helps the server to get a response from the previous API call.|||Very Fast − Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.|||Single Threaded but Highly Scalable − Node.js uses a single threaded model with event looping. Event mechanism helps the server to respond in a non-blocking way and makes the server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and the same program can provide service to a much larger number of requests than traditional servers like Apache HTTP Server.|||No Buffering − Node.js applications never buffer any data. These applications simply output the data in chunks.|||License − Node.js is released under the MIT license.|||Following is the link on github wiki containing an exhaustive list of projects, application and companies which are using Node.js. This list includes eBay, General Electric, GoDaddy, Microsoft, PayPal, Uber, Wikipins, Yahoo!, and Yammer to name a few.|||Projects, Applications, and Companies Using Node|||The following diagram depicts some important parts of Node.js which we will discuss in detail in the subsequent chapters.|||Following are the areas where Node.js is proving itself as a perfect technology partner.|||It is not advisable to use Node.js for CPU intensive applications.|||You really do not need to set up your own environment to start learning Node.js. Reason is very simple, we already have set up Node.js environment online, so that you can execute all the available examples online and learn through practice. Feel free to modify any example and check the results with different options.|||Try the following example using the Live Demo option available at the top right corner of the below sample code box (on our website) −|||For most of the examples given in this tutorial, you will find a Try it option, so just make use of it and enjoy your learning.|||If you are still willing to set up your environment for Node.js, you need the following two softwares available on your computer, (a) Text Editor and (b) The Node.js binary installables.|||This will be used to type your program. Examples of few editors include Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.|||Name and version of text editor can vary on different operating systems. For example, Notepad will be used on Windows, and vim or vi can be used on windows as well as Linux or UNIX.|||The files you create with your editor are called source files and contain program source code. The source files for Node.js programs are typically named with the extension "".js"".|||Before starting your programming, make sure you have one text editor in place and you have enough experience to write a computer program, save it in a file, and finally execute it.|||The source code written in source file is simply javascript. The Node.js interpreter will be used to interpret and execute your javascript code.|||Node.js distribution comes as a binary installable for SunOS , Linux, Mac OS X, and Windows operating systems with the 32-bit (386) and 64-bit (amd64) x86 processor architectures. |||Following section guides you on how to install Node.js binary distribution on various OS.|||Download latest version of Node.js installable archive file  from Node.js Downloads. At the time of writing this tutorial, following are the versions available on different OS.|||Based on your OS architecture, download and extract the archive node-v6.3.1-osname.tar.gz into /tmp, and then finally move extracted files into /usr/local/nodejs directory. For example:|||Add /usr/local/nodejs/bin to the PATH environment variable.|||Use the MSI file and follow the prompts to install the Node.js. By default, the installer uses the Node.js distribution in C:\Program Files\nodejs. The installer should set the C:\Program Files\nodejs\bin directory in window's PATH environment variable. Restart any open command prompts for the change to take effect.|||Create a js file named main.js on your machine (Windows or Linux) having the following code.|||Now execute main.js file using Node.js interpreter to see the result −|||If everything is fine with your installation, this should produce the following result −|||Before creating an actual ""Hello, World!"" application using Node.js, let us see the components of a Node.js application. A Node.js application consists of the following three important components −|||Import required modules − We use the require directive to load Node.js modules.|||Create server − A server which will listen to client's requests similar to Apache HTTP Server.|||Read request and return response − The server created in an earlier step will read the HTTP request made by the client which can be a browser or a console and return the response.|||We use the require directive to load the http module and store the returned HTTP instance into an http variable as follows −|||We use the created http instance and call http.createServer() method to create a server instance and then we bind it at port 8081 using the listen method associated with the server instance. Pass it a function with parameters request and response. Write the sample implementation to always return ""Hello World"".|||The above code is enough to create an HTTP server which listens, i.e., waits for a request over 8081 port on the local machine.|||Let's put step 1 and 2 together in a file called main.js and start our HTTP server as shown below −|||Now execute the main.js to start the server as follows −|||Verify the Output. Server has started.|||Open http://127.0.0.1:8081/ in any browser and observe the following result.|||Congratulations, you have your first HTTP server up and running which is responding to all the HTTP requests at port 8081.|||REPL stands for Read Eval Print Loop and it represents a computer environment like a Windows console or Unix/Linux shell where a command is entered and the system responds with an output in an interactive mode. Node.js or Node comes bundled with a REPL environment. It performs the following tasks −|||Read − Reads user's input, parses the input into JavaScript data-structure, and stores in memory.|||Eval − Takes and evaluates the data structure.|||Print − Prints the result.|||Loop − Loops the above command until the user presses ctrl-c twice.|||The REPL feature of Node is very useful in experimenting with Node.js codes and to debug JavaScript codes.|||To simplify your learning, we have set up an easy to use Node.js REPL environment online, where you can practice Node.js syntax − Launch Node.js REPL Terminal |||REPL can be started by simply running node on shell/console without any arguments as follows.|||You will see the REPL Command prompt > where you can type any Node.js command −|||Let's try a simple mathematics at the Node.js REPL command prompt −|||You can make use variables to store values and print later like any conventional script. If var keyword is not used, then the value is stored in the variable and printed. Whereas if var keyword is used, then the value is stored but not printed. You can print variables using console.log().|||Node REPL supports multiline expression similar to JavaScript. Let's check the following do-while loop in action −|||... comes automatically when you press Enter after the opening bracket. Node automatically checks the continuity of expressions.|||You can use underscore (_) to get the last result −|||ctrl + c − terminate the current command.|||ctrl + c twice − terminate the Node REPL.|||ctrl + d − terminate the Node REPL.|||Up/Down Keys − see command history and modify previous commands.|||tab Keys − list of current commands.|||.help − list of all commands.|||.break − exit from multiline expression.|||.clear − exit from multiline expression.|||.save filename − save the current Node REPL session to a file.|||.load filename − load file content in current Node REPL session.|||As mentioned above, you will need to use ctrl-c twice to come out of Node.js REPL.|||Node Package Manager (NPM) provides two main functionalities −|||Online repositories for node.js packages/modules which are searchable on search.nodejs.org|||Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.|||NPM comes bundled with Node.js installables after v0.6.3 version. To verify the same, open console and type the following command and see the result −|||If you are running an old version of NPM then it is quite easy to update it to the latest version. Just use the following command from root −|||There is a simple syntax to install any Node.js module −|||For example, following is the command to install a famous Node.js web framework module called express −|||Now you can use this module in your js file as following −|||By default, NPM installs any dependency in the local mode. Here local mode refers to the package installation in node_modules directory lying in the folder where Node application is present. Locally deployed packages are accessible via require() method. For example, when we installed express module, it created node_modules directory in the current directory where it installed the express module.|||Alternatively, you can use npm ls command to list down all the locally installed modules.|||Globally installed packages/dependencies are stored in system directory. Such dependencies can be used in CLI (Command Line Interface) function of any node.js but cannot be imported using require() in Node application directly. Now let's try installing the express module using global installation.|||This will produce a similar result but the module will be installed globally. Here, the first line shows the module version and the location where it is getting installed.|||You can use the following command to check all the modules installed globally −|||package.json is present in the root directory of any Node application/module and is used to define the properties of a package. Let's open package.json of express package present in node_modules/express/|||name − name of the package|||version − version of the package|||description − description of the package|||homepage − homepage of the package|||author − author of the package|||contributors − name of the contributors to the package|||dependencies − list of dependencies. NPM automatically installs all the dependencies mentioned here in the node_module folder of the package.|||repository − repository type and URL of the package|||main − entry point of the package|||keywords − keywords|||Use the following command to uninstall a Node.js module.|||Once NPM uninstalls the package, you can verify it by looking at the content of /node_modules/ directory or type the following command −|||Update package.json and change the version of the dependency to be updated and run the following command.|||Search a package name using NPM.|||Creating a module requires package.json to be generated. Let's generate package.json using NPM, which will generate the basic skeleton of the package.json.|||You will need to provide all the required information about your module. You can take help from the above-mentioned package.json file to understand the meanings of various information demanded. Once package.json is generated, use the following command to register yourself with NPM repository site using a valid email address.|||It is time now to publish your module −|||If everything is fine with your module, then it will be published in the repository and will be accessible to install using NPM like any other Node.js module.|||Callback is an asynchronous equivalent for a function. A callback function is called at the completion of a given task. Node makes heavy use of callbacks. All the APIs of Node are written in such a way that they support callbacks.|||For example, a function to read a file may start reading file and return the control to the execution environment immediately so that the next instruction can be executed. Once file I/O is complete, it will call the callback function while passing the callback function, the content of the file as a parameter. So there is no blocking or wait for File I/O. This makes Node.js highly scalable, as it can process a high number of requests without waiting for any function to return results.|||Create a text file named input.txt with the following content −|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Create a text file named input.txt with the following content.|||Update main.js to have the following code −|||Now run the main.js to see the result −|||Verify the Output.|||These two examples explain the concept of blocking and non-blocking calls.|||The first example shows that the program blocks until it reads the file and then only it proceeds to end the program.|||The second example shows that the program does not wait for file reading and proceeds to print ""Program Ended"" and at the same time, the program without blocking continues reading the file.|||Thus, a blocking program executes very much in sequence. From the programming point of view, it is easier to implement the logic but non-blocking programs do not execute in sequence. In case a program needs to use any data to be processed, it should be kept within the same block to make it sequential execution.|||Node.js is a single-threaded application, but it can support concurrency via the concept of event and callbacks. Every API of Node.js is asynchronous and being single-threaded, they use async function calls to maintain concurrency. Node uses observer pattern. Node thread keeps an event loop and whenever a task gets completed, it fires the corresponding event which signals the event-listener function to execute.|||Node.js uses events heavily and it is also one of the reasons why Node.js is pretty fast compared to other similar technologies. As soon as Node starts its server, it simply initiates its variables, declares functions and then simply waits for the event to occur. |||In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected.|||Although events look quite similar to callbacks, the difference lies in the fact that callback functions are called when an asynchronous function returns its result, whereas event handling works on the observer pattern. The functions that listen to events act as Observers. Whenever an event gets fired, its listener function starts executing. Node.js has multiple in-built events available through events module and EventEmitter class which are used to bind events and event-listeners as follows −|||Following is the syntax to bind an event handler with an event −|||We can fire an event programmatically as follows −|||Create a js file named main.js with the following code −|||Now let's try to run the above program and check its output −|||IT should produce the following result −|||In Node Application, any async function accepts a callback as the last parameter and a callback function accepts an error as the first parameter. Let's revisit the previous example again. Create a text file named input.txt with the following content.|||Create a js file named main.js having the following code −|||Here fs.readFile() is a async function whose purpose is to read a file. If an error occurs during the read operation, then the err object will contain the corresponding error, else data will contain the contents of the file. readFile passes err and data to the callback function after the read operation is complete, which finally prints the content.|||Many objects in a Node emit events, for example, a net.Server emits an event each time a peer connects to it, an fs.readStream emits an event when the file is opened. All objects which emit events are the instances of events.EventEmitter.|||As we have seen in the previous section, EventEmitter class lies in the events module. It is accessible via the following code −|||When an EventEmitter instance faces any error, it emits an 'error' event. When a new listener is added, 'newListener' event is fired and when a listener is removed, 'removeListener' event is fired.|||EventEmitter provides multiple properties like on and emit. on property is used to bind a function with the event and emit is used to fire an event.|||addListener(event, listener)|||Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.|||on(event, listener)|||Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.|||once(event, listener)|||Adds a one time listener to the event. This listener is invoked only the next time the event is fired, after which it is removed. Returns emitter, so calls can be chained.|||removeListener(event, listener)|||Removes a listener from the listener array for the specified event. Caution − It changes the array indices in the listener array behind the listener. removeListener will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified event, then removeListener must be called multiple times to remove each instance. Returns emitter, so calls can be chained.|||removeAllListeners([event])|||Removes all listeners, or those of the specified event. It's not a good idea to remove listeners that were added elsewhere in the code, especially when it's on an emitter that you didn't create (e.g. sockets or file streams). Returns emitter, so calls can be chained.|||setMaxListeners(n)|||By default, EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.|||listeners(event)|||Returns an array of listeners for the specified event.|||emit(event, [arg1], [arg2], [...])|||Execute each of the listeners in order with the supplied arguments. Returns true if the event had listeners, false otherwise.|||listenerCount(emitter, event)|||Returns the number of listeners for a given event.|||newListener|||event − String: the event name|||listener − Function: the event handler function|||This event is emitted any time a listener is added. When this event is triggered, the listener may not yet have been added to the array of listeners for the event.|||removeListener|||event − String The event name|||listener − Function The event handler function|||This event is emitted any time someone removes a listener. When this event is triggered, the listener may not yet have been removed from the array of listeners for the event.|||Create a js file named main.js with the following Node.js code −|||Now run the main.js to see the result −|||Verify the Output.|||Pure JavaScript is Unicode friendly, but it is not so for binary data. While dealing with TCP streams or the file system, it's necessary to handle octet streams. Node provides Buffer class which provides instances to store raw data similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.|||Buffer class is a global class that can be accessed in an application without importing the buffer module.|||Node Buffer can be constructed in a variety of ways.|||Following is the syntax to create an uninitiated Buffer of 10 octets −|||Following is the syntax to create a Buffer from a given array −|||Following is the syntax to create a Buffer from a given string and optionally encoding type −|||Though ""utf8"" is the default encoding, you can use any of the following encodings ""ascii"", ""utf8"", ""utf16le"", ""ucs2"", ""base64"" or ""hex"".|||Following is the syntax of the method to write into a Node Buffer −|||Here is the description of the parameters used −|||string − This is the string data to be written to buffer.|||offset − This is the index of the buffer to start writing at. Default value is 0.|||length − This is the number of bytes to write. Defaults to buffer.length.|||encoding − Encoding to use. 'utf8' is the default encoding.|||This method returns the number of octets written. If there is not enough space in the buffer to fit the entire string, it will write a part of the string.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to read data from a Node Buffer −|||Here is the description of the parameters used −|||encoding − Encoding to use. 'utf8' is the default encoding.|||start − Beginning index to start reading, defaults to 0.|||end − End index to end reading, defaults is complete buffer.|||This method decodes and returns a string from buffer data encoded using the specified character set encoding.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to convert a Node Buffer into JSON object −|||This method returns a JSON-representation of the Buffer instance.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to concatenate Node buffers to a single Node Buffer −|||Here is the description of the parameters used −|||list − Array List of Buffer objects to be concatenated.|||totalLength − This is the total length of the buffers when concatenated.|||This method returns a Buffer instance.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to compare two Node buffers −|||Here is the description of the parameters used −|||otherBuffer − This is the other buffer which will be compared with buf|||Returns a number indicating whether it comes before or after or is the same as the otherBuffer in sort order.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to copy a node buffer −|||Here is the description of the parameters used −|||targetBuffer − Buffer object where buffer will be copied.|||targetStart − Number, Optional, Default: 0|||sourceStart − Number, Optional, Default: 0|||sourceEnd − Number, Optional, Default: buffer.length|||No return value. Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to get a sub-buffer of a node buffer −|||Here is the description of the parameters used −|||start − Number, Optional, Default: 0|||end − Number, Optional, Default: buffer.length|||Returns a new buffer which references the same memory as the old one, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.|||When the above program is executed, it produces the following result −|||Following is the syntax of the method to get a size of a node buffer in bytes −|||Returns the size of a buffer in bytes.|||When the above program is executed, it produces following result −|||new Buffer(size)|||Allocates a new buffer of size octets. Note that the size must be no more than kMaxLength. Otherwise, a RangeError will be thrown here.|||new Buffer(buffer)|||Copies the passed buffer data onto a new Buffer instance.|||new Buffer(str[, encoding])|||Allocates a new buffer containing the given str. encoding defaults to 'utf8'.|||buf.length|||Returns the size of the buffer in bytes. Note that this is not necessarily the size of the contents. length refers to the amount of memory allocated for the buffer object. It does not change when the contents of the buffer are changed.|||buf.write(string[, offset][, length][, encoding])|||Writes a string to the buffer at offset using the given encoding. offset defaults to 0, encoding defaults to 'utf8'. length is the number of bytes to write. Returns the number of octets written.|||buf.writeUIntLE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeUIntBE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeIntLE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.writeIntBE(value, offset, byteLength[, noAssert])|||Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.|||buf.readUIntLE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUIntBE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readIntLE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readIntBE(offset, byteLength[, noAssert])|||A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.toString([encoding][, start][, end])|||Decodes and returns a string from buffer data encoded using the specified character set encoding.|||buf.toJSON()|||Returns a JSON-representation of the Buffer instance. JSON.stringify implicitly calls this function when stringifying a Buffer instance.|||buf[index]|||Get and set the octet at index. The values refer to individual bytes, so the legal range is between 0x00 and 0xFF hex or 0 and 255.|||buf.equals(otherBuffer)|||Returns a boolean if this buffer and otherBuffer have the same bytes.|||buf.compare(otherBuffer)|||Returns a number indicating whether this buffer comes before or after or is the same as the otherBuffer in sort order.|||buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])|||Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.|||buf.slice([start][, end])|||Returns a new buffer which references the same memory as the old, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.|||buf.readUInt8(offset[, noAssert])|||Reads an unsigned 8 bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt16LE(offset[, noAssert])|||Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt16BE(offset[, noAssert])|||Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt32LE(offset[, noAssert])|||Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readUInt32BE(offset[, noAssert])|||Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt8(offset[, noAssert])|||Reads a signed 8-bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt16LE(offset[, noAssert])|||Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt16BE(offset[, noAssert])|||Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt32LE(offset[, noAssert])|||Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readInt32BE(offset[, noAssert])|||Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readFloatLE(offset[, noAssert])|||Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readFloatBE(offset[, noAssert])|||Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readDoubleLE(offset[, noAssert])|||Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.readDoubleBE(offset[, noAssert])|||Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.|||buf.writeUInt8(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset. Note that the value must be a valid unsigned 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt16LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.|||buf.writeUInt16BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt32LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeUInt32BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt8(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt16LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt16BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt32LE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeInt32BE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.|||buf.writeFloatLE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means that the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeFloatBE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeDoubleLE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means that value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.writeDoubleBE(value, offset[, noAssert])|||Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||buf.fill(value[, offset][, end])|||Fills the buffer with the specified value. If the offset (defaults to 0) and end (defaults to buffer.length) are not given, it will fill the entire buffer.|||Buffer.isEncoding(encoding)|||Returns true if the encoding is a valid encoding argument, false otherwise.|||Buffer.isBuffer(obj)|||Tests if obj is a Buffer.|||Buffer.byteLength(string[, encoding])|||Gives the actual byte length of a string. encoding defaults to 'utf8'. It is not the same as String.prototype.length, since String.prototype.length returns the number of characters in a string.|||Buffer.concat(list[, totalLength])|||Returns a buffer which is the result of concatenating all the buffers in the list together.|||Buffer.compare(buf1, buf2)|||The same as buf1.compare(buf2). Useful for sorting an array of buffers.|||Streams are objects that let you read data from a source or write data to a destination in continuous fashion. In Node.js, there are four types of streams −|||Readable − Stream which is used for read operation.|||Writable − Stream which is used for write operation.|||Duplex − Stream which can be used for both read and write operation.|||Transform − A type of duplex stream where the output is computed based on input.|||Each type of Stream is an EventEmitter instance and throws several events at different instance of times. For example, some of the commonly used events are −|||data − This event is fired when there is data is available to read.|||end − This event is fired when there is no more data to read.|||error − This event is fired when there is any error receiving or writing data.|||finish − This event is fired when all the data has been flushed to underlying system.|||This tutorial provides a basic understanding of the commonly used operations on Streams.|||Create a text file named input.txt having the following content −|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Now open output.txt created in your current directory; it should contain the following −|||Piping is a mechanism where we provide the output of one stream as the input to another stream. It is normally used to get data from one stream and to pass the output of that stream to another stream. There is no limit on piping operations. Now we'll show a piping example for reading from one file and writing it to another file.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Open output.txt created in your current directory; it should contain the following −|||Chaining is a mechanism to connect the output of one stream to another stream and create a chain of multiple stream operations. It is normally used with piping operations. Now we'll use piping and chaining to first compress a file and then decompress the same.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||You will find that input.txt has been compressed and it created a file input.txt.gz in the current directory. Now let's try to decompress the same file using the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Node implements File I/O using simple wrappers around standard POSIX functions. The Node File System (fs) module can be imported using the following syntax −|||Every method in the fs module has synchronous as well as asynchronous forms. Asynchronous methods take the last parameter as the completion function callback and the first parameter of the callback function as error. It is better to use an asynchronous method instead of a synchronous method, as the former never blocks a program during its execution, whereas the second one does.|||Create a text file named input.txt with the following content −|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||The following sections in this chapter provide a set of good examples on major File I/O methods.|||Following is the syntax of the method to open a file in asynchronous mode −|||Here is the description of the parameters used −|||path − This is the string having file name including path.|||flags − Flags indicate the behavior of the file to be opened. All possible values have been mentioned below.|||mode − It sets the file mode (permission and sticky bits), but only if the file was created. It defaults to 0666, readable and writeable.|||callback − This is the callback function which gets two arguments (err, fd).|||Flags for read/write operations are −|||r|||Open file for reading. An exception occurs if the file does not exist.|||r+|||Open file for reading and writing. An exception occurs if the file does not exist.|||rs|||Open file for reading in synchronous mode.|||rs+|||Open file for reading and writing, asking the OS to open it synchronously. See notes for 'rs' about using this with caution.|||w|||Open file for writing. The file is created (if it does not exist) or truncated (if it exists).|||wx|||Like 'w' but fails if the path exists.|||w+|||Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).|||wx+|||Like 'w+' but fails if path exists.|||a|||Open file for appending. The file is created if it does not exist.|||ax|||Like 'a' but fails if the path exists.|||a+|||Open file for reading and appending. The file is created if it does not exist.|||ax+|||Like 'a+' but fails if the the path exists.|||Let us create a js file named main.js having the following code to open a file input.txt for reading and writing.|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to get the information about a file −|||Here is the description of the parameters used −|||path − This is the string having file name including path.|||callback − This is the callback function which gets two arguments (err, stats) where stats is an object of fs.Stats type which is printed below in the example.|||Apart from the important attributes which are printed below in the example, there are several useful methods available in fs.Stats class which can be used to check file type. These methods are  given in the following table.|||stats.isFile()|||Returns true if file type of a simple file.|||stats.isDirectory()|||Returns true if file type of a directory.|||stats.isBlockDevice()|||Returns true if file type of a block device.|||stats.isCharacterDevice()|||Returns true if file type of a character device.|||stats.isSymbolicLink()|||Returns true if file type of a symbolic link.|||stats.isFIFO()|||Returns true if file type of a FIFO.|||stats.isSocket()|||Returns true if file type of asocket.|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of one of the methods to write into a file −|||This method will over-write the file if the file already exists. If you want to write into an existing file then you should use another method available.|||Here is the description of the parameters used −|||path − This is the string having the file name including path.|||data − This is the  String or Buffer to be written into the file.|||options − The third parameter is an object which will hold {encoding, mode, flag}. By default. encoding is utf8, mode is octal value 0666. and flag is 'w'|||callback − This is the callback function which gets a single parameter err that returns an error in case of any writing error.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of one of the methods to read from a file −|||This method will use file descriptor to read the file. If you want to read the file directly using the file name, then you should use another method available.|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by fs.open().|||buffer − This is the buffer that the data will be written to.|||offset − This is the offset in the buffer to start writing at.|||length − This is an integer specifying the number of bytes to read.|||position − This is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.|||callback − This is the callback function which gets the three arguments, (err, bytesRead, buffer).|||Let us create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax to close an opened file −|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by file fs.open() method.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to truncate an opened file −|||Here is the description of the parameters used −|||fd − This is the file descriptor returned by fs.open().|||len − This is the length of the file after which the file will be truncated.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to delete a file −|||Here is the description of the parameters used −|||path − This is the file name including path.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to create a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||mode − This is the directory permission to be set. Defaults to 0777.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to read a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||callback − This is the callback function which gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||Following is the syntax of the method to remove a directory −|||Here is the description of the parameters used −|||path − This is the directory name including path.|||callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Let us create a js file named main.js having the following code −|||Now run the main.js to see the result −|||Verify the Output.|||fs.rename(oldPath, newPath, callback)|||Asynchronous rename(). No arguments other than a possible exception are given to the completion callback.|||fs.ftruncate(fd, len, callback)|||Asynchronous ftruncate(). No arguments other than a possible exception are given to the completion callback.|||fs.ftruncateSync(fd, len)|||Synchronous ftruncate().|||fs.truncate(path, len, callback)|||Asynchronous truncate(). No arguments other than a possible exception are given to the completion callback.|||fs.truncateSync(path, len)|||Synchronous truncate().|||fs.chown(path, uid, gid, callback)|||Asynchronous chown(). No arguments other than a possible exception are given to the completion callback.|||fs.chownSync(path, uid, gid)|||Synchronous chown().|||fs.fchown(fd, uid, gid, callback)|||Asynchronous fchown(). No arguments other than a possible exception are given to the completion callback.|||fs.fchownSync(fd, uid, gid)|||Synchronous fchown().|||fs.lchown(path, uid, gid, callback)|||Asynchronous lchown(). No arguments other than a possible exception are given to the completion callback.|||fs.lchownSync(path, uid, gid)|||Synchronous lchown().|||fs.chmod(path, mode, callback)|||Asynchronous chmod(). No arguments other than a possible exception are given to the completion callback.|||fs.chmodSync(path, mode)|||Synchronous chmod().|||fs.fchmod(fd, mode, callback)|||Asynchronous fchmod(). No arguments other than a possible exception are given to the completion callback.|||fs.fchmodSync(fd, mode)|||Synchronous fchmod().|||fs.lchmod(path, mode, callback)|||Asynchronous lchmod(). No arguments other than a possible exception are given to the completion callback. Only available on Mac OS X.|||fs.lchmodSync(path, mode)|||Synchronous lchmod().|||fs.stat(path, callback)|||Asynchronous stat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object.|||fs.lstat(path, callback)|||Asynchronous lstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.|||fs.fstat(fd, callback)|||Asynchronous fstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd.|||fs.statSync(path)|||Synchronous stat(). Returns an instance of fs.Stats.|||fs.lstatSync(path)|||Synchronous lstat(). Returns an instance of fs.Stats.|||fs.fstatSync(fd)|||Synchronous fstat(). Returns an instance of fs.Stats.|||fs.link(srcpath, dstpath, callback)|||Asynchronous link(). No arguments other than a possible exception are given to the completion callback.|||fs.linkSync(srcpath, dstpath)|||Synchronous link().|||fs.symlink(srcpath, dstpath[, type], callback)|||Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.|||fs.symlinkSync(srcpath, dstpath[, type])|||Synchronous symlink().|||fs.readlink(path, callback)|||Asynchronous readlink(). The callback gets two arguments (err, linkString).|||fs.realpath(path[, cache], callback)|||Asynchronous realpath(). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths.|||fs.realpathSync(path[, cache])|||Synchronous realpath(). Returns the resolved path.|||fs.unlink(path, callback)|||Asynchronous unlink(). No arguments other than a possible exception are given to the completion callback.|||fs.unlinkSync(path)|||Synchronous unlink().|||fs.rmdir(path, callback)|||Asynchronous rmdir(). No arguments other than a possible exception are given to the completion callback.|||fs.rmdirSync(path)|||Synchronous rmdir().|||fs.mkdir(path[, mode], callback)|||Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777.|||fs.mkdirSync(path[, mode])|||Synchronous mkdir().|||fs.readdir(path, callback)|||Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||fs.readdirSync(path)|||Synchronous readdir(). Returns an array of filenames excluding '.' and '..'.|||fs.close(fd, callback)|||Asynchronous close(). No arguments other than a possible exception are given to the completion callback.|||fs.closeSync(fd)|||Synchronous close().|||fs.open(path, flags[, mode], callback)|||Asynchronous file open.|||fs.openSync(path, flags[, mode])|||Synchronous version of fs.open().|||fs.utimes(path, atime, mtime, callback)||| |||fs.utimesSync(path, atime, mtime)|||Change file timestamps of the file referenced by the supplied path.|||fs.futimes(fd, atime, mtime, callback)||| |||fs.futimesSync(fd, atime, mtime)|||Change the file timestamps of a file referenced by the supplied file descriptor.|||fs.fsync(fd, callback)|||Asynchronous fsync. No arguments other than a possible exception are given to the completion callback.|||fs.fsyncSync(fd)|||Synchronous fsync.|||fs.write(fd, buffer, offset, length[, position], callback)|||Write buffer to the file specified by fd.|||fs.write(fd, data[, position[, encoding]], callback)|||Write data to the file specified by fd. If data is not a Buffer instance then the value will be coerced to a string.|||fs.writeSync(fd, buffer, offset, length[, position])|||Synchronous versions of fs.write(). Returns the number of bytes written.|||fs.writeSync(fd, data[, position[, encoding]])|||Synchronous versions of fs.write(). Returns the number of bytes written.|||fs.read(fd, buffer, offset, length, position, callback)|||Read data from the file specified by fd.|||fs.readSync(fd, buffer, offset, length, position)|||Synchronous version of fs.read. Returns the number of bytesRead.|||fs.readFile(filename[, options], callback)|||Asynchronously reads the entire contents of a file.|||fs.readFileSync(filename[, options])|||Synchronous version of fs.readFile. Returns the contents of the filename.|||fs.writeFile(filename, data[, options], callback)|||Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.|||fs.writeFileSync(filename, data[, options])|||The synchronous version of fs.writeFile.|||fs.appendFile(filename, data[, options], callback)|||Asynchronously append data to a file, creating the file if it does not exist. data can be a string or a buffer.|||fs.appendFileSync(filename, data[, options])|||The synchronous version of fs.appendFile.|||fs.watchFile(filename[, options], listener)|||Watch for changes on filename. The callback listener will be called each time the file is accessed.|||fs.unwatchFile(filename[, listener])|||Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename.|||fs.watch(filename[, options][, listener])|||Watch for changes on filename, where filename is either a file or an directory. The returned object is an fs.FSWatcher.|||fs.exists(path, callback)|||Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false.|||fs.existsSync(path)|||Synchronous version of fs.exists.|||fs.access(path[, mode], callback)|||Tests a user's permissions for the file specified by path. mode is an optional integer that specifies the accessibility checks to be performed.|||fs.accessSync(path[, mode])|||Synchronous version of fs.access. It throws if any accessibility checks fail, and does nothing otherwise.|||fs.createReadStream(path[, options])|||Returns a new ReadStream object.|||fs.createWriteStream(path[, options])|||Returns a new WriteStream object.|||fs.symlink(srcpath, dstpath[, type], callback)|||Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.|||Node.js global objects are global in nature and they are available in all modules. We do not need to include these objects in our application, rather we can use them directly. These objects are modules, functions, strings and object itself as explained below.|||The __filename represents the filename of the code being executed. This is the resolved absolute path of this code file. For a main program, this is not necessarily the same filename used in the command line. The value inside a module is the path to that module file.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Based on the location of your program, it will print the main file name as follows −|||The __dirname represents the name of the directory that the currently executing script resides in.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Based on the location of your program, it will print current directory name as follows −|||The setTimeout(cb, ms) global function is used to run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load. A timer cannot span more than 24.8 days.|||This function returns an opaque value that represents the timer which can be used to clear the timer.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the output is printed after a little delay.|||The clearTimeout(t) global function is used to stop a timer that was previously created with setTimeout(). Here t is the timer returned by the setTimeout() function.|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||Verify the output where you will not find anything printed.|||The setInterval(cb, ms) global function is used to run callback cb repeatedly after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load. A timer cannot span more than 24.8 days.|||This function returns an opaque value that represents the timer which can be used to clear the timer using the function clearInterval(t).|||Create a js file named main.js with the following code −|||Now run the main.js to see the result −|||The above program will execute printHello() after every 2 second. Due to system limitation.|||The following table provides a list of other objects which we use frequently in our applications. For a more detail, you can refer to the official documentation.||| Used to print information on stdout and stderr.|||Used to get information on current process. Provides multiple events related to process activities.|||There are several utility modules available in Node.js module library. These modules are very common and are frequently used while developing any Node based application.|||Provides basic operating-system related utility functions.|||Provides utilities for handling and transforming file paths.|||Provides both servers and clients as streams. Acts as a network wrapper.|||Provides functions to do actual DNS lookup as well as to use underlying operating system name resolution functionalities.|||Provides ways to handle multiple different I/O operations as a single group.|||A Web Server is a software application which handles HTTP requests sent by the HTTP client, like web browsers, and returns web pages in response to the clients. Web servers usually deliver html documents along with images, style sheets, and scripts.|||Most of the web servers support server-side scripts, using scripting languages or redirecting the task to an application server which retrieves data from a database and performs complex logic and then sends a result to the HTTP client through the Web server.|||Apache web server is one of the most commonly used web servers. It is an open source project.|||A Web application is usually divided into four layers −|||Client − This layer consists of web browsers, mobile browsers or applications which can make HTTP requests to the web server.|||Server − This layer has the Web server which can intercept the requests made by the clients and pass them the response.|||Business − This layer contains the application server which is utilized by the web server to do the required processing. This layer interacts with the data layer via the database or some external programs.|||Data − This layer contains the databases or any other source of data.|||Node.js provides an http module which can be used to create an HTTP client of a server. Following is the bare minimum structure of the HTTP server which listens at 8081 port.|||Create a js file named server.js −|||File: server.js|||Next let's create the following html file named index.htm in the same directory where you created server.js.|||File: index.htm|||Now let us run the server.js to see the result −|||Verify the Output.|||Open http://127.0.0.1:8081/index.htm in any browser to see the following result.|||Verify the Output at server end.|||A web client can be created using http module. Let's check the following example.|||Create a js file named client.js −|||File: client.js|||Now run the client.js from a different command terminal other than server.js to see the result −|||Verify the Output.|||Verify the Output at server end.|||Express is a minimal and flexible Node.js web application framework that provides a robust set of features to develop web and mobile applications. It facilitates the rapid development of Node based Web applications. Following are some of the core features of Express framework −|||Allows to set up middlewares to respond to HTTP Requests.|||Defines a routing table which is used to perform different actions based on HTTP Method and URL.|||Allows to dynamically render HTML Pages based on passing arguments to templates.|||Firstly, install the Express framework globally using NPM so that it can be used to create a web application using node terminal.|||The above command saves the installation locally in the node_modules directory and creates a directory express inside node_modules. You should install the following important modules along with express −|||body-parser − This is a node.js middleware for handling JSON, Raw, Text and URL encoded form data.|||cookie-parser − Parse Cookie header and populate req.cookies with an object keyed by the cookie names.|||multer − This is a node.js middleware for handling multipart/form-data.|||Following is a very basic Express app which starts a server and listens on port 8081 for connection. This app responds with Hello World! for requests to the homepage. For every other path, it will respond with a 404 Not Found.|||Save the above code in a file named server.js and run it with the following command.|||You will see the following output −|||Open http://127.0.0.1:8081/ in any browser to see the following result.|||Express application uses a callback function whose parameters are request and response objects.|||Request Object − The request object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.|||Response Object − The response object represents the HTTP response that an Express app sends when it gets an HTTP request.|||You can print req and res objects which provide a lot of information related to HTTP request and response including cookies, sessions, URL, etc.|||We have seen a basic application which serves HTTP request for the homepage. Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).|||We will extend our Hello World program to handle more types of HTTP requests.|||Save the above code in a file named server.js and run it with the following command.|||You will see the following output −|||Now you can try different requests at http://127.0.0.1:8081 to see the output generated by server.js. Following are a few screens shots showing different responses for different URLs.|||Screen showing again http://127.0.0.1:8081/list_user|||Screen showing again http://127.0.0.1:8081/abcd|||Screen showing again http://127.0.0.1:8081/abcdefg|||Express provides a built-in middleware express.static to serve static files, such as images, CSS, JavaScript, etc.|||You simply need to pass the name of the directory where you keep your static assets, to the express.static middleware to start serving the files directly. For example, if you keep your images, CSS, and JavaScript files in a directory named public, you can do this −|||We will keep a few images in public/images sub-directory as follows −|||Let's modify ""Hello Word"" app to add the functionality to handle static files.|||Save the above code in a file named server.js and run it with the following command.|||Now open http://127.0.0.1:8081/images/logo.png in any browser and see observe following result.|||Here is a simple example which passes two values using HTML FORM GET method. We are going to use process_get router inside server.js to handle this input.|||Let's save above code in index.htm and modify server.js to handle home page requests as well as the input sent by the HTML form.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||Now you can enter the First and Last Name and then click submit button to see the result and it should return the following result −|||Here is a simple example which passes two values using HTML FORM POST method. We are going to use process_get router inside server.js to handle this input.|||Let's save the above code in index.htm and modify server.js to handle home page requests as well as the input sent by the HTML form.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||Now you can enter the First and Last Name and then click the submit button to see the following result −|||The following HTML code creates a file uploader form. This form has method attribute set to POST and enctype attribute is set to multipart/form-data|||Let's save above code in index.htm and modify server.js to handle home page requests as well as file upload.|||Accessing the HTML document using http://127.0.0.1:8081/index.htm will generate the following form −|||You can send cookies to a Node.js server which can handle the same using the following middleware option. Following is a simple example to print all the cookies sent by the client.|||REST stands for REpresentational State Transfer. REST is web standards based architecture and uses HTTP Protocol. It revolves around resource where every component is a resource and a resource is accessed by a common interface using HTTP standard methods. REST was first introduced by Roy Fielding in 2000.|||A REST Server simply provides access to resources and REST client accesses and modifies the resources using HTTP protocol. Here each resource is identified by URIs/ global IDs. REST uses various representation to represent a resource like text, JSON, XML but JSON is the most popular one.|||Following four HTTP methods are commonly used in REST based architecture.|||GET − This is used to provide a read only access to a resource.|||PUT − This is used to create a new resource.|||DELETE − This is used to remove a resource.|||POST − This is used to update a existing resource or create a new resource.|||A web service is a collection of open protocols and standards used for exchanging data between applications or systems. Software applications written in various programming languages and running on various platforms can use web services to exchange data over computer networks like the Internet in a manner similar to inter-process communication on a single computer. This interoperability (e.g., communication between Java and Python, or Windows and Linux applications) is due to the use of open standards.|||Web services based on REST Architecture are known as RESTful web services. These webservices uses HTTP methods to implement the concept of REST architecture. A RESTful web service usually defines a URI, Uniform Resource Identifier a service, which provides resource representation such as JSON and set of HTTP Methods.|||Consider we have a JSON based database of users having the following users in a file users.json:|||Based on this information we are going to provide following RESTful APIs.|||I'm keeping most of the part of all the examples in the form of hard coding assuming you already know how to pass values from front end using Ajax or simple form data and how to process them using express Request object.|||Let's implement our first RESTful API listUsers using the following code in a server.js file −|||server.js|||Now try to access defined API using  URL: http://127.0.0.1:8081/listUsers and HTTP Method : GET on local machine using any REST client. This should produce following result −|||You can change given IP address when you will put the solution in production environment.|||Following API will show you how to add new user in the list. Following is the detail of the new user −|||You can accept the same input in the form of JSON using Ajax call but for teaching point of view, we are making it hard coded here. Following is the addUser API to a new user in the database −|||server.js|||Now try to access defined API using  URL: http://127.0.0.1:8081/addUser and HTTP Method : POST on local machine using any REST client. This should produce following result −|||Now we will implement an API which will be called using user ID and it will display the detail of the corresponding user.|||server.js|||Now try to access defined API using URL: http://127.0.0.1:8081/2 and HTTP Method : GET on local machine using any REST client. This should produce following result −|||This API is very similar to addUser API where we receive input data through req.body and then based on user ID we delete that user from the database. To keep our program simple we assume we are going to delete user with ID 2.|||server.js|||Now try to access defined API using URL: http://127.0.0.1:8081/deleteUser and HTTP Method : DELETE on local machine using any REST client. This should produce following result −|||Node.js runs in a single-thread mode, but it uses an event-driven paradigm to handle concurrency. It also facilitates creation of child processes to leverage parallel processing on multi-core CPU based systems.|||Child processes always have three streams child.stdin, child.stdout, and child.stderr which may be shared with the stdio streams of the parent process.|||Node provides child_process module which has the following three major ways to create a child process.|||exec − child_process.exec method runs a command in a shell/console and buffers the output.|||spawn − child_process.spawn launches a new process with a given command.|||fork − The child_process.fork method is a special case of the spawn() to create child processes.|||child_process.exec method runs a command in a shell and buffers the output. It has the following signature −|||Here is the description of the parameters used −|||command (String) The command to run, with space-separated arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process|||env (Object) Environment key-value pairs|||encoding (String) (Default: 'utf8')|||shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)|||timeout (Number) (Default: 0)|||maxBuffer (Number) (Default: 200*1024)|||killSignal (String) (Default: 'SIGTERM')|||uid (Number) Sets the user identity of the process. |||gid (Number) Sets the group identity of the process.|||callback The function gets three arguments error, stdout, and stderr which are called with the output when the process terminates.|||The exec() method returns a buffer with a max size and waits for the process to end and tries to return all the buffered data at once.|||Let us create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');

for(var i=0; i<3; i++) {
   var workerProcess = child_process.exec('node support.js '+i,function 
      (error, stdout, stderr) {
      
      if (error) {
         console.log(error.stack);
         console.log('Error code: '+error.code);
         console.log('Signal received: '+error.signal);
      }
      console.log('stdout: ' + stdout);
      console.log('stderr: ' + stderr);
   });

   workerProcess.on('exit', function (code) {
      console.log('Child process exited with exit code '+code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started.

Child process exited with exit code 0
stdout: Child Process 1 executed.

stderr:
Child process exited with exit code 0
stdout: Child Process 0 executed.

stderr:
Child process exited with exit code 0
stdout: Child Process 2 executed.

The spawn() Method
child_process.spawn method launches a new process with a given command. It has the following signature −

child_process.spawn(command[, args][, options])

Parameters
Here is the description of the parameters used −

command (String) The command to run
args (Array) List of string arguments
options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
stdio (Array) String Child's stdio configuration.
customFds (Array) Deprecated File descriptors for the child to use for stdio.
detached (Boolean) The child will be a process group leader.
uid (Number) Sets the user identity of the process.
gid (Number) Sets the group identity of the process.



The spawn() method returns streams (stdout &stderr) and it should be used when the process returns a volume amount of data. spawn() starts receiving the response as soon as the process starts executing.
Example
Create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');
 
for(var i = 0; i<3; i++) {
   var workerProcess = child_process.spawn('node', ['support.js', i]);

   workerProcess.stdout.on('data', function (data) {
      console.log('stdout: ' + data);
   });

   workerProcess.stderr.on('data', function (data) {
      console.log('stderr: ' + data);
   });

   workerProcess.on('close', function (code) {
      console.log('child process exited with code ' + code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started

stdout: Child Process 0 executed.

child process exited with code 0
stdout: Child Process 1 executed.

stdout: Child Process 2 executed.

child process exited with code 0
child process exited with code 0

The fork() Method
child_process.fork method is a special case of spawn() to create Node processes. It has the following signature −

child_process.fork(modulePath[, args][, options])

Parameters
Here is the description of the parameters used −

modulePath (String) The module to run in the child.
args (Array) List of string arguments
options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
execPath (String) Executable used to create the child process.
execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).
silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.



The fork method returns an object with a built-in communication channel in addition to having all the methods in a normal ChildProcess instance.
Example
Create two js files named support.js and master.js −
File: support.js

console.log(""Child Process "" + process.argv[2] + "" executed."" );

File: master.js

const fs = require('fs');
const child_process = require('child_process');
 
for(var i=0; i<3; i++) {
   var worker_process = child_process.fork(""support.js"", [i]);	

   worker_process.on('close', function (code) {
      console.log('child process exited with code ' + code);
   });
}

Now run the master.js to see the result −

$ node master.js

Verify the Output. Server has started.

Child Process 0 executed.
Child Process 1 executed.
Child Process 2 executed.
child process exited with code 0
child process exited with code 0
child process exited with code 0

Node.js - Packaging
JXcore, which is an open source project, introduces a unique feature for packaging and encryption of source files and other assets into JX packages.
Consider you have a large project consisting of many files. JXcore can pack them all into a single file to simplify the distribution. This chapter provides a quick overview of the whole process starting from installing JXcore.
JXcore Installation
Installing JXcore is quite simple. Here we have provided step-by-step instructions on how to install JXcore on your system. Follow the steps given below −
Step 1
Download the JXcore package from https://github.com/jxcore/jxcore, as per your operating system and machine architecture. We downloaded a package for Cenots running on 64-bit machine.

$ wget https://s3.amazonaws.com/nodejx/jx_rh64.zip

Step 2
Unpack the downloaded file jx_rh64.zipand copy the jx binary into /usr/bin or may be in any other directory based on your system setup.

$ unzip jx_rh64.zip
$ cp jx_rh64/jx /usr/bin

Step 3
Set your PATH variable appropriately to run jx from anywhere you like.

$ export PATH=$PATH:/usr/bin

Step 4
You can verify your installation by issuing a simple command as shown below. You should find it working and printing its version number as follows −

$ jx --version
v0.10.32

Packaging the Code
Consider you have a project with the following directories where you kept all your files including Node.js, main file, index.js, and all the modules installed locally.

drwxr-xr-x  2 root root  4096 Nov 13 12:42 images
-rwxr-xr-x  1 root root 30457 Mar  6 12:19 index.htm
-rwxr-xr-x  1 root root 30452 Mar  1 12:54 index.js
drwxr-xr-x 23 root root  4096 Jan 15 03:48 node_modules
drwxr-xr-x  2 root root  4096 Mar 21 06:10 scripts
drwxr-xr-x  2 root root  4096 Feb 15 11:56 style

To package the above project, you simply need to go inside this directory and issue the following jx command. Assuming index.js is the entry file for your Node.js project −

$ jx package index.js index

Here you could have used any other package name instead of index. We have used index because we wanted to keep our main file name as index.jx. However, the above command will pack everything and will create the following two files −

index.jxp This is an intermediate file which contains the complete project detail needed to compile the project.
index.jx This is the binary file having the complete package that is ready to be shipped to your client or to your production environment.

Launching JX File
Consider your original Node.js project was running as follows −

$ node index.js command_line_arguments

After compiling your package using JXcore, it can be started as follows −

$ jx index.jx command_line_arguments

To know more on JXcore, you can check its official website.




Useful Video Courses








 
Video 
Serverless Development with AWS Lambda and NodeJS

    44 Lectures 
     7.5 hours 
  Eduonix Learning Solutions
 



More Detail













 
Video 
Learn Nodejs by building 10 projects

    88 Lectures 
     17 hours 
  Eduonix Learning Solutions
 



More Detail













 
Video 
Unit Testing and Test Driven Development in NodeJS

    32 Lectures 
     1.5 hours 
  Richard Wells
 



More Detail













 
Video 
Nodejs Crash Course : For Backend Development

    8 Lectures 
     33 mins
  Anant Rungta
 



More Detail













 
Video 
Learn NodeJS Step by Step

    9 Lectures 
     2.5 hours 
  SHIVPRASAD KOIRALA
 



More Detail













 
Video 
Master NodeJs : A Practical Approach To Node JS Most Popular

    97 Lectures 
     6 hours 
  Skillbakerystudios
 



More Detail















 Previous Page
 Print Page


Next Page  




Advertisements






|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started.|||child_process.spawn method launches a new process with a given command. It has the following signature −|||Here is the description of the parameters used −|||command (String) The command to run|||args (Array) List of string arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process.|||env (Object) Environment key-value pairs.|||stdio (Array) String Child's stdio configuration.|||customFds (Array) Deprecated File descriptors for the child to use for stdio.|||detached (Boolean) The child will be a process group leader.|||uid (Number) Sets the user identity of the process.|||gid (Number) Sets the group identity of the process.|||The spawn() method returns streams (stdout &stderr) and it should be used when the process returns a volume amount of data. spawn() starts receiving the response as soon as the process starts executing.|||Create two js files named support.js and master.js −|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started|||child_process.fork method is a special case of spawn() to create Node processes. It has the following signature −|||Here is the description of the parameters used −|||modulePath (String) The module to run in the child.|||args (Array) List of string arguments|||options (Object) may comprise one or more of the following options −|||cwd (String) Current working directory of the child process.|||env (Object) Environment key-value pairs.|||execPath (String) Executable used to create the child process.|||execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).|||silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).|||uid (Number) Sets the user identity of the process. |||gid (Number) Sets the group identity of the process.|||The fork method returns an object with a built-in communication channel in addition to having all the methods in a normal ChildProcess instance.|||Create two js files named support.js and master.js −|||File: support.js|||File: master.js|||Now run the master.js to see the result −|||Verify the Output. Server has started.|||JXcore, which is an open source project, introduces a unique feature for packaging and encryption of source files and other assets into JX packages.|||Consider you have a large project consisting of many files. JXcore can pack them all into a single file to simplify the distribution. This chapter provides a quick overview of the whole process starting from installing JXcore.|||Installing JXcore is quite simple. Here we have provided step-by-step instructions on how to install JXcore on your system. Follow the steps given below −|||Download the JXcore package from https://github.com/jxcore/jxcore, as per your operating system and machine architecture. We downloaded a package for Cenots running on 64-bit machine.|||Unpack the downloaded file jx_rh64.zipand copy the jx binary into /usr/bin or may be in any other directory based on your system setup.|||Set your PATH variable appropriately to run jx from anywhere you like.|||You can verify your installation by issuing a simple command as shown below. You should find it working and printing its version number as follows −|||Consider you have a project with the following directories where you kept all your files including Node.js, main file, index.js, and all the modules installed locally.|||To package the above project, you simply need to go inside this directory and issue the following jx command. Assuming index.js is the entry file for your Node.js project −|||Here you could have used any other package name instead of index. We have used index because we wanted to keep our main file name as index.jx. However, the above command will pack everything and will create the following two files −|||index.jxp This is an intermediate file which contains the complete project detail needed to compile the project.|||index.jx This is the binary file having the complete package that is ready to be shipped to your client or to your production environment.|||Consider your original Node.js project was running as follows −|||After compiling your package using JXcore, it can be started as follows −|||To know more on JXcore, you can check its official website.","Asynchronous and Event Driven − All APIs of Node.js library are asynchronous, that is, non-blocking. It essentially means a Node.js based server never waits for an API to return data. The server moves to the next API after calling it and a notification mechanism of Events of Node.js helps the server to get a response from the previous API call.@@@Very Fast − Being built on Google Chrome's V8 JavaScript Engine, Node.js library is very fast in code execution.@@@Single Threaded but Highly Scalable − Node.js uses a single threaded model with event looping. Event mechanism helps the server to respond in a non-blocking way and makes the server highly scalable as opposed to traditional servers which create limited threads to handle requests. Node.js uses a single threaded program and the same program can provide service to a much larger number of requests than traditional servers like Apache HTTP Server.@@@No Buffering − Node.js applications never buffer any data. These applications simply output the data in chunks.@@@License − Node.js is released under the MIT license.|||Projects, Applications, and Companies Using Node|||I/O bound Applications@@@Data Streaming Applications@@@Data Intensive Real-time Applications (DIRT)@@@JSON APIs based Applications@@@Single Page Applications|||Import required modules − We use the require directive to load Node.js modules.@@@Create server − A server which will listen to client's requests similar to Apache HTTP Server.@@@Read request and return response − The server created in an earlier step will read the HTTP request made by the client which can be a browser or a console and return the response.|||Read − Reads user's input, parses the input into JavaScript data-structure, and stores in memory.@@@Eval − Takes and evaluates the data structure.@@@Print − Prints the result.@@@Loop − Loops the above command until the user presses ctrl-c twice.|||ctrl + c − terminate the current command.@@@ctrl + c twice − terminate the Node REPL.@@@ctrl + d − terminate the Node REPL.@@@Up/Down Keys − see command history and modify previous commands.@@@tab Keys − list of current commands.@@@.help − list of all commands.@@@.break − exit from multiline expression.@@@.clear − exit from multiline expression.@@@.save filename − save the current Node REPL session to a file.@@@.load filename − load file content in current Node REPL session.|||Online repositories for node.js packages/modules which are searchable on search.nodejs.org@@@Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.|||name − name of the package@@@version − version of the package@@@description − description of the package@@@homepage − homepage of the package@@@author − author of the package@@@contributors − name of the contributors to the package@@@dependencies − list of dependencies. NPM automatically installs all the dependencies mentioned here in the node_module folder of the package.@@@repository − repository type and URL of the package@@@main − entry point of the package@@@keywords − keywords|||The first example shows that the program blocks until it reads the file and then only it proceeds to end the program.@@@The second example shows that the program does not wait for file reading and proceeds to print ""Program Ended"" and at the same time, the program without blocking continues reading the file.|||string − This is the string data to be written to buffer.@@@offset − This is the index of the buffer to start writing at. Default value is 0.@@@length − This is the number of bytes to write. Defaults to buffer.length.@@@encoding − Encoding to use. 'utf8' is the default encoding.|||encoding − Encoding to use. 'utf8' is the default encoding.@@@start − Beginning index to start reading, defaults to 0.@@@end − End index to end reading, defaults is complete buffer.|||list − Array List of Buffer objects to be concatenated.@@@totalLength − This is the total length of the buffers when concatenated.|||otherBuffer − This is the other buffer which will be compared with buf|||targetBuffer − Buffer object where buffer will be copied.@@@targetStart − Number, Optional, Default: 0@@@sourceStart − Number, Optional, Default: 0@@@sourceEnd − Number, Optional, Default: buffer.length|||start − Number, Optional, Default: 0@@@end − Number, Optional, Default: buffer.length|||Readable − Stream which is used for read operation.@@@Writable − Stream which is used for write operation.@@@Duplex − Stream which can be used for both read and write operation.@@@Transform − A type of duplex stream where the output is computed based on input.|||data − This event is fired when there is data is available to read.@@@end − This event is fired when there is no more data to read.@@@error − This event is fired when there is any error receiving or writing data.@@@finish − This event is fired when all the data has been flushed to underlying system.|||path − This is the string having file name including path.@@@flags − Flags indicate the behavior of the file to be opened. All possible values have been mentioned below.@@@mode − It sets the file mode (permission and sticky bits), but only if the file was created. It defaults to 0666, readable and writeable.@@@callback − This is the callback function which gets two arguments (err, fd).|||path − This is the string having file name including path.@@@callback − This is the callback function which gets two arguments (err, stats) where stats is an object of fs.Stats type which is printed below in the example.|||path − This is the string having the file name including path.@@@data − This is the  String or Buffer to be written into the file.@@@options − The third parameter is an object which will hold {encoding, mode, flag}. By default. encoding is utf8, mode is octal value 0666. and flag is 'w'@@@callback − This is the callback function which gets a single parameter err that returns an error in case of any writing error.|||fd − This is the file descriptor returned by fs.open().@@@buffer − This is the buffer that the data will be written to.@@@offset − This is the offset in the buffer to start writing at.@@@length − This is an integer specifying the number of bytes to read.@@@position − This is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.@@@callback − This is the callback function which gets the three arguments, (err, bytesRead, buffer).|||fd − This is the file descriptor returned by file fs.open() method.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||fd − This is the file descriptor returned by fs.open().@@@len − This is the length of the file after which the file will be truncated.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the file name including path.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the directory name including path.@@@mode − This is the directory permission to be set. Defaults to 0777.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||path − This is the directory name including path.@@@callback − This is the callback function which gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.|||path − This is the directory name including path.@@@callback − This is the callback function No arguments other than a possible exception are given to the completion callback.|||Client − This layer consists of web browsers, mobile browsers or applications which can make HTTP requests to the web server.@@@Server − This layer has the Web server which can intercept the requests made by the clients and pass them the response.@@@Business − This layer contains the application server which is utilized by the web server to do the required processing. This layer interacts with the data layer via the database or some external programs.@@@Data − This layer contains the databases or any other source of data.|||Allows to set up middlewares to respond to HTTP Requests.@@@Defines a routing table which is used to perform different actions based on HTTP Method and URL.@@@Allows to dynamically render HTML Pages based on passing arguments to templates.|||body-parser − This is a node.js middleware for handling JSON, Raw, Text and URL encoded form data.@@@cookie-parser − Parse Cookie header and populate req.cookies with an object keyed by the cookie names.@@@multer − This is a node.js middleware for handling multipart/form-data.|||Request Object − The request object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.@@@Response Object − The response object represents the HTTP response that an Express app sends when it gets an HTTP request.|||GET − This is used to provide a read only access to a resource.@@@PUT − This is used to create a new resource.@@@DELETE − This is used to remove a resource.@@@POST − This is used to update a existing resource or create a new resource.|||exec − child_process.exec method runs a command in a shell/console and buffers the output.@@@spawn − child_process.spawn launches a new process with a given command.@@@fork − The child_process.fork method is a special case of the spawn() to create child processes.|||command (String) The command to run, with space-separated arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process
env (Object) Environment key-value pairs
encoding (String) (Default: 'utf8')
shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)
timeout (Number) (Default: 0)
maxBuffer (Number) (Default: 200*1024)
killSignal (String) (Default: 'SIGTERM')
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process@@@env (Object) Environment key-value pairs@@@encoding (String) (Default: 'utf8')@@@shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)@@@timeout (Number) (Default: 0)@@@maxBuffer (Number) (Default: 200*1024)@@@killSignal (String) (Default: 'SIGTERM')@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.@@@callback The function gets three arguments error, stdout, and stderr which are called with the output when the process terminates.|||cwd (String) Current working directory of the child process@@@env (Object) Environment key-value pairs@@@encoding (String) (Default: 'utf8')@@@shell (String) Shell to execute the command with (Default: '/bin/sh' on UNIX, 'cmd.exe' on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)@@@timeout (Number) (Default: 0)@@@maxBuffer (Number) (Default: 200*1024)@@@killSignal (String) (Default: 'SIGTERM')@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.|||command (String) The command to run@@@args (Array) List of string arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
stdio (Array) String Child's stdio configuration.
customFds (Array) Deprecated File descriptors for the child to use for stdio.
detached (Boolean) The child will be a process group leader.
uid (Number) Sets the user identity of the process.
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@stdio (Array) String Child's stdio configuration.@@@customFds (Array) Deprecated File descriptors for the child to use for stdio.@@@detached (Boolean) The child will be a process group leader.@@@uid (Number) Sets the user identity of the process.@@@gid (Number) Sets the group identity of the process.|||cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@stdio (Array) String Child's stdio configuration.@@@customFds (Array) Deprecated File descriptors for the child to use for stdio.@@@detached (Boolean) The child will be a process group leader.@@@uid (Number) Sets the user identity of the process.@@@gid (Number) Sets the group identity of the process.|||modulePath (String) The module to run in the child.@@@args (Array) List of string arguments@@@options (Object) may comprise one or more of the following options −

cwd (String) Current working directory of the child process.
env (Object) Environment key-value pairs.
execPath (String) Executable used to create the child process.
execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).
silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).
uid (Number) Sets the user identity of the process. 
gid (Number) Sets the group identity of the process.

@@@cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@execPath (String) Executable used to create the child process.@@@execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).@@@silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.|||cwd (String) Current working directory of the child process.@@@env (Object) Environment key-value pairs.@@@execPath (String) Executable used to create the child process.@@@execArgv (Array) List of string arguments passed to the executable (Default: process.execArgv).@@@silent (Boolean) If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the ""pipe"" and ""inherit"" options for spawn()'s stdio for more details (default is false).@@@uid (Number) Sets the user identity of the process. @@@gid (Number) Sets the group identity of the process.|||index.jxp This is an intermediate file which contains the complete project detail needed to compile the project.@@@index.jx This is the binary file having the complete package that is ready to be shipped to your client or to your production environment.",,"OS@@@Archive name|||Windows@@@node-v6.3.1-x64.msi|||Linux@@@node-v6.3.1-linux-x86.tar.gz|||Mac@@@node-v6.3.1-darwin-x86.tar.gz|||SunOS@@@node-v6.3.1-sunos-x86.tar.gz&&&OS@@@Output|||Linux@@@export PATH=$PATH:/usr/local/nodejs/bin|||Mac@@@export PATH=$PATH:/usr/local/nodejs/bin|||FreeBSD@@@export PATH=$PATH:/usr/local/nodejs/bin&&&Sr.No.@@@Method & Description|||1@@@
addListener(event, listener)
Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.
|||2@@@
on(event, listener)
Adds a listener at the end of the listeners array for the specified event. No checks are made to see if the listener has already been added. Multiple calls passing the same combination of event and listener will result in the listener being added multiple times. Returns emitter, so calls can be chained.
|||3@@@once(event, listener)
Adds a one time listener to the event. This listener is invoked only the next time the event is fired, after which it is removed. Returns emitter, so calls can be chained.
|||4@@@
removeListener(event, listener)
Removes a listener from the listener array for the specified event. Caution − It changes the array indices in the listener array behind the listener. removeListener will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified event, then removeListener must be called multiple times to remove each instance. Returns emitter, so calls can be chained.
|||5@@@
removeAllListeners([event])
Removes all listeners, or those of the specified event. It's not a good idea to remove listeners that were added elsewhere in the code, especially when it's on an emitter that you didn't create (e.g. sockets or file streams). Returns emitter, so calls can be chained.
|||6@@@
setMaxListeners(n)
By default, EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited.
|||7@@@
listeners(event)
Returns an array of listeners for the specified event.
|||8@@@
emit(event, [arg1], [arg2], [...])
Execute each of the listeners in order with the supplied arguments. Returns true if the event had listeners, false otherwise.
&&&Sr.No.@@@Method & Description|||1@@@
listenerCount(emitter, event)
Returns the number of listeners for a given event.
&&&Sr.No.@@@Events & Description|||1@@@newListener

event − String: the event name
listener − Function: the event handler function

This event is emitted any time a listener is added. When this event is triggered, the listener may not yet have been added to the array of listeners for the event.
|||2@@@
removeListener

event − String The event name
listener − Function The event handler function

This event is emitted any time someone removes a listener. When this event is triggered, the listener may not yet have been removed from the array of listeners for the event.
&&&Sr.No.@@@Method & Description|||1@@@
new Buffer(size)
Allocates a new buffer of size octets. Note that the size must be no more than kMaxLength. Otherwise, a RangeError will be thrown here.
|||2@@@
new Buffer(buffer)
Copies the passed buffer data onto a new Buffer instance.
|||3@@@
new Buffer(str[, encoding])
Allocates a new buffer containing the given str. encoding defaults to 'utf8'.
|||4@@@
buf.length
Returns the size of the buffer in bytes. Note that this is not necessarily the size of the contents. length refers to the amount of memory allocated for the buffer object. It does not change when the contents of the buffer are changed.
|||5@@@
buf.write(string[, offset][, length][, encoding])
Writes a string to the buffer at offset using the given encoding. offset defaults to 0, encoding defaults to 'utf8'. length is the number of bytes to write. Returns the number of octets written.
|||6@@@
buf.writeUIntLE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||7@@@
buf.writeUIntBE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||8@@@
buf.writeIntLE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||9@@@
buf.writeIntBE(value, offset, byteLength[, noAssert])
Writes a value to the buffer at the specified offset and byteLength. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of value and offset. Defaults to false.
|||10@@@
buf.readUIntLE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||11@@@
buf.readUIntBE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||12@@@
buf.readIntLE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||13@@@
buf.readIntBE(offset, byteLength[, noAssert])
A generalized version of all numeric read methods. Supports up to 48 bits of accuracy. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||14@@@
buf.toString([encoding][, start][, end])
Decodes and returns a string from buffer data encoded using the specified character set encoding.
|||15@@@
buf.toJSON()
Returns a JSON-representation of the Buffer instance. JSON.stringify implicitly calls this function when stringifying a Buffer instance.
|||16@@@
buf[index]
Get and set the octet at index. The values refer to individual bytes, so the legal range is between 0x00 and 0xFF hex or 0 and 255.
|||17@@@
buf.equals(otherBuffer)
Returns a boolean if this buffer and otherBuffer have the same bytes.
|||18@@@
buf.compare(otherBuffer)
Returns a number indicating whether this buffer comes before or after or is the same as the otherBuffer in sort order.
|||19@@@
buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])
Copies data from a region of this buffer to a region in the target buffer even if the target memory region overlaps with the source. If undefined, the targetStart and sourceStart parameters default to 0, while sourceEnd defaults to buffer.length.
|||20@@@
buf.slice([start][, end])
Returns a new buffer which references the same memory as the old, but offset and cropped by the start (defaults to 0) and end (defaults to buffer.length) indexes. Negative indexes start from the end of the buffer.
|||21@@@
buf.readUInt8(offset[, noAssert])
Reads an unsigned 8 bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means that the offset may be beyond the end of the buffer. Defaults to false.
|||22@@@
buf.readUInt16LE(offset[, noAssert])
Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||23@@@
buf.readUInt16BE(offset[, noAssert])
Reads an unsigned 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||24@@@
buf.readUInt32LE(offset[, noAssert])
Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||25@@@
buf.readUInt32BE(offset[, noAssert])
Reads an unsigned 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||26@@@
buf.readInt8(offset[, noAssert])
Reads a signed 8-bit integer from the buffer at the specified offset. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||27@@@
buf.readInt16LE(offset[, noAssert])
Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||28@@@
buf.readInt16BE(offset[, noAssert])
Reads a signed 16-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||29@@@
buf.readInt32LE(offset[, noAssert])
Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||30@@@
buf.readInt32BE(offset[, noAssert])
Reads a signed 32-bit integer from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||31@@@
buf.readFloatLE(offset[, noAssert])
Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||32@@@
buf.readFloatBE(offset[, noAssert])
Reads a 32-bit float from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||33@@@
buf.readDoubleLE(offset[, noAssert])
Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||34@@@
buf.readDoubleBE(offset[, noAssert])
Reads a 64-bit double from the buffer at the specified offset with the specified endian format. Set noAssert to true to skip validation of offset. It means the offset may be beyond the end of the buffer. Defaults to false.
|||35@@@
buf.writeUInt8(value, offset[, noAssert])
Writes a value to the buffer at the specified offset. Note that the value must be a valid unsigned 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||36@@@
buf.writeUInt16LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.
|||37@@@
buf.writeUInt16BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||38@@@
buf.writeUInt32LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||39@@@
buf.writeUInt32BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid unsigned 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||40@@@
buf.writeInt8(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 8-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||41@@@
buf.writeInt16LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||42@@@
buf.writeInt16BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 16-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||43@@@
buf.writeInt32LE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.|||44@@@
buf.writeInt32BE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid signed 32-bit integer. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of correctness. Defaults to false.
|||45@@@
buf.writeFloatLE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note that the value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means that the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||46@@@
buf.writeFloatBE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 32-bit float. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||47@@@
buf.writeDoubleLE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means that value may be too large for the specific function and offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||48@@@
buf.writeDoubleBE(value, offset[, noAssert])
Writes a value to the buffer at the specified offset with the specified endian format. Note, value must be a valid 64-bit double. Set noAssert to true to skip validation of value and offset. It means the value may be too large for the specific function and the offset may be beyond the end of the buffer leading to the values being silently dropped. It should not be used unless you are certain of its correctness. Defaults to false.
|||49@@@
buf.fill(value[, offset][, end])
Fills the buffer with the specified value. If the offset (defaults to 0) and end (defaults to buffer.length) are not given, it will fill the entire buffer.
&&&Sr.No.@@@Method & Description|||1@@@
Buffer.isEncoding(encoding)
Returns true if the encoding is a valid encoding argument, false otherwise.
|||2@@@
Buffer.isBuffer(obj)
Tests if obj is a Buffer.
|||3@@@
Buffer.byteLength(string[, encoding])
Gives the actual byte length of a string. encoding defaults to 'utf8'. It is not the same as String.prototype.length, since String.prototype.length returns the number of characters in a string.
|||4@@@
Buffer.concat(list[, totalLength])
Returns a buffer which is the result of concatenating all the buffers in the list together.
|||5@@@
Buffer.compare(buf1, buf2)
The same as buf1.compare(buf2). Useful for sorting an array of buffers.
&&&Sr.No.@@@Flag & Description|||1@@@
r
Open file for reading. An exception occurs if the file does not exist.|||2@@@
r+
Open file for reading and writing. An exception occurs if the file does not exist.|||3@@@
rs
Open file for reading in synchronous mode.|||4@@@
rs+
Open file for reading and writing, asking the OS to open it synchronously. See notes for 'rs' about using this with caution.|||5@@@
w
Open file for writing. The file is created (if it does not exist) or truncated (if it exists).|||6@@@
wx
Like 'w' but fails if the path exists.|||7@@@
w+
Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).|||8@@@
wx+
Like 'w+' but fails if path exists.|||9@@@
a
Open file for appending. The file is created if it does not exist.|||10@@@
ax
Like 'a' but fails if the path exists.|||11@@@
a+
Open file for reading and appending. The file is created if it does not exist.|||12@@@
ax+
Like 'a+' but fails if the the path exists.&&&Sr.No.@@@Method & Description|||1@@@
stats.isFile()
Returns true if file type of a simple file.|||2@@@
stats.isDirectory()
Returns true if file type of a directory.|||3@@@
stats.isBlockDevice()
Returns true if file type of a block device.|||4@@@
stats.isCharacterDevice()
Returns true if file type of a character device.|||5@@@
stats.isSymbolicLink()
Returns true if file type of a symbolic link.|||6@@@
stats.isFIFO()
Returns true if file type of a FIFO.|||7@@@
stats.isSocket()
Returns true if file type of asocket.&&&Sr.No@@@Method & Description|||1@@@
fs.rename(oldPath, newPath, callback)
Asynchronous rename(). No arguments other than a possible exception are given to the completion callback.
|||2@@@
fs.ftruncate(fd, len, callback)
Asynchronous ftruncate(). No arguments other than a possible exception are given to the completion callback.
|||3@@@
fs.ftruncateSync(fd, len)
Synchronous ftruncate().
|||4@@@
fs.truncate(path, len, callback)
Asynchronous truncate(). No arguments other than a possible exception are given to the completion callback.
|||5@@@
fs.truncateSync(path, len)
Synchronous truncate().
|||6@@@
fs.chown(path, uid, gid, callback)
Asynchronous chown(). No arguments other than a possible exception are given to the completion callback.
|||7@@@
fs.chownSync(path, uid, gid)
Synchronous chown().
|||8@@@
fs.fchown(fd, uid, gid, callback)
Asynchronous fchown(). No arguments other than a possible exception are given to the completion callback.
|||9@@@
fs.fchownSync(fd, uid, gid)
Synchronous fchown().
|||10@@@
fs.lchown(path, uid, gid, callback)
Asynchronous lchown(). No arguments other than a possible exception are given to the completion callback.
|||11@@@
fs.lchownSync(path, uid, gid)
Synchronous lchown().
|||12@@@
fs.chmod(path, mode, callback)
Asynchronous chmod(). No arguments other than a possible exception are given to the completion callback.
|||13@@@
fs.chmodSync(path, mode)
Synchronous chmod().
|||14@@@
fs.fchmod(fd, mode, callback)
Asynchronous fchmod(). No arguments other than a possible exception are given to the completion callback.
|||15@@@
fs.fchmodSync(fd, mode)
Synchronous fchmod().
|||16@@@
fs.lchmod(path, mode, callback)
Asynchronous lchmod(). No arguments other than a possible exception are given to the completion callback. Only available on Mac OS X.
|||17@@@
fs.lchmodSync(path, mode)
Synchronous lchmod().
|||18@@@
fs.stat(path, callback)
Asynchronous stat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object.
|||19@@@
fs.lstat(path, callback)
Asynchronous lstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to.
|||20@@@
fs.fstat(fd, callback)
Asynchronous fstat(). The callback gets two arguments (err, stats) where stats is an fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd.
|||21@@@
fs.statSync(path)
Synchronous stat(). Returns an instance of fs.Stats.
|||22@@@
fs.lstatSync(path)
Synchronous lstat(). Returns an instance of fs.Stats.
|||23@@@
fs.fstatSync(fd)
Synchronous fstat(). Returns an instance of fs.Stats.
|||24@@@
fs.link(srcpath, dstpath, callback)
Asynchronous link(). No arguments other than a possible exception are given to the completion callback.
|||25@@@
fs.linkSync(srcpath, dstpath)
Synchronous link().
|||26@@@
fs.symlink(srcpath, dstpath[, type], callback)
Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.
|||27@@@
fs.symlinkSync(srcpath, dstpath[, type])
Synchronous symlink().
|||28@@@
fs.readlink(path, callback)
Asynchronous readlink(). The callback gets two arguments (err, linkString).
|||29@@@
fs.realpath(path[, cache], callback)
Asynchronous realpath(). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths.
|||30@@@
fs.realpathSync(path[, cache])
Synchronous realpath(). Returns the resolved path.
|||31@@@
fs.unlink(path, callback)
Asynchronous unlink(). No arguments other than a possible exception are given to the completion callback.
|||32@@@
fs.unlinkSync(path)
Synchronous unlink().
|||33@@@
fs.rmdir(path, callback)
Asynchronous rmdir(). No arguments other than a possible exception are given to the completion callback.
|||34@@@
fs.rmdirSync(path)
Synchronous rmdir().
|||35@@@
fs.mkdir(path[, mode], callback)
Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777.
|||36@@@
fs.mkdirSync(path[, mode])
Synchronous mkdir().
|||37@@@
fs.readdir(path, callback)
Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'.
|||38@@@
fs.readdirSync(path)
Synchronous readdir(). Returns an array of filenames excluding '.' and '..'.
|||39@@@
fs.close(fd, callback)
Asynchronous close(). No arguments other than a possible exception are given to the completion callback.
|||40@@@
fs.closeSync(fd)
Synchronous close().
|||41@@@
fs.open(path, flags[, mode], callback)
Asynchronous file open.
|||42@@@
fs.openSync(path, flags[, mode])
Synchronous version of fs.open().
|||43@@@
fs.utimes(path, atime, mtime, callback)
 
|||44@@@
fs.utimesSync(path, atime, mtime)
Change file timestamps of the file referenced by the supplied path.
|||45@@@
fs.futimes(fd, atime, mtime, callback)
 
|||46@@@
fs.futimesSync(fd, atime, mtime)
Change the file timestamps of a file referenced by the supplied file descriptor.
|||47@@@
fs.fsync(fd, callback)
Asynchronous fsync. No arguments other than a possible exception are given to the completion callback.
|||48@@@
fs.fsyncSync(fd)
Synchronous fsync.
|||49@@@
fs.write(fd, buffer, offset, length[, position], callback)
Write buffer to the file specified by fd.
|||50@@@
fs.write(fd, data[, position[, encoding]], callback)
Write data to the file specified by fd. If data is not a Buffer instance then the value will be coerced to a string.
|||51@@@
fs.writeSync(fd, buffer, offset, length[, position])
Synchronous versions of fs.write(). Returns the number of bytes written.
|||52@@@
fs.writeSync(fd, data[, position[, encoding]])
Synchronous versions of fs.write(). Returns the number of bytes written.
|||53@@@
fs.read(fd, buffer, offset, length, position, callback)
Read data from the file specified by fd.
|||54@@@
fs.readSync(fd, buffer, offset, length, position)
Synchronous version of fs.read. Returns the number of bytesRead.
|||55@@@
fs.readFile(filename[, options], callback)
Asynchronously reads the entire contents of a file.
|||56@@@
fs.readFileSync(filename[, options])
Synchronous version of fs.readFile. Returns the contents of the filename.
|||57@@@
fs.writeFile(filename, data[, options], callback)
Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.
|||58@@@
fs.writeFileSync(filename, data[, options])
The synchronous version of fs.writeFile.
|||59@@@
fs.appendFile(filename, data[, options], callback)
Asynchronously append data to a file, creating the file if it does not exist. data can be a string or a buffer.
|||60@@@
fs.appendFileSync(filename, data[, options])
The synchronous version of fs.appendFile.
|||61@@@
fs.watchFile(filename[, options], listener)
Watch for changes on filename. The callback listener will be called each time the file is accessed.
|||62@@@
fs.unwatchFile(filename[, listener])
Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename.
|||63@@@
fs.watch(filename[, options][, listener])
Watch for changes on filename, where filename is either a file or an directory. The returned object is an fs.FSWatcher.
|||64@@@
fs.exists(path, callback)
Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false.
|||65@@@
fs.existsSync(path)
Synchronous version of fs.exists.
|||66@@@
fs.access(path[, mode], callback)
Tests a user's permissions for the file specified by path. mode is an optional integer that specifies the accessibility checks to be performed.
|||67@@@
fs.accessSync(path[, mode])
Synchronous version of fs.access. It throws if any accessibility checks fail, and does nothing otherwise.
|||68@@@
fs.createReadStream(path[, options])
Returns a new ReadStream object.
|||69@@@
fs.createWriteStream(path[, options])
Returns a new WriteStream object.
|||70@@@
fs.symlink(srcpath, dstpath[, type], callback)
Asynchronous symlink(). No arguments other than a possible exception are given to the completion callback. The type argument can be set to 'dir', 'file', or 'junction' (default is 'file') and is only available on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path.
&&&Sr.No.@@@Module Name & Description|||1@@@Console
 Used to print information on stdout and stderr.
|||2@@@Process
Used to get information on current process. Provides multiple events related to process activities.
&&&Sr.No.@@@Module Name & Description|||1@@@OS Module
Provides basic operating-system related utility functions.
|||2@@@Path Module
Provides utilities for handling and transforming file paths.
|||3@@@Net Module
Provides both servers and clients as streams. Acts as a network wrapper.
|||4@@@DNS Module
Provides functions to do actual DNS lookup as well as to use underlying operating system name resolution functionalities.
|||5@@@Domain Module
Provides ways to handle multiple different I/O operations as a single group.
&&&Sr.No.@@@URI@@@HTTP Method@@@POST body@@@Result|||1@@@listUsers@@@GET@@@empty@@@Show list of all the users.|||2@@@addUser@@@POST@@@JSON String@@@Add details of new user.|||3@@@deleteUser@@@DELETE@@@JSON String@@@Delete an existing user.|||4@@@:id@@@GET@@@empty@@@Show details of a user.","/* Hello World! program in Node.js */console.log(""Hello World!"");|||/* Hello, World! program in node.js */console.log(""Hello, World!"")|||$ node main.js|||http.createServer(function (request, response) {   // Send the HTTP header    // HTTP Status: 200 : OK   // Content Type: text/plain   response.writeHead(200, {'Content-Type': 'text/plain'});      // Send the response body as ""Hello World""   response.end('Hello World\n');}).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||var http = require(""http"");http.createServer(function (request, response) {   // Send the HTTP header    // HTTP Status: 200 : OK   // Content Type: text/plain   response.writeHead(200, {'Content-Type': 'text/plain'});      // Send the response body as ""Hello World""   response.end('Hello World\n');}).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||$ node main.js|||{   ""name"": ""express"",      ""description"": ""Fast, unopinionated, minimalist web framework"",      ""version"": ""4.11.2"",      ""author"": {               ""name"": ""TJ Holowaychuk"",         ""email"": ""tj@vision-media.ca""      },      ""contributors"": [{      ""name"": ""Aaron Heckmann"",      ""email"": ""aaron.heckmann+github@gmail.com""   },       {      ""name"": ""Ciaran Jessup"",      ""email"": ""ciaranj@gmail.com""   },      {      ""name"": ""Douglas Christopher Wilson"",      ""email"": ""doug@somethingdoug.com""   },      {      ""name"": ""Guillermo Rauch"",      ""email"": ""rauchg@gmail.com""   },      {      ""name"": ""Jonathan Ong"",      ""email"": ""me@jongleberry.com""   },      {      ""name"": ""Roman Shtylman"",      ""email"": ""shtylman+expressjs@gmail.com""   },      {      ""name"": ""Young Jae Sim"",      ""email"": ""hanul@hanul.me""   } ],      ""license"": ""MIT"", ""repository"": {      ""type"": ""git"",      ""url"": ""https://github.com/strongloop/express""   },      ""homepage"": ""https://expressjs.com/"", ""keywords"": [      ""express"",      ""framework"",      ""sinatra"",      ""web"",      ""rest"",      ""restful"",      ""router"",      ""app"",      ""api""   ],      ""dependencies"": {      ""accepts"": ""~1.2.3"",      ""content-disposition"": ""0.5.0"",      ""cookie-signature"": ""1.0.5"",      ""debug"": ""~2.1.1"",      ""depd"": ""~1.0.0"",      ""escape-html"": ""1.0.1"",      ""etag"": ""~1.5.1"",      ""finalhandler"": ""0.3.3"",      ""fresh"": ""0.2.4"",      ""media-typer"": ""0.3.0"",      ""methods"": ""~1.1.1"",      ""on-finished"": ""~2.2.0"",      ""parseurl"": ""~1.3.0"",      ""path-to-regexp"": ""0.1.3"",      ""proxy-addr"": ""~1.0.6"",      ""qs"": ""2.3.3"",      ""range-parser"": ""~1.0.2"",      ""send"": ""0.11.1"",      ""serve-static"": ""~1.8.1"",      ""type-is"": ""~1.5.6"",      ""vary"": ""~1.0.0"",      ""cookie"": ""0.1.2"",      ""merge-descriptors"": ""0.0.2"",      ""utils-merge"": ""1.0.0""   },      ""devDependencies"": {      ""after"": ""0.8.1"",      ""ejs"": ""2.1.4"",      ""istanbul"": ""0.3.5"",      ""marked"": ""0.3.3"",      ""mocha"": ""~2.1.0"",      ""should"": ""~4.6.2"",      ""supertest"": ""~0.15.0"",      ""hjs"": ""~0.0.6"",      ""body-parser"": ""~1.11.0"",      ""connect-redis"": ""~2.2.0"",      ""cookie-parser"": ""~1.3.3"",      ""express-session"": ""~1.10.2"",      ""jade"": ""~1.9.1"",      ""method-override"": ""~2.3.1"",      ""morgan"": ""~1.5.1"",      ""multiparty"": ""~4.1.1"",      ""vhost"": ""~3.0.0""   },      ""engines"": {      ""node"": "">= 0.10.0""   },      ""files"": [      ""LICENSE"",      ""History.md"",      ""Readme.md"",      ""index.js"",      ""lib/""   ],      ""scripts"": {      ""test"": ""mocha --require test/support/env          --reporter spec --bail --check-leaks test/ test/acceptance/"",      ""test-cov"": ""istanbul cover node_modules/mocha/bin/_mocha          -- --require test/support/env --reporter dot --check-leaks test/ test/acceptance/"",      ""test-tap"": ""mocha --require test/support/env          --reporter tap --check-leaks test/ test/acceptance/"",      ""test-travis"": ""istanbul cover node_modules/mocha/bin/_mocha          --report lcovonly -- --require test/support/env          --reporter spec --check-leaks test/ test/acceptance/""   },      ""gitHead"": ""63ab25579bda70b4927a179b580a9c580b6c7ada"",   ""bugs"": {      ""url"": ""https://github.com/strongloop/express/issues""   },      ""_id"": ""express@4.11.2"",   ""_shasum"": ""8df3d5a9ac848585f00a0777601823faecd3b148"",   ""_from"": ""express@*"",   ""_npmVersion"": ""1.4.28"",   ""_npmUser"": {      ""name"": ""dougwilson"",      ""email"": ""doug@somethingdoug.com""   },      ""maintainers"": [{      ""name"": ""tjholowaychuk"",      ""email"": ""tj@vision-media.ca""   },      {      ""name"": ""jongleberry"",      ""email"": ""jonathanrichardong@gmail.com""   },      {      ""name"": ""shtylman"",      ""email"": ""shtylman@gmail.com""   },      {      ""name"": ""dougwilson"",      ""email"": ""doug@somethingdoug.com""   },      {      ""name"": ""aredridel"",      ""email"": ""aredridel@nbtsc.org""   },      {      ""name"": ""strongloop"",      ""email"": ""callback@strongloop.com""   },      {      ""name"": ""rfeng"",      ""email"": ""enjoyjava@gmail.com""   }],      ""dist"": {      ""shasum"": ""8df3d5a9ac848585f00a0777601823faecd3b148"",      ""tarball"": ""https://registry.npmjs.org/express/-/express-4.11.2.tgz""   },      ""directories"": {},      ""_resolved"": ""https://registry.npmjs.org/express/-/express-4.11.2.tgz"",      ""readme"": ""ERROR: No README data found!""}|||var fs = require(""fs"");var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(""Program Ended"");|||Tutorials Point is giving self learning contentto teach the world in simple and easy way!!!!!|||var fs = require(""fs"");fs.readFile('input.txt', function (err, data) {   if (err) return console.error(err);   console.log(data.toString());});console.log(""Program Ended"");|||// Import events modulevar events = require('events');// Create an eventEmitter objectvar eventEmitter = new events.EventEmitter();// Create an event handler as followsvar connectHandler = function connected() {   console.log('connection succesful.');     // Fire the data_received event    eventEmitter.emit('data_received');}// Bind the connection event with the handlereventEmitter.on('connection', connectHandler); // Bind the data_received event with the anonymous functioneventEmitter.on('data_received', function() {   console.log('data received succesfully.');});// Fire the connection event eventEmitter.emit('connection');console.log(""Program Ended."");|||Tutorials Point is giving self learning contentto teach the world in simple and easy way!!!!!|||var fs = require(""fs"");fs.readFile('input.txt', function (err, data) {   if (err) {      console.log(err.stack);      return;   }   console.log(data.toString());});console.log(""Program Ended"");|||var events = require('events');var eventEmitter = new events.EventEmitter();// listener #1var listner1 = function listner1() {   console.log('listner1 executed.');}// listener #2var listner2 = function listner2() {   console.log('listner2 executed.');}// Bind the connection event with the listner1 functioneventEmitter.addListener('connection', listner1);// Bind the connection event with the listner2 functioneventEmitter.on('connection', listner2);var eventListeners = require('events').EventEmitter.listenerCount   (eventEmitter,'connection');console.log(eventListeners + "" Listner(s) listening to connection event"");// Fire the connection event eventEmitter.emit('connection');// Remove the binding of listner1 functioneventEmitter.removeListener('connection', listner1);console.log(""Listner1 will not listen now."");// Fire the connection event eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + "" Listner(s) listening to connection event"");console.log(""Program Ended."");|||buf = new Buffer(256);len = buf.write(""Simply Easy Learning"");console.log(""Octets written : ""+  len);|||buf = new Buffer(26);for (var i = 0 ; i < 26 ; i++) {  buf[i] = i + 97;}console.log( buf.toString('ascii'));       // outputs: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5));   // outputs: abcdeconsole.log( buf.toString('utf8',0,5));    // outputs: abcdeconsole.log( buf.toString(undefined,0,5)); // encoding defaults to 'utf8', outputs abcde|||var buf = new Buffer('Simply Easy Learning');var json = buf.toJSON(buf);console.log(json);|||var buffer1 = new Buffer('TutorialsPoint ');var buffer2 = new Buffer('Simply Easy Learning');var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(""buffer3 content: "" + buffer3.toString());|||var buffer1 = new Buffer('ABC');var buffer2 = new Buffer('ABCD');var result = buffer1.compare(buffer2);if(result < 0) {   console.log(buffer1 +"" comes before "" + buffer2);} else if(result === 0) {   console.log(buffer1 +"" is same as "" + buffer2);} else {   console.log(buffer1 +"" comes after "" + buffer2);}|||var buffer1 = new Buffer('ABC');//copy a buffervar buffer2 = new Buffer(3);buffer1.copy(buffer2);console.log(""buffer2 content: "" + buffer2.toString());|||var buffer1 = new Buffer('TutorialsPoint');//slicing a buffervar buffer2 = buffer1.slice(0,9);console.log(""buffer2 content: "" + buffer2.toString());|||var buffer = new Buffer('TutorialsPoint');//length of the bufferconsole.log(""buffer length: "" + buffer.length);|||var fs = require(""fs"");var data = '';// Create a readable streamvar readerStream = fs.createReadStream('input.txt');// Set the encoding to be utf8. readerStream.setEncoding('UTF8');// Handle stream events --> data, end, and errorreaderStream.on('data', function(chunk) {   data += chunk;});readerStream.on('end',function() {   console.log(data);});readerStream.on('error', function(err) {   console.log(err.stack);});console.log(""Program Ended"");|||var fs = require(""fs"");var data = 'Simply Easy Learning';// Create a writable streamvar writerStream = fs.createWriteStream('output.txt');// Write the data to stream with encoding to be utf8writerStream.write(data,'UTF8');// Mark the end of filewriterStream.end();// Handle stream events --> finish, and errorwriterStream.on('finish', function() {   console.log(""Write completed."");});writerStream.on('error', function(err) {   console.log(err.stack);});console.log(""Program Ended"");|||var fs = require(""fs"");// Create a readable streamvar readerStream = fs.createReadStream('input.txt');// Create a writable streamvar writerStream = fs.createWriteStream('output.txt');// Pipe the read and write operations// read input.txt and write data to output.txtreaderStream.pipe(writerStream);console.log(""Program Ended"");|||var fs = require(""fs"");var zlib = require('zlib');// Compress the file input.txt to input.txt.gzfs.createReadStream('input.txt')   .pipe(zlib.createGzip())   .pipe(fs.createWriteStream('input.txt.gz'));  console.log(""File Compressed."");|||var fs = require(""fs"");var zlib = require('zlib');// Decompress the file input.txt.gz to input.txtfs.createReadStream('input.txt.gz')   .pipe(zlib.createGunzip())   .pipe(fs.createWriteStream('input.txt'));  console.log(""File Decompressed."");|||var fs = require(""fs"");// Asynchronous readfs.readFile('input.txt', function (err, data) {   if (err) {      return console.error(err);   }   console.log(""Asynchronous read: "" + data.toString());});// Synchronous readvar data = fs.readFileSync('input.txt');console.log(""Synchronous read: "" + data.toString());console.log(""Program Ended"");|||var fs = require(""fs"");// Asynchronous - Opening Fileconsole.log(""Going to open file!"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");     });|||var fs = require(""fs"");console.log(""Going to get file info!"");fs.stat('input.txt', function (err, stats) {   if (err) {      return console.error(err);   }   console.log(stats);   console.log(""Got file info successfully!"");      // Check file type   console.log(""isFile ? "" + stats.isFile());   console.log(""isDirectory ? "" + stats.isDirectory());    });|||var fs = require(""fs"");console.log(""Going to write into existing file"");fs.writeFile('input.txt', 'Simply Easy Learning!', function(err) {   if (err) {      return console.error(err);   }      console.log(""Data written successfully!"");   console.log(""Let's read newly written data"");      fs.readFile('input.txt', function (err, data) {      if (err) {         return console.error(err);      }      console.log(""Asynchronous read: "" + data.toString());   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to read the file"");      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){      if (err){         console.log(err);      }      console.log(bytes + "" bytes read"");            // Print only read bytes to avoid junk.      if(bytes > 0){         console.log(buf.slice(0, bytes).toString());      }   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to read the file"");      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes) {      if (err) {         console.log(err);      }      // Print only read bytes to avoid junk.      if(bytes > 0) {         console.log(buf.slice(0, bytes).toString());      }      // Close the opened file.      fs.close(fd, function(err) {         if (err) {            console.log(err);         }          console.log(""File closed successfully."");      });   });});|||var fs = require(""fs"");var buf = new Buffer(1024);console.log(""Going to open an existing file"");fs.open('input.txt', 'r+', function(err, fd) {   if (err) {      return console.error(err);   }   console.log(""File opened successfully!"");   console.log(""Going to truncate the file after 10 bytes"");      // Truncate the opened file.   fs.ftruncate(fd, 10, function(err) {      if (err) {         console.log(err);      }       console.log(""File truncated successfully."");      console.log(""Going to read the same file"");             fs.read(fd, buf, 0, buf.length, 0, function(err, bytes){         if (err) {            console.log(err);         }         // Print only read bytes to avoid junk.         if(bytes > 0) {            console.log(buf.slice(0, bytes).toString());         }         // Close the opened file.         fs.close(fd, function(err) {            if (err) {               console.log(err);            }             console.log(""File closed successfully."");         });      });   });});|||var fs = require(""fs"");console.log(""Going to delete an existing file"");fs.unlink('input.txt', function(err) {   if (err) {      return console.error(err);   }   console.log(""File deleted successfully!"");});|||var fs = require(""fs"");console.log(""Going to create directory /tmp/test"");fs.mkdir('/tmp/test',function(err) {   if (err) {      return console.error(err);   }   console.log(""Directory created successfully!"");});|||var fs = require(""fs"");console.log(""Going to read directory /tmp"");fs.readdir(""/tmp/"",function(err, files) {   if (err) {      return console.error(err);   }   files.forEach( function (file) {      console.log( file );   });});|||var fs = require(""fs"");console.log(""Going to delete directory /tmp/test"");fs.rmdir(""/tmp/test"",function(err) {   if (err) {      return console.error(err);   }   console.log(""Going to read directory /tmp"");      fs.readdir(""/tmp/"",function(err, files) {      if (err) {         return console.error(err);      }      files.forEach( function (file) {         console.log( file );      });   });});|||// Let's try to print the value of __filenameconsole.log( __filename );|||// Let's try to print the value of __dirnameconsole.log( __dirname );|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondssetTimeout(printHello, 2000);|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondsvar t = setTimeout(printHello, 2000);// Now clear the timerclearTimeout(t);|||function printHello() {   console.log( ""Hello, World!"");}// Now call above function after 2 secondssetInterval(printHello, 2000);|||var http = require('http');var fs = require('fs');var url = require('url');// Create a serverhttp.createServer( function (request, response) {     // Parse the request containing file name   var pathname = url.parse(request.url).pathname;      // Print the name of the file for which request is made.   console.log(""Request for "" + pathname + "" received."");      // Read the requested file content from file system   fs.readFile(pathname.substr(1), function (err, data) {      if (err) {         console.log(err);                  // HTTP Status: 404 : NOT FOUND         // Content Type: text/plain         response.writeHead(404, {'Content-Type': 'text/html'});      } else {	         //Page found	           // HTTP Status: 200 : OK         // Content Type: text/plain         response.writeHead(200, {'Content-Type': 'text/html'});	                  // Write the content of the file to response body         response.write(data.toString());		      }            // Send the response body       response.end();   });   }).listen(8081);// Console will print the messageconsole.log('Server running at http://127.0.0.1:8081/');|||<html>   <head>      <title>Sample Page</title>   </head>      <body>      Hello World!   </body></html>|||var http = require('http');// Options to be used by request var options = {   host: 'localhost',   port: '8081',   path: '/index.htm'  };// Callback function is used to deal with responsevar callback = function(response) {   // Continuously update stream with data   var body = '';   response.on('data', function(data) {      body += data;   });      response.on('end', function() {      // Data received completely.      console.log(body);   });}// Make a request to the servervar req = http.request(options, callback);req.end();|||var express = require('express');var app = express();app.get('/', function (req, res) {   res.send('Hello World');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();// This responds with ""Hello World"" on the homepageapp.get('/', function (req, res) {   console.log(""Got a GET request for the homepage"");   res.send('Hello GET');})// This responds a POST request for the homepageapp.post('/', function (req, res) {   console.log(""Got a POST request for the homepage"");   res.send('Hello POST');})// This responds a DELETE request for the /del_user page.app.delete('/del_user', function (req, res) {   console.log(""Got a DELETE request for /del_user"");   res.send('Hello DELETE');})// This responds a GET request for the /list_user page.app.get('/list_user', function (req, res) {   console.log(""Got a GET request for /list_user"");   res.send('Page Listing');})// This responds a GET request for abcd, abxcd, ab123cd, and so onapp.get('/ab*cd', function(req, res) {      console.log(""Got a GET request for /ab*cd"");   res.send('Page Pattern Match');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res) {   res.send('Hello World');})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <body>            <form action = ""http://127.0.0.1:8081/process_get"" method = ""GET"">         First Name: <input type = ""text"" name = ""first_name"">  <br>         Last Name: <input type = ""text"" name = ""last_name"">         <input type = ""submit"" value = ""Submit"">      </form>         </body></html>|||var express = require('express');var app = express();app.use(express.static('public'));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.get('/process_get', function (req, res) {   // Prepare output in JSON format   response = {      first_name:req.query.first_name,      last_name:req.query.last_name   };   console.log(response);   res.end(JSON.stringify(response));})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <body>            <form action = ""http://127.0.0.1:8081/process_post"" method = ""POST"">         First Name: <input type = ""text"" name = ""first_name""> <br>         Last Name: <input type = ""text"" name = ""last_name"">         <input type = ""submit"" value = ""Submit"">      </form>         </body></html>|||var express = require('express');var app = express();var bodyParser = require('body-parser');// Create application/x-www-form-urlencoded parservar urlencodedParser = bodyParser.urlencoded({ extended: false })app.use(express.static('public'));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.post('/process_post', urlencodedParser, function (req, res) {   // Prepare output in JSON format   response = {      first_name:req.body.first_name,      last_name:req.body.last_name   };   console.log(response);   res.end(JSON.stringify(response));})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||<html>   <head>      <title>File Uploading Form</title>   </head>   <body>      <h3>File Upload:</h3>      Select a file to upload: <br />            <form action = ""http://127.0.0.1:8081/file_upload"" method = ""POST""          enctype = ""multipart/form-data"">         <input type=""file"" name=""file"" size=""50"" />         <br />         <input type = ""submit"" value = ""Upload File"" />      </form>         </body></html>|||var express = require('express');var app = express();var fs = require(""fs"");var bodyParser = require('body-parser');var multer  = require('multer');app.use(express.static('public'));app.use(bodyParser.urlencoded({ extended: false }));app.use(multer({ dest: '/tmp/'}));app.get('/index.htm', function (req, res) {   res.sendFile( __dirname + ""/"" + ""index.htm"" );})app.post('/file_upload', function (req, res) {   console.log(req.files.file.name);   console.log(req.files.file.path);   console.log(req.files.file.type);   var file = __dirname + ""/"" + req.files.file.name;      fs.readFile( req.files.file.path, function (err, data) {      fs.writeFile(file, data, function (err) {         if( err ) {            console.log( err );            } else {               response = {                  message:'File uploaded successfully',                  filename:req.files.file.name               };            }                  console.log( response );         res.end( JSON.stringify( response ) );      });   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port      console.log(""Example app listening at http://%s:%s"", host, port)})|||var express      = require('express')var cookieParser = require('cookie-parser')var app = express()app.use(cookieParser())app.get('/', function(req, res) {   console.log(""Cookies: "", req.cookies)})app.listen(8081)|||{   ""user1"" : {      ""name"" : ""mahesh"",      ""password"" : ""password1"",      ""profession"" : ""teacher"",      ""id"": 1   },      ""user2"" : {      ""name"" : ""suresh"",      ""password"" : ""password2"",      ""profession"" : ""librarian"",      ""id"": 2   },      ""user3"" : {      ""name"" : ""ramesh"",      ""password"" : ""password3"",      ""profession"" : ""clerk"",      ""id"": 3   }}|||var express = require('express');var app = express();var fs = require(""fs"");app.get('/listUsers', function (req, res) {   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      console.log( data );      res.end( data );   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||{   ""user1"" : {      ""name"" : ""mahesh"",      ""password"" : ""password1"",      ""profession"" : ""teacher"",      ""id"": 1   },      ""user2"" : {      ""name"" : ""suresh"",      ""password"" : ""password2"",      ""profession"" : ""librarian"",      ""id"": 2   },      ""user3"" : {      ""name"" : ""ramesh"",      ""password"" : ""password3"",      ""profession"" : ""clerk"",      ""id"": 3   }}|||user = {   ""user4"" : {      ""name"" : ""mohit"",      ""password"" : ""password4"",      ""profession"" : ""teacher"",      ""id"": 4   }}|||var express = require('express');var app = express();var fs = require(""fs"");var user = {   ""user4"" : {      ""name"" : ""mohit"",      ""password"" : ""password4"",      ""profession"" : ""teacher"",      ""id"": 4   }}app.post('/addUser', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      data = JSON.parse( data );      data[""user4""] = user[""user4""];      console.log( data );      res.end( JSON.stringify(data));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||{   ""user1"":{""name"":""mahesh"",""password"":""password1"",""profession"":""teacher"",""id"":1},   ""user2"":{""name"":""suresh"",""password"":""password2"",""profession"":""librarian"",""id"":2},   ""user3"":{""name"":""ramesh"",""password"":""password3"",""profession"":""clerk"",""id"":3},   ""user4"":{""name"":""mohit"",""password"":""password4"",""profession"":""teacher"",""id"":4}}|||var express = require('express');var app = express();var fs = require(""fs"");app.get('/:id', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      var users = JSON.parse( data );      var user = users[""user"" + req.params.id]       console.log( user );      res.end( JSON.stringify(user));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||var express = require('express');var app = express();var fs = require(""fs"");var id = 2;app.delete('/deleteUser', function (req, res) {   // First read existing users.   fs.readFile( __dirname + ""/"" + ""users.json"", 'utf8', function (err, data) {      data = JSON.parse( data );      delete data[""user"" + 2];             console.log( data );      res.end( JSON.stringify(data));   });})var server = app.listen(8081, function () {   var host = server.address().address   var port = server.address().port   console.log(""Example app listening at http://%s:%s"", host, port)})|||const fs = require('fs');const child_process = require('child_process');for(var i=0; i<3; i++) {   var workerProcess = child_process.exec('node support.js '+i,function       (error, stdout, stderr) {            if (error) {         console.log(error.stack);         console.log('Error code: '+error.code);         console.log('Signal received: '+error.signal);      }      console.log('stdout: ' + stdout);      console.log('stderr: ' + stderr);   });   workerProcess.on('exit', function (code) {      console.log('Child process exited with exit code '+code);   });}|||const fs = require('fs');const child_process = require('child_process'); for(var i = 0; i<3; i++) {   var workerProcess = child_process.spawn('node', ['support.js', i]);   workerProcess.stdout.on('data', function (data) {      console.log('stdout: ' + data);   });   workerProcess.stderr.on('data', function (data) {      console.log('stderr: ' + data);   });   workerProcess.on('close', function (code) {      console.log('child process exited with code ' + code);   });}|||const fs = require('fs');const child_process = require('child_process'); for(var i=0; i<3; i++) {   var worker_process = child_process.fork(""support.js"", [i]);	   worker_process.on('close', function (code) {      console.log('child process exited with code ' + code);   });}"
Learn Node.js,Node.js - Useful Resources,"Node.js - Useful Resources|||Useful Video Courses@@@Useful eBooks|||Node.js Online Training@@@MERN Stack Full Ecommerce Site - Using React, Redux, Node.js@@@Using Clean architecture for Node.js API@@@Node.Js Tutorial@@@Mastering Node.js - Second Edition@@@Node.js Web Development@@@RESTful Web API Design with Node.js 10@@@Node.js Design Patterns - Second Edition@@@MongoDB, Express, Angular, and Node.js Fundamentals",The following resources contain additional information on Node.js. Please use them to get more in-depth knowledge on this topic.,,,,
Learn Node.js,Discuss Node.js,Discuss Node.js|||Useful Video Courses|||Serverless Development with AWS Lambda and NodeJS@@@Learn Nodejs by building 10 projects@@@Unit Testing and Test Driven Development in NodeJS@@@Nodejs Crash Course : For Backend Development@@@Learn NodeJS Step by Step@@@Master NodeJs : A Practical Approach To Node JS,"Node.js is a very powerful JavaScript-based framework/platform built on Google Chrome's JavaScript V8 Engine. It is used to develop I/O intensive web applications like video streaming sites, single-page applications, and other web applications. Node.js is open source, completely free, and used by thousands of developers around the world.",,,,
