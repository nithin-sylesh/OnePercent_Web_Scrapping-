Course,Chapters,ALL Headings,Paragraphs,Unordered List Items,Ordered List Items,Tables,Code Examples
Learn Scala Collection,Scala Collections Tutorial,Scala Collections Tutorial@@@Audience@@@Prerequisites|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala has a rich set of collection library. Scala Collections may be strict or lazy. Lazy collections have elements that may not consume memory until they are accessed, like Ranges. Additionally, collections may be mutable (the contents of the reference can change) or immutable (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.|||This tutorial has been prepared for the beginners to help them understand Scala Collections library to use Collections in Scala based programs.|||For this tutorial, we assume the readers to have prior knowledge of basic software development using Java or Scala. It will help if you had some exposure to the software build and deployment process.",,,,
Learn Scala Collection,Scala Collections - Overview,Scala Collections - Overview|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map, etc. The collections may have an arbitrary number of elements or be bounded to zero or one element (e.g., Option).|||Collections may be strict or lazy. Lazy collections have elements that may not consume memory until they are accessed, like Ranges. Additionally, collections may be mutable (the contents of the reference can change) or immutable (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.|||For some problems, mutable collections work better, and for others, immutable collections work better. When in doubt, it is better to start with an immutable collection and change it later if you need mutable ones.|||This chapter throws light on the most commonly used collection types and most frequently used operations over those collections.|||Scala Lists|||Scala's List[T] is a linked list of type T.|||Scala Sets|||A set is a collection of pairwise different elements of the same type.|||Scala Maps|||A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||Scala Tuples|||Unlike an array or list, a tuple can hold objects with different types.|||Scala Options|||Option[T] provides a container for zero or one element of a given type.|||Scala Iterators|||An iterator is not a collection, but rather a way to access the elements of a collection one by one.",,,"Sr.No@@@Collections with Description|||1@@@Scala Lists
Scala's List[T] is a linked list of type T.
|||2@@@Scala Sets
A set is a collection of pairwise different elements of the same type.|||3@@@
Scala Maps
A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||4@@@Scala Tuples
Unlike an array or list, a tuple can hold objects with different types.|||5@@@Scala Options
Option[T] provides a container for zero or one element of a given type.|||6@@@Scala Iterators
An iterator is not a collection, but rather a way to access the elements of a collection one by one.",
Learn Scala Collection,Scala Collections - Environment Setup,Scala Collections - Environment Setup|||Step 1: Verify Your Java Installation@@@Step 2: Set Your Java Environment@@@Step 3: Install Scala@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala can be installed on any UNIX flavored or Windows based system. Before you start installing Scala on your machine, you must have Java 1.8 or greater installed on your computer.|||Follow the steps given below to install Scala.|||First of all, you need to have Java Software Development Kit (SDK) installed on your system. To verify this, execute any of the following two commands depending on the platform you are working on.|||If the Java installation has been done properly, then it will display the current version and specification of your Java installation. A sample output is given in the following table.|||Open Command Console and type −|||\>java -version|||Java version ""1.8.0_31""|||Java (TM) SE Run Time|||Environment (build 1.8.0_31-b31)|||Java Hotspot (TM) 64-bit Server|||VM (build 25.31-b07, mixed mode)|||Open Command terminal and type −|||$java -version|||Java version ""1.8.0_31""|||Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)|||Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)|||We assume that the readers of this tutorial have Java SDK version 1.8.0_31 installed on their system.|||In case you do not have Java SDK, download its current version from https://www.oracle.com/technetwork/java/javase/downloads/index.html and install it.|||Set the environment variable JAVA_HOME to point to the base directory location where Java is installed on your machine. For example,|||Windows|||Set JAVA_HOME to C:\ProgramFiles\java\jdk1.8.0_31|||Linux|||Export JAVA_HOME=/usr/local/java-current|||Append the full path of Java compiler location to the System Path.|||Windows|||Append the String ""C:\Program Files\Java\jdk1.8.0_31\bin"" to the end of the system variable PATH.|||Linux|||Export PATH=$PATH:$JAVA_HOME/bin/|||Execute the command java -version from the command prompt as explained above.|||You can download Scala from www.scala-lang.org/downloads. At the time of writing this tutorial, I downloaded 'scala-2.13.1-installer.jar'. Make sure you have admin privilege to proceed. Now, execute the following command at the command prompt −|||\>java -jar scala-2.13.1-installer.jar\>|||This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path ""C:\Program Files\Scala"", you can select a suitable path as per your convenience.|||Command −|||$java -jar scala-2.13.1-installer.jar|||Output −|||Welcome to the installation of Scala 2.13.1!|||The homepage is at − http://Scala-lang.org/|||press 1 to continue, 2 to quit, 3 to redisplay|||1................................................|||[ Starting to unpack ]|||[ Processing package: Software Package Installation (1/1) ]|||[ Unpacking finished ]|||[ Console installation done ]|||During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.|||Finally, open a new command prompt and type Scala -version and press Enter. You should see the following −|||\>scala -version|||Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.|||$scala -version|||Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.tut",,,"Platform@@@Command@@@Sample Output|||Windows@@@
Open Command Console and type −
\>java -version
@@@
Java version ""1.8.0_31""
Java (TM) SE Run Time
Environment (build 1.8.0_31-b31)
Java Hotspot (TM) 64-bit Server
VM (build 25.31-b07, mixed mode)|||Linux@@@
Open Command terminal and type −
$java -version@@@
Java version ""1.8.0_31""
Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)
Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Set JAVA_HOME to C:\ProgramFiles\java\jdk1.8.0_31
|||2@@@
Linux
Export JAVA_HOME=/usr/local/java-current
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Append the String ""C:\Program Files\Java\jdk1.8.0_31\bin"" to the end of the system variable PATH.|||2@@@
Linux
Export PATH=$PATH:$JAVA_HOME/bin/
&&&Platform@@@Command & Output@@@Description|||Windows@@@\>java -jar scala-2.13.1-installer.jar\>@@@This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path ""C:\Program Files\Scala"", you can select a suitable path as per your convenience.|||Linux@@@
Command −
$java -jar scala-2.13.1-installer.jar
Output −
Welcome to the installation of Scala 2.13.1!
The homepage is at − http://Scala-lang.org/
press 1 to continue, 2 to quit, 3 to redisplay
1................................................
[ Starting to unpack ]
[ Processing package: Software Package Installation (1/1) ]
[ Unpacking finished ]
[ Console installation done ]
@@@
During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.
&&&Platform@@@Command@@@Output|||Windows@@@\>scala -version@@@Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.|||Linux@@@$scala -version@@@Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.tut",
Learn Scala Collection,Scala Collections - Array,Scala Collections - Array|||Declaring Array Variables@@@Processing Arrays@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.|||Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables. The index of the first element of an array is the number zero and the index of the last element is the total number of elements minus one.|||To use an array in a program, you must declare a variable to reference the array and you must specify the type of array the variable can reference.|||The following is the syntax for declaring an array variable.|||Here, z is declared as an array of Strings that may hold up to three elements. Values can be assigned to individual elements or get access to individual elements, it can be done by using commands like the following −|||Here, the last example shows that in general the index can be any expression that yields a whole number. There is one more way of defining an array −|||Following picture represents an array myList. Here, myList holds ten double values and the indices are from 0 to 9.|||When processing array elements, we often use loop contol structures because all of the elements in an array are of the same type and the size of the array is known.|||Below is an example program of showing how to create, initialize and process arrays −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala does not directly support various array operations and provides various methods to process arrays in any dimension. If you want to use the different methods then it is required to import Array._ package.",,,,"object Demo {   def main(args: Array[String]) {      var myList = Array(1.9, 2.9, 3.4, 3.5)            // Print all the array elements      for ( x <- myList ) {         println( x )      }      // Summing all elements      var total = 0.0;      for ( i <- 0 to (myList.length - 1)) {         total += myList(i);      }      println(""Total is "" + total);      // Finding the largest element      var max = myList(0);      for ( i <- 1 to (myList.length - 1) ) {         if (myList(i) > max) max = myList(i);      }      println(""Max is "" + max);   }}"
Learn Scala Collection,Scala Collections - Multi-Dimensional Array,Scala Collections - Multi-Dimensional Array|||Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"There are many situations where you would need to define and use multi-dimensional arrays (i.e., arrays whose elements are arrays). For example, matrices and tables are examples of structures that can be realized as two-dimensional arrays.|||The following is the example of defining a two-dimensional array −|||This is an array that has three elements each being an array of integers that has three elements.|||Try the following example program to process a multi-dimensional array −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import Array._object Demo {   def main(args: Array[String]) {      var myMatrix = ofDim[Int](3,3)      // build a matrix      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            myMatrix(i)(j) = j;         }      }      // Print two dimensional array      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            print("" "" + myMatrix(i)(j));         }         println();      }   }}"
Learn Scala Collection,Scala Collections - Array with Range,Scala Collections - Array with Range|||Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Use of range() method to generate an array containing a sequence of increasing integers in a given range. You can use final argument as step to create the sequence; if you do not use final argument, then step would be assumed as 1.|||Let us take an example of creating an array of range (10, 20, 2): It means creating an array with elements between 10 and 20 and range difference 2. Elements in the array are 10, 12, 14, 16, and 18.|||Another example: range (10, 20). Here range difference is not given so by default it assumes 1 element. It create an array with the elements in between 10 and 20 with range difference 1. Elements in the array are 10, 11, 12, 13, ..., and 19.|||The following example program shows how to create an array with ranges.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import Array._object Demo {   def main(args: Array[String]) {      var myList1 = range(10, 20, 2)      var myList2 = range(10,20)      // Print all the array elements      for ( x <- myList1 ) {         print( "" "" + x )      }      println()      for ( x <- myList2 ) {         print( "" "" + x )      }   }}"
Learn Scala Collection,Scala Collections - ArrayBuffer,Scala Collections - ArrayBuffer|||Declaring ArrayBuffer Variables@@@Processing ArrayBuffer@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala provides a data structure, the ArrayBuffer, which can change size when initial size falls short. As array is of fix size and more elements cannot be occupied in an array, ArrayBuffer is an alternative to array where size is flexible.|||Internally ArrayBuffer maintains an array of current size to store elements. When a new element is added, size is checked. In case underlying array is full then a new larger array is created and all elements are copied to larger array.|||The following is the syntax for declaring an ArrayBuffer variable.|||Here, z is declared as an array-buffer of Strings which is initially empty. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ArrayBuffer −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.mutable.ArrayBuffer object Demo {   def main(args: Array[String]) = {      var myList = ArrayBuffer(""Zara"",""Nuha"",""Ayan"")      println(myList);      // Add an element      myList += ""Welcome"";      // Add two element      myList += (""To"", ""Tutorialspoint"");      println(myList);      // Remove an element      myList -= ""Welcome"";      // print second element      println(myList(1));   }}"
Learn Scala Collection,Scala Collections - List,Scala Collections - List|||Basic Operations on Lists@@@Concatenating Lists@@@Creating Uniform Lists@@@Tabulating a Function@@@Reverse List Order@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Lists are quite similar to arrays which means, all the elements of a list have the same type but there are two important differences. First, lists are immutable, which means elements of a list cannot be changed by assignment. Second, lists represent a linked list whereas arrays are flat.|||The type of a list that has elements of type T is written as List[T].|||Try the following example, here are few lists defined for various data types.|||All lists can be defined using two fundamental building blocks, a tail Nil and ::, which is pronounced cons. Nil also represents the empty list. All the above lists can be defined as follows.|||All operations on lists can be expressed in terms of the following three methods.|||head|||This method returns the first element of a list.|||tail|||This method returns a list consisting of all elements except the first.|||isEmpty|||This method returns true if the list is empty otherwise false.|||The following example shows how to use the above methods.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ::: operator or List.:::() method  or List.concat() method to add two or more lists. Please find the following example given below −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use List.fill() method creates a list consisting of zero or more copies of the same element. Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use a function along with List.tabulate() method to apply on all the elements of the list before tabulating the list. Its arguments are just like those of List.fill: the first argument list gives the dimensions of the list to create, and the second describes the elements of the list. The only difference is that instead of the elements being fixed, they are computed from a function.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use List.reverse method to reverse all elements of the list. The Following example shows the usage.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,"Sr.No@@@Methods & Description|||1@@@
head
This method returns the first element of a list.
|||2@@@
tail
This method returns a list consisting of all elements except the first.
|||3@@@
isEmpty
This method returns true if the list is empty otherwise false.
","// List of Stringsval fruit: List[String] = List(""apples"", ""oranges"", ""pears"")// List of Integersval nums: List[Int] = List(1, 2, 3, 4)// Empty List.val empty: List[Nothing] = List()// Two dimensional listval dim: List[List[Int]] = List(   List(1, 0, 0),   List(0, 1, 0),   List(0, 0, 1))|||// List of Stringsval fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))// List of Integersval nums = 1 :: (2 :: (3 :: (4 :: Nil)))// Empty List.val empty = Nil// Two dimensional listval dim = (1 :: (0 :: (0 :: Nil))) ::   (0 :: (1 :: (0 :: Nil))) ::   (0 :: (0 :: (1 :: Nil))) :: Nil|||object Demo {   def main(args: Array[String]) {      val fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      val nums = Nil      println( ""Head of fruit : "" + fruit.head )      println( ""Tail of fruit : "" + fruit.tail )      println( ""Check if fruit is empty : "" + fruit.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val fruit1 = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      val fruit2 = ""mangoes"" :: (""banana"" :: Nil)      // use two or more lists with ::: operator      var fruit = fruit1 ::: fruit2      println( ""fruit1 ::: fruit2 : "" + fruit )      // use two lists with Set.:::() method      fruit = fruit1.:::(fruit2)      println( ""fruit1.:::(fruit2) : "" + fruit )      // pass two or more lists as arguments      fruit = List.concat(fruit1, fruit2)      println( ""List.concat(fruit1, fruit2) : "" + fruit  )   }}|||object Demo {   def main(args: Array[String]) {      val fruit = List.fill(3)(""apples"") // Repeats apples three times.      println( ""fruit : "" + fruit  )      val num = List.fill(10)(2)         // Repeats 2, 10 times.      println( ""num : "" + num  )   }}|||object Demo {   def main(args: Array[String]) {      // Creates 5 elements using the given function.      val squares = List.tabulate(6)(n => n * n)      println( ""squares : "" + squares  )      val mul = List.tabulate( 4,5 )( _ * _ )            println( ""mul : "" + mul  )   }}|||object Demo {   def main(args: Array[String]) {      val fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      println( ""Before reverse fruit : "" + fruit )      println( ""After reverse fruit : "" + fruit.reverse )   }}"
Learn Scala Collection,Scala Collections - ListBuffer,Scala Collections - ListBuffer|||Declaring ListBuffer Variables@@@Processing ListBuffer@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala provides a data structure, the ListBuffer, which is more efficient than List while adding/removing elements in a list. It provides methods to prepend, append elements to a list.|||The following is the syntax for declaring an ListBuffer variable.|||Here, z is declared as an list-buffer of Strings which is initially empty. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListBuffer −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.mutable.ListBuffer object Demo {   def main(args: Array[String]) = {      var myList = ListBuffer(""Zara"",""Nuha"",""Ayan"")      println(myList);      // Add an element      myList += ""Welcome"";      // Add two element      myList += (""To"", ""Tutorialspoint"");      println(myList);      // Remove an element      myList -= ""Welcome"";      // print second element      println(myList(1));   }}"
Learn Scala Collection,Scala Collections - ListSet,Scala Collections - ListSet|||Declaring ListSet Variables@@@Processing ListSet@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. ListSet implements immutable sets and uses list structure. Elements insertion order is preserved while storing the elements.|||The following is the syntax for declaring an ListSet variable.|||Here, z is declared as an list-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.ListSetobject Demo {   def main(args: Array[String]) = {      var myList: ListSet[String] = ListSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var myList1: ListSet[String] = myList + ""Naira"";      // Remove an element      var myList2: ListSet[String] = myList - ""Nuha"";      // Create empty set      var myList3: ListSet[String] = ListSet.empty[String];      println(myList);      println(myList1);      println(myList2);      println(myList3);	     }}"
Learn Scala Collection,Scala Collections - Vector,Scala Collections - Vector|||Declaring Vector Variables@@@Processing Vector@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Vector is a general purpose immutable data structure where elements can be accessed randomly. It is generally used for large collections of data.|||The following is the syntax for declaring an Vector variable.|||Here, z is declared as an vector of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process Vector −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.Vectorobject Demo {   def main(args: Array[String]) = {      var vector: Vector[String] = Vector(""Zara"",""Nuha"",""Ayan"");      // Add an element      var vector1: Vector[String] = vector :+ ""Naira"";      // Reverse an element      var vector2: Vector[String] = vector.reverse;      // sort a vector      var vector3: Vector[String] = vector1.sorted;      println(vector);      println(vector1);      println(vector2);      println(vector3);	     }}"
Learn Scala Collection,Scala Collections - Set,"Scala Collections - Set|||Basic Operations on set@@@Concatenating Sets@@@Find Max, Min Elements in a Set@@@Find Common Values Insets@@@Useful Video Courses|||Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala","Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. There are two kinds of Sets, the immutable and the mutable. The difference between mutable and immutable objects is that when an object is immutable, the object itself can't be changed.|||By default, Scala uses the immutable Set. If you want to use the mutable Set, you'll have to import scala.collection.mutable.Set class explicitly. If you want to use both mutable and immutable sets in the same collection, then you can continue to refer to the immutable Set as Set but you can refer to the mutable Set as mutable.Set.|||Here is how you can declare immutable Sets −|||While defining an empty set, the type annotation is necessary as the system needs to assign a concrete type to variable.|||All operations on sets can be expressed in terms of the following three methods −|||head|||This method returns the first element of a set.|||tail|||This method returns a set consisting of all elements except the first.|||isEmpty|||This method returns true if the set is empty otherwise false.|||Try the following example showing usage of the basic operational methods −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ++ operator or Set.++() method to concatenate two or more sets, but while adding sets it will remove duplicate elements.|||The Following is the example to concatenate two sets.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Set.min method to find out the minimum and Set.max method to find out the maximum of the elements available in a set. Following is the example to show the program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either Set.& method or Set.intersect method to find out the common values between two sets. Try the following example to show the usage.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,"Sr.No@@@Methods & Description|||1@@@
head
This method returns the first element of a set.
|||2@@@
tail
This method returns a set consisting of all elements except the first.
|||3@@@
isEmpty
This method returns true if the set is empty otherwise false.
","object Demo {   def main(args: Array[String]) {      val fruit = Set(""apples"", ""oranges"", ""pears"")      val nums: Set[Int] = Set()      println( ""Head of fruit : "" + fruit.head )      println( ""Tail of fruit : "" + fruit.tail )      println( ""Check if fruit is empty : "" + fruit.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val fruit1 = Set(""apples"", ""oranges"", ""pears"")      val fruit2 = Set(""mangoes"", ""banana"")      // use two or more sets with ++ as operator      var fruit = fruit1 ++ fruit2      println( ""fruit1 ++ fruit2 : "" + fruit )      // use two sets with ++ as method      fruit = fruit1.++(fruit2)      println( ""fruit1.++(fruit2) : "" + fruit )   }}|||object Demo {   def main(args: Array[String]) {      val num = Set(5,6,9,20,30,45)      // find min and max of the elements      println( ""Min element in Set(5,6,9,20,30,45) : "" + num.min )      println( ""Max element in Set(5,6,9,20,30,45) : "" + num.max )   }}|||object Demo {   def main(args: Array[String]) {      val num1 = Set(5,6,9,20,30,45)      val num2 = Set(50,60,9,20,35,55)      // find common elements between two sets      println( ""num1.&(num2) : "" + num1.&(num2) )      println( ""num1.intersect(num2) : "" + num1.intersect(num2) )   }}"
Learn Scala Collection,Scala Collections - BitSet,Scala Collections - BitSet|||Declaring BitSet Variables@@@Processing BitSet@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Bitset is a common base class for mutable and immutable bitsets. Bitsets are sets of non-negative integers and are represented as variable-size arrays of bits packed into 64-bit words. The memory footprint of a bitset is represented by the largest number stored in it.|||The following is the syntax for declaring an BitSet variable.|||Here, z is declared as an bit-set of non-negative integers which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process BitSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.BitSetobject Demo {   def main(args: Array[String]) = {      var mySet: BitSet = BitSet(0, 1, 2);      // Add an element      var mySet1: BitSet = mySet + 3;      // Remove an element      var mySet2: BitSet = mySet - 2;      var mySet3: BitSet = BitSet(4, 5);      // Adding sets      var mySet4: BitSet = mySet1 ++ mySet3;      println(mySet);      println(mySet1);      println(mySet2);      println(mySet4);	     }}"
Learn Scala Collection,Scala Collections - HashSet,Scala Collections - HashSet|||Declaring HashSet Variables@@@Processing HashSet@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. HashSet implements immutable sets and uses hash table. Elements insertion order is not preserved.|||The following is the syntax for declaring an HashSet variable.|||Here, z is declared as an hash-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process HashSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.HashSetobject Demo {   def main(args: Array[String]) = {      var mySet: HashSet[String] = HashSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var mySet1: HashSet[String] = mySet + ""Naira"";      // Remove an element      var mySet2: HashSet[String] = mySet - ""Nuha"";      // Create empty set      var mySet3: HashSet[String] = HashSet.empty[String];      println(mySet);      println(mySet1);      println(mySet2);      println(mySet3);	     }}"
Learn Scala Collection,Scala Collections - TreeSet,Scala Collections - TreeSet|||Declaring TreeSet Variables@@@Processing TreeSet@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. TreeSet implements immutable sets and keeps elements in sorted order.|||The following is the syntax for declaring an TreeSet variable.|||Here, z is declared as an tree-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process TreeSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.TreeSetobject Demo {   def main(args: Array[String]) = {      var mySet: TreeSet[String] = TreeSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var mySet1: TreeSet[String] = mySet + ""Naira"";      // Remove an element      var mySet2: TreeSet[String] = mySet - ""Nuha"";      // Create empty set      var mySet3: TreeSet[String] = TreeSet.empty[String];      println(mySet);      println(mySet1);      println(mySet2);      println(mySet3);	     }}"
Learn Scala Collection,Scala Collections - Map,Scala Collections - Map|||Basic Operations on MAP@@@Concatenating Maps@@@Print Keys and Values from a Map@@@Check for a key in Map@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. Maps are also called Hash tables. There are two kinds of Maps, the immutable and the mutable. The difference between mutable and immutable objects is that when an object is immutable, the object itself can't be changed.|||By default, Scala uses the immutable Map. If you want to use the mutable Map, you'll have to import scala.collection.mutable.Map class explicitly. If you want to use both mutable and immutable Maps in the same, then you can continue to refer to the immutable Map as Map but you can refer to the mutable set as mutable.Map.|||The Following is the example statements to declare immutable Maps −|||While defining empty map, the type annotation is necessary as the system needs to assign a concrete type to variable. If we want to add a key-value pair to a Map, we can use the operator + as follows.|||All operations on maps can be expressed in terms of the following three methods.|||keys|||This method returns an iterable containing each key in the map.|||values|||This method returns an iterable containing each value in the map.|||isEmpty|||This method returns true if the map is empty otherwise false.|||Try the following example program showing usage of the Map methods.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ++ operator or Map.++() method to concatenate two or more Maps, but while adding Maps it will remove duplicate keys.|||Try the following example program to concatenate two Maps.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can iterate through the keys and values of a Map using ""foreach"" loop. Here, we used method foreach associated with iterator to walk through the keys. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either Map.contains method to test if a given key exists in the map or not. Try the Following example program to key checking.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,"Sr.No@@@Methods & Description|||1@@@
keys
This method returns an iterable containing each key in the map.
|||2@@@
values
This method returns an iterable containing each value in the map.
|||3@@@
isEmpty
This method returns true if the map is empty otherwise false.
","object Demo {   def main(args: Array[String]) {      val colors = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      val nums: Map[Int, Int] = Map()      println( ""Keys in colors : "" + colors.keys )      println( ""Values in colors : "" + colors.values )      println( ""Check if colors is empty : "" + colors.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val colors1 = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      val colors2 = Map(         ""blue"" -> ""#0033FF"", ""yellow"" -> ""#FFFF00"", ""red"" -> ""#FF0000""      )      // use two or more Maps with ++ as operator      var colors = colors1 ++ colors2      println( ""colors1 ++ colors2 : "" + colors )      // use two maps with ++ as method      colors = colors1.++(colors2)      println( ""colors1.++(colors2)) : "" + colors )   }}|||object Demo {   def main(args: Array[String]) {      val colors = Map(""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"",""peru"" -> ""#CD853F"")      colors.keys.foreach{         i =>           print( ""Key = "" + i )         println("" Value = "" + colors(i) )      }   }}|||object Demo {   def main(args: Array[String]) {      val colors = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      if( colors.contains( ""red"" )) {         println(""Red key exists with value :""  + colors(""red""))      } else {         println(""Red key does not exist"")      }      if( colors.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + colors(""maroon""))      } else {         println(""Maroon key does not exist"")      }   }}"
Learn Scala Collection,Scala Collections - HashMap,Scala Collections - HashMap|||Declaring HashMap Variables@@@Processing HashMap@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. HashMap implements immutable map and uses hash table to implement the same.|||The following is the syntax for declaring an HashMap variable.|||Here, colors is declared as an hash-map of Strings, Int which has three key-value pairs. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process HashMap −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.HashMapobject Demo {   def main(args: Array[String]) = {      var myMap: HashMap[String,String] = HashMap(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      );      // Add an element      var myMap1: HashMap[String,String] = myMap + (""white"" -> ""#FFFFFF"");      // Print key values      myMap.keys.foreach{          i =>           print( ""Key = "" + i )         println("" Value = "" + myMap(i) )      }      if( myMap.contains( ""red"" )) {         println(""Red key exists with value :""  + myMap(""red""))      } else {         println(""Red key does not exist"")      }      if( myMap.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + myMap(""maroon""))      } else {         println(""Maroon key does not exist"")      }      //removing element      var myMap2: HashMap[String,String] = myMap - (""white"");      // Create empty map      var myMap3: HashMap[String,String] = HashMap.empty[String, String];      println(myMap1);      println(myMap2);      println(myMap3);		     }}"
Learn Scala Collection,Scala Collections - ListMap,Scala Collections - ListMap|||Declaring ListMap Variables@@@Processing ListMap@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. ListMap implements immutable map and uses list to implement the same. It is used with small number of elements.|||The following is the syntax for declaring an ListMap variable.|||Here, colors is declared as an hash-map of Strings, Int which has three key-value pairs. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListMap −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.ListMapobject Demo {   def main(args: Array[String]) = {      var myMap: ListMap[String,String] = ListMap(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      );      // Add an element      var myMap1: ListMap[String,String] = myMap + (""white"" -> ""#FFFFFF"");      // Print key values      myMap.keys.foreach{          i =>           print( ""Key = "" + i )         println("" Value = "" + myMap(i) )       }      if( myMap.contains( ""red"" )) {         println(""Red key exists with value :""  + myMap(""red""))      } else {         println(""Red key does not exist"")      }      if( myMap.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + myMap(""maroon""))      } else {         println(""Maroon key does not exist"")      }      //removing element      var myMap2: ListMap[String,String] = myMap - (""white"");      // Create empty map      var myMap3: ListMap[String,String] = ListMap.empty[String, String];      println(myMap1);      println(myMap2);	      println(myMap3);		     }}"
Learn Scala Collection,Scala Collections - Iterator,Scala Collections - Iterator|||Find Min & Max Valued Element@@@Find the Length of the Iterator@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"An iterator is not a collection, but rather a way to access the elements of a collection one by one. The two basic operations on an iterator it are next and hasNext. A call to it.next() will return the next element of the iterator and advance the state of the iterator. You can find out whether there are more elements to return using Iterator's it.hasNext method.|||The most straightforward way to ""step through"" all the elements returned by an iterator is to use a while loop. Let us follow the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use it.min and it.max methods to find out the minimum and maximum valued elements from an iterator. Here, we used ita and itb to perform two different operations because iterator can be traversed only once. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either it.size or it.length methods to find out the number of elements available in an iterator. Here, we used ita and itb to perform two different operations because iterator can be traversed only once. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) {      val it = Iterator(""a"", ""number"", ""of"", ""words"")      while (it.hasNext){         println(it.next())      }   }}|||object Demo {   def main(args: Array[String]) {      val ita = Iterator(20,40,2,50,69, 90)      val itb = Iterator(20,40,2,50,69, 90)      println(""Maximum valued element "" + ita.max )      println(""Minimum valued element "" + itb.min )   }}|||object Demo {   def main(args: Array[String]) {      val ita = Iterator(20,40,2,50,69, 90)      val itb = Iterator(20,40,2,50,69, 90)      println(""Value of ita.size : "" + ita.size )      println(""Value of itb.length : "" + itb.length )   }}"
Learn Scala Collection,Scala Collections - Option,Scala Collections - Option|||Using getOrElse() Method@@@Using isEmpty() Method@@@Useful Video Courses|||Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Example|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Option[ T ] is a container for zero or one element of a given type. An Option[T] can be either Some[T] or None object, which represents a missing value. For instance, the get method of Scala's Map produces Some(value) if a value corresponding to a given key has been found, or None if the given key is not defined in the Map.|||Option type is used frequently in Scala programs and you can compare this with the null value available in Java which indicate no value. For example, the get method of  java.util.HashMap returns either a value stored in the HashMap, or null if no value was found.|||Let's say we have a method that retrieves a record from the database based on a primary key.|||The method will return Some[Person] if the record is found but None if the record is not found. Let us follow the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The most common way to take optional values apart is through a pattern match. For example try the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following is the example program to show how to use getOrElse() method to access a value or a default when no value is present.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following is the example program to show how to use isEmpty() method to check if the option is None or not.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) {      val capitals = Map(""France"" -> ""Paris"", ""Japan"" -> ""Tokyo"")      println(""capitals.get( \""France\"" ) : "" +  capitals.get( ""France"" ))      println(""capitals.get( \""India\"" ) : "" +  capitals.get( ""India"" ))   }}|||object Demo {   def main(args: Array[String]) {      val capitals = Map(""France"" -> ""Paris"", ""Japan"" -> ""Tokyo"")      println(""show(capitals.get( \""Japan\"")) : "" + show(capitals.get( ""Japan"")) )      println(""show(capitals.get( \""India\"")) : "" + show(capitals.get( ""India"")) )   }   def show(x: Option[String]) = x match {      case Some(s) => s      case None => ""?""   }}|||object Demo {   def main(args: Array[String]) {      val a:Option[Int] = Some(5)      val b:Option[Int] = None       println(""a.getOrElse(0): "" + a.getOrElse(0) )      println(""b.getOrElse(10): "" + b.getOrElse(10) )   }}|||object Demo {   def main(args: Array[String]) {      val a:Option[Int] = Some(5)      val b:Option[Int] = None       println(""a.isEmpty: "" + a.isEmpty )      println(""b.isEmpty: "" + b.isEmpty )   }}"
Learn Scala Collection,Scala Collections - Queue,Scala Collections - Queue|||Declaring Queue Variables@@@Processing Queue@@@Useful Video Courses|||Syntax@@@Command@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Queue is First In First Out, FIFO data structure and allows to insert and retrieve elements in FIFO manner.|||The following is the syntax for declaring an Queue variable.|||Here, queue is declared as an Queue of numbers. Value can be added at front by using commands like the following −|||Value can be retrived at front by using commands like the following −|||Below is an example program of showing how to create, initialize and process Queue −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.mutable.Queueobject Demo {   def main(args: Array[String]) = {      var queue = Queue(1, 2, 3, 4, 5);      // Print queue elements      queue.foreach{(element:Int) => print(element + "" "")}      println();      // Print first element      println(""First Element: "" + queue.front)      // Add an element      queue.enqueue(6);      // Print queue elements      queue.foreach{(element:Int) => print(element+ "" "")}      println();      // Remove an element      var dq = queue.dequeue;      // Print dequeued element      println(""Dequeued Element: "" + dq)      // Print queue elements      queue.foreach{(element:Int) => print(element+ "" "")}   }}"
Learn Scala Collection,Scala Collections - Tuple,Scala Collections - Tuple|||Iterate over the Tuple@@@Converting to String@@@Swap the Elements@@@Useful Video Courses|||Example@@@Commands@@@Output@@@Example@@@Commands@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala tuple combines a fixed number of items together so that they can be passed around as a whole. Unlike an array or list, a tuple can hold objects with different types but they are also immutable.|||The following is an example of a tuple holding an integer, a string, and the console.|||Which is syntactic sugar (short cut) for the following −|||The actual type of a tuple depends upon the number and of elements it contains and the types of those elements. Thus, the type of (99, ""Luftballons"") is Tuple2[Int, String]. The type of ('u', 'r', ""the"", 1, 4, ""me"") is Tuple6[Char, Char, String, Int, Int, String]|||Tuples are of type Tuple1, Tuple2, Tuple3 and so on. There currently is an upper limit of 22 in the Scala if you need more, then you can use a collection, not a tuple. For each TupleN type, where 1 <= N <= 22, Scala defines a number of element-access methods. Given the following definition −|||To access elements of a tuple t, you can use method t._1 to access the first element, t._2 to access the second, and so on. For example, the following expression computes the sum of all elements of t.|||You can use Tuple to write a method that takes a List[Double] and returns the count, the sum, and the sum of squares returned in a three-element Tuple, a Tuple3[Int, Double, Double]. They are also useful to pass a list of data values as messages between actors in concurrent programming.|||Try the following example program. It shows how to use a tuple.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.productIterator() method  to iterate over all the elements of a Tuple.|||Try the following example program to iterate over tuples.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.toString() method to concatenate all the elements of the tuple into a string. Try the following example program to convert to String.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.swap method to swap the elements of a Tuple2.|||Try the following example program to swap the elements.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) {      val t = (4,3,2,1)      val sum = t._1 + t._2 + t._3 + t._4      println( ""Sum of elements: ""  + sum )   }}|||object Demo {   def main(args: Array[String]) {      val t = (4,3,2,1)      t.productIterator.foreach{ i =>println(""Value = "" + i )}   }}|||object Demo {   def main(args: Array[String]) {      val t = new Tuple3(1, ""hello"", Console)      println(""Concatenated String: "" + t.toString() )   }}|||object Demo {   def main(args: Array[String]) {      val t = new Tuple2(""Scala"", ""hello"")      println(""Swapped Tuple: "" + t.swap )   }}"
Learn Scala Collection,Scala Collections - Seq,Scala Collections - Seq|||Declaring Seq Variables@@@Processing Seq@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Seq is a trait to represent immutable sequences. This structure provides index based access and various utility methods to find elements, their occurences and subsequences. A Seq maintains the insertion order.|||The following is the syntax for declaring an Seq variable.|||Here, seq is declared as an Seq of numbers. Seq provides commands like the following −|||Below is an example program of showing how to create, initialize and process Seq −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.Seqobject Demo {   def main(args: Array[String]) = {      var seq = Seq(1, 2, 3, 4, 5, 3)      // Print seq elements      seq.foreach{(element:Int) => print(element + "" "")}      println()      println(""Seq ends with (5,3): "" + seq.endsWith(Seq(5, 3)))      println(""Seq contains 4: "" + seq.contains(4))      println(""Last index of 3: "" + seq.lastIndexOf(3))      println(""Reversed Seq"" + seq.reverse)              }}"
Learn Scala Collection,Scala Collections - Stack,Scala Collections - Stack|||Declaring Stack Variables@@@Processing Stack@@@Useful Video Courses|||Syntax@@@Command@@@Command@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Stack is Last In First Out, LIFO data structure and allows to insert and retrieve element at top, in LIFO manner.|||The following is the syntax for declaring an Stack variable.|||Here, stack is declared as an Stack of numbers. Value can be added at top by using commands like the following −|||Value can be retrived from top by using commands like the following −|||Value can be removed from top by using commands like the following −|||Below is an example program of showing how to create, initialize and process Stack −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.mutable.Stackobject Demo {   def main(args: Array[String]) = {      var stack: Stack[Int] = Stack();      // Add elements      stack.push(1);      stack.push(2);      // Print element at top      println(""Top Element: "" + stack.top)      // Print element      println(""Removed Element: "" + stack.pop())      // Print element      println(""Top Element: "" + stack.top)	   }}"
Learn Scala Collection,Scala Collections - Stream,Scala Collections - Stream|||Declaring Stream Variables@@@Processing Stream@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala Stream is special list with lazy evaluation feature. In scala stream, elements are evaluated only when they are needed. Stream supports lazy computation and is performance savvy.|||The following is the syntax for declaring an Stream variable.|||Here, stream is declared as a stream of numbers. Here 1 is head of stream, 2, 3 are tail of stream. Stream.empty marks the end of the stream. Values can be retrived using take commands like the following −|||Below is an example program of showing how to create, initialize and process Stream −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"import scala.collection.immutable.Streamobject Demo {   def main(args: Array[String]) = {      val stream = 1 #:: 2 #:: 3 #:: Stream.empty      // print stream      println(stream)      // Print first two elements	      stream.take(2).print      println()      // Create an empty stream      val stream1: Stream[Int] = Stream.empty[Int]      // Print element      println(s""Stream: $stream1"")   }}"
Learn Scala Collection,Scala Collections - Drop Method,Scala Collections - Drop Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"drop() method is method used by List to select all elements except first n elements of the list.|||The following is the syntax of drop method.|||Here, n is the number of elements to be dropped from the list. This method returns the all the elements of list except first n ones.|||Below is an example program of showing how to use drop method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3, 4, 5)      // print list      println(list)      //apply operation      val result = list.drop(3)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - DropWhile Method,Scala Collections - DropWhile Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"dropWhile() method is method used by List to drop all elements which satisfies a given condition.|||The following is the syntax of dropWhile method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the list. This method returns the all the elements of list except dropped ones.|||Below is an example program of showing how to use dropWhile method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(3, 6, 9, 4, 2)      // print list      println(list)      //apply operation      val result = list.dropWhile(x=>{x % 3 == 0})      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Filter Method,Scala Collections - Filter Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"filter() method is method used by List to select all elements which satisfies a given predicate.|||The following is the syntax of filter method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the list. This method returns the all the elements of list which satisfiles the given condition.|||Below is an example program of showing how to use filter method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(3, 6, 9, 4, 2)      // print list      println(list)      //apply operation      val result = list.filter(x=>{x % 3 == 0})      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Find Method,Scala Collections - Find Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"find() method is method used by Iterators to find an element which satisfies a given predicate.|||The following is the syntax of find method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the iterator. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use find method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val iterator = Iterator(3, 6, 9, 4, 2)      //apply operation      val result = iterator.find(x=>{x % 3 == 0})      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - FlatMap Method,Scala Collections - FlatMap Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"flatMap() method is method of TraversableLike trait, it takes a predicate, applies it to each element of the collection and returns a new collection of elements returned by the predicate.|||The following is the syntax of flatMap method.|||Here, f: (A) ? GenTraversableOnce[B] is a predicate or condition to be applied on each element of the collection. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use flatMap method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 5, 10)      //apply operation      val result = list.flatMap{x => List(x,x+1)}      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Flatten Method,Scala Collections - Flatten Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"flatten() method is a member GenericTraversableTemplate trait, it  returns a single collection of elements by merging child collections.|||The following is the syntax of flatten method.|||Here, f: (A) ? GenTraversableOnce[B] is a predicate or condition to be applied on each element of the collection. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use flatten method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(List(1,2), List(3,4))      //apply operation      val result = list.flatten      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Fold Method,Scala Collections - Fold Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"fold() method is a member of TraversableOnce trait, it is used to collapse elements of collections.|||The following is the syntax of fold method.|||Here, fold method takes associative binary operator function as a parameter. This method returns the result as value. It considers first input as initial value and second input as a function (which takes accumulated value and current item as input).|||Below is an example program of showing how to use fold method −|||Here we've passed 0 as initial value to fold function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.fold(0)(_ + _)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - FoldLeft Method,Scala Collections - FoldLeft Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"foldLeft() method is a member of  TraversableOnce trait, it is used to collapse elements of collections. It navigates elements from Left to Right order. It is primarily used in recursive functions and prevents stack overflow exceptions.|||The following is the syntax of fold method.|||Here, foldLeft method takes associative binary operator function as a parameter. This method returns the result as value.|||Below is an example program of showing how to use foldLeft method −|||Here we've passed 0 as initial value to fold function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.foldLeft(0)(_ + _)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - FoldRight Method,Scala Collections - FoldRight Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"foldRight() method is a member of TraversableOnce trait, it is used to collapse elements of collections. It navigates elements from Right to Left order.|||The following is the syntax of foldRight method.|||Here, fold method takes associative binary operator function as a parameter. This method returns the resulted value.|||Below is an example program of showing how to use foldRight method −|||Here we've passed 0 as initial value to foldRight function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.foldRight(0)(_ + _)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Map Method,Scala Collections - Map Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"map() method is a member of TraversableLike trait, it is used to run a predicate method on each elements of a collection. It returns a new collection.|||The following is the syntax of map method.|||Here, map method takes a prediate function as a parameter. This method returns the updated collection.|||Below is an example program of showing how to use map method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get twice of each element.      val result = list.map(_ * 2)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Partition Method,Scala Collections - Partition Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"partition() method is a member of TraversableLike trait, it is used to run a predicate method on each elements of a collection. It returns two collections, one collection is of elements which satisfiles a given predicate function and another collection is of elements which do not satisfy the given predicate function.|||The following is the syntax of map method.|||Here, partition method takes a prediate function as a parameter. This method returns the collections.|||Below is an example program of showing how to use partition method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3, 4, 5, 6, 7)      //apply operation to get twice of each element.      val (result1, result2) = list.partition(x=>{x % 3 == 0})      //print result      println(result1)      println(result2)         }}"
Learn Scala Collection,Scala Collections - Reduce Method,Scala Collections - Reduce Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"reduce() method is a member of  TraversableOnce trait, it is used to collapse elements of collections. It is similar to fold method but it does not take initial value.|||The following is the syntax of reduce method.|||Here, reduce method takes associative binary operator function as a parameter. This method returns the resultant value.|||Below is an example program of showing how to use fold method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.reduce(_ + _)      //print result      println(result)         }}"
Learn Scala Collection,Scala Collections - Scan Method,Scala Collections - Scan Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"scan() method is a member of  TraversableLike trait, it is similar to fold method but is used to apply a operation on each elements of collection and return a collection.|||The following is the syntax of fold method.|||Here, scan method takes associative binary operator function as a parameter. This method returns the updated collection as result. It considers first input as initial value and second input as a function.|||Below is an example program of showing how to use scan method −|||Here we've passed 0 as initial value to scan function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to create a running total of all elements of the list      val list1 = list.scan(0)(_ + _)      //print list      println(list1)         }}"
Learn Scala Collection,Scala Collections - Zip Method,Scala Collections - Zip Method|||Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"zip() method is a member of IterableLike trait, it is used to merge a collection to current collection and result is a collection of pair of tuple elements from both collections.|||The following is the syntax of zip method.|||Here, zip method takes a collection as parameter. This method returns the updated collection of pair as result.|||Below is an example program of showing how to use zip method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,,"object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      val list1 = List(""A"", ""B"", ""C"", ""D"")      //apply operation to create a zip of list      val list2 = list zip list1      //print list      println(list2)         }}"
Learn Scala Collection,Scala Collections - Quick Guide,"Scala Collections - Quick Guide@@@Scala Collections - Overview@@@Scala Collections - Environment Setup@@@Scala Collections - Array@@@Scala Collections - Multi-Dimensional Array@@@Scala Collections - Array with Range@@@Scala Collections - ArrayBuffer@@@Scala Collections - List@@@Scala Collections - ListBuffer@@@Scala Collections - ListSet@@@Scala Collections - Vector@@@Scala Collections - Set@@@Scala Collections - BitSet@@@Scala Collections - HashSet@@@Scala Collections - TreeSet@@@Scala Collections - Map@@@Scala Collections - HashMap@@@Scala Collections - ListMap@@@Scala Collections - Iterator@@@Scala Collections - Option@@@Scala Collections - Queue@@@Scala Collections - Tuple@@@Scala Collections - Seq@@@Scala Collections - Stack@@@Scala Collections - Stream@@@Scala Collections - Drop Method@@@Scala Collections - DropWhile Method@@@Scala Collections - Filter Method@@@Scala Collections - Find Method@@@Scala Collections - FlatMap Method@@@Scala Collections - Flatten Method@@@Scala Collections - Fold Method@@@Scala Collections - FoldLeft Method@@@Scala Collections - FoldRight Method@@@Scala Collections - Map Method@@@Scala Collections - Partition Method@@@Scala Collections - Reduce Method@@@Scala Collections - Scan Method@@@Scala Collections - Zip Method|||Step 1: Verify Your Java Installation@@@Step 2: Set Your Java Environment@@@Step 3: Install Scala@@@Declaring Array Variables@@@Processing Arrays@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Declaring ArrayBuffer Variables@@@Processing ArrayBuffer@@@Basic Operations on Lists@@@Concatenating Lists@@@Creating Uniform Lists@@@Tabulating a Function@@@Reverse List Order@@@Declaring ListBuffer Variables@@@Processing ListBuffer@@@Declaring ListSet Variables@@@Processing ListSet@@@Declaring Vector Variables@@@Processing Vector@@@Basic Operations on set@@@Concatenating Sets@@@Find Max, Min Elements in a Set@@@Find Common Values Insets@@@Declaring BitSet Variables@@@Processing BitSet@@@Declaring HashSet Variables@@@Processing HashSet@@@Declaring TreeSet Variables@@@Processing TreeSet@@@Basic Operations on MAP@@@Concatenating Maps@@@Print Keys and Values from a Map@@@Check for a key in Map@@@Declaring HashMap Variables@@@Processing HashMap@@@Declaring ListMap Variables@@@Processing ListMap@@@Find Min & Max Valued Element@@@Find the Length of the Iterator@@@Using getOrElse() Method@@@Using isEmpty() Method@@@Declaring Queue Variables@@@Processing Queue@@@Iterate over the Tuple@@@Converting to String@@@Swap the Elements@@@Declaring Seq Variables@@@Processing Seq@@@Declaring Stack Variables@@@Processing Stack@@@Declaring Stream Variables@@@Processing Stream@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Syntax@@@Usage@@@Example@@@Command@@@Output@@@Useful Video Courses|||Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Example@@@Syntax@@@Command@@@Command@@@Example@@@Command@@@Output@@@Example@@@Commands@@@Output@@@Example@@@Commands@@@Output@@@Example@@@Command@@@Output@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Command@@@Command@@@Example@@@Command@@@Output@@@Syntax@@@Command@@@Example@@@Command@@@Output|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala","Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map, etc. The collections may have an arbitrary number of elements or be bounded to zero or one element (e.g., Option).|||Collections may be strict or lazy. Lazy collections have elements that may not consume memory until they are accessed, like Ranges. Additionally, collections may be mutable (the contents of the reference can change) or immutable (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.|||For some problems, mutable collections work better, and for others, immutable collections work better. When in doubt, it is better to start with an immutable collection and change it later if you need mutable ones.|||This chapter throws light on the most commonly used collection types and most frequently used operations over those collections.|||Scala Lists|||Scala's List[T] is a linked list of type T.|||Scala Sets|||A set is a collection of pairwise different elements of the same type.|||Scala Maps|||A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||Scala Tuples|||Unlike an array or list, a tuple can hold objects with different types.|||Scala Options|||Option[T] provides a container for zero or one element of a given type.|||Scala Iterators|||An iterator is not a collection, but rather a way to access the elements of a collection one by one.|||Scala can be installed on any UNIX flavored or Windows based system. Before you start installing Scala on your machine, you must have Java 1.8 or greater installed on your computer.|||Follow the steps given below to install Scala.|||First of all, you need to have Java Software Development Kit (SDK) installed on your system. To verify this, execute any of the following two commands depending on the platform you are working on.|||If the Java installation has been done properly, then it will display the current version and specification of your Java installation. A sample output is given in the following table.|||Open Command Console and type −|||\>java -version|||Java version ""1.8.0_31""|||Java (TM) SE Run Time|||Environment (build 1.8.0_31-b31)|||Java Hotspot (TM) 64-bit Server|||VM (build 25.31-b07, mixed mode)|||Open Command terminal and type −|||$java -version|||Java version ""1.8.0_31""|||Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)|||Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)|||We assume that the readers of this tutorial have Java SDK version 1.8.0_31 installed on their system.|||In case you do not have Java SDK, download its current version from https://www.oracle.com/technetwork/java/javase/downloads/index.html and install it.|||Set the environment variable JAVA_HOME to point to the base directory location where Java is installed on your machine. For example,|||Windows|||Set JAVA_HOME to C:\ProgramFiles\java\jdk1.8.0_31|||Linux|||Export JAVA_HOME=/usr/local/java-current|||Append the full path of Java compiler location to the System Path.|||Windows|||Append the String ""C:\Program Files\Java\jdk1.8.0_31\bin"" to the end of the system variable PATH.|||Linux|||Export PATH=$PATH:$JAVA_HOME/bin/|||Execute the command java -version from the command prompt as explained above.|||You can download Scala from www.scala-lang.org/downloads. At the time of writing this tutorial, I downloaded 'scala-2.13.1-installer.jar'. Make sure you have admin privilege to proceed. Now, execute the following command at the command prompt −|||\>java -jar scala-2.13.1-installer.jar\>|||This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path ""C:\Program Files\Scala"", you can select a suitable path as per your convenience.|||Command −|||$java -jar scala-2.13.1-installer.jar|||Output −|||Welcome to the installation of Scala 2.13.1!|||The homepage is at − http://Scala-lang.org/|||press 1 to continue, 2 to quit, 3 to redisplay|||1................................................|||[ Starting to unpack ]|||[ Processing package: Software Package Installation (1/1) ]|||[ Unpacking finished ]|||[ Console installation done ]|||During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.|||Finally, open a new command prompt and type Scala -version and press Enter. You should see the following −|||\>scala -version|||Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.|||$scala -version|||Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.tut|||Scala provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.|||Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables. The index of the first element of an array is the number zero and the index of the last element is the total number of elements minus one.|||To use an array in a program, you must declare a variable to reference the array and you must specify the type of array the variable can reference.|||The following is the syntax for declaring an array variable.|||Here, z is declared as an array of Strings that may hold up to three elements. Values can be assigned to individual elements or get access to individual elements, it can be done by using commands like the following −|||Here, the last example shows that in general the index can be any expression that yields a whole number. There is one more way of defining an array −|||Following picture represents an array myList. Here, myList holds ten double values and the indices are from 0 to 9.|||When processing array elements, we often use loop contol structures because all of the elements in an array are of the same type and the size of the array is known.|||Below is an example program of showing how to create, initialize and process arrays −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala does not directly support various array operations and provides various methods to process arrays in any dimension. If you want to use the different methods then it is required to import Array._ package.|||There are many situations where you would need to define and use multi-dimensional arrays (i.e., arrays whose elements are arrays). For example, matrices and tables are examples of structures that can be realized as two-dimensional arrays.|||The following is the example of defining a two-dimensional array −|||This is an array that has three elements each being an array of integers that has three elements.|||Try the following example program to process a multi-dimensional array −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Use of range() method to generate an array containing a sequence of increasing integers in a given range. You can use final argument as step to create the sequence; if you do not use final argument, then step would be assumed as 1.|||Let us take an example of creating an array of range (10, 20, 2): It means creating an array with elements between 10 and 20 and range difference 2. Elements in the array are 10, 12, 14, 16, and 18.|||Another example: range (10, 20). Here range difference is not given so by default it assumes 1 element. It create an array with the elements in between 10 and 20 with range difference 1. Elements in the array are 10, 11, 12, 13, ..., and 19.|||The following example program shows how to create an array with ranges.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala provides a data structure, the ArrayBuffer, which can change size when initial size falls short. As array is of fix size and more elements cannot be occupied in an array, ArrayBuffer is an alternative to array where size is flexible.|||Internally ArrayBuffer maintains an array of current size to store elements. When a new element is added, size is checked. In case underlying array is full then a new larger array is created and all elements are copied to larger array.|||The following is the syntax for declaring an ArrayBuffer variable.|||Here, z is declared as an array-buffer of Strings which is initially empty. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ArrayBuffer −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Lists are quite similar to arrays which means, all the elements of a list have the same type but there are two important differences. First, lists are immutable, which means elements of a list cannot be changed by assignment. Second, lists represent a linked list whereas arrays are flat.|||The type of a list that has elements of type T is written as List[T].|||Try the following example, here are few lists defined for various data types.|||All lists can be defined using two fundamental building blocks, a tail Nil and ::, which is pronounced cons. Nil also represents the empty list. All the above lists can be defined as follows.|||All operations on lists can be expressed in terms of the following three methods.|||head|||This method returns the first element of a list.|||tail|||This method returns a list consisting of all elements except the first.|||isEmpty|||This method returns true if the list is empty otherwise false.|||The following example shows how to use the above methods.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ::: operator or List.:::() method  or List.concat() method to add two or more lists. Please find the following example given below −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use List.fill() method creates a list consisting of zero or more copies of the same element. Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use a function along with List.tabulate() method to apply on all the elements of the list before tabulating the list. Its arguments are just like those of List.fill: the first argument list gives the dimensions of the list to create, and the second describes the elements of the list. The only difference is that instead of the elements being fixed, they are computed from a function.|||Try the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use List.reverse method to reverse all elements of the list. The Following example shows the usage.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala provides a data structure, the ListBuffer, which is more efficient than List while adding/removing elements in a list. It provides methods to prepend, append elements to a list.|||The following is the syntax for declaring an ListBuffer variable.|||Here, z is declared as an list-buffer of Strings which is initially empty. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListBuffer −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. ListSet implements immutable sets and uses list structure. Elements insertion order is preserved while storing the elements.|||The following is the syntax for declaring an ListSet variable.|||Here, z is declared as an list-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Vector is a general purpose immutable data structure where elements can be accessed randomly. It is generally used for large collections of data.|||The following is the syntax for declaring an Vector variable.|||Here, z is declared as an vector of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process Vector −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. There are two kinds of Sets, the immutable and the mutable. The difference between mutable and immutable objects is that when an object is immutable, the object itself can't be changed.|||By default, Scala uses the immutable Set. If you want to use the mutable Set, you'll have to import scala.collection.mutable.Set class explicitly. If you want to use both mutable and immutable sets in the same collection, then you can continue to refer to the immutable Set as Set but you can refer to the mutable Set as mutable.Set.|||Here is how you can declare immutable Sets −|||While defining an empty set, the type annotation is necessary as the system needs to assign a concrete type to variable.|||All operations on sets can be expressed in terms of the following three methods −|||head|||This method returns the first element of a set.|||tail|||This method returns a set consisting of all elements except the first.|||isEmpty|||This method returns true if the set is empty otherwise false.|||Try the following example showing usage of the basic operational methods −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ++ operator or Set.++() method to concatenate two or more sets, but while adding sets it will remove duplicate elements.|||The Following is the example to concatenate two sets.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Set.min method to find out the minimum and Set.max method to find out the maximum of the elements available in a set. Following is the example to show the program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either Set.& method or Set.intersect method to find out the common values between two sets. Try the following example to show the usage.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Bitset is a common base class for mutable and immutable bitsets. Bitsets are sets of non-negative integers and are represented as variable-size arrays of bits packed into 64-bit words. The memory footprint of a bitset is represented by the largest number stored in it.|||The following is the syntax for declaring an BitSet variable.|||Here, z is declared as an bit-set of non-negative integers which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process BitSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. HashSet implements immutable sets and uses hash table. Elements insertion order is not preserved.|||The following is the syntax for declaring an HashSet variable.|||Here, z is declared as an hash-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process HashSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Set is a collection of pairwise different elements of the same type. In other words, a Set is a collection that contains no duplicate elements. TreeSet implements immutable sets and keeps elements in sorted order.|||The following is the syntax for declaring an TreeSet variable.|||Here, z is declared as an tree-set of Strings which has three members. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process TreeSet −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. Maps are also called Hash tables. There are two kinds of Maps, the immutable and the mutable. The difference between mutable and immutable objects is that when an object is immutable, the object itself can't be changed.|||By default, Scala uses the immutable Map. If you want to use the mutable Map, you'll have to import scala.collection.mutable.Map class explicitly. If you want to use both mutable and immutable Maps in the same, then you can continue to refer to the immutable Map as Map but you can refer to the mutable set as mutable.Map.|||The Following is the example statements to declare immutable Maps −|||While defining empty map, the type annotation is necessary as the system needs to assign a concrete type to variable. If we want to add a key-value pair to a Map, we can use the operator + as follows.|||All operations on maps can be expressed in terms of the following three methods.|||keys|||This method returns an iterable containing each key in the map.|||values|||This method returns an iterable containing each value in the map.|||isEmpty|||This method returns true if the map is empty otherwise false.|||Try the following example program showing usage of the Map methods.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either ++ operator or Map.++() method to concatenate two or more Maps, but while adding Maps it will remove duplicate keys.|||Try the following example program to concatenate two Maps.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can iterate through the keys and values of a Map using ""foreach"" loop. Here, we used method foreach associated with iterator to walk through the keys. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either Map.contains method to test if a given key exists in the map or not. Try the Following example program to key checking.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. HashMap implements immutable map and uses hash table to implement the same.|||The following is the syntax for declaring an HashMap variable.|||Here, colors is declared as an hash-map of Strings, Int which has three key-value pairs. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process HashMap −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala map is a collection of key/value pairs. Any value can be retrieved based on its key. Keys are unique in the Map, but values need not be unique. ListMap implements immutable map and uses list to implement the same. It is used with small number of elements.|||The following is the syntax for declaring an ListMap variable.|||Here, colors is declared as an hash-map of Strings, Int which has three key-value pairs. Values can be added by using commands like the following −|||Below is an example program of showing how to create, initialize and process ListMap −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||An iterator is not a collection, but rather a way to access the elements of a collection one by one. The two basic operations on an iterator it are next and hasNext. A call to it.next() will return the next element of the iterator and advance the state of the iterator. You can find out whether there are more elements to return using Iterator's it.hasNext method.|||The most straightforward way to ""step through"" all the elements returned by an iterator is to use a while loop. Let us follow the following example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use it.min and it.max methods to find out the minimum and maximum valued elements from an iterator. Here, we used ita and itb to perform two different operations because iterator can be traversed only once. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use either it.size or it.length methods to find out the number of elements available in an iterator. Here, we used ita and itb to perform two different operations because iterator can be traversed only once. Following is the example program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Option[ T ] is a container for zero or one element of a given type. An Option[T] can be either Some[T] or None object, which represents a missing value. For instance, the get method of Scala's Map produces Some(value) if a value corresponding to a given key has been found, or None if the given key is not defined in the Map.|||Option type is used frequently in Scala programs and you can compare this with the null value available in Java which indicate no value. For example, the get method of  java.util.HashMap returns either a value stored in the HashMap, or null if no value was found.|||Let's say we have a method that retrieves a record from the database based on a primary key.|||The method will return Some[Person] if the record is found but None if the record is not found. Let us follow the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||The most common way to take optional values apart is through a pattern match. For example try the following program.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following is the example program to show how to use getOrElse() method to access a value or a default when no value is present.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Following is the example program to show how to use isEmpty() method to check if the option is None or not.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Queue is First In First Out, FIFO data structure and allows to insert and retrieve elements in FIFO manner.|||The following is the syntax for declaring an Queue variable.|||Here, queue is declared as an Queue of numbers. Value can be added at front by using commands like the following −|||Value can be retrived at front by using commands like the following −|||Below is an example program of showing how to create, initialize and process Queue −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala tuple combines a fixed number of items together so that they can be passed around as a whole. Unlike an array or list, a tuple can hold objects with different types but they are also immutable.|||The following is an example of a tuple holding an integer, a string, and the console.|||Which is syntactic sugar (short cut) for the following −|||The actual type of a tuple depends upon the number and of elements it contains and the types of those elements. Thus, the type of (99, ""Luftballons"") is Tuple2[Int, String]. The type of ('u', 'r', ""the"", 1, 4, ""me"") is Tuple6[Char, Char, String, Int, Int, String]|||Tuples are of type Tuple1, Tuple2, Tuple3 and so on. There currently is an upper limit of 22 in the Scala if you need more, then you can use a collection, not a tuple. For each TupleN type, where 1 <= N <= 22, Scala defines a number of element-access methods. Given the following definition −|||To access elements of a tuple t, you can use method t._1 to access the first element, t._2 to access the second, and so on. For example, the following expression computes the sum of all elements of t.|||You can use Tuple to write a method that takes a List[Double] and returns the count, the sum, and the sum of squares returned in a three-element Tuple, a Tuple3[Int, Double, Double]. They are also useful to pass a list of data values as messages between actors in concurrent programming.|||Try the following example program. It shows how to use a tuple.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.productIterator() method  to iterate over all the elements of a Tuple.|||Try the following example program to iterate over tuples.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.toString() method to concatenate all the elements of the tuple into a string. Try the following example program to convert to String.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||You can use Tuple.swap method to swap the elements of a Tuple2.|||Try the following example program to swap the elements.|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Seq is a trait to represent immutable sequences. This structure provides index based access and various utility methods to find elements, their occurences and subsequences. A Seq maintains the insertion order.|||The following is the syntax for declaring an Seq variable.|||Here, seq is declared as an Seq of numbers. Seq provides commands like the following −|||Below is an example program of showing how to create, initialize and process Seq −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Stack is Last In First Out, LIFO data structure and allows to insert and retrieve element at top, in LIFO manner.|||The following is the syntax for declaring an Stack variable.|||Here, stack is declared as an Stack of numbers. Value can be added at top by using commands like the following −|||Value can be retrived from top by using commands like the following −|||Value can be removed from top by using commands like the following −|||Below is an example program of showing how to create, initialize and process Stack −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||Scala Stream is special list with lazy evaluation feature. In scala stream, elements are evaluated only when they are needed. Stream supports lazy computation and is performance savvy.|||The following is the syntax for declaring an Stream variable.|||Here, stream is declared as a stream of numbers. Here 1 is head of stream, 2, 3 are tail of stream. Stream.empty marks the end of the stream. Values can be retrived using take commands like the following −|||Below is an example program of showing how to create, initialize and process Stream −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||drop() method is method used by List to select all elements except first n elements of the list.|||The following is the syntax of drop method.|||Here, n is the number of elements to be dropped from the list. This method returns the all the elements of list except first n ones.|||Below is an example program of showing how to use drop method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||dropWhile() method is method used by List to drop all elements which satisfies a given condition.|||The following is the syntax of dropWhile method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the list. This method returns the all the elements of list except dropped ones.|||Below is an example program of showing how to use dropWhile method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||filter() method is method used by List to select all elements which satisfies a given predicate.|||The following is the syntax of filter method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the list. This method returns the all the elements of list which satisfiles the given condition.|||Below is an example program of showing how to use filter method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||find() method is method used by Iterators to find an element which satisfies a given predicate.|||The following is the syntax of find method.|||Here, p: (A) => Boolean is a predicate or condition to be applied on each element of the iterator. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use find method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||flatMap() method is method of TraversableLike trait, it takes a predicate, applies it to each element of the collection and returns a new collection of elements returned by the predicate.|||The following is the syntax of flatMap method.|||Here, f: (A) ? GenTraversableOnce[B] is a predicate or condition to be applied on each element of the collection. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use flatMap method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||flatten() method is a member GenericTraversableTemplate trait, it  returns a single collection of elements by merging child collections.|||The following is the syntax of flatten method.|||Here, f: (A) ? GenTraversableOnce[B] is a predicate or condition to be applied on each element of the collection. This method returns the Option element containing the matched element of iterator which satisfiles the given condition.|||Below is an example program of showing how to use flatten method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||fold() method is a member of TraversableOnce trait, it is used to collapse elements of collections.|||The following is the syntax of fold method.|||Here, fold method takes associative binary operator function as a parameter. This method returns the result as value. It considers first input as initial value and second input as a function (which takes accumulated value and current item as input).|||Below is an example program of showing how to use fold method −|||Here we've passed 0 as initial value to fold function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||foldLeft() method is a member of  TraversableOnce trait, it is used to collapse elements of collections. It navigates elements from Left to Right order. It is primarily used in recursive functions and prevents stack overflow exceptions.|||The following is the syntax of fold method.|||Here, foldLeft method takes associative binary operator function as a parameter. This method returns the result as value.|||Below is an example program of showing how to use foldLeft method −|||Here we've passed 0 as initial value to fold function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||foldRight() method is a member of TraversableOnce trait, it is used to collapse elements of collections. It navigates elements from Right to Left order.|||The following is the syntax of foldRight method.|||Here, fold method takes associative binary operator function as a parameter. This method returns the resulted value.|||Below is an example program of showing how to use foldRight method −|||Here we've passed 0 as initial value to foldRight function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||map() method is a member of TraversableLike trait, it is used to run a predicate method on each elements of a collection. It returns a new collection.|||The following is the syntax of map method.|||Here, map method takes a prediate function as a parameter. This method returns the updated collection.|||Below is an example program of showing how to use map method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||partition() method is a member of TraversableLike trait, it is used to run a predicate method on each elements of a collection. It returns two collections, one collection is of elements which satisfiles a given predicate function and another collection is of elements which do not satisfy the given predicate function.|||The following is the syntax of map method.|||Here, partition method takes a prediate function as a parameter. This method returns the collections.|||Below is an example program of showing how to use partition method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||reduce() method is a member of  TraversableOnce trait, it is used to collapse elements of collections. It is similar to fold method but it does not take initial value.|||The following is the syntax of reduce method.|||Here, reduce method takes associative binary operator function as a parameter. This method returns the resultant value.|||Below is an example program of showing how to use fold method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||scan() method is a member of  TraversableLike trait, it is similar to fold method but is used to apply a operation on each elements of collection and return a collection.|||The following is the syntax of fold method.|||Here, scan method takes associative binary operator function as a parameter. This method returns the updated collection as result. It considers first input as initial value and second input as a function.|||Below is an example program of showing how to use scan method −|||Here we've passed 0 as initial value to scan function and then all values are added. Save the above program in Demo.scala. The following commands are used to compile and execute this program.|||zip() method is a member of IterableLike trait, it is used to merge a collection to current collection and result is a collection of pair of tuple elements from both collections.|||The following is the syntax of zip method.|||Here, zip method takes a collection as parameter. This method returns the updated collection of pair as result.|||Below is an example program of showing how to use zip method −|||Save the above program in Demo.scala. The following commands are used to compile and execute this program.",,,"Sr.No@@@Collections with Description|||1@@@Scala Lists
Scala's List[T] is a linked list of type T.
|||2@@@Scala Sets
A set is a collection of pairwise different elements of the same type.|||3@@@
Scala Maps
A Map is a collection of key/value pairs. Any value can be retrieved based on its key.|||4@@@Scala Tuples
Unlike an array or list, a tuple can hold objects with different types.|||5@@@Scala Options
Option[T] provides a container for zero or one element of a given type.|||6@@@Scala Iterators
An iterator is not a collection, but rather a way to access the elements of a collection one by one.&&&Platform@@@Command@@@Sample Output|||Windows@@@
Open Command Console and type −
\>java -version
@@@
Java version ""1.8.0_31""
Java (TM) SE Run Time
Environment (build 1.8.0_31-b31)
Java Hotspot (TM) 64-bit Server
VM (build 25.31-b07, mixed mode)|||Linux@@@
Open Command terminal and type −
$java -version@@@
Java version ""1.8.0_31""
Open JDK Runtime Environment (rhel-2.8.10.4.el6_4-x86_64)
Open JDK 64-Bit Server VM (build 25.31-b07, mixed mode)
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Set JAVA_HOME to C:\ProgramFiles\java\jdk1.8.0_31
|||2@@@
Linux
Export JAVA_HOME=/usr/local/java-current
&&&Sr.No@@@Platform & Description|||1@@@
Windows
Append the String ""C:\Program Files\Java\jdk1.8.0_31\bin"" to the end of the system variable PATH.|||2@@@
Linux
Export PATH=$PATH:$JAVA_HOME/bin/
&&&Platform@@@Command & Output@@@Description|||Windows@@@\>java -jar scala-2.13.1-installer.jar\>@@@This command will display an installation wizard, which will guide you to install Scala on your windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where Scala will be installed. I selected default given path ""C:\Program Files\Scala"", you can select a suitable path as per your convenience.|||Linux@@@
Command −
$java -jar scala-2.13.1-installer.jar
Output −
Welcome to the installation of Scala 2.13.1!
The homepage is at − http://Scala-lang.org/
press 1 to continue, 2 to quit, 3 to redisplay
1................................................
[ Starting to unpack ]
[ Processing package: Software Package Installation (1/1) ]
[ Unpacking finished ]
[ Console installation done ]
@@@
During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where Scala will be installed. I entered /usr/local/share, you can select a suitable path as per your convenience.
&&&Platform@@@Command@@@Output|||Windows@@@\>scala -version@@@Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.|||Linux@@@$scala -version@@@Scala code runner version 2.13.1 -- Copyright 2002-2019, LAMP/EPFL and Lightbend, Inc.tut&&&Sr.No@@@Methods & Description|||1@@@
head
This method returns the first element of a list.
|||2@@@
tail
This method returns a list consisting of all elements except the first.
|||3@@@
isEmpty
This method returns true if the list is empty otherwise false.
&&&Sr.No@@@Methods & Description|||1@@@
head
This method returns the first element of a set.
|||2@@@
tail
This method returns a set consisting of all elements except the first.
|||3@@@
isEmpty
This method returns true if the set is empty otherwise false.
&&&Sr.No@@@Methods & Description|||1@@@
keys
This method returns an iterable containing each key in the map.
|||2@@@
values
This method returns an iterable containing each value in the map.
|||3@@@
isEmpty
This method returns true if the map is empty otherwise false.
","object Demo {   def main(args: Array[String]) {      var myList = Array(1.9, 2.9, 3.4, 3.5)            // Print all the array elements      for ( x <- myList ) {         println( x )      }      // Summing all elements      var total = 0.0;      for ( i <- 0 to (myList.length - 1)) {         total += myList(i);      }      println(""Total is "" + total);      // Finding the largest element      var max = myList(0);      for ( i <- 1 to (myList.length - 1) ) {         if (myList(i) > max) max = myList(i);      }      println(""Max is "" + max);   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myMatrix = ofDim[Int](3,3)      // build a matrix      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            myMatrix(i)(j) = j;         }      }      // Print two dimensional array      for (i <- 0 to 2) {         for ( j <- 0 to 2) {            print("" "" + myMatrix(i)(j));         }         println();      }   }}|||import Array._object Demo {   def main(args: Array[String]) {      var myList1 = range(10, 20, 2)      var myList2 = range(10,20)      // Print all the array elements      for ( x <- myList1 ) {         print( "" "" + x )      }      println()      for ( x <- myList2 ) {         print( "" "" + x )      }   }}|||import scala.collection.mutable.ArrayBuffer object Demo {   def main(args: Array[String]) = {      var myList = ArrayBuffer(""Zara"",""Nuha"",""Ayan"")      println(myList);      // Add an element      myList += ""Welcome"";      // Add two element      myList += (""To"", ""Tutorialspoint"");      println(myList);      // Remove an element      myList -= ""Welcome"";      // print second element      println(myList(1));   }}|||// List of Stringsval fruit: List[String] = List(""apples"", ""oranges"", ""pears"")// List of Integersval nums: List[Int] = List(1, 2, 3, 4)// Empty List.val empty: List[Nothing] = List()// Two dimensional listval dim: List[List[Int]] = List(   List(1, 0, 0),   List(0, 1, 0),   List(0, 0, 1))|||// List of Stringsval fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))// List of Integersval nums = 1 :: (2 :: (3 :: (4 :: Nil)))// Empty List.val empty = Nil// Two dimensional listval dim = (1 :: (0 :: (0 :: Nil))) ::   (0 :: (1 :: (0 :: Nil))) ::   (0 :: (0 :: (1 :: Nil))) :: Nil|||object Demo {   def main(args: Array[String]) {      val fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      val nums = Nil      println( ""Head of fruit : "" + fruit.head )      println( ""Tail of fruit : "" + fruit.tail )      println( ""Check if fruit is empty : "" + fruit.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val fruit1 = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      val fruit2 = ""mangoes"" :: (""banana"" :: Nil)      // use two or more lists with ::: operator      var fruit = fruit1 ::: fruit2      println( ""fruit1 ::: fruit2 : "" + fruit )      // use two lists with Set.:::() method      fruit = fruit1.:::(fruit2)      println( ""fruit1.:::(fruit2) : "" + fruit )      // pass two or more lists as arguments      fruit = List.concat(fruit1, fruit2)      println( ""List.concat(fruit1, fruit2) : "" + fruit  )   }}|||object Demo {   def main(args: Array[String]) {      val fruit = List.fill(3)(""apples"") // Repeats apples three times.      println( ""fruit : "" + fruit  )      val num = List.fill(10)(2)         // Repeats 2, 10 times.      println( ""num : "" + num  )   }}|||object Demo {   def main(args: Array[String]) {      // Creates 5 elements using the given function.      val squares = List.tabulate(6)(n => n * n)      println( ""squares : "" + squares  )      val mul = List.tabulate( 4,5 )( _ * _ )            println( ""mul : "" + mul  )   }}|||object Demo {   def main(args: Array[String]) {      val fruit = ""apples"" :: (""oranges"" :: (""pears"" :: Nil))      println( ""Before reverse fruit : "" + fruit )      println( ""After reverse fruit : "" + fruit.reverse )   }}|||import scala.collection.mutable.ListBuffer object Demo {   def main(args: Array[String]) = {      var myList = ListBuffer(""Zara"",""Nuha"",""Ayan"")      println(myList);      // Add an element      myList += ""Welcome"";      // Add two element      myList += (""To"", ""Tutorialspoint"");      println(myList);      // Remove an element      myList -= ""Welcome"";      // print second element      println(myList(1));   }}|||import scala.collection.immutable.ListSetobject Demo {   def main(args: Array[String]) = {      var myList: ListSet[String] = ListSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var myList1: ListSet[String] = myList + ""Naira"";      // Remove an element      var myList2: ListSet[String] = myList - ""Nuha"";      // Create empty set      var myList3: ListSet[String] = ListSet.empty[String];      println(myList);      println(myList1);      println(myList2);      println(myList3);	     }}|||import scala.collection.immutable.Vectorobject Demo {   def main(args: Array[String]) = {      var vector: Vector[String] = Vector(""Zara"",""Nuha"",""Ayan"");      // Add an element      var vector1: Vector[String] = vector :+ ""Naira"";      // Reverse an element      var vector2: Vector[String] = vector.reverse;      // sort a vector      var vector3: Vector[String] = vector1.sorted;      println(vector);      println(vector1);      println(vector2);      println(vector3);	     }}|||object Demo {   def main(args: Array[String]) {      val fruit = Set(""apples"", ""oranges"", ""pears"")      val nums: Set[Int] = Set()      println( ""Head of fruit : "" + fruit.head )      println( ""Tail of fruit : "" + fruit.tail )      println( ""Check if fruit is empty : "" + fruit.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val fruit1 = Set(""apples"", ""oranges"", ""pears"")      val fruit2 = Set(""mangoes"", ""banana"")      // use two or more sets with ++ as operator      var fruit = fruit1 ++ fruit2      println( ""fruit1 ++ fruit2 : "" + fruit )      // use two sets with ++ as method      fruit = fruit1.++(fruit2)      println( ""fruit1.++(fruit2) : "" + fruit )   }}|||object Demo {   def main(args: Array[String]) {      val num = Set(5,6,9,20,30,45)      // find min and max of the elements      println( ""Min element in Set(5,6,9,20,30,45) : "" + num.min )      println( ""Max element in Set(5,6,9,20,30,45) : "" + num.max )   }}|||object Demo {   def main(args: Array[String]) {      val num1 = Set(5,6,9,20,30,45)      val num2 = Set(50,60,9,20,35,55)      // find common elements between two sets      println( ""num1.&(num2) : "" + num1.&(num2) )      println( ""num1.intersect(num2) : "" + num1.intersect(num2) )   }}|||import scala.collection.immutable.BitSetobject Demo {   def main(args: Array[String]) = {      var mySet: BitSet = BitSet(0, 1, 2);      // Add an element      var mySet1: BitSet = mySet + 3;      // Remove an element      var mySet2: BitSet = mySet - 2;      var mySet3: BitSet = BitSet(4, 5);      // Adding sets      var mySet4: BitSet = mySet1 ++ mySet3;      println(mySet);      println(mySet1);      println(mySet2);      println(mySet4);	     }}|||import scala.collection.immutable.HashSetobject Demo {   def main(args: Array[String]) = {      var mySet: HashSet[String] = HashSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var mySet1: HashSet[String] = mySet + ""Naira"";      // Remove an element      var mySet2: HashSet[String] = mySet - ""Nuha"";      // Create empty set      var mySet3: HashSet[String] = HashSet.empty[String];      println(mySet);      println(mySet1);      println(mySet2);      println(mySet3);	     }}|||import scala.collection.immutable.TreeSetobject Demo {   def main(args: Array[String]) = {      var mySet: TreeSet[String] = TreeSet(""Zara"",""Nuha"",""Ayan"");      // Add an element      var mySet1: TreeSet[String] = mySet + ""Naira"";      // Remove an element      var mySet2: TreeSet[String] = mySet - ""Nuha"";      // Create empty set      var mySet3: TreeSet[String] = TreeSet.empty[String];      println(mySet);      println(mySet1);      println(mySet2);      println(mySet3);	     }}|||object Demo {   def main(args: Array[String]) {      val colors = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      val nums: Map[Int, Int] = Map()      println( ""Keys in colors : "" + colors.keys )      println( ""Values in colors : "" + colors.values )      println( ""Check if colors is empty : "" + colors.isEmpty )      println( ""Check if nums is empty : "" + nums.isEmpty )   }}|||object Demo {   def main(args: Array[String]) {      val colors1 = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      val colors2 = Map(         ""blue"" -> ""#0033FF"", ""yellow"" -> ""#FFFF00"", ""red"" -> ""#FF0000""      )      // use two or more Maps with ++ as operator      var colors = colors1 ++ colors2      println( ""colors1 ++ colors2 : "" + colors )      // use two maps with ++ as method      colors = colors1.++(colors2)      println( ""colors1.++(colors2)) : "" + colors )   }}|||object Demo {   def main(args: Array[String]) {      val colors = Map(""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"",""peru"" -> ""#CD853F"")      colors.keys.foreach{         i =>           print( ""Key = "" + i )         println("" Value = "" + colors(i) )      }   }}|||object Demo {   def main(args: Array[String]) {      val colors = Map(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      )      if( colors.contains( ""red"" )) {         println(""Red key exists with value :""  + colors(""red""))      } else {         println(""Red key does not exist"")      }      if( colors.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + colors(""maroon""))      } else {         println(""Maroon key does not exist"")      }   }}|||import scala.collection.immutable.HashMapobject Demo {   def main(args: Array[String]) = {      var myMap: HashMap[String,String] = HashMap(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      );      // Add an element      var myMap1: HashMap[String,String] = myMap + (""white"" -> ""#FFFFFF"");      // Print key values      myMap.keys.foreach{          i =>           print( ""Key = "" + i )         println("" Value = "" + myMap(i) )      }      if( myMap.contains( ""red"" )) {         println(""Red key exists with value :""  + myMap(""red""))      } else {         println(""Red key does not exist"")      }      if( myMap.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + myMap(""maroon""))      } else {         println(""Maroon key does not exist"")      }      //removing element      var myMap2: HashMap[String,String] = myMap - (""white"");      // Create empty map      var myMap3: HashMap[String,String] = HashMap.empty[String, String];      println(myMap1);      println(myMap2);      println(myMap3);		     }}|||import scala.collection.immutable.ListMapobject Demo {   def main(args: Array[String]) = {      var myMap: ListMap[String,String] = ListMap(         ""red"" -> ""#FF0000"", ""azure"" -> ""#F0FFFF"", ""peru"" -> ""#CD853F""      );      // Add an element      var myMap1: ListMap[String,String] = myMap + (""white"" -> ""#FFFFFF"");      // Print key values      myMap.keys.foreach{          i =>           print( ""Key = "" + i )         println("" Value = "" + myMap(i) )       }      if( myMap.contains( ""red"" )) {         println(""Red key exists with value :""  + myMap(""red""))      } else {         println(""Red key does not exist"")      }      if( myMap.contains( ""maroon"" )) {         println(""Maroon key exists with value :""  + myMap(""maroon""))      } else {         println(""Maroon key does not exist"")      }      //removing element      var myMap2: ListMap[String,String] = myMap - (""white"");      // Create empty map      var myMap3: ListMap[String,String] = ListMap.empty[String, String];      println(myMap1);      println(myMap2);	      println(myMap3);		     }}|||object Demo {   def main(args: Array[String]) {      val it = Iterator(""a"", ""number"", ""of"", ""words"")      while (it.hasNext){         println(it.next())      }   }}|||object Demo {   def main(args: Array[String]) {      val ita = Iterator(20,40,2,50,69, 90)      val itb = Iterator(20,40,2,50,69, 90)      println(""Maximum valued element "" + ita.max )      println(""Minimum valued element "" + itb.min )   }}|||object Demo {   def main(args: Array[String]) {      val ita = Iterator(20,40,2,50,69, 90)      val itb = Iterator(20,40,2,50,69, 90)      println(""Value of ita.size : "" + ita.size )      println(""Value of itb.length : "" + itb.length )   }}|||object Demo {   def main(args: Array[String]) {      val capitals = Map(""France"" -> ""Paris"", ""Japan"" -> ""Tokyo"")      println(""capitals.get( \""France\"" ) : "" +  capitals.get( ""France"" ))      println(""capitals.get( \""India\"" ) : "" +  capitals.get( ""India"" ))   }}|||object Demo {   def main(args: Array[String]) {      val capitals = Map(""France"" -> ""Paris"", ""Japan"" -> ""Tokyo"")      println(""show(capitals.get( \""Japan\"")) : "" + show(capitals.get( ""Japan"")) )      println(""show(capitals.get( \""India\"")) : "" + show(capitals.get( ""India"")) )   }   def show(x: Option[String]) = x match {      case Some(s) => s      case None => ""?""   }}|||object Demo {   def main(args: Array[String]) {      val a:Option[Int] = Some(5)      val b:Option[Int] = None       println(""a.getOrElse(0): "" + a.getOrElse(0) )      println(""b.getOrElse(10): "" + b.getOrElse(10) )   }}|||object Demo {   def main(args: Array[String]) {      val a:Option[Int] = Some(5)      val b:Option[Int] = None       println(""a.isEmpty: "" + a.isEmpty )      println(""b.isEmpty: "" + b.isEmpty )   }}|||import scala.collection.mutable.Queueobject Demo {   def main(args: Array[String]) = {      var queue = Queue(1, 2, 3, 4, 5);      // Print queue elements      queue.foreach{(element:Int) => print(element + "" "")}      println();      // Print first element      println(""First Element: "" + queue.front)      // Add an element      queue.enqueue(6);      // Print queue elements      queue.foreach{(element:Int) => print(element+ "" "")}      println();      // Remove an element      var dq = queue.dequeue;      // Print dequeued element      println(""Dequeued Element: "" + dq)      // Print queue elements      queue.foreach{(element:Int) => print(element+ "" "")}   }}|||object Demo {   def main(args: Array[String]) {      val t = (4,3,2,1)      val sum = t._1 + t._2 + t._3 + t._4      println( ""Sum of elements: ""  + sum )   }}|||object Demo {   def main(args: Array[String]) {      val t = (4,3,2,1)      t.productIterator.foreach{ i =>println(""Value = "" + i )}   }}|||object Demo {   def main(args: Array[String]) {      val t = new Tuple3(1, ""hello"", Console)      println(""Concatenated String: "" + t.toString() )   }}|||object Demo {   def main(args: Array[String]) {      val t = new Tuple2(""Scala"", ""hello"")      println(""Swapped Tuple: "" + t.swap )   }}|||import scala.collection.immutable.Seqobject Demo {   def main(args: Array[String]) = {      var seq = Seq(1, 2, 3, 4, 5, 3)      // Print seq elements      seq.foreach{(element:Int) => print(element + "" "")}      println()      println(""Seq ends with (5,3): "" + seq.endsWith(Seq(5, 3)))      println(""Seq contains 4: "" + seq.contains(4))      println(""Last index of 3: "" + seq.lastIndexOf(3))      println(""Reversed Seq"" + seq.reverse)              }}|||import scala.collection.mutable.Stackobject Demo {   def main(args: Array[String]) = {      var stack: Stack[Int] = Stack();      // Add elements      stack.push(1);      stack.push(2);      // Print element at top      println(""Top Element: "" + stack.top)      // Print element      println(""Removed Element: "" + stack.pop())      // Print element      println(""Top Element: "" + stack.top)	   }}|||import scala.collection.immutable.Streamobject Demo {   def main(args: Array[String]) = {      val stream = 1 #:: 2 #:: 3 #:: Stream.empty      // print stream      println(stream)      // Print first two elements	      stream.take(2).print      println()      // Create an empty stream      val stream1: Stream[Int] = Stream.empty[Int]      // Print element      println(s""Stream: $stream1"")   }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3, 4, 5)      // print list      println(list)      //apply operation      val result = list.drop(3)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(3, 6, 9, 4, 2)      // print list      println(list)      //apply operation      val result = list.dropWhile(x=>{x % 3 == 0})      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(3, 6, 9, 4, 2)      // print list      println(list)      //apply operation      val result = list.filter(x=>{x % 3 == 0})      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val iterator = Iterator(3, 6, 9, 4, 2)      //apply operation      val result = iterator.find(x=>{x % 3 == 0})      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 5, 10)      //apply operation      val result = list.flatMap{x => List(x,x+1)}      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(List(1,2), List(3,4))      //apply operation      val result = list.flatten      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.fold(0)(_ + _)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.foldLeft(0)(_ + _)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.foldRight(0)(_ + _)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get twice of each element.      val result = list.map(_ * 2)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3, 4, 5, 6, 7)      //apply operation to get twice of each element.      val (result1, result2) = list.partition(x=>{x % 3 == 0})      //print result      println(result1)      println(result2)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to get sum of all elements of the list      val result = list.reduce(_ + _)      //print result      println(result)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      //apply operation to create a running total of all elements of the list      val list1 = list.scan(0)(_ + _)      //print list      println(list1)         }}|||object Demo {   def main(args: Array[String]) = {      val list = List(1, 2, 3 ,4)      val list1 = List(""A"", ""B"", ""C"", ""D"")      //apply operation to create a zip of list      val list2 = list zip list1      //print list      println(list2)         }}"
Learn Scala Collection,Scala Collections - Useful Resources,Scala Collections - Useful Resources|||Useful Links on Scala@@@Useful Books on Scala,"The following resources contain additional information on Scala. Please use them to get more in-depth knowledge on this topic.|||The Scala Programming Language − All the information required to start writing programs in Scala! Contains manuals, a tour of Scala, information on the available Scala books, many guides, and useful documentation resources.|||Standard scaladoc Scala API − Browse the online API documentation generated by using our standard scaladoc tool.|||JavaTM 2 SDK, Standard Edition  − Official site for JavaTM 2 SDK, Standard Edition.|||Free Java Download − Download Java for your desktop computer now!|||Sun Developer Network − Sun Microsystem's official website listing down all the API documentation, latest Java Technologies, Books and other resource.|||To enlist your site on this page, please drop an email to contact@tutorialspoint.com","The Scala Programming Language − All the information required to start writing programs in Scala! Contains manuals, a tour of Scala, information on the available Scala books, many guides, and useful documentation resources.@@@Standard scaladoc Scala API − Browse the online API documentation generated by using our standard scaladoc tool.@@@JavaTM 2 SDK, Standard Edition  − Official site for JavaTM 2 SDK, Standard Edition.@@@Free Java Download − Download Java for your desktop computer now!@@@Sun Developer Network − Sun Microsystem's official website listing down all the API documentation, latest Java Technologies, Books and other resource.",,,
Learn Scala Collection,Discuss Scala Collections,Discuss Scala Collections|||Useful Video Courses|||Scala Online Training@@@Apache Spark with Scala - Hands On with Big Data@@@Delta Lake with Apache Spark using Scala@@@Apache Spark with Scala useful for Databricks Certification@@@Machine Learning with Apache Spark 3.0 using Scala,"Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map, etc. The collections may have an arbitrary number of elements or be bounded to zero or one element (e.g., Option).",,,,
